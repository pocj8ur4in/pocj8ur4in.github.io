var store = [{
        "title": "[FE] 1. HTML",
        "excerpt":"HTML (HyperText Mark-up Language) : 웹 문서의 구조를 기술하는 마크업 언어         하이퍼링크 (hyperlink) : 문서 내 어떤 요소와 다른 요소 간의 비선형적 (nonlinear) 연결   하이퍼텍스트 (hypertext) : 하이퍼링크를 통해 상호 연결되어 네트워크처럼 구성된 문서   &lt;html&gt; &lt;head&gt; \t&lt;div style=\"color: blue; font-size: 15px;\"&gt; \t\tHello World! \t&lt;/div&gt; &lt;/head&gt; &lt;/html&gt;    \t \t\t \t\t\tHello World! \t\t \t      HTML 요소 (HTML Elements) : HTML 문서나 웹 페이지를 이루는 개별적인 부분            HTML 태그 (HTML Tags) &lt;tag&gt;&lt;/tag&gt; : 요소의 시작과 끝을 나타내 문서의 구조를 명시하는 마크업 기호                    HTML 속성 (HTML Attributes) &lt;tag element=\"\"&gt; : 여는 태그 내에서 명령어를 구체화하는 속성                            HTML 변수 (HTML Arguments) &lt;tag element=\"value\"&gt; : 태그 내의 속성에 해당되는 인자                                                   HTML 내용 (HTML Contents) : HTML 문서를 통해 화면에 표시될 내용   # HTML 전역 속성 (HTML Global Attributes) : 모든 HTML 요소에서 사용 가능한 속성   class와 id  : CSS나 JavaScript에서 요소를 선택하거나 접근할 때 사용하는 속성     클래스 (class=\"\") : HTML 문서에서 정의된 요소의 별칭   아이디 (id=\"\") : HTML 문서에서 정의된 고유한 식별자   &lt;div class=\"class\"&gt; \t&lt;div id=\"id\"&gt; \t  class &amp; id \t&lt;/div&gt; &lt;/div&gt;   lang : 웹 문서의 텍스트가 어떤 언어로 작성되었는지 나타내는 속성   &lt;p lang=\"ko\"&gt;한글&lt;/p&gt; &lt;p lang=\"en\"&gt;english&lt;/p&gt;   한글  english   style : 요소에 적용할 CSS을 나타내는 속성   &lt;div style=\"color: white; font-size: 15px; background-color: black;\"&gt; \t&lt;a href=\"https://pocj8ur4in.github.io\" target=\"_blank\" title=\"pocj8ur4in\"&gt;   \t  pocj8ur4in \t&lt;/a&gt; &lt;/div&gt;             pocj8ur4in      title : 요소의 설명을 나타내는 속성   &lt;p title=\"pocj8ur4in\"&gt;pocj8ur4in&lt;/p&gt;   pocj8ur4in   # 범위 관련 HTML 태그   &lt;html&gt;&lt;/html&gt; : HTML으로 작성된 문서임을 선언하는 태그     &lt;!DOCTYPE html&gt; : 마크업 언어에서의 문서 형식을 정의하는 태그            DTD 태그 (Document Type Definition)       웹 브라우저의 렌더링 엔진이 관용 모드 (Quirks Mode)가 아닌 표준 모드로 렌더링       HTML5`` :&lt;!DOCTYPE html&gt;```으로 선언           &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; ... &lt;/html&gt;   &lt;head&gt;&lt;/head&gt; : 웹 문서의 속성을 선언하는 태그     실제 웹 브라우저 화면 상에는 출력되지 않는 HTML 문서의 정보들을 넣음   &lt;!DOCTYPE html lang=\"ko\"&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; ... &lt;/head&gt; ... &lt;/html&gt;   &lt;body&gt;&lt;/body&gt; : 웹 문서의 모양을 선언하는 태그     실제 웹 브라우저 화면 상에는 출력되는 HTML 문서의 레이아웃을 넣음   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; ... &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt;   # 메타 정보 관련 태그     메타 정보 (meta data) : 웹 서버와 웹 브라우저 간 상호 교환되는 정보   &lt;title&gt;&lt;/title&gt; : 웹 문서의 제목을 선언하는 태그     브라우저의 제목 표시줄이나 페이지 탭에 표시되는 제목을 출력   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; \t&lt;title&gt;웹 문서의 제목&lt;/title&gt; &lt;/head&gt; &lt;/html&gt;   &lt;base /&gt; : 웹 문서에 포함된 모든 상대 URL들에 대한 기준 URL를 선언하는 태그     상대 URL를 사용하는 다른 HTML 요소보다 앞에 위치해야 함   한 문서에 하나의 &lt;base&gt;만을 사용 가능   문서 내에 &lt;base&gt;가 존재하지 않으면, 해당 문서의 기준 URL는 (현재 위치).(상대 URL)   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; \t&lt;base href=\"기준 URL (절대 경로, 상대 경로 모두 가능)\" \ttarget=\"_self (현재 창에서 열기) | _blank (새로운 창에서 열기)\" /&gt; &lt;/head&gt; &lt;/html&gt;   &lt;link /&gt; : 현재 웹 문서와 외부 리소스 간의 관계를 정의하는 태그     HTML, CSS, 아이콘 등을 가져옴    \t \t\t \t\t\tlink 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\trel \t\t\t현재 웹 문서와 외부 소스 간의 관계 \t\t \t\t \t\t\thref \t\t\t외부 소스의 주소 \t\t \t\t \t\t\ttype \t\t\t외부 소스의 타입 \t\t \t   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;link \trel=\"manifest\"\t\t\t&lt;!--? 현재 웹 문서와 웹 익스텐션이 포함하는 manifest.json을 연결할 때 --&gt; \thref=\"manifest.json\"/&gt; &lt;link \trel=\"canonical\"\t\t\t&lt;!--? 검색 엔진을 위한 대표 URL를 설정하는 rel 변수 --&gt; \thref=\"대표 URL\"/&gt;\t\t\t&lt;!--? 웹 문서 내 URL는 다르나 동일한 내용의 웹 문서가 있을 때 사용 --&gt; &lt;link \trel=\"shortcut icon\"\t\t&lt;!--? 브라우저 탭에 표시될 아이콘을 설정하는 rel 변수 --&gt; \thref=\"PUBLIC_URL%/favicon.ico\" \ttype=\"image/x-icon\" \tsizes=\"16x16\"/&gt; &lt;link\t\t\t\t\t&lt;!--? 애플 메타 태그 (apple meta tag) --&gt; \trel=\"apple-touch-icon\"\t\t&lt;!--? '홈 화면에 추가' 기능을 사용할 때 표시될 웹 사이트의 아이콘을 설정하는 rel 변수 --&gt; \thref=\"%PUBLIC_URL%/img/apple-icon-57.png\" \tsizes=\"12x57\"/&gt; &lt;link \trel=\"apple-touch-startup-icon\"\t&lt;!--? '홈 화면에 추가' 기능을 사용할 때 로딩 시 스타트업 이미지을 설정하는 rel 변수 --&gt; \tsizes=\"320x460\"\t\t\t&lt;!--? 단, 이미지의 크기가 각 기기에 맞게끔 정확히 맞춰져 있어야 제대로 화면에 표시 --&gt; \thref=\"%PUBLIC_URL%/img/apple-icon-320.png\"/&gt; &lt;/head&gt; &lt;/html&gt;   &lt;style&gt;&lt;/style&gt; : 현재 웹 문서의 스타일 정보를 정의하는 태그     CSS 선택자, 속성, 값을 설정    \t \t\t \t\t\tstyle 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\ttype \t\t\t외부 소스의 타입 \t\t \t   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;style&gt; \tbody { background-color: #fff; } \tdiv { color: #000; } &lt;/&gt; &lt;/head&gt; &lt;/html&gt;   &lt;meta /&gt; : 기타 메타데이터 요소들을 선언하는 태그     검색 엔진 등이 웹 페이지를 읽을 때 해당 서비스에서 이 페이지를 어떻게 표시할지 설명    \t  \t\t  \t\t\tmeta 태그의 속성 값  \t\t\t설명  \t\t  \t  \t  \t\t  \t\t\tname  \t\t\t메타 정보의 이름 선언 : 웹 서버가 웹 브라우저의 요청에 대해 응답할 정보들을 지정하는 속성  \t\t \t\t  \t\t\thttp-equiv  \t\t\tHTTP 문서의 초기 정보 선언 : 웹 서버가 웹 문서 내에 HTML 응답 헤더를 넣어 웹 브라우저가 초기 정보를 지정하는 속성  \t\t  \t\t  \t\t\tcontent  \t\t\t메타 정보의 내용 선언 : name 변수와 http-equiv 태그를 선언할 때 같이 포함되어야 할 내용을 지정하는 속성  \t\t  \t   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt;  &lt;meta  name=\"description\"\t\t\t\t&lt;!--? 웹 브라우저의 검색 결과에 표시될 웹 문서의 설명을 선언하는 name 변수 --&gt;  content=\"설명\"/&gt;\t\t\t\t&lt;!--? content 값은 공백을 포함해 최대 150글자여야 함 --&gt;      &lt;meta  name=\"keywords\"\t\t\t\t&lt;!--? 웹 브라우저의 검색 엔진에 의해 검색될 검색 키워드를 선언하는 name 변수 --&gt;  content=\"키워드1, 키워드2,...\"/&gt;       &lt;meta  name=\"date\"\t\t\t\t\t&lt;!--? 웹 문서가 작성된 날짜를 선언하는 name 변수 --&gt;  content=\"2022-09-21T17:38:06+09:00\"/&gt;\t\t&lt;!--? content 값은 \"연도-월-일T시:분:초+(GMT)\" 형식으로 작성 --&gt; \t\t\t\t\t\t&lt;!--? GMT는 그리니치 표준시와 현 국가/지역 사이의 시차를 의미 --&gt;   &lt;meta  name=\"robots\"\t\t\t\t\t&lt;!--? 검색 로봇을 제어하는 name 변수 --&gt;  content=\"robots의 content 변수1,...\"/&gt;\t\t&lt;!--? Index : 해당 문서를 포함해 링크가 걸린 곳을 수집 대상으로 지정 --&gt; \t\t\t\t\t\t&lt;!--? Noindex : 해당 문서를 수집 대상에서 제외 --&gt; \t\t\t\t\t\t&lt;!--? Follow : 해당 문서를 수집 대상으로 지정 --&gt; \t\t\t\t\t\t&lt;!--? Nofollow : 해당 문서를 포함해 링크가 걸린 곳을 수집 대상에서 제외 --&gt; \t\t\t\t\t\t&lt;!--? All : 'Index, Follow'와 동일 --&gt; \t\t\t\t\t\t&lt;!--? None : 'Noindex, Nofollow'와 동일 --&gt;  &lt;meta  name=\"viewport\"\t\t\t\t&lt;!--? 모든 장치에서 웹 문서가 잘 보이도록 뷰 포트를 설정하는 name 변수 --&gt;  content=\"width=device-width,  initial-scale=1.0\"/&gt;   &lt;meta\t\t\t\t\t\t&lt;!--? twitter : 트위터의 '미리보기'을 설정하는 name 변수 --&gt;  name=\"twitter:card\"\t\t\t\t&lt;!--? twitter:card : 트위터 미리보기를 표시 --&gt;  content=\"summary\"/&gt;       &lt;meta  name=\"twitter:url\"\t\t\t\t&lt;!--? twitter:url : 트위터 미리보기에서 표시될 웹 페이지 주소 --&gt;  content=\"website_url\"/&gt;       &lt;meta  name=\"twitter:title\"\t\t\t\t&lt;!--? twitter:title : 트위터 미리보기에서 표시될 웹 페이지 제목 --&gt;  content=\"website_name\"/&gt;        &lt;meta  name=\"twitter:description\"\t\t\t&lt;!--? twitter:description : 트위터 미리보기에서 표시될 웹 페이지 설명 --&gt;  content=\"website_description\"/&gt;        &lt;meta  name=\"twitter:image\"\t\t\t\t&lt;!--? twitter:image : 트위터 미리보기에서 표시될 웹 페이지 이미지 --&gt;  content=\"website_image\"/&gt;       &lt;meta\t\t\t\t\t\t&lt;!--? apple-mobile-web-app : 사파리 '홈 화면에 추가'을 설정하는 name 변수 --&gt;  name=\"apple-mobile-web-app-title\"\t\t&lt;!--? 홈 화면에 추가 기능을 사용할 때 표시될 웹 사이트의 이름 --&gt;  content=\"website_name\"/&gt;       &lt;meta  name=\"apple-mobile-web-app-capable\"\t\t&lt;!--? 홈 화면에 추가 기능을 사용할 때 브라우저의 UI 사용 여부 --&gt;  content=\"yes\"/&gt;       &lt;meta  name=\"apple-mobile-web-app-status-bar-style\"\t&lt;!--? 홈 화면에 추가 기능을 사용할 때 표시될 상태바의 색상 --&gt;  content=\"black-translucent\"/&gt; \t\t\t&lt;!--? default : 회색, black : 검정, black-translucent : 반투명 --&gt;       &lt;meta  http-equiv=\"X-UA-Compatible\"\t\t\t&lt;!--? 웹 문서를 렌더링할 IE 버전을 명시해 웹 호환성을 지정하는 http-equiv 변수 --&gt;  content=\"X-UA-Compatible의 content 변수\"/&gt;\t&lt;!--? IE=5,7,8,EmulateIE7,EmulateIE8 : 각 버전에 해당하는 렌더링 방식 사용 --&gt; \t\t\t\t\t\t&lt;!--? IE=edge : 항상 최신 표준 모드로 렌더링 --&gt; \t\t\t\t\t\t&lt;!--? IE=edge, chrome=1: ~, Chrome이 설치되어 있다면 Chrome으로 렌더링 --&gt; \t  &lt;meta  charset=\"문자 인코딩 방식\"/&gt;\t\t\t&lt;!--? 웹 브라우저의 문자 인코딩 방식 ('호환성 보기') 을 지정하는 http-equiv 변수 --&gt; \t\t\t\t\t\t&lt;!--? EUC-KR (ISO-2022-KR) : ISO-숫자 타입 문자 인코딩 (한글을 2비트로 변환) --&gt; \t\t\t\t\t\t&lt;!--? UTF-8,16,32 : 유니코드 변환 포맷 인코딩 (모든 문자를 8,16,32비트로 변환) --&gt;   &lt;meta  http-equiv=\"content-security-policy\"\t\t&lt;!--? XSS, 데이터 삽입 공격을 대비해 웹 문서 컨텐츠 정책을 명시하는 http-equiv 변수 --&gt;  content=\"CSP 지시문\"/&gt;\t\t\t\t&lt;!--? default-src : 모든 컨텐츠는 현재 도메인에서만 제공 (디폴트 설정) --&gt; \t\t\t\t\t\t&lt;!--? connect-src : 연결 가능한 URL 제한 --&gt; \t\t\t\t\t\t&lt;!--? script-src : 스크립트 관련 권한 집합 제어 --&gt; \t\t\t\t\t\t&lt;!--? style-src : 스타일시트 관련 권한 집합 제어 --&gt; \t\t\t\t\t\t&lt;!--? img-src : 이미지 관련 권한 집합 제어 --&gt; \t\t\t\t\t\t&lt;!--? font-src : 웹 글꼴을 제공할 수 있는 URL 지정 --&gt; \t\t\t\t\t\t&lt;!--? frame-src : 상위 iframe 도메인에서 하위 iframe 도메인을 확인하고 제어 --&gt;       &lt;meta  http-equiv=\"content-security-policy\"  content=\"CSP 지시문 CSP 옵션\"/&gt;\t\t\t&lt;!--? *.trusted.com : 접근 허용할 도메인 지정 --&gt; \t\t\t\t\t\t&lt;!--? 'none' : 모든 도메인 차단 --&gt; \t\t\t\t\t\t&lt;!--? 'self' : 현재 도메인만 허용 --&gt; \t\t\t\t\t\t&lt;!--? 'unsafe-inline' : 소스 코드 내 인라인 자바스크립트 및 CSS 허용 --&gt; \t\t\t\t\t\t&lt;!--? 'nonce-암호화된 문자' : 암호화된 방식으로 인라인 자바스크립트 및 CSS 허용 --&gt;   &lt;meta  http-equiv=\"content-script-type\"\t\t&lt;!--? 웹 문서에 사용된 프로그래밍 언어를 명시하는 http-equiv 변수 --&gt;  content=\"text/프로그래밍 언어\"/&gt;       &lt;meta  http-equiv=\"default-style\"\t\t\t&lt;!--? 웹 문서에 우선적으로 적용할 스타일 시트를 지정하는 http-equiv 변수 --&gt;  content=\"스타일시트\"/&gt;       &lt;meta  http-equiv=\"refresh\"\t\t\t\t&lt;!--? 웹 문서를 새로고침하는 시간 간격을 지정하는 http-equiv 변수 --&gt;  content=\"시간 간격\"; url=\"\"/&gt;\t\t\t&lt;!--? url=\"\" : 새로고침한 후 이동할 주소 지정 --&gt;       &lt;meta  http-equiv=\"cache-control\"\t\t\t&lt;!--? 웹 캐시 사용 여부를 지정하는 http-equiv 변수 --&gt;  content=\"no-cache\"/&gt;\t\t\t\t&lt;!--? no-cache : 사용자의 웹 브라우저가 항상 캐시를 읽지 않고 페이지를 갱신 --&gt;       &lt;meta  http-equiv=\"pragma\"\t\t\t\t&lt;!--? 현재 웹 문서를 캐시로 저장할지 여부를 지정하는 http-equiv 변수 --&gt;  content=\"no-cache\"/&gt;\t\t\t\t&lt;!--? no-cache : 사용자의 웹 브라우저가 항상 캐시를 읽지 않고 페이지를 갱신 --&gt;       &lt;meta  http-equiv=\"expires\"\t\t\t\t&lt;!--? 현재 웹 문서의 웹 캐시 만료일을 지정하는 http-equiv 변수 --&gt;  content=\"캐시 만료일\"/&gt;       &lt;meta  http-equiv=\"장면 전환 http-equiv 변수\"\t\t&lt;!--? 특정 상황에서의 장면 전환 효과를 지정하는 http-equiv 변수 --&gt;  content=\"revealtrans(duration=수행할 시간,\t&lt;!--? page-enter : 현재 페이지 접속 시  --&gt;  transition=수행할 방법)\"/&gt;\t\t\t&lt;!--? page-exit : 현재 페이지 종료 시 --&gt; \t\t\t\t\t\t&lt;!--? site-enter : 현재 사이트 접속 시 --&gt; \t\t\t\t\t\t&lt;!--? site-exit : 현재 사이트 종료 시 --&gt;       &lt;meta  http-equiv=\"origin-trial\"\t\t\t&lt;!--? 웹 개발자가 웹 문서에 실험단계인 속성을 명시하는 http-equiv 변수 --&gt;  content=\"....\"/&gt;       &lt;meta\t\t\t\t\t\t&lt;!--? 오픈그래프 태그 (OpenGraph Tag) --&gt;  property=\"og:오픈그래프 변수\"\t\t\t&lt;!--? SNS에 게시될 때 데이터 설정을 최적화하는 property 변수 --&gt;  content=\"오픈그래프 변수에 해당되는 값\"/&gt;\t\t&lt;!--? og 필수 변수 --&gt; \t  \t\t\t\t\t&lt;!--? title : 웹 사이트 제목 --&gt; \t\t\t\t\t\t&lt;!--? type : 웹 문서의 타입 --&gt; \t\t\t\t\t\t&lt;!--? image : 웹 문서에 표현될 이미지 --&gt; \t\t\t\t\t\t&lt;!--? url : 웹 문서의 대표 URL --&gt; \t\t\t\t\t\t&lt;!--? og 옵션 변수 --&gt; \t\t\t\t\t\t&lt;!--? description : 웹 문서 내에 표현될 설명 --&gt; \t\t\t\t\t\t&lt;!--? locale : 웹 문서 내에 표현될 언어 --&gt; \t\t\t\t\t\t&lt;!--? locale:alternate : 웹 문서 내에 표현될 다국적 언어 --&gt; \t\t\t\t\t\t&lt;!--? site_name : 웹 문서 내에 표현될 카테고리 제목 --&gt; \t\t\t\t\t\t&lt;!--? audio : 웹 문서에 포함되는 오디오 파일 URL --&gt; \t\t\t\t\t\t&lt;!--? video : 웹 문서에 포함되는 비디오 파일 URL --&gt; \t\t\t\t\t\t&lt;!--? og 오브젝트 변수 --&gt; \t\t\t\t\t\t&lt;!--? width : 웹 문서에 표현될 오브젝트의 가로 길이 --&gt; \t\t\t\t\t\t&lt;!--? height : 웹 문서에 표현될 오브젝트의 세로 길이 --&gt; \t\t\t\t\t\t&lt;!--? url : 웹 문서에 표현될 오브젝트의 URL --&gt; \t\t\t\t\t\t&lt;!--? secure_url : 웹 문서에 표현될 오브젝트의 HTTPS URL --&gt; \t\t\t\t\t\t&lt;!--? alt : 표현될 오브젝트에 대한 설명 --&gt; &lt;/head&gt; &lt;/html&gt;   # 컨텐츠 구분 관련 태그   &lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt; : 문서 정보 계층을 구조화하는 태그     문서나 구분된 영역의 제목을 설정 (Heading)            숫자가 낮을 수록 높은 단계의 제목           &lt;h1&gt;h1&lt;/h1&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;h4&gt;h4&lt;/h4&gt; &lt;h5&gt;h5&lt;/h5&gt; &lt;h6&gt;h6&lt;/h6&gt;   \th1  \th2  \th3  \th4  \th5  \th6    &lt;header&gt;&lt;/header&gt; : 문서의 헤더를 선언하는 태그     헤더 (header) 영역 : 일반적으로 로고, 제목, 검색 등이 포함   &lt;header&gt; &lt;h1&gt;제목&lt;/h1&gt; ... &lt;/header&gt;  header { display: block; }   &lt;footer&gt;&lt;/footer&gt; : 문서의 푸터를 선언하는 태그     푸터 (footer) 영역 : 일반적으로 작성자, 저작권, 관련 문서 등이 포함   &lt;footer&gt; &lt;p&gt;작성자&lt;/p&gt; ... &lt;/footer&gt;  footer { display: block; }   &lt;main&gt;&lt;/main&gt; : 문서의 주요 컨텐츠 영역을 선언하는 태그     한 문서에 하나의 &lt;main&gt; 태그만을 선언 가능   IE에서 지원하지 않음   &lt;main&gt; &lt;h1&gt;주요 컨텐츠&lt;/h1&gt; ... &lt;/main&gt;  main { display: block; }   &lt;article&gt;&lt;/article&gt; : 독립적으로 구분되거나 재사용 가능한 영역을 선언하는 태그     &lt;h1&gt;~&lt;h6&gt; 태그를 포함해 식별   작성한 날짜와 시간을 &lt;time&gt; 태그의 datetime 속성으로 작성   &lt;article&gt; &lt;h2&gt;독립 영역 1&lt;/h2&gt; ... &lt;/article&gt; &lt;article&gt; &lt;h2&gt;독립 영역 2&lt;/h2&gt; ... &lt;/article&gt;  article { display: block; }   &lt;section&gt;&lt;/section&gt; : 문서의 일반적인 영역을 선언하는 태그     &lt;h1&gt;~&lt;h6&gt; 태그를 포함해 식별   &lt;section&gt; &lt;h2&gt;일반 영역 1&lt;/h2&gt; ... &lt;/section&gt; &lt;section&gt; &lt;h2&gt;일반 영역 2&lt;/h2&gt; ... &lt;/section&gt;  section { display: block; }   &lt;aside&gt;&lt;/aside&gt; : 문서의 별도 컨텐츠 영역을 선언하는 태그     사이드 (aside) 영역 : 일반적으로 광고나 사이드바로 설정   &lt;aside&gt; &lt;h4&gt;별도 컨텐츠&lt;/h4&gt; ... &lt;/aside&gt;  aside { display: block; }   &lt;nav&gt;&lt;/nav&gt; : 다른 페이지로 이동하기 위한 링크를 선언하는 태그     일반적으로 바로가기, 목차, 색인 등으로 설정   &lt;a&gt; 태그로 링크 선언   &lt;nav&gt; \t&lt;a href=\"/html/\"&gt;HTML&lt;/a&gt; | \t&lt;a href=\"/html/css/\"&gt;CSS&lt;/a&gt; | \t&lt;a href=\"/html/css/js/\"&gt;JavaScript&lt;/a&gt; &lt;/nav&gt; &lt;nav&gt;     &lt;ol&gt;         &lt;li&gt;&lt;a href=\"#\"&gt;HTML&lt;/a&gt;&lt;/li&gt;         &lt;li&gt;&lt;a href=\"#\"&gt;CSS&lt;/a&gt;&lt;/li&gt;         &lt;li&gt;&lt;a href=\"#\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt;     &lt;/ol&gt; &lt;/nav&gt;  aside { display: block; }   &lt;div&gt;&lt;/div&gt; : 아무것도 나타내지 않은 컨텐츠 영역을 선언하는 태그     일반적으로 CSS와 연게해 꾸미는 목적으로 사용   &lt;div&gt; &lt;h2&gt;아무것도 나타내지 않은 컨텐츠 영역&lt;/h2&gt; ... &lt;/div&gt;  div { display: block; }   # 인라인 텍스트 관련 태그   &lt;p&gt;&lt;/p&gt; : 하나의 문단을 선언하는 태그   &lt;p align=\"center\"&gt;문단 1 : 가운데 정렬&lt;/p&gt; &lt;p align=\"right\"&gt;문단 2 : 오른쪽 정렬&lt;/p&gt;    \t문단 1 : 가운데 정렬  \t문단 2 : 오른쪽 정렬    p { display: block; }   &lt;hr&gt; : 문단을 분리하는 가로줄을 넣는 태그   ↓ 가로줄 &lt;hr&gt; ↑ 가로줄    \t↓ 가로줄 \t \t↑ 가로줄   hr { display: block; }  &lt;a&gt;&lt;/a&gt; : 하이퍼링크를 생성하는 태그   \t \t\t \t\t\ta 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tdownload \t\t\t이 요소가 리소스를 다운로드하는 용도인가? (boolean) \t\t \t\t \t\t\thref \t\t\t링크된 문서를 입력 \t\t \t\t \t\t\ttarget \t\t\t링크된 문서를 어떻게 열지 지정 \t\t \t\t \t\t\tname \t\t\t링크의 이름을 지정 (문서 내에서도 이 이름을 이용해 이동 가능) \t\t \t   &lt;a   href=\"https://pocj8ur4in.github.io\"   target=\"_blank\"   title=\"pocj8ur4in\"&gt;     pocj8ur4in &lt;/a&gt;             pocj8ur4in      a { display: inline; }   &lt;code&gt;&lt;/code&gt; : 소스 코드를 넣는 태그     `을 3번 쓰는 것으로 대체 가능   &lt;code&gt; \tprint(\"Hello World!\") &lt;code&gt;    \tprint(\"Hello World!\")    code { display: inline; }   &lt;time&gt; : 날짜나 시간을 나타내기 위해 선언하는 태그   &lt;p&gt;Hello World!&lt;time datetime=\"유효한 날짜나 시간\"&gt;&lt;/p&gt;  time { display: inline; }   &lt;span&gt;&lt;/span&gt; : 아무것도 나타내지 않는 컨텐츠 영역을 선언하는 태그     일반적으로 CSS와 연게해 꾸미는 목적으로 사용   &lt;p&gt;Hello &lt;span style=\"color:blue\"&gt;World&lt;/span&gt;!&lt;/p&gt;    \tHello World!    span { display: inline; }   &lt;br&gt; : 줄바꿈을 선언하는 태그     Enter 키를 2번 입랙한 것으로 대체 가능   &lt;br&gt;       br { display: inline; }   # 목록 관련 태그   &lt;li&gt;&lt;/li&gt; : 목록을 표시할 때 각 항목들을 선언하는 태그     &lt;ol&gt;과 &lt;ul&gt;은 &lt;li&gt;의 부모            &lt;li&gt;는 단독으로 사용할 수 없음            \t \t\t \t\t\tli 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tvalue \t\t\t숫자로 항목의 순서 지정 \t\t \t   &lt;!--? 잘못된 사용 --&gt; &lt;li&gt;X&lt;/li&gt; &lt;li&gt;Y&lt;/li&gt; &lt;li&gt;Z&lt;/li&gt;   li { display: list-item; }   &lt;ul&gt;&lt;/ul&gt; : 순서 없는 목록을 선언하는 태그   &lt;ul&gt; \t&lt;li&gt;X&lt;/li&gt; \t&lt;li&gt;Y&lt;/li&gt; \t&lt;li&gt;Z&lt;/li&gt; &lt;/ul&gt;    \t \t\tX \t\tY \t\tZ \t   ul { display: block; }   &lt;ol&gt;&lt;/ol&gt; : 순서 있는 목록을 선언하는 태그     정렬된 목록의 항목 순서는 해당 항목의 중요도를 의미할 수 있음    \t \t\t \t\t\tli 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tstart \t\t\t숫자로 항목에 매겨진 번호의 시작 값 지정 \t\t \t\t \t\t\ttype \t\t\t항목에 매겨진 번호의 유형 지정 \t\t \t   &lt;ol&gt; \t&lt;li&gt;X&lt;/li&gt; \t&lt;li&gt;Y&lt;/li&gt; \t&lt;li&gt;Z&lt;/li&gt; &lt;/ol&gt;    \t \t\tX \t\tY \t\tZ \t   ol { display: block; }   &lt;dl&gt;&lt;/dl&gt; : 용어 (&lt;dt&gt;&lt;/dt&gt;)와 정의 (&lt;dd&gt;&lt;/dd&gt;) 쌍의 영역을 선언하는 태그     &lt;dd&gt;와 &lt;dt&gt;는 &lt;dl&gt;의 자식            &lt;dd&gt;와 &lt;dt&gt;는 단독으로 사용할 수 없음           키 (key)와 값 (value)의 형태를 표현할 때 사용   &lt;dl&gt;   &lt;dt&gt;용어 1&lt;/dt&gt;&lt;dd&gt;정의 1&lt;/dd&gt;   &lt;dt&gt;용어 2&lt;/dt&gt;&lt;dd&gt;정의 2&lt;/dd&gt; &lt;/dl&gt;    \t   \t\t용어 1정의 1   \t\t용어 2정의 2 \t   dl, dt, dd { display: block; }   # 표 관련 태그   &lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt; : 표를 만드는 태그     데이터 표(&lt;table&gt;)의 행(&lt;tr&gt;), 머리글 열(&lt;th&gt;)과 내용 열(&lt;td&gt;)을 생성    \t \t\t \t\t\ttable 태그 \t\t\t설명 \t\t \t \t \t\t \t\t\ttr \t\t\t표의 행 표현 \t\t \t\t \t\t\tth \t\t\t표의 머리말 열 표현 \t\t \t\t \t\t\ttd \t\t\t표의 내용 열 표현 \t\t \t    \t \t\t \t\t\ttable 컨텐츠 구분 \t\t\t설명 \t\t \t \t \t\t \t\t\tcaption \t\t\t표의 제목 부분 기술 \t\t \t\t \t\t\tcol \t\t\t표의 열 정보 기술 \t\t \t\t \t\t\tthead \t\t\t표의 헤더 부분 기술 \t\t \t\t \t\t\ttbody \t\t\t표의 본문 부분 기술 \t\t \t\t \t\t\ttfoot \t\t\t표의 푸터 부분 기술 \t\t \t    \t \t\t \t\t\ttable 관련 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tabbr \t\t\tth : 표에서 열에 대한 설명 \t\t \t\t \t\t\tscope \t\t\tth : 어느 부분의 머리말인지 명시 col / row : 자신의 열 / 자신의 행 colgroup / rowgroup : 모든 열 / 모든 행 \t\t \t\t \t\t\tcolspan \t\t\t표에서 병합하려는 열의 수 \t\t \t\t \t\t\trowspan \t\t\t표에서 병합하려는 행의 수 \t\t \t   &lt;table&gt;   &lt;caption&gt;OO고등학교 시간표&lt;/caption&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt; &lt;/th&gt;       &lt;th&gt;월&lt;/th&gt;       &lt;th&gt;화&lt;/th&gt;       &lt;th&gt;수&lt;/th&gt;       &lt;th&gt;목&lt;/th&gt;       &lt;th&gt;금&lt;/th&gt;      &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;1교시&lt;/th&gt;       &lt;td&gt;수학&lt;/td&gt;       &lt;td rowspan=\"2\"&gt;국어&lt;/td&gt;       &lt;td&gt;수학&lt;/td&gt;       &lt;td&gt;과학&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2교시&lt;/th&gt;       &lt;td rowspan=\"2\"&gt;사회&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;       &lt;td&gt;국어&lt;/td&gt;       &lt;td rowspan=\"3\"&gt;음악&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;3교시&lt;/th&gt;       &lt;td&gt;수학&lt;/td&gt;       &lt;td rowspan=\"2\"&gt;미술&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;4교시&lt;/th&gt;       &lt;td&gt;체육&lt;/td&gt;       &lt;td&gt;사회&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;    \tOO고등학교 시간표 \t \t\t \t\t\t  \t\t\t월 \t\t\t화 \t\t\t수 \t\t\t목 \t\t\t금 \t\t \t \t \t\t \t\t\t1교시 \t\t\t수학 \t\t\t국어 \t\t\t수학 \t\t\t과학 \t\t\t영어 \t　　 \t\t \t\t\t2교시 \t\t\t사회 \t\t\t영어 \t\t\t국어 \t\t\t음악 \t　　 \t\t \t\t\t3교시 \t\t\t수학 \t\t\t미술 \t\t\t영어 \t\t \t\t \t\t\t4교시 \t\t\t체육 \t\t\t사회 \t\t\t영어 \t　　 \t   table { display: table; } tr { display: table-row; } th, td { display: table-cell; }   # 멀티미디어 관련 태그   &lt;img&gt; : 이미지를 삽입하는 태그   \t \t\t \t\t\timg 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t이미지 파일의 경로를 지정 절대 경로 : http:// 또는 https:// 상대 경로 : /path/filename \t\t \t\t \t\t\talt \t\t\t이미지가 출력되지 않을 경우 이미지에 대한 설명을 제공 \t\t \t\t \t\t\ttitle \t\t\t이미지에 대한 추가 정보를 제공  (마우스가 접근하면 말풍선으로 표시) \t\t \t\t \t\t\twidth, height \t\t\t이미지의 가로, 세로의 길이를 지정 (HTML5 : 픽셀만 지정 가능, %는 CSS 대체) \t\t \t\t \t\t\tborder \t\t\t이미지의 경계선의 두께를 지정 (기본값 : 1px) \t\t \t   &lt;img src=\"https://cdn.pixabay.com/photo/2020/10/21/04/01/leaves-5672036_1280.png\"   alt=\"leaves-5672036_1280.png\"   title=\"이미지\"   height=\"360px\"   width=\"360px\"   border=\"0px\"&gt;      img { display: inline; }   &lt;audio&gt; : 오디오를 삽입하는 태그    \t \t\t \t\t\taudio 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t삽입할 오디오의 주소 지정 \t\t \t\t \t\t\tautoplay \t\t\t오디오의 자동 재생 여부 지정 \t\t \t\t \t\t\tcontrols \t\t\t오디오의 소리 조절, 시간대 탐색, 일시정지 및 재시작을 할 수 있는 컨트롤러 생성 \t\t \t\t \t\t\tloop \t\t\t비디오의 재시작 여부 지정 \t\t \t\t \t\t\tpreload \t\t\t웹 문서를 열 때 동영상, 메타데이터 로드 여부 지정 auto : 모두 로드 metadata : 메타데이터만 로드 none : 모두 로드하지 않음 \t\t \t   audio { display: inline; }   &lt;video&gt; : 비디오를 삽입하는 태그    \t \t\t \t\t\tvideo 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t삽입할 비디오의 주소 지정 \t\t \t\t \t\t\tposter \t\t\t삽입할 비디오 썸네일 이미지의 주소 지정 \t\t \t\t \t\t\ttype \t\t\t삽입할 비디오의 타입 지정 \t\t \t\t \t\t\theight \t\t\t비디오의 출력 영역 높이 지정 \t\t \t\t \t\t\twidth \t\t\t비디오의 출력 영역 너비 지정 \t\t \t\t \t\t\tposter \t\t\t비디오 포스터 프레임의 주소 지정 \t\t \t\t \t\t\tautoplay \t\t\t비디오의 자동 재생 여부 지정 \t\t \t\t \t\t\tcontrols \t\t\t비디오의 소리 조절, 시간대 탐색, 일시정지 및 재시작을 할 수 있는 컨트롤러 생성 \t\t \t\t \t\t\tloop \t\t\t비디오의 재시작 여부 지정 \t\t \t\t \t\t\tpreload \t\t\t웹 문서를 열 때 동영상, 메타데이터 로드 여부 지정 auto : 모두 로드 metadata : 메타데이터만 로드 none : 모두 로드하지 않음 \t\t \t      video { display: inline; }   &lt;figure&gt;&lt;/figure&gt; : 이미지나 다이어그램 영역을 삽입하는 태그     &lt;figcation&gt; : &lt;figure&gt;에 포함되어 이미지나 다이어그램의 설명을 추가하는 태그   &lt;figure&gt;   &lt;figcaption&gt;     figure   &lt;/figcaption&gt;   &lt;img     src=\"https://cdn.pixabay.com/photo/2020/10/21/04/01/leaves-5672036_1280.png\"     alt=\"leaves-5672036_1280.png\"     title=\"이미지\"     height=\"360px\"     width=\"360px\"&gt; &lt;/figure&gt;    \t \t\tfigure \t \t   figure { display: block; } figcation { display: inline; }   # 프레임 관련 태그   &lt;iframe&gt;&lt;/iframe&gt; : 웹 문서 안에 박스형으로 프레임을 넣어 문서 안의 문서를 표현하는 태그     중첩된 브라우저 프레임 : 다른 HTML 문서를 현재 HTML 문서에 삽입    \t \t\t \t\t\tiframe 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tname \t\t\t프레임의 이름 지정 \t\t \t\t \t\t\tsrc \t\t\t삽입할 웹 문서의 주소 지정 \t\t \t\t \t\t\theight \t\t\t프레임의 높이 지정 \t\t \t\t \t\t\twidth \t\t\t프레임의 너비 지정 \t\t \t\t \t\t\tsandbox \t\t\t일기 전용으로 삽입 (Boolean) allow-form : 양식 제출 가능 allow-scripts : 스크립트 실행 가능 allow-same-origin : 같은 도메인의 리소스 사용 가능 \t\t \t\t \t\t\tframeborder \t\t\t프레임 테두리 표시 여부 지정 (Boolean) \t\t \t\t \t\t\tallowfullscreen \t\t\t프레임의 전체 화면 모드 전환 여부 지정 \t\t \t   &lt;div&gt; \t&lt;iframe \t\tsrc=\"https://github.com/pocj8ur4in\" \t\twidth=\"360\" \t\theight=\"360\" \t\tscrolling=\"no\" \t\tframeborder=\"1\" \t\tallowfullscreen=\"true\" \t\tallow=\" \t\t\tclipboard-write; \t\t\tencrypted-media; \t\t\tpicture-in-picture; \t\t\tweb-share\" \t\tsandbox=\" \t\t\tallow-same-origin \t\t\tallow-popups \t\t\tallow-scripts\" \t\t&gt; \t&lt;/iframe&gt; &lt;/div&gt;    \t \t   iframe { display: inline; }   # 스크립트 관련 태그   &lt;script&gt;&lt;/script&gt; : 외부 스크립트 파일을 참조하는 태그     외부 스크립트 파일 : javascript, CSS    \t \t\t \t\t\tscript 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t삽입할 외부 스크립트의 주소 지정 \t\t \t\t \t\t\tasync \t\t\t스크립트의 비동기적 실행 여부 (Boolean) \t\t \t\t \t\t\tdefer \t\t\t문서 파싱 후 작동 여부 (Boolean) \t\t \t\t \t\t\ttype \t\t\t삽입할 외부 스크립트의 타입 지정 \t\t \t\t \t\t\tframeborder \t\t\t프레임 테두리 표시 여부 지정 (Boolean) \t\t \t\t \t\t\tallowfullscreen \t\t\t프레임의 전체 화면 모드 전환 여부 지정 \t\t \t   &lt;script type=\"application/ld+json\"&gt;\t&lt;!--? 구조화된 JSON-LD 데이터 스니펫 : 제목, 작성자 및 세부 정보를 Google이 수집 --&gt;   {     \"@context\": \"https://schema.org\",            \"@type\": \"website\",       \"name\": \"website_name\",       \"author\": {         \"@type\": \"Person\",         \"name\": \"Person_name\"       },       \"description\": \"website_description\",       \"url\": \"website_url\"   } &lt;/script&gt;   script { display: none; }   # 양식 관련 태그   &lt;form&gt;&lt;/form&gt; : 웹 서버에 제출하기 위한 양식의 입력값을 받는 태그     &lt;form&gt;이 다른 &lt;form&gt;을 자식 요소로 포함할 수 없음      form 태그가 동작하는 과정         사용자가 브라우저를 통해 폼이 있는 웹 문서에 방문     사용자가 브라우저를 통해 폼의 내용을 입력     폼 안에 있는 모든 데이터를 웹 서버로 전송     웹 서버는 전송받은 폼 데이터의 처리를 위해 웹 프로그램으로 전달     웹 프로그램에서 데이터를 처리하고, 결과에 따른 새로운 웹 문서를 웹 서버로 전달     웹 서버는 전송받은 새로운 웹 문서를 브라우저로 전송     브라우저는 전송받은 새로운 웹 문서를 표현       \t \t\t \t\t\tform 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tname \t\t\t폼을 식별하기 위한 고유한 이름 지정 \t\t \t\t \t\t\taccept-charset \t\t\t폼 전송에 사용할 문자 인코딩 방식 지정 \t\t \t\t \t\t\tautocomplete \t\t\t자동 완성 기능을 사용할지 여부 지정 (ON | OFF) \t\t \t\t \t\t\taction \t\t\t입력 양식에 입력된 값을 저장할 데이터베이스 문서 지정 (해당 문서는 PHP나 ASP로 작성) \t\t \t\t \t\t\tnovalidate \t\t\t양식 데이터의 유효성을 검사하지 않을지 지정 \t\t \t\t \t\t\ttarget \t\t\taction에서 지정한 스크립트 파일을 현재 창이 아닌 다른 위치에 열도록 지정 \t\t \t\t \t\t\tmethod \t\t\tHTTP 메소드 (웹 서버와의 통신 방식) 지정 (GET | POST) \t\t \t   &lt;html&gt;   &lt;body&gt;     &lt;form       action = \"http://localhost:4000/form.jsp\"       accept-charset=\"utf-8\"       name = \"person_info\"       method = \"get\"&gt;      &lt;/form&gt;   &lt;/body&gt; &lt;html&gt;  form { display: block; }   &lt;label&gt;&lt;/label&gt; : 양식에 이름을 지정하는 태그     &lt;label for=\"\"&gt; : label의 for의 값과 양식의 id의 값이 같으면 연결하는 속성   &lt;label&gt; 가능 요소 : &lt;button&gt;, &lt;input&gt;, &lt;progress&gt;, &lt;select&gt;, &lt;textarea&gt;   &lt;label for=\"input-label\"&gt;   input-text &lt;/label&gt;  &lt;input type=\"text\" id=\"input-text\"&gt;  &lt;label for=\"checkbox-label\"&gt;   checkbox-text &lt;/label&gt;  &lt;input type=\"checkbox\" id=\"checkbox-text\"&gt;    \tinput-text \t \tcheckbox-text \t   label { display: inline; }   &lt;input&gt; : 입력값을 입력받을 필드를 선언하는 태그    \t \t\t \t\t\tinput 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tname \t\t\t입력값 필드을 식별하기 위한 고유한 이름 지정 \t\t \t\t \t\t\ttype \t\t\t입력값 필드의 종류를 지정 \t\t \t    \t \t\t \t\t\tinput type 변수 \t\t\t설명 \t\t \t \t \t\t \t\t\ttext \t\t\t한 줄의 문자열 생성 (기본 변수) \t\t \t\t \t\t\tpassword \t\t\t비밀번호 생성 \t\t \t\t \t\t\trange \t\t\t지정한 범위의 숫자 생성 \t\t \t\t \t\t\tcheckbox \t\t\t선택/해제할 수 있는 항목 (중복 가능) 생성 \t\t \t\t \t\t\tradio \t\t\t선택/해제할 수 있는 항목 (중복 불가) 생성 \t\t \t\t \t\t\tsubmit \t\t\t클릭할 경우 입력값을 전송하는 버튼 생성 \t\t \t\t \t\t\tsearch \t\t\t클릭할 경우 입력값을 검색하는 버튼 생성 \t\t \t\t \t\t\treset \t\t\t클릭할 경우 입력값을 초기화하는 버튼 생성 \t\t \t\t \t\t\tfile \t\t\t파일을 업로드하는 버튼 생성 \t\t \t\t \t\t\thidden \t\t\t입력값 없이 폼과 함께 전송해야 하는 정보를 감쌈 (hidden flied) \t\t \t   &lt;input type=\"text\" name=\"text\"&gt;    \t   &lt;input type=\"password\" name=\"password\"&gt;    \t   &lt;input type=\"range\" name=\"range\"&gt;    \t   &lt;input type=\"checkbox\" name=\"checkbox\" value=\"1\"&gt;1 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"2\"&gt;2 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"3\"&gt;3 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"4\"&gt;4 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"5\"&gt;5    \t1  \t2  \t3  \t4  \t5   &lt;input type=\"radio\" name=\"radio\" value=\"1\"&gt;1 &lt;input type=\"radio\" name=\"radio\" value=\"2\"&gt;2 &lt;input type=\"radio\" name=\"radio\" value=\"3\"&gt;3 &lt;input type=\"radio\" name=\"radio\" value=\"4\"&gt;4 &lt;input type=\"radio\" name=\"radio\" value=\"5\"&gt;5    \t1  \t2  \t3  \t4  \t5   &lt;input type=\"submit\" name=\"submit\"&gt;    \t   &lt;input type=\"search\" name=\"search\"&gt;    \t   &lt;input type=\"reset\" name=\"reset\"&gt;    \t   &lt;input type=\"file\" name=\"file\"&gt;    \t      input { display: inline-block; }   &lt;button&gt;&lt;/button&gt; : 클릭 가능한 버튼을 생성하는 태그    \t \t\t \t\t\tbutton 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tautofocus \t\t\t페이지가 로드될 때 자동으로 포커싱 여부 (Boolean). 문서 내에 고유해야 함 \t\t \t\t \t\t\tdisabled \t\t\t버튼의 비활성화 여부 (Boolean) \t\t \t\t \t\t\tname \t\t\t폼 데이터와 함께 전송될 버튼의 이름을 지정 \t\t \t\t \t\t\ttype \t\t\t버튼의 종류를 지정 (button, reset, submit) \t\t \t   &lt;button name=\"button\"&gt; \t버튼 &lt;/button&gt;    \t버튼    button { display: inline-block; }   &lt;textarea&gt;&lt;/textarea&gt; : 여러 줄의 문자열 값을 입력받는 태그    \t \t\t \t\t\ttextarea 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tautofocus \t\t\t페이지가 로드될 때 자동으로 포커싱 여부 (Boolean). 문서 내에 고유해야 함 \t\t \t\t \t\t\tautocomplete \t\t\t자동 완성 기능을 사용할지 여부 지정 (ON | OFF) \t\t \t\t \t\t\tdisabled \t\t\t텍스트 에이리어의 비활성화 여부 (Boolean) \t\t \t\t \t\t\trows \t\t\t텍스트 에이리어의 행의 개수을 지정 \t\t \t\t \t\t\tcols \t\t\t텍스트 에이리어의 열의 개수을 지정 \t\t \t\t \t\t\tmaxlength \t\t\t텍스트 에이리어에 입력 가능한 최대 문자 수 \t\t \t\t \t\t\tplaceholder \t\t\t텍스트 에이리어에 입력할 문자열에 대한 힌트 \t\t \t\t \t\t\treadonly \t\t\t읽기 전용 여부 (Boolean) \t\t \t   &lt;textarea cols=\"50\" rows=\"10\"&gt;&lt;/textarea&gt;    \t      textarea { display: inline-block; }   &lt;progress&gt;&lt;/progress&gt; : 작업의 진행률을 표시하는 태그    \t \t\t \t\t\tprogress 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tmax \t\t\t작업의 총량 지정 \t\t \t\t \t\t\tvalue \t\t\t작업의 진행량 지정 \t\t \t   &lt;progress value=\"70\" max=\"100\"&gt;70 %&lt;/progress&gt;    \t70 %      progress { display: inline-block; }   &lt;select&gt;&lt;/select&gt; : 드롭다운 목록을 생성하는 태그     드롭다운 항목(&lt;option&gt;)의 드롭다운 목록(&lt;select&gt;) 제공    \t \t\t \t\t\tselect 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tautocomplete \t\t\t자동 완성 기능을 사용할지 여부 지정 (ON | OFF) \t\t \t\t \t\t\tdisabled \t\t\t드롭다운 목록의 비활성화 여부 (Boolean) \t\t \t\t \t\t\tmultiple \t\t\t다중으로 선택할지 여부 (Boolean) \t\t \t\t \t\t\tname \t\t\t드롭다운 목록의 이름 지정 \t\t \t\t \t\t\tsize \t\t\t드롭다운 목록에서 한 번에 볼 수 있는 행의 개수 \t\t \t   select { display: inline-block; }   &lt;option&gt;&lt;/option&gt; : 드롭다운 목록에 대한 드롭다운 항목을 생성하는 태그     &lt;option&gt;는 선택적 빈 태그로 사용 가능   &lt;optgroup&gt;으로 그룹화 가능    \t \t\t \t\t\toption 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tdisabled \t\t\t드롭다운 항목의 비활성화 여부 (Boolean) \t\t \t\t \t\t\tlabel \t\t\t드롭다운 항목의 제목 지정 (생략되면 포함된 텍스트를 표시) \t\t \t\t \t\t\tselected \t\t\t옵션이 선택되었음을 표시 (Boolean) \t\t \t\t \t\t\tvalue \t\t\t양식으로 제출될 값 (생략되면 포함된 텍스트를 값으로 사용) \t\t \t   &lt;form&gt;     &lt;select&gt;         &lt;option&gt;a&lt;/option&gt;         &lt;option&gt;b&lt;/option&gt;         &lt;option&gt;c&lt;/option&gt;         &lt;option&gt;d&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select autofocus&gt;         &lt;option&gt;e&lt;/option&gt;         &lt;option&gt;f&lt;/option&gt;         &lt;option&gt;g&lt;/option&gt;         &lt;option&gt;h&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select disabled&gt;         &lt;option&gt;i&lt;/option&gt;         &lt;option&gt;j&lt;/option&gt;         &lt;option&gt;k&lt;/option&gt;         &lt;option&gt;l&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select multiple&gt;         &lt;option&gt;m&lt;/option&gt;         &lt;option&gt;n&lt;/option&gt;         &lt;option&gt;o&lt;/option&gt;         &lt;option&gt;p&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select name=\"select box\" size=\"2\"&gt;         &lt;option&gt;q&lt;/option&gt;         &lt;option&gt;r&lt;/option&gt;         &lt;option&gt;s&lt;/option&gt;         &lt;option&gt;t&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt;                 a         b         c         d                     e         f         g         h                     i         j         k         l                     m         n         o         p                     q         r         s         t        option, optgroup { display: block; }   &lt;fieldset&gt;&lt;/fieldset&gt; : 같은 목적의 양식을 그룹화하는 태그     &lt;legend&gt; 태그로 제목을 지정할 수 있음   &lt;form&gt;   &lt;fieldset&gt;     &lt;legend&gt;커피 사이즈&lt;/legend&gt;     &lt;label&gt;         &lt;input type=\"radio\" name=\"size\" value=\"t\" /&gt;         톨     &lt;/label&gt;     &lt;label&gt;         &lt;input type=\"radio\" name=\"size\" value=\"g\" /&gt;         그란데     &lt;/label&gt;     &lt;label&gt;         &lt;input type=\"radio\" name=\"size\" value=\"v\" /&gt;         벤티     &lt;/label&gt;   &lt;/fieldset&gt; &lt;/form&gt;           커피 사이즈                       톨                            그란데                            벤티           fieldset, legend { display: block; }  ","categories": [],
        "tags": ["FrontEnd"],
        "url": "/html1/",
        "teaser": null
      },{
        "title": "[Language] 1. 파이썬 (Python)",
        "excerpt":"파이썬 (Python) : 소스 코드를 한 줄씩 읽는 인터프리터 언어 (Interpreter Language)      대화식 프로그래밍 (&gt;&gt;&gt;) : 사용자가 입력하면 인터프리터가 바로 번역 및 처리 작업을 한 후 결과를 응답   블록 처리 규칙 : 괄호 ({}) 대신 들여쓰기 (Indentation)를 블럭 단위로 사용            : : 제어문이나 함수나 클래스의 이름의 끝을 표현           순수 객체 지향 : 변수, 클래스, 함수, 상수 등 모든 것을 객체로 취급   변수 (Variable) : 객체를 저장할 수 있는 메모리 공간     객체 (Object) : 어떠한 상태 (State)와 행동 (Behavior)을 가지고 있는 데이터            객체의 상태는 속성값 (Value), 객체의 행동은 메소드 (Method)으로 메모리에 저장됨           &gt;&gt;&gt; x = 100 # x는 100의 값을 가짐      None : 변수에 아무런 값이 존재하지 않는 것을 표현   &gt;&gt;&gt; y = None  # y는 어떤 값도 가지지 않음   연산자 (Operator) : 변수 및 특정한 값들에 대한 작업을 위해 사용되는 기호     산술 연산자 (Arithmetic~) : 더하기 (+), 빼기 (-), 곱하기 ( *), 나누기 (/), 나머지 (%), 제곱 (**), 몫 (//)   할당 연산자 (Assignment~) : 대입 (=), 산술하고 대입 (+=, -=, *=, /=, %=)   비교 연산자 (Comparison~) : 같음 (==), 같지 않음 (!=), 큼 (&gt;), 크거나 같음 (&gt;=), 작거나 같음 (&lt;=), 작음 (&lt;)   논리 연산자 (Logical~) : 모두 참 (and), 하나라도 참 (or), 결과와 반대로 (not)   식별 연산자 (Identity~) : 두 변수가 같은 객체 메모리이면 (is), 두 변수가 같은 객체 메모리가 아니면 (is not)   멤버 연산자 (Member~) : 객체 내에 해당 값이 포함되면 (in), 객체 내에 해당 값이 포함되지 않으면 (not in)   비트 연산자 (Bitwise~) : 비트 AND 연산 (&amp;), 비트 OR 연산 (|)   자료형 (Data type) : 저장되는 데이터의 종류에 따른 변수의 형태   &gt;&gt;&gt; type(1) &lt;class 'int'&gt;                               # 수치) 정수  &gt;&gt;&gt; type(3.14) &lt;class 'float'&gt;                             # 수치) 실수  &gt;&gt;&gt; type(1+2j) &lt;class 'complex'&gt;                           # 수치) 복소수  &gt;&gt;&gt; type('hello') &lt;class 'str'&gt;                               # 문자열  &gt;&gt;&gt; type(False) &lt;class 'bool'&gt;                              # 부울  &gt;&gt;&gt; type([1,2,3,4,5]) &lt;class 'list'&gt;                              # 리스트  &gt;&gt;&gt; type((1,2,3,4,5)) &lt;class 'tuple'&gt;                             # 튜플  &gt;&gt;&gt; type({1,2,3,4,5}) &lt;class 'set'&gt;                               # 집합  &gt;&gt;&gt; type({1:10,2:20,3:30,4:40,5:50}) &lt;class 'dict'&gt;                              # 딕셔내리  수치 (Numbers) : 수학에서 사용하는 수를 표현하는 자료형      정수 (int) : 양수, 음수, 0 등의 정수를 표현            파이썬은 메모리가 허용하는 범위에서 지원 가능한 수까지 지원       b, o, x : 2진수, 8진수, 16진수로 표현           num1 = 0 num2 = -1 num3 = 10 # 10진수의 10 num4 = 0b10 # 2진수의 10, 10진수로 표현하면 2 num5 = 0x10 # 16진수의 10, 10진수로 표현하면 16      실수 (float) : 유리수와 무리수 등의 실수를 표현            e : 10의 거듭제곱을 표현           num1 = 3.14 # 3.14로 출력 num2 = 3.14e2 # 314.0로 출력 num3 = 3.14e-3 # 0.00314로 출력      복소수 (complex) : 복소수를 표현 (실수부 + 허수부 (j) 로 구성)            .real : 복소수의 실수부를 실수형 상수로 표현       .imag : 복소수의 허수부를 실수형 상수로 표현       complex(x, y) : 복소수형 상수를 표현           num1 = 1+2j num2 = num1.real # 1.0으로 표현 num3 = num2.imag # 2.0으로 표현 num4 = complex(1,2) # (1+2j)로 표현   부울 (bool) : 참 또는 거짓을 표현하는 자료형 (첫 글자는 대문자로 시작)     True : 참을 표현 (1의 값을 가짐)   False : 거짓을 표현 (0의 값을 가짐)   bool1 = True bool2 = False   시퀀스 (Sequence) : 자료들이 순서를 가지고 나열되어 있는 자료형      인덱싱 (Indexing) : 인덱스에 해당하는 요소 하나를 취함          인덱스 (Index) : 위치를 가리키는 정수값 (0부터 시작)       data[0], data[1], data[2]       슬라이싱 (Slicing) : 자료에서 일정 범위에 해당하는 부분을 취함     data[1:2] data[3:] data[-1:]      print('hello'[::2]) # 홀수 번째 문자들만 추출한 문자열 print('hello'[::-1]) # 거꾸로 된 문자열        연결 (+) : 두 개의 자료를 순서 있게 연결해 새로운 자료로 만듬     data = 'hello'[0] + 'hello'[4]       반복 (*) : 자료를 일정한 횟수로 반복해 새로운 자료로 만듬     data = [1, 2, 3, 4, 5] * 3       data = 'hello' * 2       len : 자료를 구성하는 요소의 개수 / 길이 출력     data = len([1, 2, 3, 4, 5])      data = len('hello')       ìn: 자료에 값이 있는지 확인     data = 1 in data      data = 'e' in 'hello'         문자열 (str) : 한 글자 이상의 문자, 숫자, 기호를 표현   str1 = `hello` str2 = \"World\" str3 = \"\"\" hello World \"\"\" str4 = \"hello 'World'\" str5 = 'hello \"World\"'      이스케이프 문자 : 키보드로 입력하기 어려운 기호를 나타내기 위한 문자          \\n : 줄바꿈     \\t : 탭     \\\\ : \\     \\' : '     \\\" : \"         리스트 (list) : 값을 변경할 수 있는 여러 개의 데이터를 하나의 변수로 표현   &gt;&gt;&gt; li1 = [ 1, 'two', 3, 3, 'five' ]        # 리스트 &gt;&gt;&gt; li2 = [  ]                              # 빈 리스트      튜플 (tuple) : 값을 변경할 수 없는 여러 개의 데이터를 하나의 변수로 표현   &gt;&gt;&gt; tp1 = ( 1, 2, 3, 4, 4 )                 # 튜플 &gt;&gt;&gt; tp2 = (  )                              # 빈 튜플   논시퀀스 (Non-Sequence) : 자료들이 순서를 가지지 않고 나열되어 있는 자료형     집합 (set) : 값을 변경할 수 있고 여러 개의 데이터를 중복되지 않게 하나의 변수로 표현하는 자료형   &gt;&gt;&gt; st1 = { 1, 2, 3, 4, 5 }                 # 집합 &gt;&gt;&gt; st2 = set()                             # 빈 집합      딕셔내리 (dict) : 서로 대응되고 중복되지 않는 키와 값으로 데이터를 표현하는 자로형   &gt;&gt;&gt; dc1 = { 1:\"one\", 2:\"two\" }              # 딕셔내리 &gt;&gt;&gt; dc2 = {}                                # 빈 딕셔내리  for i in range(10): dc2[i] = str(i)  print(dc2) # {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9'}   제어문 (control flow) : 프로그램의 흐름을 지시하는 문장     조건문 if : 조건이 참인 경우에 실행할 문장을 지정해 수행            else : 조건이 거짓인 경우에 실행할 문장을 지정해 수행       elif : else if. 여러 개의 조건을 순차적으로 체크하기 위해 사용           if condition1:     statement1 elif condition2:     statement2 else:     statement3      반복문 for : 반복할 블록을 특정한 범위를 지정해 반복해 수행            continue : 현재 반복중인 블록의 나머지 부분을 실행하지 않고 다음 반복문을 수행       break : 반복문을 수행하지 않고 블록 밖으로 탈출       else : 반복문이 모두 수행되었을 때 수행           range = [1,2,3,4,5,6,7,8,9]  for i in range:        print(i)      반복문 while : 반복할 블록을 특정한 조건을 지정하고, 조건이 참이면 반복해 수행            continue : 현재 반복중인 블록의 나머지 부분을 실행하지 않고 다음 반복문을 수행       break : 반복문을 수행하지 않고 블록 밖으로 탈출           while condition:     if condition1:         break     if condition2:         continue     statement1 else:     statement2      반복 가능한 (iterable) 데이터 : 문자열, 리스트, 튜플, 집합, 딕셔내리, 바이트          __iter__ 메소드를 가지고 있음 : 반복자를 반환                반복자 (iterator) : __next__ 메소드를 통해 컨테이너의 개별 요소를 반복                  임포트 (import) : 모듈에 있는 함수들을 활용하기 위해 가져오는 것      모듈 (module) : 이미 만들어진 함수들을 하나의 파이썬 파일에 묶어둔 것     import mod       패키지 (package) : 모듈을 계층적인 디렉터리 형태로 구성한 것         디렉터리를 파이썬 패키지로 인식하려면 계층적으로 이루어져 있는 각 디렉토리마다 __init__.py 파일이 필요            pack 디렉토리에 mod.py와 __init__.py (내용 : version = 1.0)이 있는 구조       import pack.mod           import time # 파이썬 내장 모듈인 time 모듈 : time.sleep() 함수를 활용하기 위해 임포트  print('장비를 정지합니다.') time.sleep(5) print('안 되잖아?') time.sleep(5) print('어, 정..정지가 안 돼. 정지시킬 수가 없어.')      from : 계층구조를 모두 표시하지 않고 패키지나 모듈의 함수 호출   from 모듈 import 함수 from 패키지 import 모듈      as : 이름이 복잡하거나 계층구조가 복잡한 모듈에 이름을 붙어서 호출   import 모듈 as 별명   클래스 (class) : 객체지향 프로그래밍에서 특정 객체의 생성을 위해 변수와 메소드를 정의하는 공간 (namespace)          객체지향 프로그래밍 (OOP) : 프로그램을 객체 단위로 나누고 이들 간의 상호 작용으로 서술하는 방식                객체 (object) : 하나의 역할을 수행하는 멤버 (변수와 메소드)의 집합                        변수 (variable) : 데이터를 저장하기 위해 할당된 메모리 공간             메소드 (method) : 특정 작업을 수행하는 일련의 문장을 하나로 묶은 것                                         클래스 멤버 (class member) : 클래스에 정적으로 선언된 변수와 메소드            클래스 내에서 변수와 메소드를 선언           인스턴스 멤버 (instance member) : 클래스에 동적으로 선언된 변수와 메소드            클래스의 메소드 내에서 변수와 메소드를 선언              인스턴스 멤버는 클래스 멤버를 참조할 수 있지만, 클래스 멤버는 인스턴스 멤버를 참조할 수 없다.          클래스 멤버 : 클래스가 메모리에 로드될 때 생성     인스턴스 멤버 : 인스턴스가 생성될 때, 즉 클래스가 메모리에 로드된 이후에 생성       … 인스턴스가 생성될 때 클래스는 항상 메모리에 로드되어 있다. 그러나, 클래스의 생성이 인스턴스의 존재를 보장하지 않는다.    class myClass:   def func(self, name): # 클래스 메소드는 첫번째 인자가 반드시 self이여야 함     self.name = name     print(name + ' : ' + var)  obj = myClass() var = obj.var obj.func(var) # '클래스 멤버 : 클래스 멤버' 출력      클래스 생성자 init  : 클래스의 인스턴스 객체가 생성될 때 제일 먼저 호출되어 실행 (인스턴스 멤버 초기화)   클래스 소멸자 del : 클래스의 인스턴스 객체가 메모리에서 제거될 때 자동적으로 호출   class myClass:   def __init__(self):     self.var = '클래스 멤버'     print('&gt; myClass 클래스 시작') # '&gt; myClass 클래스 시작' 출력  ...    def __del__(self):     print('&gt; myClass 클래스 종료') # '&gt; myClass 클래스 종료' 출력  obj = myClass() ... del obj      클래스 상속 (class inherit) : 부모 클래스가 가진 멤버나 메소드를 상속받는 자식 클래스가 사용할 수 있게 하는 것   class subClass (myClass):   함수 (function) : 소스 코드에서 일정한 동작을 수행하는 코드     사용자 정의 함수 def( parameter ) : 함수 이름과 인수로 함수 정의            인자 (parameter) : 함수 호출 시 입력받을 값                    인자의 이름와 값을 넣어 호출할 수 있음 : 넣지 않으면 입력한 순서대로 배정           인자는 기본값을 지정할 수 있음 : 기본값이 있는 인자는 기본값이 없는 인자 뒤에 와야 함           가변 인자 : 개수를 정하지 않고 입력하는 값을 모두 인자로 사용 (* : 튜플로 저장, ** : 딕셔내리로 저장)                       반환값 (return value) : 반환문 return으로 반환할 값 정의                    반환문을 만날 경우, 해당 함수를 종료하고 반환값을 반환                           # 사용자 정의 함수 선언 def function_name( p1 = 2, p2) :     return p1  # 사용자 정의 함수 호출 &gt;&gt;&gt; user_func = function_name( p1 = 3, p2 = 4 )      전역 변수 (global) : 코드 전반에 걸쳐 유효한 변수   def function():   global param   param = 23      내장 함수 (Built-in Functions) : 다른 파이썬 모듈의 임포트 없이 사용할 수 있는 함수   &gt; dir(__builtins__) # 파이썬에서 사용할 수 있는 내장 함수를 확인   print() : 인자로 입력된 객체 값을 화면에 출력     end=\"\" : 출력되는 값 뒤에 추가될 값 지정 (기본값 : \\n)   x = 100 print(x) print(x, end = \"\") # 맨 뒤에 줄바꿈이 되지 않은 문장 출력      포맷 문자열 : 변하는 값을 포함하는 문자열을 표현하기 위해 사용되는 기호          %s : 문자열에 대응     %c : 문자나 기호 1개에 대응     %d : 정수에 대응     %f : 실수에 대응      input() : 키보드로 입력된 객체 값을 문자열로 반환     인수로 입력된 문자열은 화면에 출력   x = input('&gt; 값을 입력하세요 : ') print('입력된 값 : ' + x)   type() : 인자로 입력된 객체 값의 자료형을 반환   print(type(1))                           # &lt;class 'int'&gt; print(type(3.14))                        # &lt;class 'float'&gt; print(type(1+2j))                        # &lt;class 'complex'&gt; print(type('hello'))                     # &lt;class 'str'&gt; print(type(False))                       # &lt;class 'bool'&gt; print(type([1,2,3,4,5]))                 # &lt;class 'list'&gt; print(type((1,2,3,4,5)))                 # &lt;class 'tuple'&gt; print(type({1,2,3,4,5}))                 # &lt;class 'set'&gt; print(type({1:10,2:20,3:30,4:40,5:50}))  # &lt;class 'dict'&gt;   divmod() : 첫번째 정수 인자를 두번째 정수 인자로 나눈 결과 (몫, 나머지)를 튜플 형태로 반환   a = 11 b = 3 c, d = divmod(a, b) # c와 d에 3, 2 저장   hex()/bin()/int() : 10진수를 16진수로 / 10진수를 2진수로 / 2진수나 16진수를 10진수로 변환해 반황   b = 0b11110000; h = 0xf0 print(int(b)) # 240 print(int(h)) # 240 print(bin(int(b))) # 0b11110000 print(hex(int(h))) # 0xf0   abs() : 인자로 입력된 수치형 값의 절대값을 반환   print(abs(-3)) # 3  print(abs(-3.14)) # 3.14   max()/min(): 인자로 입력된 시퀀스형 값의 최댓값 / 최솟값을 반환   print(max(pneumonoultramicroscopicsilicovolcanoconiosis)) # s print(min(pneumonoultramicroscopicsilicovolcanoconiosis)) # p print(max([1, -3, 2, 0, -5, 6])) # 6 print(min(1, -3, 2, 0, -5, 6)) # -5   round() : 인자로 입력된 수치형 값의 반올림한 값을 반환   print(round(3.14)) # 3   int()/float()/str() : 인자를 실수형 값으로 / 정수형 값으로 / 문자열로 변환   print(int(3.14)) # 3 print(float(i(3.14))) # 3.0 print(int('3')) # 오류 print(float('3.14')) # 오류 print(str(3.14)) # 3.14   filter() : 첫번째 인자인 함수에 두번째 인자인 반복 가능한 데이터의 값을 순서대로 넣어 참인 것만 리스트로 반환   def positive(x):     return x &gt; 0  print(list(filter(positive, [1, -3, 2, 0, -5, 6]))) # [1, 2, 6]   .count() : 문자열이나 리스트에서 인자로 입력된 특정 문자(열)의 개수를 반환   print('hello world'.count('l')) # 3 print('hello world'.count('he')) # 1 print('hello world'.count(' ')) # 1   .find() : 문자열에서 인자로 입력된 특정 문자(열)이 처음 나오는 위치를 나타내는 인덱스 반환     두번째 인자를 입력할 경우, 두번째 인자에 해당되는 인덱스부터 탐색   print('hello world'.find('l')) # 2 print('hello world'.find('he')) # 0 print('hello world'.find('l', 6)) # 9   .split() : 문자열을 인자로 입력된 문자(열)로 나눈 결과를 리스트로 반환     구분자 (separator)로 들어올 인자가 없으면, 공백을 기준으로 문자열을 나눔   print('http://naver.com'.split('/')) # 'http:', '/', '/', 'naver', '.com' print('hello world'.split()) # 'hello', 'world'   .join() : 인자로 입력된 리스트의 모든 요소를 연결된 문자열을 반환   print('/'.join(['2022', '12', '25'])) # 2022/12/25   replace() : 문자열에서 인자로 입력된 특정 문자(열)을 다른 문자(열)로 바꾼 문자열을 반환   print('hello world'.replace('l', 'L') # heLLo worLd   sorted() : 인자로 입력된 문자열이나 리스트, 딕셔내리의 요소를 오름차순으로 정렬한 리스트를 반환     reverse = true : 문자를 내림차순으로 정렬   print(sorted(input())) # 입력된 문자열을 오름차순으로 정렬 print(sorted(input(), reverse = true)) # 입력된 문자열을 오름차순으로 정렬      key = : 딕셔내리의 특정 기준을 바탕으로 오름차순으로 정렬   dc2 = {} for i in range(10):   for j in range(10, 0):     dc2[i] = str(j)  def f1(x):   return x[0]  def f2(x):   return x[1]  ret_dc2 = sorted(dc2.items(), key = f1 | f2) # key | value를 기준으로 정렬   range() : 인자로 범위를 지정해 순차적인 정수 리스트를 반환     인자가 1개 : 0부터 (인자 - 1)까지 순차적인 정수 리스트   인자가 2개 : (첫번째 인자)부터 (두번째 인자 - 1)까지 순차적인 정수 리스트   print(range(10)) print(range(10, 20))   .reverse()/reversed() : 인자로 입력된 리스트를 거꾸로 함 / 거꾸로 한 리스트를 반환   listData = list(range(5)) listData.reverse()  print(listData) # 4,3,2,1,0 print(reversed.(listData)) # 0,1,2,3,4   append() : 인자로 입력된 값을 리스트의 맨 마지막 요소로 추가   listData = list(range(5)) listData.append(7)  print(listData) # 0,1,2,3,4,7   insert() : 리스트의 첫번째 인자의 인덱스에 해당되는 위치에 두번째 인자로 입력된 값을 삽입   listData = ['0', '1', '2', '3', '4']  listData.insert(2, '7') print(listData)  # 0,1,7,2,3,4   remove()/del() : 리스트나 딕셔내리의 특정 요소를 / 인덱스가 인자인 요소를 삭제   listData = ['0', '1', '2', '3', '4']  listData.remove('1') print(listData) # 0,2,3,4  del listData[3] print(listData) # 0,2,3   sum() : 임의의 정수가 요소인 리스트에서 모든 요소의 합을 반환   print(sum(list(range(5))))   clear() : 딕셔내리의 모든 요소를 제거한 빈 딕셔내리로 바꿈   dc2 = {} or i in range(10): dc2[i] = str(i)  dc2.clear()  print(dc2) # {}   keys()/values()/items() : 딕셔내리의 키 / 값 / 모두를 추출해 반환     list()로 변환하지 않으면 print()에 넣으면 dict_keys([...]), dict_values([...]) dict_items([...])로 출력   dc2 = {} or i in range(10): dc2[i] = str(i)  print(list(dc2.keys())) print(list(dc2.values())) print(list(dc2.items()))   all()/any() : 리스트의 모든 요소가 True이면 False / False면 True   listData = [False, False, True, True] print(all(listData)) print(any(listData)) print(all(listData[::2])) print(any(listData[::2]))   lambda  : 함수 이름 없이 한줄로 함수를 정의   f = lambda x: x * x print(f(8)) # 64  f = lambda x, y: x + y print(f(8,9)) # 17   map() : 인자를 바꾸어 함수를 반복해 호출한 결과를 나열   f = lambda x: x * x args = [1,2,3,4,5] ret = map(f, args) print(list(ret))   파일 입출력 (file input &amp; output) : 텍스트나 바이너리 파일을 읽고 쓰는 것      open : 파일 열기 (파일이 없는 경우 생성)            r, rt : 읽기 모드 (파일을 읽을 때 사용)       w, wt : 쓰기 모드 (파일을 편집할 때 사용)       a, at : 추가 모드 (파일의 마지막에 내용을 추가할 때 사용)              파일이 해당 디렉토리에 존재하지 않는 경우, 새로운 파일이 생성됨    파일 객체 = open(파일 이름, 모드)  f1 = open(\"readme1.txt\", 'r') f2 = open(\"readme2.txt\", 'w') f3 = open(\"readme3.txt\", 'a')      .read()/.readline()/.readlines() : 파일을 모두 문자열로 / 한줄씩 문자열로 / 한줄을 요소로 한 리스트로 읽기   f = open(\"readme.txt\", 'r') data1 = f.read() data2 = f.readline() data3 = f.readlines()      .write()/.writelines() : 파일에 입력받은 인자를 전부 / 한줄씩 쓰기   f = open(\"readme.txt\", 'w') data1 = '&gt; 다음은 입력된 값입니다.' data2 = input('&gt; 파일에 입력할 값 : ') f.write(data1 + data2)      .close : 열려 있는 파일을 닫기   f.close()      with ~ as  : 파일을 열고 파일에 대한 처리가 끝나면 자동으로 파일을 닫음   with open('readme.txt', 'w') as f:   ...  ","categories": [],
        "tags": ["Language"],
        "url": "/python1/",
        "teaser": null
      },{
        "title": "[Algorithm] 1. 알고리즘 (Algorithm)과 복잡도 (Complexity)",
        "excerpt":"알고리즘 (Algorithm) : 어떠한 문제를 해결하기 위한 절차나 방법      입력 (input) : 외부에서 제공된 자료가 존재하거나 존재하지 않아야 함   출력 (output) : 최소 1개 이상의 결과를 가져야 함   알고리즘의 복잡도 (Complexity) : 알고리즘의 성능을 나타내는 척도   공간 복잡도 (Space Complexity) : 문제를 해결할 때 걸리는 공간과 입력의 함수 관계     특정한 크기의 입력에 대해 알고리즘이 얼마나 많은 메모리를 차지하는가?   알고리즘을 위해 필요한 메모리의 양   시간 복잡도 (Time Complexity) : 문제를 해결할 때 걸리는 시간과 입력의 함수 관계     특정한 크기의 입력에 대해 알고리즘이 얼마나 오래 걸리는가?   알고리즘을 위해 필요한 연산의 횟수   만약 프로그램을 비효율적으로 작성해 시간 제한 (Time Limit)를 넘기면, 시간 초과 (Time Limit Exceeded)   빅 오 표기법 (Big-O) : 최악의 경우만을 고려해 시간 복잡도를 계산     가장 빠르게 증가할, 즉 가장 높은 차수의 항만을 고려하고 계수와 나머지 차수의 항들은 계산에서 제외   만약 크기 N의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 N의 식을 가지면, 점근적 시간 복잡도는 O(N)   공통 시간 복잡도 표 (Common Time Complexity Table)   \t \t\t \t\t\t빅 오 표기법 \t\t\t설명 \t\t \t    \t                      O(1)             상수 시간                               O(logN)             로그 시간                               O(N)             선형 시간                               O(N * logN)             로그 선형 시간                               O(N^2)             2차 시간                               O(N^3)             3차 시간                               O(N^4)             4차 시간                    만약 시간 제한이 1초인 문제를 해결할 때, 시간 복잡도 …인 알고리즘을 설계해야 한다.         N의 범위가 500인 경우 : O(N^3)     N의 범위가 2,000인 경우 : O(N^2)     N의 범위가 100,000인 경우 : O(N * logN)     N의 범위가 10,000,000인 경우 : O(N^3)              수행 시간 측정 Code by Python       import time start_time = time.time() # 측정 시작 ... end_time = time.time() # 측정 종료 print(end_time - start_time) # 수행 시간 출력  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/algorithm1/",
        "teaser": null
      },{
        "title": "[MacOS] 1. 홈브류 (Homebrew)",
        "excerpt":"Homebrew : macOS용 패키지 관리 어플리케이션 (Package Management Application)      일반적으로 커맨드라인 도구나 시스템 패키지 설치에 사용   cask Package : GUI 어플리케이션 설치도 가능하게 해주는 Homebrew 확장 패키지   mas Package : App Store 어플리케이션 설치도 가능하게 해주는 Homebrew 확장 패키지   Homebrew 설치     터미널 실행 후 다음 명령어를 입력   /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"      터미널 창에 다음 명령어를 입력해 Homebrew가 정상적으로 설치되었는지 확인   brew --version // \"Homebrew X.X.X\" 출력 : 정상 설치 // \"zsh: command not found: brew\" 출력 : 설치 오류   cask Package 설치     터미널 창에 다음 명령어를 입력   brew install cask      터미널 창에 다음 명령어를 입력해 cask Package가 정상적으로 설치되었는지 확인   brew list   mas Package 설치     터미널 창에 다음 명령어를 입력   brew install mas      터미널 창에 다음 명령어를 입력해 mas Package가 정상적으로 설치되었는지 확인   brew list   Homebrew 명령어                              Homebrew 명령어 이름             Homebrew 명령어 설명                                         brew --version             Homebrew의 버전 정보 확인                               brew doctor             Homebrew 설치 환경을 검사                               brew update             Homebrew를 최신 버전으로 업데이트                               brew list             설치된 패키지를 확인                               brew upgrade             설치된 모든 패키지를 업데이트                               brew search (패키지명)             해당 패키지가 설치되어 있는지 검색                               brew install (패키지명)             해당 패키지를 최신 버전으로 설치                               brew info (패키지명)             해당 패키지의 정보 확인                               brew upgrade (패키지명)             해당 패키지를 업데이트                               brew uninstall (패키지명)             해당 패키지를 삭제                               brew outdated             최신 버전이 존재하는 패키지 확인                               brew cleanup (패키지명)             해당 패키지의 구버전에 해당하는 파일 삭제                 cask 명령어     기존의 brew 명령어 뒤에 --cask를 추가   mas 명령어                              mas 명령어 이름             mas 명령어 설명                                         mas version             mas의 버전 정보 확인                               mas list             mas로 설치된 패키지 확인                               mas upgrade             mas로 설치된 모든 패키지를 최신 버전으로 업데이트                               mas search (검색어)             앱스토어에서 해당 검색어와 일치하는 패키지 검색                               mas install (패키지 ID)             해당되는 ID를 가진 패키지를 최신 버전으로 설치                               mas upgrade (패키지 ID)             해당되는 ID를 가진 패키지를 최신 버전으로 업데이트                               mas uninstall (패키지명)             mas로 설치된 해당 패키지를 삭제                               mas outdated             mas로 설치된 패키지 중 최신 버전이 존재하는 패키지 확인                 Homebrew 삭제     터미널 실행 후 다음 명령어를 입력   // Homebrew로 설치한 모든 package를 일괄 삭제 brew remove --force --ignore-dependencies $(brew list)  // Homebrew 삭제 ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"      터미널 창에 다음 명령어를 입력해 Homebrew가 정상적으로 삭제되었는지 확인   brew --version // \"zsh: command not found: brew\" 출력 : 정상 삭제 // \"Homebrew X.X.X\" 출력 : 삭제 오류  ","categories": [],
        "tags": ["MacOS"],
        "url": "/homebrew1/",
        "teaser": null
      },{
        "title": "[FE] 2. CSS",
        "excerpt":"CSS (Cascading Style Sheet) : 웹 문서가 표현되는 방법을 기술하는 스타일시트 언어           레이아웃 및 디자인 정보로 인해 HTML 문서의 구조화가 어려워진 문제를 해결하기 위해 CSS 탄생           (1) Inline Style : HTML 태그의 style 속성으로 태그의 속성을 일일이 적용   &lt;p style=\"color: blue\"&gt;     hello world &lt;/p&gt;   (2) Inline Style Sheet : HTML 문서 내 &lt;style&gt; 태그로 한 문서의 스타일 적용   &lt;head&gt;     &lt;style&gt;         body { background-color: black; }     &lt;/style&gt; &lt;/head&gt;   (3) Linking Style Sheet : 내용에 스타일 정보를 분리해 별도의 스타일시트 (.css) 파일을 만들고 HTML 문서와 연결   &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;  CSS 스타일시트 (CSS Style Sheet) : 스타일을 선언하고 태그를 선택하는 CSS RuleSet의 집합     CSS 선택자 (CSS Selector) : 어떤 HTML 태그나 HTML 속성을 꾸밀지 지정   CSS 선언 (CSS declaration) : CSS 선택자에 대한 CSS 속성과 CSS 값을 정의            CSS 속성 (CSS Attributes) : 선택자가 지정한 것을 어떤 속성으로 꾸밀지 지정       CSS 변수 (CSS Arguments) : 지정된 속성을 어떻게 나타낼지 지정           CSS 선택자 {     CSS 속성 : CSS 값; /* CSS 선언 */ }  CSS 선택자 { /* 세미클론 (;)으로 선언을 구분해 여러 번의 선언 가능 */     CSS 속성1 : CSS 값1;     CSS 속성2 : CSS 값2; }   CSS 선택자 { /* 작은따옴표 ('') 혹은 큰따옴표 (\"\")으로 값의 공백 처리 */     CSS 속성1 : 'CSS 값1';     CSS 속성2 : \"CSS 값2\"; }      ! 같은 CSS 선택자나 CSS 속성이 선언되었다면? : CSS RuleSet에 대한 우선순위의 필요성    캐스케이딩 (Cascading) : 같은 CSS 선언이 여러 번 선언하였다면, 나중에 선언된 것을 적용     나중에 선언된 것이 먼저 선언된 것을 덮어버림 (Override)   CSS 선택자 { /* 나중에 선언된 CSS 속성1의 값2가 적용된다. */     CSS 속성1 : CSS 값1;     CSS 속성1 : CSS 값2; }     전역적인 것을 먼저 적용하고, 그 다음에 지역적인 것을 적용            부모 태그에서 선언된 속성은 자식 태그로 상속되어, 부모 자식에서 선언된 값이 적용된다.       자식 태그에서 상속받은 속성을 다시 선언되면, 자식 태그에서 선언된 값이 적용된다.           &lt;p style=\"color: red\"&gt;     &lt;span style=\"color: blue\"&gt;         CSS 우선순위 : span의 font-color 속성이 p의 font-color 속성보다 높다.     &lt;/span&gt; &lt;/p&gt;                 CSS 우선순위 : span의 font-color 속성이 p의 font-color 속성보다 높다.         CSS 명시도 (Specificity) : 작성된 순서가 아닌, CSS 선언에 적용되는 가중치에 따라 우선순위 적용     가중치는 네 가지 기준을 숫자로 표현 (0,0,0,0) : 제일 앞의 숫자가 높을수록 높은 우선순위를 가짐            명시도가 동일할 경우, 나중에 선언된 것을 우선해 적용 (Cascading)           p..div &gt; span { color : green;} /* 몀시도 : 0,1,0,2 */ b span {color : red;} /* 명시도 : 0,0,0,2 */      첫번째 0 : 인라인 스타일 (inline style)의 개수   세번째 0 : 클래스, 가상 클래스, 속성 선택자의 개수   두번째 0 : ID 선택자의 개수   네번째 0 : 태그 선택자, 가상 요소 선택자의 개수   !important : 기존의 우선순위를 무시하고 해당 CSS 선언을 우선해 적용   CSS 선택자 { */     CSS 속성1 : CSS 값1 !important;     CSS 속성1 : CSS 값2; }  CSS 선택자 (CSS Selector) : HTML 문서에 스타일을 입힐 요소를 선택하는 문자     여러 종류의 선택자를 중첩 가능 (p.span)   여러 종류의 선택자를 space 키로 구분해 동시에 선택 가능  (p.span p.img)   CSS 선택자 {     CSS 속성 : CSS 값; }   전체 선택자 * : 모든 요소를 선택하는 선택자   * {   color: blue; }   태그 선택자 tag : 해당 태그의 요소를 선택하는 선택자   tag {   color: aqua; }   아이디 선택자 #id : 해당 아이디의 요소를 선택하는 선택자   #tag {   color: red; }   클래스 선택자 .class : 해당 클래스의 요소를 선택하는 선택자   .class {   color: green; }   후손 선택자 (selector1) (selector2) : 해당 선택자의 모든 하위 요소 중 하나를 지정해 선택하는 선택자   div tag {      color: yellow; } ... &lt;div&gt;     &lt;tag&gt;         hello world     &lt;/tag&gt; &lt;/div&gt; &lt;div&gt;     &lt;span&gt;         &lt;tag&gt;             hello world         &lt;/tag&gt;     &lt;/span&gt; &lt;/div&gt;   자손 선택자 (selector1)&gt;(selector2) : 해당 선택자의 자식 요소 중 하나를 지정해 선택하는 선택자   div &gt; tag{      color: purple; } ... &lt;div&gt;     &lt;tag&gt;         hello world     &lt;/tag&gt; &lt;/div&gt;   형제 선택자 (selector1)~(selector2) : 해당 선택자의 형제 요소 중 하나를 지정해 선택하는 선택자   div ~ tag{      color: pink; } ... &lt;div&gt;     hello world &lt;/div&gt; &lt;tag&gt;     ! &lt;/tag&gt;   인접 형제 선택자 (selector1)+(selector2) : 선택자의 형제 중 바로 다음에 오는 요소를 선택하는 선택자   div + tag{      color: gray; } ... &lt;div&gt;     hello world &lt;/div&gt; &lt;tag&gt;     ? &lt;/tag&gt; &lt;tag&gt;     ! &lt;/tag&gt; /* 첫번째 형제 요소인 \"?\"가 회색으로 출력 */   속성 선택자 [attr] : 태그에 해당 속성이 명시된 요소들을 모두 선택하는 선택자     [attr = \"A\"] : 해당 속성이 명시된 요소들 중 값이 일치하는 것들만 선택   [attr ~= \"B\"] : 해당 속성이 명시된 요소들 (띄어쓰기로 여러 값이 저장된 요소 포함) 중 값이 일치하는 것들만 선택   [attr ^= \"C\"] : 해당 속성이 명시된 요소들 중 값을 접두사로 가지는 것들만 선택   [attr $= \"D\"] : 해당 속성이 명시된 요소들 중 값을 접미사로 가지는 것들만 선택   [attr *= \"E\"] : 해당 속성이 명시된 요소들 중 값을 포함하는 것들만 선택   tag[attributes]{      color: white; } ... &lt;tag attributes=\"true\"&gt;     hello world &lt;/tag&gt;  tag[attributes=\"attr\"]{      color: yellow; } ... &lt;tag attributes=\"attr\"&gt;     hello world &lt;/tag&gt;   가상 클래스 선택자 (Pseudo-class Selector) : 가상 클래스를 선택하는 선택자     앵커 가상 클래스 : 어떤 요소에 대한 스타일을 추가하는 선택자            link : 사용자가 이전에 방문하지 않은 요소에 대한 스타일을 추가하는 선택자       visited : 사용자가 이전에 방문하였던 요소에 대한 스타일을 추가하는 선택자       :hover : 사용자가 해당 요소에 커서를 접근시킬 때의 동적인 스타일을 추가하는 선택자       :active : 사용자가 해당 요소를 클릭할 때의 동적인 스타일을 추가하는 선택자       :focus : 사용자가 해당 요소에 키보드로 포커싱할 때의 동적인 스타일을 추가하는 선택자           a:link {     color: black; } a:visited {     color: gray; } a:hover {     color: red; } a:active {     color: gray; } a:focus {     color: yellow; }      순서 가상 클래스 : 순서가 존재하는 요소의 특정 항목에 대한 스타일을 추가하는 선택자            :first-child : li의 첫번쩨 요소에 대한 스타일를 추가하는 선택자       :last-child : li의 마지막 요소에 대한 스타일를 추가하는 선택자       :nth-child(n) : li의 n번쩨 요소에 대한 스타일를 추가하는 선택자           ol li:first-child {     border-top: none; } ol li:last-child {     border-top: none; } ol li:nth-child(2) {     border-top: none; }   가상 요소 선택자 (Pseudo-element Selector) : 가상 요소를 선택하는 선택자     선택된 요소의 태그 안에 가상 요소가 자식 요소로 위치 (::before &gt; 컨텐츠 &gt; ::after 순)   선택자::가상 요소 {     property: value; }      ::before : 요소 내용의 앞에 새 컨텐츠를 추가하는 선택자   tag::before {     content: \"Hello, \"; }      ::after : 요소 내용의 뒤에 새 컨텐츠를 추가하는 선택자   tag::after {     content: \"World! \"; }      ::first-letter : 요소의 첫번째 글자를 선택하는 선택자   tag::first-line {   color: orange; }      ::first-line : 요소의 첫번째 줄을 선택하는 선택자   tag::first-line {   color: orange; }      현재까지 배운 것을 토대로 여러 HTML 문서로 이루어진 가상의 웹사이트를 디자인한다고 가정해보자.         태그나 문서에 스타일을 적용하는 경우를 배제하고, 스타일시트에 모든 스타일 정보가 존재한다 가정하자.     모든 HTML문서가 &lt;body&gt;, &lt;main&gt;, &lt;section&gt;, &lt;p&gt;만 존재하고, 다음의 구조를 이룬다.       &lt;body&gt;   &lt;main&gt;     &lt;section&gt;       &lt;p&gt; Hello World! &lt;/p&gt;     &lt;/section&gt;   &lt;/main&gt; &lt;/body&gt;            그리고 스타일시트에는 다음과 같은 CSS 선택자만 사용한다고 가정하자.                문서의 전반적인 스타일을 적용하기 위한 &lt;body&gt;를 지정할 선택자         메인 컨텐츠의 스타일을 적용하기 위한 &lt;main&gt;를 지정할 선택자         세부 컨텐츠의 스타일을 적용하기 위한 &lt;section&gt;를 지정할 선택자         문단의 스타일을 적용하기 위한 &lt;p&gt;를 지정할 선택자                   A는 모든 문서의 “Hello World!”를 빨간색으로 적용하고 싶어서 태그에 스타일을 적용했다.     p {    color:green; }       그런데 B가 특정 문서의 “Hello World!”를 초록색으로 적용하고 싶어서 id와 #를 사용했다.     &lt;p id=\"sec2\"&gt; Hello World! &lt;/p&gt;      #sec {    color:green; }       A가 그걸 보고     p {    color:green; }            CSS는 시대가 요구하는 의도대로 설계되었으나, 기존의 설계와 새로운 요구사항에 괴리가 발생                문서를 잘 표현하기 위해 설계된 방법 vs 어플리케이션을 잘 표현하기 위해 설계된 방법                        이를 절충하기 위해 기존의 의도와는 다른 방식으로 CSS를 사용해 화면을 표현                                     CSS가 웹 문서를 웹 사이트에 표현하는 데에서 시작되어 대규모 웹 서비스를 만드는 데에 한계점 존재                그러므로, 이를 극복하기 위한 최신 기술들을 꾸준히 학습하고, 프로젝트에 도입해야 된다!                          CSS 변수 (CSS variables) : CSS 사용자 속성 (CSS 일반 속성과 동일한 문법으로 변수를 정의 가능)            var() 함수 : CSS 변수값을 읽는 데에 사용       :root : CSS 변수를 전역 변수로 정의           .ex {     --variable-name: value; }  :root {        --variable-name: value; }   # 박스 모델 (Box Model) 관련 CSS 속성     모든 HTML 엘리멘트들은 박스 모양으로 구성되어 있음            마진 영역 (Margin Area)       테두리 영역 (Border Area)       패딩 영역 (Padding Area)       컨텐츠 영역 (Content Area)                         마진 영역 (Margin Area)                      테두리 영역 (Border Area)                              패딩 영역 (Padding Area)                                      컨텐츠 영역 (Content Area)                                               width, height : 박스의 가로, 세로 길이를 지정하는 속성   &lt;div style=\"     position: relative;     background-color: black;     margin-left: auto;     margin-right: auto;     width: 200px;     height: 200px;\"&gt;     &lt;div style=\"         position: absolute;         background-color: white;         margin-left: auto;         margin-right: auto;         width: 70%;         height: 70%;\"&gt;     &lt;/div&gt; &lt;/div&gt;                margin : 마진에 값을 부여하는 속성     margin-top: : 위쪽 마진에 값을 부여하는 속성   margin-right: : 오른쪽 마진에 값을 부여하는 속성   margin-bottom: : 아랫쪽 마진에 값을 부여하는 속성   margin-left: : 왼쪽 마진에 값을 부여하는 속성   .box {     margin: xx yy zz ww;     /* xx는 위쪽 마진, yy는 오른쪽 마진, zz는 아랫쪽 마진, ww는 왼쪽 마진 */     margin-top: xx;     margin-right: yy;     margin-bottom: zz;     margin-left: ww; }                 margin-top                                       margin-left                                              테두리 영역 (Border Area)                                      패딩 영역 (Padding Area)                                              컨텐츠 영역 (Content Area)                                                                margin-right                         margin-bottom        padding : 패딩에 값을 부여하는 속성     padding-top: : 위쪽 패딩에 값을 부여하는 속성   padding-right: : 오른쪽 패딩에 값을 부여하는 속성   padding-bottom: : 아랫쪽 패딩에 값을 부여하는 속성   padding-left: : 왼쪽 패딩에 값을 부여하는 속성   .box {     padding: xx yy zz ww;     /* xx는 위쪽 패딩, yy는 오른쪽 패딩, zz는 아랫쪽 패딩, ww는 왼쪽 패딩 */     padding-top: xx;     padding-right: xx;     padding-bottom: xx;     padding-left: xx; }                 마진 영역 (Margin Area)                  테두리 영역 (Border Area)              padding-top                                        padding-left                                          컨텐츠 영역 (Content Area)                           padding-right                  padding-bottom                  border : 테두리에 값을 부여하는 속성                                               border: 속성                 설명                                                             기본값                 medium, none, color                                           상속 여부                 N                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  border: 값                                     설명                                                                                                                                                                 border-width                                                                                                                                                                                                                                 border-width: 값                                                     테두리의 두께 정도 지정                                                                                                                                                                                                                                                 medium                                                     기본값                                                                                                                                                       thick                                                     기본값보다 굵게                                                                                                                                                       thin                                                     기본값보다 얇게                                                                                                                                                       %, px, em, rem                                                     직접 테두리의 두께 정도 지정                                                                                                                                                                                                                                                                                   border-style                                                                                                                                                                                                                                 border-style: 값                                                     테두리의 모양 지정                                                                                                                                                                                                                                                 none                                                     테두리를 생성하지 않음 (기본값)                                                                                                                                                       dashed, dotted, double, groove, hidden, inset,  outset, ridge, solid                                                     여러 모양의 테두리를 생성                                                                                                                                                                                                                                                                                   border-color                                     테두리의 색상 지정                                                                                                       border-radius                                     %, px, em, rem 등으로 테두리의 모서리에 대한 둥근 정도 지정                                                                                      top-left-x                                             top-right-x                                             bottom-right-x                                             bottom-left-x                                             top-left-y                                             top-right-y                                             bottom-right-y                                             bottom-left-y                                                                                                                                                                                                                                         &lt;div style=\"     background-color: black;     text-align: center;     margin-left: auto;     margin-right: auto;     padding-top: 2%;     padding-bottom: 2%;     \"&gt;     &lt;div style=\"         border: dashed 5px red;         margin-left: 5%;         margin-right: 5%;         border-radius: 25%;         padding-bottom: inherit;\"&gt;     dashed 5px red (border-radius: 25%)         &lt;div style=\"             border: dotted 3px blue;             margin-left: inherit;             margin-right: inherit;             padding-bottom: inherit;\"&gt;         dotted 3px blue             &lt;div style=\"                 border: double 7px green;                 margin-left: inherit;                 margin-right: inherit;                 padding-bottom: inherit;\"&gt;             double 7px green                 &lt;div style=\"                     border: solid 3px gray;                     margin-left: inherit;                     margin-right: inherit;                     padding-bottom: inherit;\"&gt;                     solid 3px gray                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt;             dashed 5px red (border-radius: 25%)                  dotted 3px blue                          double 7px green                                      solid 3px gray                                               box-sizing : 박스 크기의 기준을 지정하는 속성                                               box-sizing: 속성                 설명                                                             기본값                 content-box                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  box-sizing: 값                                     설명                                                                                                                                                                 content-box                                     컨텐츠 영역을 기준으로 지정                                                                                                       border-box                                     테두리 영역을 기준으로 지정                                                                                                                                                           .cb {     box-sizing: content-box; } .bb {     box-sizing: border-box; } .iib {     box-sizing: initial; } .ihb {     box-sizing: inherit; }   # 배경 관련 CSS 속성   background-color : 배경의 색상을 지정하는 속성                                               background-color: 속성                 설명                                                             기본값                 transparent                                           상속 여부                 N                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  background-color: 값                                     설명                                                                                                                                                                 transparent                                     배경색 없음                                                                                                       color                                     배경색 지정                                                                                                                                                           &lt;div style=\"     position: relative;     background-color: black;     width: 200px;     height: 200px;\"&gt;     &lt;div style=\"         position: absolute;         background-color: white;         margin-left: auto;         margin-right: auto;         width: 70%;         height: 70%;\"&gt;         &lt;div style=\"             position: absolute;             background-color: black;             margin-left: auto;             margin-right: auto;             width: 70%;             height: 70%;\"&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt;                                  background-image : 배경 이미지를 지정하는 속성                                               background-image: 속성                 설명                                                             기본값                 none                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  background-image: 값                                     설명                                                                                                                                                                 none                                     배경 이미지 사용 안함                                                                                                       url(\"\")                                     배경 이미지 URL 지정                                                                                                                                                              background-attachment : 배경 이미지의 스크롤 여부를 지정하는 속성            scroll : 내용을 스크롤하면 배경 이미지는 스크롤되지 않음       fixed : 배경 이미지가 움직이지 않음       local : 내용을 스크롤하면 배경 이미지는 스크롤       initial : 현재의 속성값을 기본값으로 지정       inherit : 부모 요소의 속성값 상속           background-position : 배경 이미지의 위치를 지정하는 속성            x y : 가로와 세로 위치 지정 (left-right, center, top-bottom, %, length)       initial : 현재의 속성값을 기본값으로 지정       inherit : 부모 요소의 속성값 상속           background-size : 배경 이미지의 크기를 지정하는 속성            length : 배경 이미지의 가로와 세로 크기나 백분율을 직접 지정       cover : 가로/세로 비율을 유지하면서, 배경을 다 채울 수 있도록 이미지 조절       contain : 가로/세로 비율을 유지하면서, 배경을 벗어나지 않도록 이미지 조절       initial : 현재의 속성값을 기본값으로 지정       inherit : 부모 요소의 속성값 상속           &lt;div style=\"background-image: https://cdn.pixabay.com/photo/2020/10/21/04/01/leaves-5672036_1280.png;\"&gt;     background-image &lt;/div&gt;   overflow : 컨텐츠가 요소의 크기를 벗어날 때의 처리 방법을 지정하는 속성                                               overflow: 속성                 설명                                                             기본값                 visible                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  overflow: 값                                     설명                                                                                                                                                                 visible                                     박스를 넘어가도 내용을 표시                                                                                                       hidden                                     박스를 넘어간 부분은 표시하지 않음                                                                                                       scroll                                     무조건 스크롤바 표시                                                                                                       auto                                     박스를 넘어가면 스크롤바 표시                                                                                                                                                           &lt;div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: visible;         margin-right: 5%;\"&gt;             visible     &lt;/div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: hidden;         margin-right: 5%;\"&gt;             hidden     &lt;/div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: scroll;         margin-right: 5%;\"&gt;             scroll     &lt;/div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: auto;         margin-right: 5%\"&gt;             auto     &lt;/div&gt; &lt;/div&gt;                         자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.                           자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.                           자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.                           자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.         z-index : 요소들의 수직 위치를 지정하는 속성     숫자가 클수록 위에, 숫자가 작을수록 아래에 위치   // 수직 위치를 역순으로 배치 &lt;div style=\"     width: 100px; \theight: 100px; \tposition: absolute;     top: 30px; \tleft: 210px;     background-color: red;     z-index: 1;\"&gt;&lt;/div&gt; &lt;div style=\"width: 100px; \theight: 100px; \tposition: absolute;     top: 60px; \tleft: 270px;     background-color: blue;\"&gt;&lt;/div&gt; &lt;div style=\"width: 100px; \theight: 100px;     position: absolute;     top: 90px; \tleft: 240px;     background-color: green;     z-index: -1;\"&gt;&lt;/div&gt;   # 글자 관련 CSS 속성   color : 글자의 색상을 지정하는 속성                                               color: 속성                 설명                                                             기본값                 #000000                                           상속 여부                 Y                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  color: 값                                     설명                                                                                                                                                                 color                                     색상 지정                                                                                                                                                           &lt;div style=\"color:red\"&gt;     hello world &lt;/div&gt;       hello world   font-size : 글자의 크기를 지정하는 속성                                               font-size: 속성                 설명                                                             기본값                 medium                                           상속 여부                 Y                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  font-size: 값                                     설명                                                                                                                                                                 medium                                     웹 브라우저에서 정한 기본값                                                                                                       xx-small, x-small, small, large, x-large, xx-large                                     기본값에 대한 상대적인 크기                                                                                                       smaller, larger                                     부모 요소의 글자 크기에 대한 상대적인 크기                                                                                                       px                                     글자 크기를 직접 지정                                                                                                       %, em                                     부모 요소의 글자 크기에 대한 상대적인 글자 크기의 비율을 직접 지정                                                                                                       rem                                     최상위 요소의 글자 크기에 대한 상대적인 글자 크기의 비율을 직접 지정                                                                                                                                                           &lt;div style=\"font-size: xx-small\"&gt;xx-small&lt;/div&gt; &lt;div style=\"font-size: x-small\"&gt;x-small&lt;/div&gt; &lt;div style=\"font-size: small\"&gt;small&lt;/div&gt; &lt;div style=\"font-size: medium\"&gt;medium&lt;/div&gt; &lt;div style=\"font-size: large\"&gt;large&lt;/div&gt; &lt;div style=\"font-size: x-large\"&gt;x-large&lt;/div&gt; &lt;div style=\"font-size: xx-large\"&gt;xx-large&lt;/div&gt;        xx-small     x-small     small     medium     large     x-large     xx-large   &lt;div style=\"font-size: smaller\"&gt;smaller&lt;/div&gt; &lt;div&gt;medium&lt;/div&gt; &lt;div style=\"font-size: larger\"&gt;larger&lt;/div&gt;        smaller     medium     larger   &lt;div style=\"font-size: 10px\"&gt;     10px     &lt;i style=\"font-size: 200%;\"&gt;         20px         &lt;span style=\"font-size: 0.8em\"&gt;             16px             &lt;b style=\"font-size: 1rem\"&gt;                 1rem             &lt;/b&gt;         &lt;/span&gt;     &lt;/i&gt; &lt;/div&gt;        10px              20px                      16px                              1rem                              font-family : 글꼴을 지정하는 속성                                               font-family: 속성                 설명                                                             기본값                 웹 브라우저의 기본 글꼴                                           상속 여부                 Y                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  font-family: 값                                     설명                                                                                                                                                                 font                                     글꼴 이름 / 글꼴 유형                                                                                                                                                           &lt;div style=\"font-family: (지정할 글꼴);\"&gt;     지정된 글꼴로 출력합니다. &lt;/div&gt;   &lt;div style=\"font-family: (지정할 글꼴1), (지정할 글꼴2);\"&gt;     지정된 글꼴1로 출력하되 (i) 해당 글꼴이 존재하지 않는다면 (ii) 표현할 수 없다면, 지정된 글꼴2로 출력합니다. &lt;/div&gt;   font-weight : 글자의 굵기 정도를 지정하는 속성     나타낼 수 있는 굵기의 정도는 글꼴마다 다름                                               font-weight: 속성                 설명                                                             기본값                 normal                                           상속 여부                 Y                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  font-weight: 값                                     설명                                                                                                                                                                 normal                                     보통 굵기 (400)                                                                                                       bold                                     굵은 굵기 (700)                                                                                                       bolder                                     상속된 값보다 굵은 크기                                                                                                       lighter                                     상속된 값보다 얇은 크기                                                                                                       number                                     굵기 정도를 직접 지정                                                                                                                                                           &lt;div style=\"font-weight: normal\"&gt;     &lt;div style=\"font-weight: lighter\"&gt;normal-lighter&lt;/div&gt;     normal     &lt;div style=\"font-weight: bolder\"&gt;normal-bolder&lt;/div&gt; &lt;/div&gt; &lt;div style=\"font-weight: bold\"&gt;     &lt;div style=\"font-weight: lighter\"&gt;bold-lighter&lt;/div&gt;     bold     &lt;div style=\"font-weight: bolder\"&gt;bold-bolder&lt;/div&gt; &lt;/div&gt;                 normal-lighter         normal         normal-bolder                   bold-lighter         bold         bold-bolder        # 텍스트 관련 CSS 속성   text-align : 텍스트를 정렬하는 속성                                               text-align: 문법                 설명                                                             left                 왼쪽 정렬                                           right                 오른쪽 정렬                                           center                 가운데 정렬                                           justify                 양쪽 정렬                              &lt;div style=\"text-align: left;\"&gt;바다는 크레파스보다 진한 푸르고 육중한 비늘을 무겁게 뒤채면서, 숨을 쉰다.&lt;/div&gt; &lt;div style=\"text-align: right;\"&gt;중립국으로 가는 석방 포로를 실은 인도 배 타고르호는, 흰 페인트로 말쑥하게 칠한 삼천 톤의 몸을 떨면서, 물건처럼 빼곡이 들어찬 동지나 바다의 훈김을 헤치며 미끄려져 간다.&lt;/div&gt; &lt;div style=\"text-align: center;\"&gt;석방 포로 이명준(李明俊)은, 오른편의 곧장 갑판으로 통한 사닥다리를 타고 내려가, 배 뒤쪽 난간에 가서, 거기에 기대어 선다.&lt;/div&gt; &lt;div style=\"text-align: justify;\"&gt;담배를 꺼내 물고 라이터를 켜댔으나 바람에 이내 꺼지고 하여, 몇 번이나 그르친 끝에, 그 자리에 쭈그리고 앉아서 오른팔로 얼굴을 가리고 간신히 댕긴다.&lt;/div&gt;        바다는 크레파스보다 진한 푸르고 육중한 비늘을 무겁게 뒤채면서, 숨을 쉰다.     중립국으로 가는 석방 포로를 실은 인도 배 타고르호는, 흰 페인트로 말쑥하게 칠한 삼천 톤의 몸을 떨면서, 물건처럼 빼곡이 들어찬 동지나 바다의 훈김을 헤치며 미끄려져 간다.     석방 포로 이명준(李明俊)은, 오른편의 곧장 갑판으로 통한 사닥다리를 타고 내려가, 배 뒤쪽 난간에 가서, 거기에 기대어 선다.     담배를 꺼내 물고 라이터를 켜댔으나 바람에 이내 꺼지고 하여, 몇 번이나 그르친 끝에, 그 자리에 쭈그리고 앉아서 오른팔로 얼굴을 가리고 간신히 댕긴다.   text-decoration : 텍스트을 꾸미는 선을 지정하는 속성                                               text-decoration: 속성                 설명                                                             기본값                 none                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  text-decoration: 값                                     설명                                                                                                                                                                 none                                     선을 만들지 않음                                                                                                       line-through                                     취소선 생성                                                                                                       overline                                     윗줄 생성                                                                                                       underline                                     밑줄 생성                                                                                                                                                           &lt;div style=\"text-decoration: none\"&gt;none&lt;/div&gt; &lt;div style=\"text-decoration: line-through\"&gt;line-through&lt;/div&gt; &lt;div style=\"text-decoration: overline\"&gt;overline&lt;/div&gt; &lt;div style=\"text-decoration: underline\"&gt;underline&lt;/div&gt; &lt;div style=\"text-decoration: line-through overline underline\"&gt;text-decoration&lt;/div&gt;        none     line-through     overline     underline     text-decoration   columns : 여러 개의 문단을 만드는 속성                                               columns: 속성                 설명                                                             기본값                 auto                                           속성값                 문단의 최대 개수 or 문단의 최소 가로 길이                               &lt;div style=\"columns: 3;\"&gt;자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.&lt;/div&gt;        자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.   &lt;div style=\"columns: 150px;\"&gt;자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.&lt;/div&gt;        자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.   # 애니메이션 관련 CSS 속성   transform: : 요소의 형태를 변화시키는 속성   transform: rotate( angle )  /* 요소를 angle (각의 크기)만큼 회전 (단위 : deg, turn) */ transform: rotateX( angle ) /* 가로를 축으로 회전 */ transform: rotateY( angle ) /* 세로를 축으로 회전 */  transform: translate( Xpx, Ypx ) /* 요소를 가로축, 세로축 기준으로 이동 */ transform: translateX( px ) /* 가로축을 기준으로 이동 */ transform: translateY( px ) /* 세로축을 기준으로 이동 */  transform: scale( X ) /* 가로와 세로를 모두 X배만큼 확대 */ transform: scale( X, Y ) /* 가로로 X배만큼 확대, 세로로 Y배만큼 확대 */ transform: scaleX( X ) /* 가로로 X배만큼 확대 */ transform: scaleY( Y ) /* 세로로 Y배만큼 확대 */  transform: skewX( Xdeg ) // 가로 뱡향으로 비틈 transform: skewY( Ydeg ) // 세로 뱡향으로 비틈 transform: skewX( Xdeg, Ydeg ) // 가로 뱡향으로 X도만큼, 세로 방향으로 Y도만큼 비틈   animation : 요소에 애니메이션 효과를 넣는 속성   @keyframes name { /* 애니메이션에 이름을 붙이고, 어떤 모양에서 어떤 모양으로 바꿀지 지정 */ 0% { ... } /* 시작할 때 요소의 모양 지정 */ n% { ... } /* n%일 때 요소의 모양 지정 */ 100% { ... } /* 끝날 때 요소의 모양 지정 */}  animation-name: /* 어떤 이름의 @keyframes를 사용할지 지정 */;   animation-duration: /* 애니메이션이 진행될 시간 지정 (단위: s 또는 ms) */;  animation-timing-function: /* 애니메이션의 진행 속도 지정 */   /* cubic-bezier(n,n,n,n) 함수 : 애니메이션을 3차원 베지에 곡선에 맞게 표현 */   /* linear : cubic-bezier(0,0,1,1). 애니메이션 효과가 처음부터 끝까지 일정한 속도로 진행 */   /* ease : 기본값. cubic-bezier(0.25,0.1,0.25,1). 애니메이션 효과가 천천히 시작되어 빨라졌다가 다시 느려짐 */   /* ease-in : cubic-bezier(0.42,0,1,1). 애니메이션 효과가 천천히 시작됨 */   /* ease-out : cubic-bezier(0,0,0.58,1). 애니메이션 효과가 천천히 끝남 */   /* ease-in-out : cubic-bezier(0.42,0,0.58,1). 애니메이션 효과가 천천히 시작되어 천천히 끝남 */   /* steps(1,...) 함수 : 애니메이션을 스텝에 맞게 끝어서 표현 */   /* step-start : steps(1,start). 시작하는 지점에 스텝 */   /* step-end : steps(1,end). 끝나는 지점에 스텝 */  animation-delay: /* 애니메이션이 시작하기 전에 대기하는 시간 지정 (단위: s 또는 ms) */;  animation-iteration-count: /* 애니메이션이 반복하는 횟수 지정 */;  animation-direction: /* 애니메이션이 진행하는 방향 지정 (normal | reverse | alternate | alternate-reverse) */;  animation-fill-mode: /* 애니메이션 종료 후의 상태 지정 (none | forwards | backwards | both) */;  animation-play-state : /* 애니메이션의 진행 여부 지정 (running | paused) */;   transition: : 요소에 트랜지션 효과를 넣는 속성   transition-property: /* 트랜지션의 속성 지정 (none | all | property) */;  transition-timing-function: /* 트랜지션의 진행 속도 지정 */;   /* cubic-bezier(n,n,n,n) 함수 : 애니메이션을 3차원 베지에 곡선에 맞게 표현 */   /* linear : cubic-bezier(0,0,1,1). 애니메이션 효과가 처음부터 끝까지 일정한 속도로 진행 */   /* ease : 기본값. cubic-bezier(0.25,0.1,0.25,1). 애니메이션 효과가 천천히 시작되어 빨라졌다가 다시 느려짐 */   /* ease-in : cubic-bezier(0.42,0,1,1). 애니메이션 효과가 천천히 시작됨 */   /* ease-out : cubic-bezier(0,0,0.58,1). 애니메이션 효과가 천천히 끝남 */   /* ease-in-out : cubic-bezier(0.42,0,0.58,1). 애니메이션 효과가 천천히 시작되어 천천히 끝남 */   /* steps(1,...) 함수 : 애니메이션을 스텝에 맞게 끝어서 표현 */   /* step-start : steps(1,start). 시작하는 지점에 스텝 */   /* step-end : steps(1,end). 끝나는 지점에 스텝 */  transition-duration: /* 트랜지션이 진행될 시간 지정 (단위: s 또는 ms) */;  transition-delay: /* 트랜지션이 시작하기 전에 대기하는 시간 지정 (단위: s 또는 ms) */;  ","categories": [],
        "tags": ["FrontEnd"],
        "url": "/css1/",
        "teaser": null
      },{
        "title": "[Git] 1. Git 개념 및 명령어 정리",
        "excerpt":"버전 관리 (Version Control) : 특정한 시간 기준으로 파일 변화를 저장하고 관리      버전 (Version) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용   1. 로컬 버전 관리 (Local Version Control)     로컬 사용자가 서버 없이 로컬 컴퓨터 내의 데이터베이스를 이용해 파일의 변경 정보 관리            협업에서 사용하기 어려움, 내부 정보가 손상되면 복구할 방법이 없음           2. 중앙집중식 버전 관리 (Central Version Control) : 서브 머신 (SVN)     클라이언트가 최종본를 관리하는 데이터베이스 서버로부터 개별 파일을 로컬에 다운로드, 수정본을 서버에 올림            데이터베이스 서버에 의존적, 협업 규모가 커지면 수정 충돌 문제 발생 (유사 사례 : 나무위키의 편집 충돌)           3. 분산형 버전 관리 (Distributed Version Control) : 깃 (Git)     클라이언트가 원격 저장소에서 전체 기록과 각 기록을 추적할 수 있는 정보를 포함한 데이터를 로컬 저장소에 저장            클라이언트가 자신의 작업을 원격 저장소에 독립적인 로컬 저장소에 버전별로 저장하고 관리       여러 클라이언트들의 작업을 여러 로컬 저장소로 다원화해 각 클라이언트는 충돌의 염려 없이 작업 가능       필요한 경우에 클라이언트가 서버의 원격 저장소에 원하는 버전을 통합 (서버 단위의 편집 버전을 +1)                    클라이언트는 원격 저장소에 자신의 작업을 통합시킬 때만 서버와 통신하면 됨                           깃 (Git) : 분산형 버전 관리 시스템 (Distributed Version Control System)     터미널 창에 다음 명령어를 입력해 homebrew를 통해 git 설치   brew install git   .gitignore 디렉터리 : 버전 관리를 하지 않을 파일이나 디렉터리, 혹은 파일 확장자를 설정      특정한 이름을 가진 파일 제외   filename.txt      특정한 확장자를 가진 파일 제외   *.txt      특정한 경로 아래의 파일 제외   folder/      특정한 경로 아래의 특정한 확장자를 가진 파일 제외   folder/filename.txt      예외 만들기   !filename.txt   README.md 파일 : 프로젝트에 대한 설명과 사용 방법, LICENSE 등의 내용을 작성     기존의 Markdown에 깃허브에서만 사용 가능한 기능을 추가한 Github Flavored Markdown을 이용   Github 프로젝트 레포지토리 페이지에서 README.md가 표현된 것을 확인 가능            자신의 아이디와 같은 이름의 레포지토리의 README.md는 해당 사용자의 깃허브 프로필에 표시됨                 뱃지 : 해당 사이트에서 뱃지의 구성 요소들을 직접 지정해 생성한 후 img 태그로 삽입   &lt;img src=\"https://img.shields.io/badge/(아이콘 내용)-(아이콘 색상)?style=flat-square&amp;logo=(로고 이름)&amp;logoColor=(로고 색상)\"/&gt;         방문자 수 : 해당 사이트에서 Target URL과 로고를 선택한 후 a 태그로 삽입   &lt;a href=\"https://github.com/pocj8ur4in\"&gt; ... &lt;/a&gt;         Solved.ac 티어 : 해당 사이트에서 마크다운 언어로 삽입   [![Solved.ac 프로필] (http://mazassumnida.wtf/api/v2/generate_badge?boj={백준ID})] (https://solved.ac/백준ID)         Solved.ac 잔디 : 해당 사이트에서 img 태그로 삽입   &lt;img src=\"http://mazandi.herokuapp.com/api?handle={백준ID}&amp;theme=warm\"/&gt;         자주 사용한 언어 : 해당 사이트에서 마크다운 언어로 삽입   [![Top Langs] (https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브ID)] (https://github.com/깃허브ID/github-readme-stats)         Header &amp; Footer : 해당 사이트에서 마크다운 언어로 삽입   ![header] (https://capsule-render.vercel.app/api?type=모양&amp;color=auto&amp;height=높이&amp;section=header&amp;text=내용&amp;fontSize=폰트크기)    ![Footer] (https://capsule-render.vercel.app/api?type=모양&amp;color=auto&amp;height=높이&amp;section=header&amp;text=내용&amp;fontSize=폰트크기)     .git 디렉터리 : 깃의 버전을 저장할 로컬 저장소     버전 (Version) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용            작업 트리 (working tree) : 파일 수정, 저장 등의 작업을 하는 작업 디렉터리                    스테이징 (Staging) : 작업 트리에서 작업한 파일을 버전으로 만들기 위해 스테이지로 이동                       스테이지 (stage) : 버전으로 만들 파일이 대기하는 스테이징 영역                    커밋 (Commit) : 스테이지에서 대기중인 파일을 버전으로 만들어 레포지토리에 저장                       레포지토리 (repository) : 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 저장소           깃 명령어 (Git Command) : git &lt;command&gt; 형식으로 구성          git : 깃 명령 다음에 입력할 수 있는 명령어 옵션 확인       $ git ...         git init : 깃 저장소를 만들 디렉터리 초기화 (깃 저장소인 .git 디렉터리가 생성)   $ git init Initialized empty Git repository in ...      git status :  깃의 현재 상태 확인            untracked 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하지 않습니다. (파일이 스테이지에서 대기 : false)       tracked 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하고 있습니다. (파일이 스테이지에서 대기 : true)                    unmodified 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되지 않았습니다.                            Working tree clean                                   modified 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었으나 스테이징되지 않았습니다.                            Changes not stage for commit:                                   staged 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었고 스테이징되었습니다.                            Changes to be committed:                                                   $ git status On branch master  // 현재 master 브랜치에 위치해 있음 No commits yet    // 아직 커밋한 파일이 존재하지 않음 nothing to commit // 현재 커밋한 파일이 존재하지 않음  $ git status On branch master No commits yet untracked files   // untracked 상태 : 아직 버전 관리하지 않은 파일들이 존재함      git add : 작업 트리에서 스테이지로 스테이징   $ git add helloWorld.txt      git commit : 스테이지에 있는 파일을 버전으로 커밋            -m 옵션을 통해 커밋과 함께 메시지 저장       -am 옵션을 통해 스테이징과 커밋을 동시에 처리           $ git commit -m \"message1\"      git log : 레포지토리에 저장된 버전 정보 확인            커밋 해시 (commit hash) : 커밋을 구별하는 ID (HEAD-&gt;master : 해당 버전이 가장 최신임을 표시)       작성자 (Author) : git config --global user를 통해 입력한 사용자 정보 (이름과 이메일)       작성일 (Date) : 버전이 작성된 시각       커밋 메시지 (commit message) : git commit -m을 통해 저장된 메시지          ","categories": [],
        "tags": ["Git"],
        "url": "/git1/",
        "teaser": null
      },{
        "title": "[CS] 1. 운영체제 (Operation System)",
        "excerpt":"운영체제 (Operation System) : 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어      컴퓨터 시스템 자원의 효율적인 관리 (Performance) : 하드웨어 자원을 각각의 사용자 응용 프로그램에 적절히 분배            하드웨어 자원 (Hardware Resource) : CPU 시간, 기억 장치 및 디스크 영역, I/O 장치           사용자 편의성 제공 (Convenience) : 사용자가 더 편리하게 사용할 수 있는 환경을 구성       프로세스 관리 (Process Management)   메인 메모리 관리 (Main Memory Management)   파일 관리(File Management)   저장 장치 관리 (Storage Management)   I/O 장치 관리 (I/O Device Management)   시스템 호출 (System call)    부팅 (Booting) : 컴퓨터를 시작할 때 자기 자신을 구동시킬 프로그램을 스스로 불러내는 동작     메인 메모리 (Main Memory) : 즉시 필요한 데이터를 저장하는 주 기억 장치            RAM : 휘발성 주 기억 장치 (전원이 꺼지면 모든 내용이 지워짐)                    코드 영역 (Code Area) : 실행할 프로그램의 코드가 저장되는 영역                            CPU는 이 영역에 저장된 명령어를 하나씩 호출해 수행함                                   데이터 영역 (Data Area) : 실행할 프로그램의 전역 변수와 정적 변수가 저장된 영역                            프로그램 시작 시 할당, 프로그램 종료 시 소멸                                   스택 영역 (Stack Area) : 프로그램의 함수 호출과 관련된 지역 변수와 매개 변수가 정적으로 저장된 영역                            후입선출 (Last-In, First-Out) 방식에 따른 동작 : PUSH로 데이터 저장, POP로 데이터 인출               메모리의 높은 주소에서 메모리의 낮은 주소의 방향으로 할당               함수 호출 시 할당, 함수 호출 종료 시 소멸                                   힙 영역 (Heap Area) : 사용자에 의해 동적으로 할당되고 해제되는 전역 변수가 저장되는 영역                            할당되는 변수의 크기 제한이 없음 : 크기 제한이 존재하는 스택에 비해 액세스 속도가 상대적으로 느림               CPU에 의해 효율적으로 관리되는 스택 영역과 달리, 사용자가 힙 영역을 관리해야 함                                    메모리 단편화 (Memory Fragmentation) : 사용 가능한 메모리가 존재하나, 할당 불가능                                               메모리의 낮은 주소에서 메모리의 높은 주소의 방향으로 할당                                               ROM : 비휘발성 주 기억 장치 (전원이 꺼져도 그 안의 내용이 계속 유지)                    POST (Power-On Self-Test) : 부팅 시 가장 처음 실행, 현재 컴퓨터의 상태 검사           부트 로더 (Boot Loader) : POST 다음에 실행, 보조 기억 장치의 운영체제를 탐색 후 RAM에 할당                            보조 기억 장치에서 RAM으로 할당된 운영체제는 컴퓨터 전원이 꺼질 때까지 상주 (Resident)                                                   SSD/HDD : 운영체제가 저장된 보조 기억 장치            커널 (Kernel) : 운영체제가 수행하는 모든 작업이 저장       명령어 해석기 (Shell) : 사용자가 요청하는 명령어를 해석해 커널에 요청하고 결과를 출력                    응용 프로그램 (Application) : 운영체제 위에서 수행되며, 운영체제가 지원하는 자원만을 사용 가능                           일괄 처리 시스템 (Batch Processing System) : 프로그램 수행 과정의 자동화     Resident Monitor : 프로세서에 할당하기 위해 (컴파일 -&gt; 링크 -&gt; 로딩)의 과정을 하나의 프로그램으로 작성   시분할 시스템 (Time-sharing System) : CPU가 프로그램을 수행하는 시간을 제한     스위칭 (Switching) : 프로그램이 일정 시간 실행되면 Time Out을 발생시켜 다음 프로그램으로 넘어가게 함   다중 작업 (Multitasking) : CPU가 짧은 시간 내에 여러 프로그램을 스위칭해 동시에 작업하는 것처럼 보이게 함            CPU 스케줄링 (CPU Scheduling) : CPU가 어느 프로그램을 실행할지 선택하는 작업           다중 프로그래밍 (Multiprogramming) : 메모리에 여러 응용 프로그램을 적재해 idle 상태 최소화     프로그램 실행 시에 계산을 담당하는 CPU와 입출력을 담당하는 I/O 장치가 교대로 실행            idle상태 : I/O 장치가 실행되는 동안 CPU가 아무런 작업도 하지 않는 상태           인터럽트 기반 시스템 (Interrupt-based System) : 인터럽트 발생 시 ISR에 맞는 처리 수행     인터럽트 (Interrupt) : 프로그램 실행 중에 예기치 않은 상황이 발생할 경우 이를 CPU에 알리는 전기 신호            외부 인터럽트 (Eternal Interrupt) = 하드웨어 인터럽트 (Hardware Interrupt)       내부 인터럽트 (Internal Interrupt) = 소프트웨어 언터럽트 (Software Interrupt)                    예외 (Exception)           시스템 호출 (System call)                           인터럽트 서비스 루틴 (Interrupt Service Routine) : 인터럽트 신호를 처리할 방법을 내포한 운영체제 내의 코드   이중 모드 (Dual Mode Execution) : 유저 (User) 모드와 커널 (Kernel) 모드를 나눔      ! 문제 : 어떤 작업이 자원을 계속해서 점유하는 일과 같이 컴퓨터의 작업 효율을 저해하는 행위로부터 보호할 수단 필요       CPU 내 레지스터 (Register)의 Mode-Bit를 플래그 (flag)로 활용해 나타냄 (커낼 모드 : 0, 유저 모드 : 1)   각 명령어에 Mode-Bit를 넣어 시스템 내의 Mode-Bit와 같을 시에만 명령어 수행   특권 명령어 (Privileged Instruction) : 커널 모드에서만 내릴 수 있는 명령어            STOP, HALT, RESET, SET_TIMER 등       유저 모드에서는 특권 명령어를 내릴 수 없음 (내부 인터럽트를 발생해 해당 명령어를 요청한 프로그램을 강제 종료)           시스템 호출 (System Call) : Mode-Bit를 바꾸는 행위 (INT 80)            사용자가 하드웨어 자원에 접근할 때, 프로그램에서 시스템 호출을 발생시켜 운영체제에 위임해 커널 모드로 처리                   컴퓨터가 부팅되는 과정 : 커널 모드     응용 프로그램이 실행되는 과정 : 커널 모드     응용 프로그램이 실행되는 중일 때 : 유저 모드     인터럽트가 발생한 후 처리하는 과정 : 커널 모드     인터럽트를 처리한 후 : 유저 모드      하드웨어 보호 (H/W Protection) : 잘못된 명령이나 접근에 보호하기 위해 운영체제에서 내부 인터럽트 발생      ! 문제 : 정보들이 여러 I/O 장치를 통해 컴퓨터로 입출력되는 과정에서 장치 간 혹은 데이터 간의 혼선이 발생할 수 있음    입출력 장치 보호 (I/O Protection) : in, out과 같은 입출력 명령을 특권 명령으로 지정해 운영체제를 통해 수행     입출력 수행 시에는 관리자 모드로 전환해 특권 명령을 내림            Privileged Instruction Violation : 사용자가 입출력 명령을 직접 내린 경우 프로그램을 강제 종료              ! 문제 : 다른 사용자나 운영체제에 할당된 메모리 영역에 접근해 정보나 프로그램을 해킹할 수 있음    메모리 보호 (Memory Protection) : CPU와 메인 메모리 간 주소 버스에 Memory Management Unit 설치     두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장   사용자에 할당된 메모리 영역을 벗어난 주소값을 가져오지 못하게 함   Memory Management Unit 설정은 운영체제만 변경 가능            Segment Violation : 사용자에 할당된 메모리 영역을 벗어난 주소값이 MMU에 오면 내부 인터럽트를 발생시킴              ! 문제 : 프로그램에서의 무한 루프로 인해 CPU가 독점되어 다른 프로그램이 수행되지 못할 수 있음    CPU 보호 (CPU Protection) : 타이머 (Timer)를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킴     타이머 (Timer) : 무한 루프나 자원 독점을 막기 위해 특정 시간이 지나면 타이머 인터럽트를 발생시킴            타이머 인터럽트 (Timer Interrupt) : 인터럽트의 ISR에서 CPU가 프로그램의 CPU 점유 시간을 측정해 분배       운영체제는 타이머가 끝난 작업을 종료시키고 스케줄링 (Scheduling) 이전에 타이머 실행           프로세스 (Process) : 실제 메인 메모리에 할당되어 실행 중인 프로그램     프로그램은 보조 기억 장치에서 아무런 동작을 하지 않은 상태   어떤 요청에 의해 메인 메모리에 할당되어 CPU를 사용하면서 실행   각각의 프로세스는 CPU에 의해 샐행된 후 …를 생성 (메인 메모리를 효율적으로 사용해야 함)            프로세스 테이블 엔트리 = 프로세스 컨트롤 블록 (Process Control Block)       주소 공간 (Address Space)                    코드 세그먼트 (Code Segment) : 프로그램 소스 코드가 저장           데이터 세그먼트 (Data Segment) : 전역 변수가 저장           스택 세그먼트 (Stack Segment) : 지역변수와 매개변수가 저장                              지역변수와 매개변수가 후입선출을 따른 스택에 저장되므로, 전역 변수를 먼저 선언해 메인 메모리의 공간 절약 가능    프로세스의 생성과 종료 (Creation and Destruction of Process)     최초의 프로세스인 Init의 생성은 부팅된 운영체제가 처음 수행하는 작업 중 하나   생성된 프로세스가 다른 프로세스를 생성하는 과정을 반복            프로세스의 생성을 위한 시스템 호출 : fork()       프로세스의 종료를 위한 시스템 호출 : exit()           생성된 모든 프로세스는 자신을 식별할 수 있는 고유의 정수값인 PID을 가짐            생성된 모든 프로세스는 자신을 생성한 사용자 고유의 UID 값 또한 가짐 (부모와 자식이 동일한 값)                 프로세스 트리 (Process Tree) : 부모 프로세스인 A에서 자식 프로세스인 B, C, D가 파생되어 생성            부모 프로세스 : 프로세스를 생성한 프로세스       자식 프로세스 : 프로세스로부터 생성된 프로세스       형제 프로세스 : 같은 부모 프로세스에서 파생된 자식 프로세스           프로세스 컨트롤 블록 (Process Control Block) : 프로세스에 대한 모든 정보를 저장하는 곳     CPU는 여러 프로세스를 빈번히 전환하면서 수행하기에 각 프로세스의 데이터를 저장해야 작업을 이어서 수행할 수 있음   운영체제 내에서 프로세스를 관리하는 코드 부분에 저장            프로세스 컨트롤 블록에 데이터를 저장 및 복원하는 시간 역시 다중 작업을 위해 프로세스에 할당되는 시간에 포함           프로세스 상태, 프로그램 카운터, 스택 포인터, 파일 디스크립터 등의 정보 포함      프로세스 상태 (Process Status) : 각 단계들에서 상태 전이가 일어나 다음 단계로 넘어감     New : 프로그램이 메인 메모리에 할당된 상태   Ready : 프로세스가 언제든 실행 가능한 상태; 할당된 프로그램이 실행되기 위한 모든 준비를 마친 상태로 대기된 상태            n개의 작업이 있을 때, CPU의 프로세서는 스케줄러의 0~(n-1)번, 즉 n개의 작업을 번갈아 처리           Running : CPU가 해당 프로세스를 실제로 실행중인 상태   Waiting=Blocked : Running이 불가능한 상태            프로세스가 끝나지 않은 시점에 해당되는 I/O 정보가 없어 작업할 수 없음       Waiting가 끝나면 다시 CPU에 실행되기 위해 Ready로 돌아가야 함           Terminated : 프로세스가 완전히 종료된 상태              I/O 작업으로 인한 상태 변화 : Running -&gt; Waiting -&gt; Ready -&gt; Running     시간 초과로 인터럽트에 의한 상태 변화 : Running -&gt; Ready -&gt; Running      프로세스 큐 (Process Queue) : 커널이 프로세스 스케줄링을 위해 데이터 영역에서 관리하는 큐     Ready Queue : 프로세스 상태가 Ready인 프로세스들이 CPU 제어를 기다리는 큐            어떤 CPU 스케줄링 알고리즘을 선택하는지에 따라 CPU 제어 순서가 달라짐           Job Queue : 보조 기억 장치의 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐            시스템 내의 모든 프로세스 관리 : Ready Queue, Device Queue에 속한 모든 프로세스 포함           Device Queue : 프로세스 상태가 Waiting인 프로세스들이 CPU 외의 자원을 기다리는 큐            기다리는 자원들마다 큐가 할당되며, 해당 자원이 사용되면 인터럽트를 발생시키고 Ready Queue로 이동                 각 큐는 프로세스의 프로세스 컨트롤 블록을 가리키는 포인터 방식으로 연결 리스트를 구현   스케줄러 (CPU Scheduler) : 프로세스 순서를 정해 프로세스 큐에 올릴 것을 결정하는 커널의 코드     장기 스케줄러 (Long-term Scheduler) : 생성된 프로세스 중 Job Queue에서 Ready Queue에 이동시킬 것 선택            장기 스케줄러는 현재 메모리에 할당된 프로세스의 개수 (Degree of multiprogramming)를 제어       장기 스케줄러는 I/O bound Process,CPU bound Process를 메인 메모리에 적절히 할당해야 함                    I/O bound Process : I/O 작업 (입출력) 비중이 높은 프로세스           CPU bound Process : CPU 작업 (계산) 비중이 높은 프로세스                           중기 스케줄러 (Medium-term Scheduler) : 실행 중인 프로세스 중 보조 저장 장치로 옮길 것을 주기적으로 검사            Swapping (Swap-out↔Swap-in) : Swap-in할 때 이전 공간으로 재할당되는 것은 보장되지 않음                    Swap-out : 메인 메모리에서 우선 순위가 은 프로세스를 통째로 보조 기억 장치로 저장           Swap-in : 나중에 해당 프로세스가 다시 사용되려 할 때 보조 기억 장치에서 메인 메모리에 다시 할당                       중기 스케줄러 또한 현재 메모리에 할당된 프로세스의 개수 (Degree of multiprogramming)를 제어           단기 스케줄러 (Short-term Scheduler) : Ready Queue 내에서 프로세스들 중 어떤 것을 다음에 실행시킬지 선택            CPU 스케줄러 (CPU Scheduler) 라고도 부르며, 시분할 시스템에서 Time Out이 발생하면 호출           문맥 전환 (Context Switching) : CPU가 실행중인 프로세스를 멈추고 다른 프로세스를 실행하는 작업     문맥 (Context) : 각 프로세스 컨트롤 블록 내에서 표현            하드웨어 문맥 : 프로그램 카운터 정보와 레지스터 정보를 저장       프로세스 주소 공간 : 각 프로세스가 갖고 있는 독자적인 주소 공간에 위치           CPU 스케줄러 : CPU가 어느 프로세스를 다음에 실행할지 지정   디스패쳐 (Dispatcher) : 문맥 전환이 발생하면 Ready에서 Running으로 상태 전이            문맥 전환 오버헤드 (Context Switching Overhead) : 문맥 전환이 발생할 때마다 디스패쳐를 매번 실행시킴                CPU에서 실행중인 프로세스의 데이터는 해당 프로세스의 프로세스 컨트롤 블록에 갱신   새로 시작될 프로세스의 프로세스 컨트롤 블록를 CPU로 복원   캐시와 Translation Lookup Buffer를 재설정           시스템 호출로 인한 인터럽트 발생 시 :                실행 중인 프로세스의 문맥을 프로세스 컨트롤 블록에 갱신하나, 문맥 전환은 이루어지지 않음                  CPU 스케줄링 (CPU Scheduling) : CPU 스케줄러에서 어느 프로세스를 다음에 실행할지 지정     선점 (Preemptive) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 강제로 점유할 수 있음   비선점 (Non-Preemptive) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 점유할 수 없음            예외 : I/O 발생           CPU 스케줄링 척도 (CPU Scheduling Criteria) : CPU 스케줄링의 효율을 분석하는 기준     CPU 점유율 (CPU Utilization) : 현재 CPU가 작업을 수행하는 비율 -&gt; 높을수록 좋음   처리율 (Throughput) : 단위 시간 당 완료되는 프로세스의 개수 -&gt; 많을수록 좋음   소요 시간 (Turnaround Time) : 프로세스가 생성된 시간부터 종료되는 데까지 걸린 시간 -&gt; 짧을수록 좋음   대기 시간 (Waiting Time) : CPU 제어를 위해 Ready Queue에서”만” 대기한 시간 -&gt; 짧을수록 좋음            평균 대기 시간 (Average Waiting Time) : (각 프로세스들의 대기 시간의 합) / (프로세스들의 개수)           응답 시간 (Response Time) : Interactive System에서 입력에 대한 반응 시간 -&gt; 짧을수록 좋음   선입선출 (First-Come, First-Served) 스케줄링 : 가장 먼저 작업을 요청한 프로세스를 먼저 수행     비선점 (Non-Preemptive)   들어온 순서대로 작업을 수행한다고 해도 그것이 반드시 효율적이지 않음            Convoy Effect : CPU를 많이 점유하는 프로세스가 먼저 수행되어 나머지 프로세스들이 그만큼 오래 대기                \t \t\t \t\t\tProcess \t\t\tBurst Time (msec) \t\t \t    \t                P1         3                       P2         3                       P3         24                     FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.                Average Waiting Time : (0 + 3 + 6) / 3 = 3msec                       \t \t\t \t\t\tProcess \t\t\tBurst Time (msec) \t\t \t    \t                P1         24                       P2         3                       P3         3                     FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.                Average Waiting Time : (0 + 24 + 27) / 3 = 17msec                 CPU를 오래 점유하는 P3로 상대적으로 빠른 처리가 가능한 P1과 2가 오래 대기하는 Convoy Effect 발생!      최단작업 (Shortest-Job-First) 스케줄링 : 시간이 가장 짧게 수행되는 프로세스를 먼저 수행     비선점 (Non-Preemptive), 선점 (Preemptive)   일반적으로 가장 빠른 평균 대기 시간을 가지나, 현실에선 각 프로세스의 CPU 점유 시간이 주어지지 않아 비현실적        \t \t\t \t\t\tProcess \t\t\tBurst Time (msec) \t\t \t    \t                P1         6                       P2         8                       P3         7                       P4         3                     FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, P4 순으로 처리한다.                Average Waiting Time : (0 + 6 + 14 + 21) / 4 = 10.25msec                 SJF Scheduling : (작업 시간이 짧은 순서대로) P4, P1, P3, P2 순으로 처리한다.                Average Waiting Time : (0 + 3 + 9 + 16) / 4 = 7msec                  우선순위 (Priority) 스케줄링 : 우선순위가 가장 높은 프로세스를 먼저 수행     비선점 (Non-Preemptive), 선점 (Preemptive)   우선순위는 정수값으로 표현되며, 값이 작을수록 우선순위가 높음        \t \t\t \t\t\tProcess \t\t\tBurst Time (msec)       Priority \t\t \t    \t                P1         10         3                       P2         1         1                       P3         2         4                       P4         1         5                       P5         5         2                     Priority Scheduling : (우선순위가 높은 순서대로) P2, P5, P1, P3, P4 순으로 처리한다.                Average Waiting Time : (0 + 1 + 6 + 16 + 18) / 5 = 8.2 msec                  라운드 로빈 (Round-Robin) 스케줄링 : 원 모양으로 모든 프로세스를 돌아가면서 수행     선점 (Preemptive)   시분할 시스템에서 CPU가 한 프로세스를 일정 시간 수행한 뒤 대기 상태로 보내고, 다음 프로세스를 수행하는 것 반복            Time Quantum : CPU가 한 프로세스를 수행하는 시간 -&gt; 스케줄리의 효율성이 Time Quantum의 크기에 의존                \t \t\t \t\t\tProcess \t\t\tBurst Time (msec)       Time Quantum \t\t \t    \t                P1         7         4msec                       P2         4                       P3         4                     RP Scheduling : (CPU에 요청받은 순서) P1, P2, P3, 그리고 (완료하지 못한) P1 순으로 처리                Average Waiting Time : (4 + 8 + 12) / 3 = 8 msec                       \t \t\t \t\t\tProcess \t\t\tBurst Time (msec)       Time Quantum \t\t \t    \t                P1         7         3msec                       P2         4                       P3         4                     RP Scheduling : (CPU에 요청받은 순서) P1, P2, P3, (완료하지 못한) P1, P2, P3, 그리고 P1 순으로 처리                Average Waiting Time : (12 + 13 + 14) / 3 = 13 msec                  멀티레벨 큐 (Multi-level Queue) 스케줄링 : 각 프로세스 그룹에 따른 큐를 두어 수행     프로세스 그룹 : 프로세스를 기준에 따라 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치            Interactive Process : 유저 수준 &gt; 데이터를 바로바로 처리 (I/O bound Process)       Batch Process : 유저 수준 &gt; 일정 시간에 데이터를 한번에 처리 (CPU bound Process)           우선순위에 따라 대기할 큐를 지정할 수 있고, 각 큐마다 서로 다른 스케줄링 방식을 사용 가능   멀티레벨 피드백 큐 (Multi-level Feedback Queue) 스케줄링 : 멀테레벨 큐에 피드백 추가     멀티레벨 큐처럼 프로세스를 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치            모든 프로세스들은 처음에는 무조건 우선순위가 가장 높은 큐에서 대기                    vs 멀티레벨 큐 : 우선순위에 따른 큐 지정 가능                           피드백 (Feedback) : time out이 발생한 프로세스를 보다 낮은 우선순위의 큐로 격하            I/O bound Process는 높은 우선순위, CPU bound Process는 낮은 우선순위           프로세스 간 통신 (Inter-Process Communication) : 프로세스 간에 데이터를 주고받는 행위     독립 프로세스 (Independent Process) : (단일 처리 시스템에서) 다른 프로세스에 독립적인 동기적 프로세스   협력 프로세스 (Cooperating Process) : 실행중인 다른 프로세스와의 상호 작용을 통해 수행되는 비동기적 프로세스   공유 메모리 (Shared Memory) : 협력 프로세스 간 하나의 공유 메모리 영역을 만들어 상호 통신     공유 메모리 세그먼트 : 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치       장점 : 커널 의존성이 낮아 속도가 빠르고, 유저 레벨에서의 IPC가 가능해 자유로운 통신이 가능   단점 : 자원과 데이터를 공유하기에 동기화 문제가 발생   메시지 패싱 (Message Passing) : 협력 프로세스 간 각자의 메시지를 운영 체제에 전달해 통신     장점 : 별도의 구축 없이 커널만을 이용하기에 비교적 구현이 쉬움   단점 : 커널을 이용할 때마다, 시스템 호출에 따른 문맥 전환이 매번 발생 (문맥 복사 2번 수행, 문맥 전환 오버헤드 발생)   쓰레드 (Thread) : 프로세스 내부의 흐름     CPU를 구성하는 기본 단위로, 일반적으로 하나의 프로세스은 하나의 쓰레드가 존재   하나의 쓰레드는 고유한 Thread ID, Program Counter, Register Set 및 Stack을 가짐   다중 쓰레드 (Multi-Threads) :  하나의 프로세스에 쓰레드가 2개 이상 존재     Concurrent : 한 프로세스에서 여러 쓰레드가 빠른 시간 간격으로 스위칭되어 동시에 실행되는 것처럼 보임            여러 쓰레드들이 하나의 프로세스 안에 속하면서 code, data 메모리 공간과 프로세스 자원 file과 I/O 공유       메시지 패싱 X (운영 체제를 거치지 않고도 통신 가능), 공유 메모리 X (공유 메모리를 만들지 않아도 됨)                    멀티 프로세스에 비해 문맥 전환 시간이 짧고, 메모리와 자원의 할당이 더 효율적                           운영체제가 다중 쓰레드를 지원 : 현대 운영체제에서의 문맥 전환은 프로세스가 아닌 쓰레드 단위로 이루어짐            하나의 프로세스 안에서 여러 쓰레드가 수행되다가 다른 프로세스로 넘어가 그 프로세스의 쓰레드를 수행함                    웹 브라우저 : 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 따로 수행                           다중 쓰레드 모델 (Multi-Threads Models) :  2개 이상의 쓰레드로 구성된 모델     유저 쓰레드 (User Thread) : 유저 레벨의 쓰레드 라이브러리를 통해 관리되는 쓰레드   커널 쓰레드 (Kernel Thread) :  운영체제가 제공하고 직접 관리하는 쓰레드   Many-to-One 모델 : 한 커널 쓰레드가 여러 유저 쓰레드 처리     병목 현상 : 시스템 호출이 발생하면, 모든 유저 쓰레드가 대기해야 함   One-to-One 모델 : 유저 쓰레드 한 개당 커널 쓰레드를 대응시켜 처리     커널 쓰레드가 과도하게 생성되어 비효율적임   Many-to-Many 모델 : 여러 유저 쓰레드가 여러 커널 쓰레드 처리     커널 쓰레드의 수는 유저 쓰레드의 수보다 작거나 같게 해야 함   Two-Level 모델 : 중요한 작업은 One-to-One으로, 나머지는 Many-to-One으로 처리   메인 메모리 관리 (Main Memory Management)     메모리 공간은 기본적으로 주소 (address)와 데이터 (data)로 구성되어 있음            CPU는 주소를 가지고 메인 메모리에 요청을 하거나 해당 주소에 계산 결과를 저장       메인 메모리는 CPU가 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달                 프로그램의 빌드는 소스 파일, 목적 파일, 실행 파일 순서로 생성            소스 파일 (Source file) : 고수준 언어 또는 어셈블리어                    컴파일 단계 : 소스 파일은 컴파일러 또는 어셈블러에 의해 컴파일 또는 어셈블하여 목적 파일 생성                       목적 파일 (Object file) : 컴파일된 결과 또는 어셈블된 결과                    링크 단계 : 목적 파일은 링커 (Linker)에 의해 라이브러리를 찾아 정보를 추가해 실행 파일 생성                       실행 파일 (Executable file) : 링크된 결과                    로드 단계 : 실행 파일은 로더 (Loader)에 의해 메인 메모리에 할당                                 빌드된 프로그램은 code, data, stack 영역으로 구분됨            단순히 생성된 프로그램은 code, data 영역만 존재       로드 단계에서 프로그램이 실행을 위해 메모리에 적재되었을 때, 운영체제에 의해 stack 영역이 추가됨           메모리 계층 (Memory hierarchy) : 각각의 특징이 있는 저장 장치를 혼용해 효율성 극대화     메모리 매니저 (Memory Manager) : 메모리 하이라키를 관리하는 관리 시스템의 일부분         캐시 (Cash) : 빠르고, 비싸고, 휘발성   메인 메모리 (Main Memory) : 캐시보다 느리고, 캐시보다 싸고, 휘발성   디스크 스토리지 (Disk Storage) : 메인 메모리보다 느리고, 메인 메모리보다 싸고, 비휘발성      메모리 계층 구조를 통해 프로그래머가 사용하기 좋은 모델로 추상화하고, 운영체제를 통해 추상회된 객체를 관리한다.    Q. CPU가 한 번에 한 프로세스를 수행하면? : Mono-Programming      메인 프레임 (mainframe) : RAM 위의 OS에 유저 프로그램이 주소로 연결되어 존재   임베디드 시스템 (Embedded System) : OS가 위치한 ROM 아래에 유저 프로그램이 주소로 연결되어 존재   퍼스널 컴퓨터 (personal computer) : 메인 프레임 + ROM 위 장치 관리자가 유저 프로그램 위에서 OS의 관리를 받음      하단 내용은, CPU가 여러 프로세스를 돌아가면서 수행하는 Multi-Programming 환경이라 가정한다.    Q. 만약 메모리 추상화를 사용하지 않는다면? : 모든 프로그램이 물리 메모리를 직접 사용     프로그래머에게 제공되는 메모리 영역 : 실제 물리 메모리 (0 ~ (실제 물리 메모리의 크기))            각 주소는 n비트로 구성된 셀 (Cell)로 정의           하드웨어의 도움 없이 두 프로그램이 동시에 메모리에서 실행된다는 것은 불가능            메모리의 프로세스를 이미지 형태로 디스크에 저장하고, 프로그램을 메모리로 스와핑 (Swapping)할 순 있음              ! 메모리 추상화를 사용하지 않는다고 했으니, 메모리 계층 구조 또한 존재하지 않는거네?         아니다. 메모리를 추상화하는 방법 중 하나로, 메모리 추상화를 사용하지 않는 것이다.                { a, b, c, d, … } 를 추상화하는 방법 (1) := alphabetic         { a, b, c, d, … } 를 추상화하는 방법 (2) := { a, b, c, d, … }                   … 운영체제는 메모리 계층 구조를 이루는 캐시, 메인 메모리, 디스크 스토리지를 물리 주소를 통해 직접 접근한다.         그런데, 물리 주소를 직접 접근하는 방법에는 Protection &amp; Relocation 이슈가 존재한다.      P1. 프로텍션 (Protection) : 한 프로세스가 운영체제나 다른 프로세스의 파티션을 침범하지 못하게 해야 함     IBM360모델 : 프로텍션 코드 (Protection code)            프로세스의 PSW에는 4bit 키가 포함 / 메모리를 2KB 블럭 단위로 나누고, 각 블록에 4bit 프로텍션 코드 할당       수행되는 프로세스는 자신의 PSW 키와 액세스하는 블럭의 프로텍션 코드를 비교해, 일치하지 않으면 트랩 발생           P2. 리로케이트 (Relocation) : 변수 주소나 프로시저 주소에 대한 접근에 차이가 발생     컴파일된 .exe 파일을 파티션에 로드해 실행할 때, 바이너리 파일이 아닌, 파티션을 기준으로 접근해야 함            컴파일된 .exe 파일을 파티션 A와 B에 각각 로드해 실행할 때, 각 파티션을 기준으로 접근해야 함              컴파일된 .exe 파일의 첫번째 명령어가 100번지에 있는 프로시저 콜이라고 가정하면…         해당 파일을 파티션에 로드해 실행했을 때 : 0 + 100번지로 접근 (파티션의 시작 주소) + 100번지로 접근         IBM360모델 : 정적 재배치 (Static Relocation)            프로그램이 메모리에 로드될 때, 파티션을 기준으로 접근하도록 명령어 수정                    링커가 프로그램의 어떤 부분이 리로케이트되어야 하는지 알아야 함                           주소 바인딩 (Address Binding) : 프로세스의 논리적 주소를 물리적 메모리 주소로 연결     주소 공간 (address space) : 프로세스가 메모리에 접근할 때 사용하는 주소들의 집합            각 프로세스들은 자신들만의 주소 공간을 가짐 -&gt; logical address           프로그램이 어떤 주소를 사용해도, 메인 메모리에 할당된 주소를 찾아가도록 해야 함            논리 주소 (logical address) : CPU에서 사용하는 주소. 메모리 내 프로세스의 독립적인 공간       물리 주소 (physical address) : 메인 메모리에서 사용하는 주소. 하드웨어에 의해 정해진 주소 공간              … 그러므로 프로그램이 할당된 실제 메모리 주소 공간의 위치는 프로그램을 실행하는 CPU에 전혀 영향을 미치지 않음         그럼 어떻게 각각의 프로세스들에게 서로 다른 주소 공간을 제공할 수 있을까?      MMU의 재배치 레지스터 (Relocation Register) : 프로세스의 논리 공간을 메모리의 물리 공간으로 연속해 매핑     동적 재배치 (Dynamic relocation) : 프로세스의 논리 주소를 메모리의 물리 주소으로 변경            베이스 레지스터 (Base Register) : (파티션의 시작 주소)       리미트 레지스터 (Limit Register) : (파티션의 크기)                 현재 프로그램이 파티션에 로드되었을 때, 프로그램이 로드된 파티션의 크기를 리미트 레지스터의 값에 저장   CPU는 메인 메모리에서 주소가 사용 가능한지 여부를 생각하지 않고, 명시된 그대로 물리 주소를 사용하려고 함   CPU가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더해 수행 (Relocation)   CPU가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소가 리미트 레지스터의 값과 동일하거나 큰지 확인 (Protection)            O : 프로텍션 바이오레이션 (Protection Violation) 발생시켜 메모리 참조를 중단       X : 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더한 값을 메모리 버스에 보냄              Q. 그럼 베이스 레지스터 &amp; 리미트 레지스터를 사용하면 이젠 더 이상 문제가 없는걸까?         모든 메모리 참조마다 덧셈과 비교 연산이 요구되기에, 비교적 시간이 오래 걸림 : 특히 덧셈 연산이!                블로트웨어 (Bloatware) : 메모리의 크기를 증가하는 속도를 소프트웨어의 크기가 증가하는 속도가 역전                             정적 메모리 파티션 (Fixed memory partitions) : 메모리를 파티션 여러 개로 미리 나누고 프로세스 할당                Multiple input Queues : 도착한 작업을 크기에 맞는 가장 작은 파티션에 넣음         Single input Queue : 도착한 작업을 수용할 큐를 하나만 배정, 먼저 도착한 작업을 먼저 실행시킴                             정적 메모리 파티션은 메모리가 시스템이 구동할 모든 프로세스를 적재 가능한 용량을 가져야 성립하나,             시스템이 구동할 모든 프로세스들이 필요한 메모리의 전체 크기는 실제 RAM 용량보다 크다.       프로그램이 시작하기 전에 이미 실행 중인 프로세스들이 적재되어 있다.            … 모든 프로세스들을 계속 적재하기엔, 물리 메모리 크기에 한계가 있다는 문제에 대해, 2가지 해결책이 제시되었다.         Swapping : 한 프로세스의 전체 이미지가 메모리로 적재되어 실행되다가 실행되지 않으면 디스크로 이동     Virtual Memory : 한 프로세스의 전체 이미지가 아닌 일부만 메모리에 있어도 프로세스의 실행이 가능      스와핑 (Swapping) : 메모리에 로드된 프로세스 중에 장기간 미사용된 것을 하드 디스크에 이미지 형태로 저장     프로세스 이미지 (Process Image) : 프로그램이 메모리에 로드되고 실행되어 데이터가 변경된 프로세스            하드 디스크에 존재하는 .exe, .app에 데이터가 변경되었기에 이를 하드 디스크의 backing store에 저장                    swap-out : 메인 메모리 -&gt; Backing store           swap-in : Backing store -&gt; 메인 메모리                                 … backing store는 메인 메모리의 모든 프로세스가 swap-out될 때 데어터의 소실 없이 저장할 수 있어야 한다.         그러므로, 하드 디스크에서 backing store이 할당받는 크기는 최소 메인 메모리의 크기라 예상할 수 있다.            (a) 각 프로그램의 데이터 세그먼트가 늘어날 공간을 미리 확보   (b) 각 프로그램의 세그먼트를 프로그램 텍스트 / 데이터 세그먼트 / 스택 세그먼트로 나눔            프로그램 텍스 위의 데이터 세그먼트와 스택 세그먼트가 서로를 향해 자라게끔 함                    힙 (Heap) 영역 (Room for growth) : 사용자가 동적으로 할당할 영역                            malloc, calloc 등의 명령어로 관리                                                   동적 메모리 파티션 (Dynamic memory partitions) : 프로그램이 메모리에 로드될 때마다 파티션을 나누고 할당     운영체제가 동적으로 할당된 프로세스를 관리 : 힙 영역이 커지므로, 프로세스의 확장을 위한 공간이 할당되어야 함         (b) Bit Maps 사용 : 맵에 X비트를 관장할 Y개의 할당 단위 (allocation unit)            단위 유닛이 메모리에 할당되어 있으면 유닛의 값을 1, 할당되어 있지 않으면 0 (flag bit)                   할당 단위가 작아지면? : 유닛의 개수 Y가 커진다.                Y를 표현할 flag bit가 많이 필요하므로, 맵의 크기가 커져 맵을 탐색할 때의 성능이 저하된다.                 할당 단위가 커지면? : 유닛의 개수 Y가 작아진다.                Y를 표현할 flag bit가 적게 필요하므로, 비트맵의 공간이 작아진다.         마지막 프로세스에 빈 공간 역시 커져 더 많은 메모리 공간이 낭비될 가능성이 있다.                   … Bit Maps의 문제점 : 프로세스가 k개의 할당 단위를 요구할 때, 맵에서 k개의 0비트를 연속해서 찾아야 한다.       (c) Linked Lists 사용 : 메모리의 낮은 주소부터 링크드 리스트의 노드가 있음            각 엔트리는 P (프로세스) or H (홀)을 표현하는 flag, 시작 주소, 길이, 다음 엔트리를 가리키는 포인터로 구성                   프로세스 종료 시 Linked Lists를 업데이트하는 방법                종료되는 프로세스는 일반적으로 2개의 이웃을 가짐 → 이웃은 다른 프로세스가 차지한 공간이거나 빈 공간                             (a) X에 해당되는 엔트리를 X에서 H로 바꿔 갱신     (b), (c) 2개의 엔트리를 통합해 하나로 표현     (d) 3개의 엔트리를 통합해 하나로 표현      Contiguous Memory Allocation : 메모리에 새로 생성된 프로세스들을 위한 메모리 공간 할당     메모리 단편화 (Memory fragmentation) : 메인 메모리에 흩어진 홀들이 불연속적으로 할당된 상태            프로세스 생성 &amp; 종료 반복 → scattered holes       홀 (Hole) : 메인 메모리에서 프로세스가 할당되지 않은 영역           외부 단편화 (External fragmentation) : 프로세스를 할당할 크기가 충분하나, 메모리 단편화로 할당이 불가능한 상태         First-fit : 프로세스 크기보다 크거나 같은 홀을 탐색하는 순서 중에서 가장 먼저 찾은 홀에 프로세스 할당         Best-fit : 할당할 프로세스 크기와 홀의 크기 차이가 가장 작은 홀에 프로세스 할당         Worst-fit : 할당할 프로세스 크기와 홀의 크기 차이가 가장 큰 홀에 프로세스 할당            Best-fit을 사용하였다가 다른 프로세스가 쓰지 못할 정도의 홀이 생겼을 때를 위한 대안                 Compaction : 메모리 여러 곳에 흩어져있는 홀들을 강제로 하나로 병합            홀을 옮기는 오버헤드가 매우 크고, 어느 홀을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않음              일반적으로 할당 속도는 First-fit가 가장 빠르며, 메모리 이용률은 First-fit와 Best-fit이 비슷하다.         하지만 Best-fit을 사용하더라도, 외부 단편화로 인해 여전히 전체 메모리의 1/3 정도를 낭비한다.      페이징 (Paging) : 프로그램과 메모리를 일정한 크기로 나눔     가상 주소 (Virtual address) : 프로그램이 가상 메모리에서 참조하는 주소            가상 메모리 (Virtual Memory)가 있다면, 각 프로그램은 자신의 고유한 가상 주소 공간을 가짐                    가상 메모리 사용 O : 가상 주소가 그대로 메모리 버스에 실려 물리 주소가 됨           가상 메모리 사용 X : 가상 주소가 MMU에 의해 물리 주소로 매핑                                 가상 주소 공간과 물리 주소 공간은 고정된 크기 단위의 유닛들로 동일하게 나뉜다.            가상 페이지 (Virtual Page) : 가상 주소 공간을 나눈 조각. 각 페이지는 연속된 주소를 가짐       페이지 프레임 (Page Frame) : 물리 메모리를 나눈 조각.                   다음 그림에서는 가상 주소 공간을 64KB, 물리 메모리 공간을 32KB, 유닛 크기는 4KB로 가정하고 있다.                논리 주소 (logical address) : 세그먼트 (segment) + 오프셋 (offset)                세그먼트 (segment) : 64KB의 고정된 길이와 시작 위치으로만 구성         오프셋 (offset) : 세그먼트의 시작 지점에서 실제 주소까지 떨어진 거리                 가상 주소 (virtual address) : single 32-bit unsigned integer                가상 페이지는 16진수로 표현 (16bit) : 0x00000000 ~ 0xffffffff의 범위 (4096bit=4KB)                 물리 주소 (physical address) : 물리 메모리에서 각각의 셀 (cell)의 주소                페이지 프레임은 가상 페이지가 매핑되는 물리 메모리의 일부분(4096bit=4KB)                        명령어 MOV REG, 0을 수행한다고 가정해보자.             이 명령어에서 접근하는 가상 주소 0는 MMU로 전달된다.       MMU는 해당 가상 주소가 가상 페이지 0에 속한 것임을 확인한다.       MMU는 가상 페이지 0에 매핑된 물리 주소의 페이지 프레임이 2임을 계산한다.       가상 주소 0은 물리 주소 8192로 변환되고, 이 물리 주소가 메모리 버스에 실린다.            … 가상 페이지를 페이지 프레임에 매핑하는 것만으론, 가상 주소 공간이 물리 주소 공간보다 큰 문제를 해결하지 못한다.    페이지 폴트 (Page Fault) : 페이지가 메모리에 매핑되어 있지 않음을 파악하면 CPU에서 트랩 발생     present 비트 : 어떤 페이지가 실제 메모리에 존재하는지 표현하는 비트 (가상 페이지에 X로 표현)            페이지가 메모리에 매핑되어 있지 않으면, CPU에서 트랩을 발생시켜 운영체제에 이를 알림           Page Fault가 발생하면, 운영체제는 적게 사용되고 있는 페이지 프레임을 하나 선택            선택한 페이지가 수정되었다면 (dirty 상태) 이를 디스크에 기록       선택한 페이지가 수정되지 않았다면 (clean 상태) 디스크에 존재하는 것과 동일하니 기록하지 않음       선택한 기존 페이지의 내용을 지우고, 참조하려는 페이지의 내용을 페이지 프레임에 적재       선택한 기존 페이지 프레임을 X로, 참조한 페이지 프레임을 숫자로 매핑시켜 가상 페이지 맵 수정       트랩이 발생한 명령어를 다시 실행              명령어 MOV REG, 24576을 수행할 때 Page Fault가 발생해 OS에서 페이지 프레임 1을 교체한다고 가정해보자.         가상 페이지 1이 더 이상 매핑되지 않음 (X)을 표시한다.     가상 페이지 7이 페이지 프레임 1에 매핑되었음을 표시한다.      페이징 테이블 (Page Table) : 가상 페이지 번호 (VPN)를 페이지 프레임 번호 (PFN)로 매핑      위의 매핑 정보를 바탕으로 가상 주소 8196를 물리 주소 24580로 변환하는 과정을 가정해 살펴보자.               16비트 크기를 갖는 가상 주소는 VPN와 오프셋으로 구분된다.                페이지 번호는 페이지 테이블의 인덱스로 사용된다.                 페이지 테이블에는 VPN에 대응되는 PFN이 기록되어 있다.                present가 1이면, 페이지 테이블의 PFN 3과 가상 주소의 오프셋 12가 결합해 물리 주소가 된다.                 물리 주소를 주소 출력 레지스터를 통해 메모리 버스로 전달해 참조한다.              페이지 테이블엔 디스크에 존재하는 페이지의 디스크 주소에 대한 정보가 없음 (Page Fault : 운영체제 내부에서 처리)            메모리에 존재하는 페이지 주소에 대한 정보만 존재 : 하드웨어가 가상 주소를 물리 주소로 변경할 때 사용                 페이지 테이블의 각 페이지에 존재하는 정보            페이지 프레임 번호 (PFN) : 가상 주소를 물리 주소로 매핑                    해당 페이지가 매핑된 물리 주소 결정                       Present 비트 : PFN이 유효한지 아닌지 결정 (가상 주소가 사용될 때마다 확인)                    0 (X)이면 해당 엔트리에 대응되는 페이지가 물리 메모리에 존재하지 않는 상태 (트랩 발생)                       Protection 비트 : 어떤 접근이 허용되는지 표시                    write, read, execute                       Modify 비트 : 페이지가 수정되었는지 아닌지 확인                    페이지의 내용이 write되면, 하드웨어가 자동으로 비트를 1로 세팅                            Modify 비트가 1 (dirty)이면, 페이지 프레임이 교체될 때 디스크에 기록되어야 함               Modify 비트가 0 (clean)이면, 페이지 프레임이 교체될 때 새로운 내용으로 덮어씌워도 됨                                               Reference 비트 : 해당 페이지가 write 또는 read로 접근되었을 때 설정                    운영체제가 Page Fault의 처리를 위해 교체할 페이지 프레임을 선택할 때 사용                       Cashing Disabled 비트 : 해당 페이지가 캐싱될 수 있는지 여부                    페이지가 메모리가 아닌 장치 레지스터에 매핑되어 있을 때 실행                                          64bit 주소를 사용하는 컴퓨터는 가상 주소 공간이 2^64byte       가상 주소 공간의 한 페이지가 4KB = 2^12byte이면,                    페이지 테이블의 엔트리 개수는 전체 공간을 한 페이지로 나눈 2^52개           엔트리 하나당 4byte의 크기를 가진다면, 페이지 테이블의 크기는 2^52 * 4byte                            … 페이징은 다음 두 가지 문제를 해결해야 한다.         가상 주소 공간이 커지면, 페이지 테이블의 크기 (= 페이지 테이블 엔트리의 개수) 또한 증가한다.                페이지 테이블을 유지하기 위해 필요한 메모리의 크기가 클 수 있음                 가상 주소에서 물리 주소로의 변환이 빠르게 이루어져야 한다.                메모리를 참조하는 오버헤드가 작아야 함                  TLBs (Translation Lookaside Buffers) : 페이징의 속도를 높이고, 큰 가상 주소 공간을 지원하는 기법      대부분의 프로그램들은 적은 개수의 페이지를 집중적으로 참조하는 경향이 있다.         페이지 테이블의 일부 엔트리만이 높은 빈도로 참조되고, 나머지 엔트리는 낮은 빈도로 참조된다.         TLB : 페이지 테이블의 참조 없이 가상 주소를 물리 주소로 매핑할 수 있는 작은 크기의 메모리            MMU 내부에 존재하며, 적은 개수의 엔트리를 가짐                    각각의 TLB 엔트리는 한 페이지에 대한 정보를 포함                                        MMU는 주소 변환을 할 때 요청된 가상 페이지가 TLB에 있는지 검색     가상 페이지가 존재하고 보호코드를 위반하지 않으면, 대응되는 페이지 프레임을 사용하여 주소 변환을 실행     TLB가 존재하지 않으면, TLB miss 발생. MMU는 페이지 테이블에서 해당 페이지 테이블 엔트리를 검색     그리고 TLB 엔트리 중 하나를 선택해 그 내용을 교체. 페이지 테이블에 없는 수정 비트는 페이지 테이블에 기록     찾은 페이지 테이블 엔트리를 TLB 엔트리에 기록 (이때 다시 참조한다면 TLB hit로 처리)     새로운 정보가 적재될 때는 페이지 테이블 엔트리에 있는 내용이 적재         메모리 계층 구조에서 발생할 수 있는 miss의 경우의 수 : 2^3가지 -&gt; 실제 발생 가능한 경우의 수 : 5가지      \t   \t\t   \t\t\t  Cache         TLB         Virtual Memory         발생 가능 여부 \t\t\t  설명 \t\t   \t   \t   \t\t   \t\t\t  hit         hit         hit         가능 (최선) \t\t\t  (1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X) (2) Cache가 hit이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 있음 \t\t   \t\t   \t\t\t  miss         hit         hit         가능 \t\t\t  (1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X) (2) Cache가 miss이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 없음 (3) Virtual Memory가 hit이므로, 캐시에 데이터를 불러오기 위해 메모리에 접근하면 데이터를 가져올 수 있음 (4) 메모리에서 캐시로 가져온 데이터를 CPU에 전달 \t\t          \t\t\t  hit         miss         hit         가능 \t\t\t  (1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O) (2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환 (3) Cache가 hit이므로, 변환한 물리 주소로 캐시에 접근해 캐시에 있는 데이터를 CPU에 전달 \t\t          \t\t\t  miss         miss         hit         가능 \t\t\t  (1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O) (2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환 (3) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음 (4) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달 \t\t          \t\t\t  miss         miss         miss         가능 (최악) \t\t\t  (1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O) (2) Virtual Memory가 miss이므로 (Page fault), 하드 디스크에서 데이터를 직접 가져와 페이지 테이블을 업데이트 (3) 이제 TLB가 miss &gt; hit이므로, 가상 주소를 물리 주소로 변환 가능. (4) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음 (5) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달 \t\t          \t\t\t  miss         hit         miss         불가능 \t\t\t  메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음 \t\t          \t\t\t  hit         hit         miss         불가능 \t\t\t  메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음 \t\t          \t\t\t  hit         miss         miss         불가능 \t\t\t  메모리 계층 구조 위반 : Page fault인데 Cache가 hit일 수 없음 (캐시에 데이터가 있을 수 없음) \t\t   \t                TLB miss인 경우 : 페이지 테이블에는 정보가 있지만, TLB에 그 정보가 들어있지 않을 때                해결책 : 페이지 테이블의 페이지 엔트리 내 데이터를 가져와 TLB에 넣음                 Page fault인 경우 : TLB에도 정보가 없고, 페이지 테이블에도 그 정보가 없을 때                운영체제는 권한을 받아 하드 디스크의 데이터를 페이지 테이블에 가져오고, TLB에 가져온 데이터를 넣음                  다단계 페이지 테이블 (Multi-level Page Table)     페이지 테이블을 페이지 프레임 크기로 나눔            해당 페이지 테이블의 페이지가 invalid하면 메모리에 할당하지 않음       기존의 단일한 페이지 테이블을 트리 구조로 연결           페이지 디렉토리 (Page Dictionary) : 페이지 프레임의 유무를 확인하는 자료구조            적어도 하나의 PFN이 valid하다면, 페이지 디렉토리의 해당 엔트리는 존재함                        기존의 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있음     다단계 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있지 않음       다단계 페이지 테이블에서의 모든 페이지 테이블은 항상 메모리에 유지될 필요가 없다.          필요한 페이지 테이블만 메모리에 할당해 절약할 수 있음   페이지 디렉토리로 물리 메모리의 빈 공간에 페이지 테이블 엔트리를 생성 가능   기존의 TLB Miss가 2번 늘어나 주소 변환이 2번 필요하고, TLB Miss를 처리해 메모리를 최적화하는 로직이 복잡해짐   역 페이지 테이블 (Inverted Page Table)     빠른 하드웨어 레지스터로 구성된 단일한 페이지 테이블 사용            페이지 테이블의 각 엔트리는 하나의 메모리 프레임에 대응           크기가 고정된 페이지 테이블에 프로세스를 맵핑            프로세스 실행 시 운영체제는 메모리에 존재하는 프로세스의 페이지 테이블 전체를 하드웨어 레지스터 배열에 적재           논리 주소는 PID, PFN, offset으로 구성   물리 주소는 MFN와 offset으로 구성         논리 주소의 PID와 PFN 정보를 바탕으로 페이지 테이블에서 동일한 엔트리 탐색   페이지 테이블에서 PID와 PFN가 일치하는 (MFN)번째 항목을 발견   MFN과 Offset 정보를 바탕으로 확인된 메모리 주소에 접근           64bit를 사용하는 컴퓨터에서 256MB의 물리 메모리가 4KB 페이지 프레임 2^18개로 구성되었다면,                페이지 테이블을 사용할 때의 페이지 테이블의 엔트리는,                        가상 주소 공간 2^64byte을 한 페이지 프레임의 크기 4KB = 2^12byte로 나눈 2^52개                             역 페이지 테이블을 사용하는 페이지 테이블의 엔트리는 물리 메모리의 페이지 프레임의 개수와 같으므로,                        물리 메모리 256MB = 2^28byte를 한 페이지 프레임의 크기 4KB = 2^12byte로 나눈 2^16개                                         프로세스 실행 중엔 페이지 테이블을 위한 추가적인 메모리 참조가 필요 없음 (프로세스 확장이 페이지 테이블과 무관)   페이지 테이블이 커질수록 구현을 위한 비용이 증가하고, 최악의 경우 페이지 테이블 전체를 적재해야 함 ex) 문맥 교환   페이지 교체 알고리즘 (Page Replacement Algorithm) : 페이지 폴트 시 교체할 페이지 선택     교체한 페이지가 다시 필요해져 페이지 폴트가 발생하는 비율을 줄여야 함 : 자주 사용되지 않을 페이지를 선택해야 함            제거할 페이지 중 최고의 페이지는 가장 긴 시간동안 접근하지 않을 페이지           최적 페이지 교체 알고리즘 (Optimal Page Replacement Algorithm) : 가장 사용하지 않을 페이지 교체     운영체제가 모든 페이지 참조를 수집했다고 가정하면, 각 페이지들이 몇개의 명령어 뒤에 처음으로 참조되는지 알 수 있음   그 중 가장 많은 명령어 뒤에 참조되는 페이지를 교체      페이지 폴트가 발생했을 때, 운영체제가 각 페이지들이 어느 시점에 참조되는지 알 수 없음         프로세스를 처음 돌린 뒤에 수집된 정보를 바탕으로 사용 가능      NRU (Not Recently Used) 페이지 교체 알고리즘 : 최근에 사용되지 않은 페이지 교체     가상 메모리를 지원할 때, 각 페이지마다 운영체제가 페이지 사용 정보를 수집하기 위한 2개의 상태 비트를 유지            R (Reference 비트) : 페이지가 참조될 때마다 설정 (read/write)       M (Modify 비트) : 페이지가 수정될 때 마다 설정 (clean/dirty)           최근에 참조되지 않은 페이지를 참조된 페이지와 구별하기 위해 주기적으로 (clock tick마다) R비트를 0으로 초기화   페이지를 4개의 클래스로 분류            클래스 0 : R = 0, M = 0       클래스 1 : R = 0, M = 1       클래스 2 : R = 1, M = 0       클래스 3 : R = 1, M = 1           페이지 폴트가 발생했을 때, 낮은 클래스에 있는 페이지 중 하나를 랜덤으로 교체            참조도, 수정도 안된 클래스 3에 속한 페이지가 있으면 내쫓고,       없으면 최소 한 사이클에서 참조되지 않은 클래스 2에 속한 페이지가 있으면 내쫓고,       없으면 자주 참조되지만 수정되지 않은 클래스 1에 속한 페이지가 있으면 내쫓고,       없으면 참조도, 수정도 이루어진 클래스 0에 속한 페이지가 있으면 내쫓는다.              가장 최근에 참조되지 않은, 변경된 페이지의 교체가 집중적으로 참조된, 변경되지 않은 페이지의 교체보다 좋음    FIFO 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지 교체     메모리에 페이지들이 들어온 순서대로 링크드 리스트를 sorting   페이지 폴트가 발생하면, 맨 앞에 들어온 것을 교체           메모리에 오래 있던 페이지가 자주 사용되는 페이지일 수 있음                 벨레이디의 모순 (Belady's anomaly) : 페이지 프레임이 늘어나면, 페이지 폴트의 개수가 오히려 느는 경우           Second-Chance 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지의 R을 검사한 후 교체     메모리에 페이지들이 들어온 순서대로 링크드 리스트를 sorting   페이지 폴트가 발생하면, 가장 오래된 페이지의 R을 검사            R = 0이면, 이 페이지는 최근에 사용되지 않은 페이지이므로 교체해도 됨       R = 1이면, 이 페이지를 맨 뒤로 옮기고, R를 0으로 초기화 (적재 시간도 현재시간으로 갱신)하고 다시 검사              자주 참조되는 페이지를 교체할 가능성이 있는 FIFO를 개선         하지만, 페이지를 리스트 맨 뒤로 이동시켜아 하기 때문에 동작의 효율성이 떨어질 수 있음      Clock 페이지 교체 알고리즘 : 시계 모양 원형 리스트를 구성하고, 화살표가 가리킨 페이지의 R을 검사     메모리에 페이지들이 들어온 순서대로 원형 리스트를 sorting   페이지 폴트가 발생하면, 화살표가 가리키는 페이지의 R을 검사            R = 0이면, 최근에 사용되지 않은 페이지이므로, 새로운 페이지 삽입 후 화살표를 다음 페이지로 이동       R = 1이면, 이 페이지의 R를 0으로 초기화하고 그 다음 페이지를 검사              LRU 페이지 교체 알고리즘 : 가장 오랫동안 사용되지 않은 페이지를 교체     메모리에 페이지들이 들어온 순서대로 링크드 리스트를 sorting            가장 최근에 사용된 것을 리스트의 맨 앞에, 가장 오래된 것을 리스트의 맨 뒤에 오게끔 배치           페이지 폴트가 발생하면, 가장 맨뒤에 있는 페이지를 추출      모든 메모리의 참조마다 리스트를 갱신해야 함 : 리스트에서 페이지를 탐색, 삭제, 이동하는 작업은 오래 걸림    LRU의 하드웨어 구현 1 : 64bit 카운터     카운터가 명령을 실행할 때마다 C값을 1씩 증가   각 페이지 테이블 엔트리는 카운터 값을 저장할 수 있는 공간을 가짐   메모리가 참조될 때마다 참조된 메모리를 담고 있는 페이지를 가리키는 페이지 테이블 엔트리에 C값 저장   페이지 폴트가 발생하면, 모든 페이지 테이블 엔트리의 C값을 조사해 가장 적은 값을 갖는 페이지를 교체      LRU의 하드웨어 구현 2 : N*N bit로 구성된 행렬을 갖는 LRU 하드웨어     N개의 페이지 프레임 -&gt; N*N bit로 구성된 행렬 : 행렬의 모든 값의 초기값은 0   페이지 프레임 k가 참조되면, LRU 하드웨어는            행렬에서 k번째 행의 모든 비트를 1로 설정       k번째 열의 모든 비트를 0으로 설정           행의 이진 값이 가장 작은 행에 대응되는 페이지 프레임이 가장 과거에 참조된 것           페이지가 0,1,2,3,2,1,0,3,2,3 순으로 참조되었다고 가정하자.         일단 1행을 모두 1로 0열을 0으로 초기화     1행을 모두 1로, 1열을 모두 0으로 초기화     페이지 폴트가 발생하면, 행 값이 제일 낮은 프레임을 교체                만약 그림 j에서 페이지 폴트가 발생하였으면, 2행이 가장 낮으므로 프레임 2를 교체                  LRU의 소프트웨어 구현 1 : NFU (Not Frequently Used)     각 페이지마다 각 페이지들이 얼마나 자주 참조되었는지 알려줄 소프트웨어 카운터를 유지 (카운터의 초기값은 0)   클록 인터럽트가 발생할 때마다 운영체제는 메모리의 모든 페이지를 검사하여 R의 값을 소프트웨어 카운터에 더함   페이지 폴트가 발생하면, 가장 적은 카운터 값을 갖는 페이지가 교체      NFU에는 잊어버리는 기능이 부재되어 있다.         다중 패스 컴파일러의 경우 : 패스 1에서 자주 참조된 페이지들은 높은 카운터 값을 가짐, 이는 패스 2에서도 유지     만일 패스 1이 그 이후 다른 패스들보다 더 긴 실행 시간을 가진다면 혹은 패스 1에서 더 많은 참조가 일어난다면, 패스 1에서 실행된 페이지들은 그 이후 패스에서 사용되는 페이지들에 비해 더 큰 카운터 값을 가짐                그러므로 패스 1에 사용되던 페이지 대신 현재 패스에 사용하는 유용한 페이지들을 교체                  LRU의 소프트웨어 구현 2 : 에이징 (Aging)     NFU를 기반으로, 다음의 사항을 변경한다.            R를 더하기 전에 오른쪽으로 1비트 시프트한다.       R는 오른쪽 비트가 아닌 왼쪽 최상위 비트에 추가된다.                       시간 순서를 구별할 정보를 기록                LRU : 오직 하나의 비트로 참조 여부만 기록해, 페이지 3, 5 중 어떤 페이지가 더 먼저 참조되었는지 모름         에이징 : 시간 순서를 구별할 정보를 기록해, 2번의 클록 틱 전에 1번 더 참조된 페이지 5 대신 3 교체                 과거에 대한 정보를 제한                NFU : 과거에 대한 정보를 모두 기억해 10번째 전에 참조되었는지, 100번 전에 참조되었는지 알 수 없다.         에이징 : 최대 N번 전에 정보를 기록할 N비트만이 존재해, 과거에 대한 정보를 제한된다.                  워킹 세트 알고리즘 (The Working Set Page Replacement Algorithm) : 페이지 집합 관리           스레싱 (Thrashing) : 멀티 프로그래밍의 정도가 높아 페이지 폴트가 계속 발생해 페이지 교체 시간이 길어짐                멀티 프로그래밍의 정도가 높은 경우 : 여러 프로세스로 인해 프로세스가 충분한 페이지를 가지지 못함                        어느 순간부터 CPU 점유율이 하락 (프로세스는 스와핑하느라 바쁜데, CPU는 아무것도 안한다.)                                                 Demand Paging : 실제로 필요할 때 (요청이 있으면) 그 page를 메모리에 올린다.                프로세스가 시작될 때 메모리에는 어떤 페이지도 존재하지 않음         CPU가 첫 명령어를 fetch하면 페이지 폴트를 통해 운영체제가 로드                 참조의 지역성 (Locality of reference) : 프로세스는 작은 페이지만을 집중적으로 참조하는 경향이 있음                locality set : 집중적으로 참조되는 해당 페이지의 집합                     워킹 세트 (Working Set) W(K, T) : 프로세스가 현재 사용하고 있는 페이지의 집합            워킹 세트의 locality set : 프로세스가 일정 시간 원활히 수행되기 위해 한번에 올라와야 하는 페이지들의 집합              워킹 세트를 (시간 T)에 대해, 가장 최근에 (횟수 K번) 발생한 메모리 참조에 의해 사용된 페이지의 집합이면,         뒤의 페이지가 앞의 페이지를 포함하니 K를 늘리수록 커지다가, (가상 페이지의 개수가 한정되어) 한 곳에 수렴              워킹 세트 모델 (Working Set)            PrePaging : 각 프로세스의 워킹 세트를 추적하다, 프로세스가 실행되기 전 그 프로세스의 워킹 세트 미리 로드       주기적인 인터럽트가 R을 일정 시간마다 초기화       페이지 폴트가 발생하면, 페이지 테이블을 스캔해서 쫓아낼 페이지를 탐색       해당 프로세스의 워킹 세트 전체를 한꺼번에 메모리에 올라갈 수 있는 경우에만 메모리에 할당                    그렇지 않을 경우, 모든 페이지 프레임들을 모두 반납시키고 디스크로 swap-out (스레싱 방지)                              워킹 세트 윈도우 (Working Set Window) : 올라올 워킹 세트를 결정 (워킹 세트 윈도우의 크기 : T)            페이지가 참조된 시점부터 T 시간 동안 메모리에 유지하고, 그 시점이 지나면 메모리에서 지움           메모리에 있는 프로세스들의 워킹 세트 크기의 합이 페이지 프레임의 수보다 클 경우 : 일부 프로세스를 swap-out            남은 프로세스의 워킹 세트가 메모리에 모두 올라가게 해 이를 우선적으로 충족 (멀티프로그래밍의 정도를 줄임)           워킹 세트를 모두 할당한 후에도 페이지 프레임이 남으면, swap-out된 프로세스를 메모리에 올려 워킹 세트 재할당           현재 가상 시간 (Current virtual time) : 프로세스가 시작된 후에 CPU를 실제 사용한 시간     마지막으로 사용한 시간 (Time of last use)                 페이지의 현재 가상 시간이 2204일 때 페이지 폴트가 발생하면,                페이지 테이블을 모두 스캔하면서 R을 체크한다.         R = 1 : 마지막으로 페이지를 사용한 시간을 현재 가상 시간으로 바꾼다.         R = 0 : age = (현재 가상 시간 - 마지막으로 페이지를 사용한 시간)와 T 비교                        age &gt; T : 워킹 세트에 그 페이지가 포함되어 있지 않으므로, 그 페이지를 지우고 게속 스캔한다.             age &lt;= T : 가장 큰 age를 만드는 페이지를 기억하고 계속 스캔한다.                             마지막까지 스캔했을 때 (모든 엔트리가 age &lt;= T이면), 가장 큰 age를 만드는 페이지를 지운다.         모든 엔트리가 R = 1이면 (가장 큰 age를 만드는 페이지를 모른다면), 한 페이지를 랜덤으로 지운다.                  세그멘테이션 (Segmentation) : 하나의 가상 주소를 제공하는 페이징과 달리, 여러 개의 가상 주소 제공     프로세스를 논리적 내용을 기반으로 나누어서 메모리에 배치            세그멘테이션 기법에서의 프로세스는 세그멘트 (segment)의 집합                    각 세그먼트는 자기만의 선형적인 주소 공간을 가짐                       페이징 기법에서는 주소 공간이 서로 충돌될 수 있지만, 세그멘테이션에서는 동적으로 테이블이 커지거나 줄어듬              세그먼트 테이블 : 각 엔트리의 논리 주소는 &lt;segment-number, offset&gt;            페이징과 달리 세그먼트의 크기는 일정하지 않기에 테이블에 limit 정보가 추가로 담겨 있음       만약 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 프로세스가 강제 종료                        논리 주소 (2, 100) : 물리 주소 4400번지     논리 주소 (1, 500) : 인터럽트로 인해 프로세스가 강제로 종료 (범위 벗어남)         세그멘테이션의 장점            보호 : 세그먼테이션도 페이징처럼 r, w, x를 테이블에 추가하는데, 프로세스를 논리적으로 나눠 비트 설정 간단       공유 : 세그먼테이션은 정확히 code 영역만 나누기에 다른 영역을 포함할 확률이 높은 페이징보다 더 효율적              …하지만 세그멘테이션은 외부 단편화 문제를 해결하지 못해, 현재는 페이징 기법을 대부분 사용한다.          외부 단편화 : 메모리 할당을 처음 시작할 때 크기가 서로 다른 프로세스로 인해 다양한 크기의 홀이 발생 (checkerboarding)                세그먼트를 논리적인 단위로 나눈 세그멘테이션 역시 외부 단편화로 인해 메모리 낭비가 큼                 세그멘테이션을 페이징 (Paged segmentation) : 펜티엄 (Pentium)                cs, ds, ss를 각각의 세그먼트가 아닌 하나의 주소 공간으로 통일해서 사용                        그러므로 cs, ds, ss는 다 같은 셀렉터 값을 가짐                             세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 2번                        CPU의 세그먼트 테이블에서 주소 변환, 그리고 다음 페이지 테이블에서 주소 변환                                     ","categories": [],
        "tags": ["Computer Science"],
        "url": "/os1/",
        "teaser": null
      },{
        "title": "[Docker] 1. Virtualization",
        "excerpt":"가상화 (Virtualization) : 컴퓨터 자원 (Computer Resource)의 추상화      하드웨어 종속성 배제 : 물리적인 하드웨어 자원을 논리적인 단위로 나누고 이를 통합해 가상의 자원을 활용   리소스 가상화 (Resource Virtualization) : 컴퓨터 내 특정 자원만을 추상화     (가상의) 메인 메모리 : 가상 메모리 (Virtual Memory)   (가상의) 저장 장치 : 클라우드 (Cloud)   (가상의) 그래픽 카드 : vGPU   (가상의) 네트워크 : 가상 사설 네트워크 (Virtual Personal Network)   플랫폼 가상화 (Platform Virtualization) : 여러 개의 프로세스을 구동할 수 있는 플랫폼을 추상화     에뮬레이션 (Emulation) : 다른 컴퓨터 프로세서를 위해 쓰인 운영체제와 응용 프로그램을 실행   하드웨어 수준 가상화 (H/W-level Virtualization) : 하드웨어 플랫폼 위의 하이퍼바이저를 통해 가상 머신을 관리함        운영체제 수준 가상화 (O/S-level Virtualization) : 운영체제의 커널이 각각의 격리된 프로세스를 동작시킴            에뮬레이터 (Emulator) : 모든 하드웨어 자원의 동작을 소프트웨어로 대체             애뮬레이터 안의 응용 프로그램은 물리 하드웨어가 아닌 인터프리터 프로그램을 통해 실행 (JVM)                    인터프리터 프로그램은 가상 머신에서 명령을 수행할 때마다 물리 CPU가 처리할 바이너리 코드 갱신           물리 CPU는 에뮬레이터를 실행하기 위한 바이너리 코드를 해석해 이를 대신 실행                       장점 : 아키텍쳐가 전혀 다른 하드웨어 역시 가상화할 수 있음 (vs 하이퍼바이저 : 가상화할 수 없음)       단점 : 물리 CPU 내에서 직접 실행할 때보다 비효율적임                하이퍼바이저 (Hypervisor) : 다수의 가상 머신을 생성, 실행, 제어하는 논리적 플랫폼으로써의 프로세스             하이퍼바이저 안의 응용 프로그램은 물리 하드웨어를 하이퍼바이저에 의해 제한적으로 사용                하드웨어 가상 머신 (H/W Virtual Machine) : 하이퍼바이저에 의해 생성된 가상 환경                        Type 1. 호스팅 (Hosting) : 하이퍼바이저가 일반 프로그램과 같이 운영체제의 소프트웨어 계층에서 실행                     장점 : 가상의 하드웨어를 구동하기에 호스트 운영 체제에 큰 제약이 없음           단점 : 호스트 위에 게스트를 구동하는 방식이기에 비교적 큰 오버헤드 가짐 / GPU Passthrough 미지원                                Type 2. 네이티브 (Native) : 하이퍼바이저를 하드웨어에 직접 임베디드되어 실행                     장점 : 별도의 호스트가 없어 오버헤드가 적음 / 하드웨어를 직접 제어하기에 효율적인 자원 사용 가능           단점 : 자체적인 가상 머신에 대한 관리 기능이 없기에, 이를 위한 별도의 컴퓨터나 콘솔이 필요                        전가상화 (Full-Virtualization) : 하이퍼바이저에서 명령을 번역                             게스트가 요청한 명령은 하이퍼바이저가 실행한 관리용 가상 머신 DOM을 통해 하드웨어에 접근               하이퍼바이저가 각 가상 머신들의 모든 명령을 번역하여 실행하고, 이에 맞게 자원을 할당해야 함                                                반가상화 (Para-Virtualization) : 게스트 가상 머신에서 명령을 번역                             게스트 가상 머신이 하이퍼 콜 (Hyper Call)을 통해 하이퍼바이저에 명령을 직접 요청               게스트 가상 머신의 운영 체제가 하이퍼 콜을 요청할 수 있게 커널을 수정해야 함                                                   컨테이너 (Container) : 소프트웨어 패키지 (Software Package)의 추상화     컨테이너는 프로세스가 동작하는 격리된 사용자 공간 인스턴스            하나의 응용 프로그램과 그 응용 프로그램의 동작을 위한 라이브러리로 구성           운영체제의 커널은 여러 개의 격리된 컨테이너를 갖추어 각각의 개별적인 서버처럼 동작시킴           컨테이너를 사용하는 이유?                가상머신보다 공간을 적게 차지하며, 재가동성 또한 가상머신보다 좋다.         어플리케이선과 동일한 환경 세트로 개발되기에, 테스트에서 프로덕션까지의 이식성 및 일관성에 용이하다.         동적으로 리소스를 사용할 수 있어, 별도의 리소스를 할당할 필요가 없다.         서버의 밀도를 늪일 수 있다. 즉, 서버 내의 리소스를 과다하게 사용하지 않는 선에서 최적화가 가능하다.         하나의 커널에서 동작하기에, 업데이트 및 패치 작업 등을 한번만 수행하면 모든 컨테이너에 적용된다.                          리눅스 컨테이너 (Linux Container) : 리눅스에서 제공하는 운영체제 레벨의 컨테이너 기술             커널 레벨의 격리된 (isolated) 공간만 제공할 뿐, 개발 및 서버 운영에 필요한 부가 기능 부족              운영체제 A에만 가능한 a, 운영체제 B에만 가능한 b, 운영체제 C에만 가능한 c을 동시에 실행한다고 가정한다면,         에뮬레이션 : 응용 프로그램 ×3 ⊂ 에뮬레이트 운영체제 ×3 ⊂ 에뮬레이터 ×3 ⊂ 호스트 운영체제 ⊂ 하드웨어     Type 1. 호스팅 : 응용 프로그램 ×3 ⊂ 게스트 운영체제 ×3 ⊂ 하이퍼바이저 ⊂ 호스트 운영체제 ⊂ 하드웨어     Type 2. 네이티브 &gt; 전가상화 : 응용 프로그램 ×3 ⊂ 게스트 운영체제 ×3 ⊂ DOM ⊂ 하이퍼바이저 ⊂ 하드웨어     Type 2. 네이티브 &gt; 반가상화 : 응용 프로그램 ×3 ⊂ 수정된 게스트 운영체제 ×3 ⊂ 하이퍼바이저 ⊂ 하드웨어     운영체제 수준 가상화 : 컨테이너 프로세스 ×3 ⊂ 컨테이너 관리 소프트웨어 ⊂ 운영체제 ⊂ 하드웨어         Q. MacOS에서 도커로 윈도우 컨테이너를 실행하는 경우엔? : 응용 프로그램을 실행할 때 (O) 운영 체제를 실행할 때 (X)            윈도우 컨테이너 ⊂ 가상 머신 (호스팅) ⊂ 컨테이너 관리 소프트웨어 ⊂ 운영체제 ⊂ 하드웨어          ","categories": [],
        "tags": ["Docker"],
        "url": "/docker1/",
        "teaser": null
      },{
        "title": "[BE] 1. 스프링 (Spring) 기초",
        "excerpt":"   해당 포스트는 김영한의 스프링 입문 로드맵 강의들을 바탕으로 작성되었습니다.     객체지향 프로그래밍 (OOP) : 프로그램을 객체를 단위로 나누어 이들의 상호작용으로 서술하는 방식     캡슐화 (Encapsulation) : 변수와 함수를 하나의 단위로 묶는 것   정보 은닉 (Information Hiding) : 프로그램의 구현을 외부로 드러나지 않게 내부로 감추는 것   상속 (Inheritance) : 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것   다형성 (Polymorphism) : 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석되는 것   객체 지향 5원칙 (SOLID) : 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙      SRP (Single Responsibility Principle) : 객체는 오직 하나의 책임을 가져야 한다.            클래스를 설계할 때 어플리케이션의 경계를 정하고, 추상화로 어플리케이션 내의 속성과 메소드를 설계해야 한다.           OCP (Open Closed Principle) : 객체는 확장에 대해 개방적이고 수정에 대해 폐쇄적이어야 한다.            클래스, 모듈, 함수와 연동할 때는 상위 클래스나 인터페이스를 중간에 두어 직접적인 연동을 피해야 한다.           LSP (Liskov Substitution Principle) : 자식 클래스는 항상 자신의 부모 클래스를 대체할 수 있다.            자식 클래스의 인스턴스는 부모 클래스의 인스턴스 역할을 대신할 때에도 논리적으로 문제가 없어야 한다.           ISP (Interface Segregation Principle) : 클라이언트에서 사용하지 않는 메서드는 사용해선 안 된다.            각 상황에 맞는 메소드만 클래스에게 제공하도록 인터페이스를 작게 나누어 설계해야 한다.           DIP (Dependency Inversion Principle) : 자신보다 변하기 쉬운 것에 의존해선 안된다.            추상성이 높고 고수준의 클래스는 구체적이고 저수준의 클래스에 의존하지 않도록 설계해야 한다.           자바 빈 (Java Bean) : 자바 객체를 재사용 가능하도록 컴포넌트화한 클래스     클래스는 반드시 패키지화되어야 한다.   멤버변수는 프로퍼티라고 부른다.   프로퍼티의 접근 제어자는 private이다.   데이터를 저장하는 필드와 그 데이터를 조작하기 위한 외부에서의 접근은 getter와 setter 메소드로 한다.   프로퍼티가 boolean이면, get가 아닌 is를 사용해도 된다.   public class MemberInfo {   private int id;   private String Name;   private String pw;      public int getId() { return id; }   public void setId(int id) { this.id = id; }   public String getName() { return Name; }   public void setName(String name) { this.Name = name; }   public String getPw() { return pw; }   public void setPw(String pw) { this.pw = pw; } }      ….. 서버 사이드에서 어플리케이선을 개발할 때 자바 빈만으로 해결하지 못하는 문제가 발생한다.          기존 어플리케이션에 필요한 비즈니스 로직만이 아닌, DB와 트랜젝션 처리를 위한 프로그램이 추가로 필요하다.     각각의 어플리케이션 서버에는 독자적인 API이 제공되기에 어플리케이션의 컴포넌트화가 어렵다.      EJB, J2EE : 비즈니스 로직과 시스템 서비스 로직을 분산하고, 로직 간의 규약을 규정     비즈니스 로직을 탑재한 부품을 Enterprise Bean이라 부른다.   DB와 트랙젝션 처리 등의 시스템 서비스를 이용하는 부품을 컨테이너 (Container)라 부른다.   비즈니스 객체들을 관리하는 EJB 컨테이너에서 필요할 때마다 객체를 꺼내는 방식으로 객체들 간의 의존성을 해결한다.   @Stateless public class Service {    @PersistenceContext   private Manager Manager;    public void addCustomer(Customer customer) {     Manager.persist(customer);   } }      ….. EJB는 비즈니스 로직이 특정 EJB 컨테이너에 종속되는 문제가 발생한다. (기술 침투)          EJB 컨테이너를 사용하기 위한 코드 (상속 &amp; 구현)들이 많고, EJB 컨테이너가 없으면 불필요한 코드가 된다.     회사마다 EJB 컨테이너를 구현한 내용이 달라 다른 회사의 EJB 컨테이너로의 변경이 어렵다.      스프링 (spring) : 자바 (JAVA) 기반의 웹 프레임워크 (Web Framework)     순수 자바 객체 (Plain Old Java Object) 방식 : POLO            인터페이스를 직접 구현하거나 상속받지 않아 기존 라이브러리 지원에 용이하고, 코드가 간결하며 객체가 가벼움           관점 지향 프로그래밍 (Aspect Oriented Programming) : AOP            로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리할 수 있음           의존성 주입 (Dependency Injection) : DI            프로그래밍 구성 요소 간 의존 관계를 코드 밖에서 설정을 통해 정의해, 재사용률을 높이고 모듈 간 결합도를 낮춤           제어의 역전 (Inversion of Control) : IoC            객체의 생성부터 소멸까지의 제어권이 프레임워크에게 있어, 외부 라이브러리 코드가 개발자의 코드를 호출           모델-뷰-컨트롤러 (Model-View-Controller) : MVC 패턴            사용자 인터페이스, 데이터 및 논리 제어의 구현에 사용되는 소프트웨어 디자인 패턴           모듈화 디자인 (Modulation) : 한 프레임워크을 여러 기능적 구성요소 (Module)로 조합해 완성            Core : 제어의 역전 (IOC)과 의존성 주입 (DI) 기능 제공       DAO : 자바 데이터베이스 커넥터 (JDBC) 추상 계층 제공 (VO 클래스로 접근)       ORM : ORM이나 데이터베이스 API와의 통합 기능 제공       Web : 웹 어플리케이션 구현과 관련된 기능 제공       JEE : 엔터프라이즈 J2EE 스펙과 관한 기능 제공           스프링부트 (SpringBoot) : 스프링 프레임워크의 기술을 편리하게 사용할 수 있도록 지원     단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성하고 관리            dependencies의 starter 라이브러리로 초기 환경에 필요한 라이브러리 설정 및 버전 관리의 자동화       XML 파일을 자체적으로 빌드하여 스프링 프로젝트 내 객체 의존성 관리의 자동화       톰캣 (Tomcat)과 같은 내장 서버가 존재해 프로젝트 내의 서버 설치 및 버전 관리의 자동화       스프링 외부 라이브러리를 자동으로 구성       매트릭, 상태 확인, 외부 구성과 같은 프로덕션 준비 기능 제공              그레이들 (Gradle) : 그루비 (Groovy) 기반의 스프링부트 빌드 자동화 툴         기존에 사용되던 메이븐 (Maven)과 같은 구조화된 빌드 프레임워크                build.gradle의 dependencies에서 스프링과 스프링부트의 라이브러리 설정 및 버전 관리 자동화                 JAVA만 사용 가능한 메이븐과 달리 C/C++, Python 등의 다양한 언어 지원     XML의 정적인 설정 정보에서 벗어나 도메인 언어인 그루비를 통해 코드로서의 설정 정보 구성      프로젝트 환경설정 : spring initializr에서 스프링부트 View 페이지 제작         빌드 관리 툴 : Gradle   언어 : JAVA   스프링부트 버전 : SNAPSHOT이 아닌 최신 버전   라이브러리 선택 : spring Web (웹), tymeleaf (HTML을 만드는 템플릿 엔진)         .idea : 인텔리제이의 설정 파일이 위치한 디렉토리   gradle : 그레이들의 설정 파일이 위치한 디렉토리   src : 프로젝트가 위치 (main과 test 디렉토리가 분리된 구조가 표준으로 쓰임)            main : Java 패키지와 소스 파일이 위치하는 java / xml, 설정 파일이 위치하는 resources       test : test 코드들과 관련된 소스 파일이 위치                 build.gradle : dependencies에서 스프링과 스프링부트의 라이브러리 설정 및 버전 관리 자동화            plugins : 그레이들에서 사용할 플러그인       group, version, sourceCompatibility : 사전에 설정한 그룹명, 버전, Java 버전       repositories : dependencies의 라이브러리를 가져올 사이트       dependencies : 그레이들에 의해 관리되는 라이브러리           라이브러리 (Library) : API를 바탕으로 플랫폼에서 바로 실행될 수 있도록 모듈화된 프로그램의 집합     혼자서 완전하게 동작하는 것이 아닌 어느 특정한 부분만을 수행하도록 제작 : 기계어나 바이트 코드로 존재 (비휘발성)            자바에서는 라이브러리를 .jar 형태로 배포                   프레임워크 (Framework) : 특정한 문제 해결을 위해 클래스, 라이브러리, 인터페이스를 결합시킨 구조                모듈화 (Modulation) : 재사용 가능한 클래스와 라이브러리들을 그룹 단위로 융합시켜 제공                 프레임워크와 라이브러리의 차이? : 제어의 역전 (IOC)이 발생하는가?         build.gradle의 dependencies에서 그레이들을 통해 라이브러리가 관리되는 것을 확인 가능   // build.gradle  plugins { \tid 'org.springframework.boot' version 'X.X.X' \tid 'io.spring.dependency-management' version 'X.X.X.RELEASE' \tid 'java' }  repositories {  // repositories : 그레이들에 의존성 추가된 라이브러리 다운로드 \tmavenCentral() }  dependencies {  // dependencies : 그레이들에 의존성 추가     implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'      implementation 'org.springframework.boot:spring-boot-starter-web'     testImplementation 'org.springframework.boot:spring-boot-starter-test'     compileOnly('org.springframework.boot:spring-boot-devtools') }      Gradle은 기본적으로 하나의 라이브러리에 관련된, 의존 관계에 있는 라이브러리를 모두 가져옴            왼쪽 탭의 외부 라이브러리를 통해 가져온 모든 라이브러리를 확인 가능       오른쪽 탭의 Gradle를 통해 라이브러리 간의 의존 관계를 확인 가능                 spring-boot-starter 라이브러리 : core, logging, spring boot 등 필요한 모든 의존관계를 가져옴            logging : 로깅을 위한 인터페이스. log4j, logback을 구현체로 가짐 (system.out.~이 아닌 log로 출력)           spring-boot-starter-web 라이브러리 : WAS인 톰캣이 내장되어 있음   spring-boot-starter-test 라이브러리 : JUnit, mockito, assertj 등 테스트 코드를 위한 라이브러리를 가져옴            JUnit : 테스트 프레임워크       mockito : 목 라이브러리       assertj : 테스트 코드의 작성을 돕는 라이브러리       spring-test : 스프링 통합 테스트를 지원           spring-boot-devtools 라이브러리 : 어플리케이션 개발 시 유용한 기능을 제공            Automatic Restart : 브라우저로 전송되는 내용들에 대한 코드가 변경되면, 자동으로 어플리케이션을 재시작                    “고급 설정 &gt; 선택 영역 없이 복사, 잘라내기 액션을 호출하면 현재 줄이 복사, 잘라내기 되지 않습니다” 체크           “빌드, 실행, 배포 &gt; 컴파일러 &gt; 프로젝트 자동으로 빌드 (실행/디버그 중이 아닌 경우에만 작동)” 체크                       Property Defaults : thymeleaf의 Application cache 값을 false로 하여 개발 환경에서 캐싱 비활성화                    application.properties에서 spring.thymeleaf.cache 값을 false                           package hello.hellospring;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class HelloApplication {  \tpublic static void main(String[] args) { \t\tSpringApplication.run(HelloApplication.class, args); \t} }         main.java.project의 클래스를 실행하면, localhost:8080으로 웹 어플리케이션에 접속 가능              gradle를 통해서 아닌, Intellij IDEA로 바로 빌드           빌드 (Build) : 소스 코드를 브라우저에서 실행할 수 있는 하나의 소프트웨어로 변환하는 작업     컴파일, 테스팅, 배포 등의 과정의 집합      어플리케이션 종료 후 다음 명령어로 빌드 : 해당 경로의 lib에 springmvc-0.0.1-SNAPSHOT.jar 파일이 생성    $ ./gradlew build   // 프로젝트 빌드      다음 명령어로 빌드된 파일로 IDE 없이 웹 어플리케이션을 동작    $ java -jar springmvc-0.0.1-SNAPSHOT.jar   MVC : Model, View, Controller로 구분     모델 (Model) : 컨트롤러에서 데이터를 생성해 이를 뷰에 전달 (HaspMap 형태 : key와 value를 저장)   뷰 (View) : 정적 웹 페이지 형식의 html 파일            뷰 리졸버 (View Resolver) : 컨트롤러가 템플릿에 반환한 html 파일을 찾아 브라우저로 전달           컨트롤러 (Controller) : 서버에서 온 요청을 받아 서버 로직을 수행한 후 그 결과를 다시 클라이언트에 전달   정적 웹 페이지 (Static Web Page) : 미리 저장된 파일 그대로 랜더링 과정 없이 전달되는 웹 페이지      일반적으로 .html 형식의 파일들로 저장되었다가 HTTP를 통해 전달            웹 서버는 사용자의 요쳥에 해당되는 웹 페이지를 보냄           스프링부트에 내장 : src.resources.static 패키지에 index.html을 작성하면 첫 화면으로 표현            templates에 접속하려는 파일에 매핑된 컨트롤러가 없으면, src.resources.static 패키지에서 찾아 반환           &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;/body&gt; &lt;/html&gt;         http://localhost:8080에 접속하면 에러 화면이 아닌, 탭 이름이 Title인 빈 화면 표시      동적 웹 페이지 (Dynamic Web Page) : 스크립트에 의해 처리된 후 생성되어 전달되는 웹 페이지      타임리프 (thymeleaf) 템플릿 엔진 : 정적인 HTML에 동적인 기능을 부여       웹 서버는 사용자의 요청을 해석해 데이터를 가공한 후 생성된 웹 페이지 전달            클라이언트 사이드 (Client-side) : 웹 서버가 JSON 파일을 전달하면, 브라우저는 자바스크립트로 HTML 완성                    장점 : 웹 페이지를 처음 로딩할 때 상대적으로 느리지만 유저와의 빠른 인터렉션 가능           단점 : 봇 크롤러가 자바스크립트를 읽지 못해 검색 엔진 최적화 불가능, 쿠키 외 사용자 정보를 담을 수 없음                       서버 사이드 (Server-side) : 클라이언트가 요청할 때마다 웹 서버에서 템플릿에 데이터를 포함한 HTML를 전달                    장점 : 웹 페이지를 처음 로딩할 때 상대적으로 빠름           단점 : 새로운 요청마다 새로고침이 매번 발생해 비효율적임, 사용자에 대한 정보를 서버가 저장                       Ajax 요청 : 클라이언트가 Ajax Request을 보내 서버에서 데이터를 받아 HTML 완성              main.java.group에 helloController 패키지를 생성하고, 그 안에 helloController 클래스를 작성    // helloController.java  package hello.hellospring.helloController; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  @Controller // 컨트롤러 역할을 부여하는 어노테이션  public class helloController {     @GetMapping(\"hello\")     public String hello (Model model) {  // Model model : 매개변수로 넣어줄 mvc의 model를 의미         model.addAttribute(\"data\", \"World!\");  // 첫번째 패라미터를 두번째 패라미터로 치환         return \"hello\";   // 반환값이 들어오면 viewResolver가 resource:templates/ + {ViewName} + .html을 표현     } }      resources.templates에 hello.html를 작성하고 localhost:8080/hello에서 표현된 페이지 확인    &lt;!--? hello.html --&gt;  &lt;!DOCTYPE HTML&gt;   &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;    &lt;!--? xmlns:th 태그로 타임리프 엔진 선언해 타임리프 문법을 사용 --&gt;   &lt;head&gt;     &lt;title&gt;dynamic&lt;/title&gt;     &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;p th:text=\"'Hello ' + ${data}\" &gt;Let there be light&lt;/p&gt; &lt;!--? 컨트롤러롤 통해 받은 첫번째 패라미터를 두번째 패라미터로 치환 --&gt;   &lt;/body&gt; &lt;/html&gt;         일반 텍스트인 Let there be light 대신 컨트롤러가 전달한 attribute의 값인 Hello World!가 출력          웹 브라우저에 주소 (localhost:8080/hello) 입력   내장 톰캣 서버가 전달받은 주소를 스프링으로 전송   스프링이 helloController에 맵핑된 것을 확인하고 메소드 호출   스프링이 뷰 리졸버에 반환값과 model(data:hello!)를 전달   뷰 리졸버가 템플릿에 반환된 hello와 동일한 .html 파일을 찾음   타임리프 템플릿 엔진이 찾은 .html 파일을 렌더링   웹 브라우저가가 변환된 .html 파일을 화면에 표현      main.java.Controller의 helloController.java와 resources.templates의 hello-template.html 수정    // helloController.java  package group.project.Controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam;  @Controller // 컨트롤러 역할을 부여하는 어노테이션  public class helloController {     @GetMapping(\"hello-mvc\")  // HTTP GET 요청을 처리하는 메소드를 맵핑해 \".../URL\"에 따라 어떤 페이지를 보여줄지 결정하는 어노테이션     public String helloMvc (@RequestParam(\"name\") String name, Model model) {     // @requestparam : 패러미터로 값을 전달. 만약 패러미터로 ?name=ddd을 전달받으면 메소드의 name 패러미터의 값은 ddd로 정해짐         model.addAttribute(\"name\", name);   // 모델의 name attribute의 값을 ddd로 설정         return \"hello-template\";    // 반환값이 들어오면 viewResolver가 resource:templates/ + {ViewName} + .html을 표현     } }  &lt;!--? hello-template.html --&gt;  &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;     &lt;body&gt;         &lt;p th:text=\"'hello ' + ${name}\"&gt;hello! empty&lt;/p&gt;         &lt;!--? 일반 텍스트를 컨트롤러가 전달한 attribute의 값으로 치환 --&gt;     &lt;/body&gt; &lt;/html&gt;      localhost:8080/hello-mvc?name=입력값에서 템플릿 엔진으로 표현된 페이지 확인          웹 브라우저에 주소 (localhost:8080/hello-mvc?name=입력값) 입력   내장 톰캣 서버가 전달받은 주소를 스프링으로 전송   스프링이 helloController에 맵핑된 것을 확인하고 메소드 호출   스프링이 뷰 리졸버에 반환값과 model(name:입력값)를 전달   뷰 리졸버가 템플릿에 반환된 hello-template와 동일한 .html 파일을 찾음   타임리프 템플릿 엔진이 찾은 .html 파일을 렌더링   웹 브라우저가가 변환된 .html 파일을 화면에 표현   API (Application Programming Interface) : 어플리케이션 프로그래밍 인터페이스     @ResponseBody() 어노테이션 : 뷰 리졸버가 작동하지 않아 페이지가 반환되지 않음            소스 코드가 반환돠는 템블릿과 달리, HTTP의 body에 직접 문자를 넣어 그대로 반환           // helloController 수정  package group.project.Controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody;  @Controller // 컨트롤러 역할을 부여하는 어노테이션  public class helloController {   @GetMapping(\"hello-string\")   @ResponseBody // @ResponseBody : HTTP의 body에 직접 데이터의 값을 넣겠 다는 의미      public String helloString (@RequestParam (value = \"name\", required = false) String name){ // required : 패러미터 입력이 필수인지 설정     return \"hello \" + name; // 데이터 그 자체가 반환됨   } }      http://localhost:8080/hello-string?name=입력값의 페이지 소스에서 문자열만 반환됨          @ResponseBody() 어노테이션의 API 방식 : HTTP의 body에 직접 객처를 넣으면, 객체가 JSON 방식으로 반환   // helloController 수정  package group.project.Controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody;  @Controller // 컨트롤러 역할을 부여하는 어노테이션  public class helloController {   @GetMapping(\"hello-api\")   @ResponseBody // @ResponseBody : HTTP의 body에 직접 데이터의 값을 넣겠다는 의미      public String helloString (@RequestParam (value = \"name\", required = false) String name){     Hello hello = new Hello();     hello.setName(name);          return hello; // // 객체를 JSON 방식으로 반환   }    static class Hello {  // 내부 클래스     private String name;          public String getName() {       return name;     }      public void setName(String name) {       this.name = name;     }      } }      http://localhost:8080/hello-string?name=입력값의 페이지 소스에서 JSON이 반환          ResponseBody 어노테이션을 사용한다는 것은?          viewResolver 대신 HttpMessageConverter가 동작                문자 처리는 StringHttpMessageConverter에서 처리         객체 처리는 MappingJackson2HttpMessageConverter에서 처리 : JSON 형식으로 반환         … 이외에도 byte 등의 처리는 내장된 여러 HttpMessageConverter에서 처리                 Controller는 클라이언트의 HTTP Accept Header와 서버의 컨트롤러 반환 타입 정보를 조합해 동작시킬 HttpMessageConverter 선택      예제 1 : 회원 관리 예제      비즈니스 요구 사항 정리          데이터 : 회원의 아이디 (ID), 회원의 이름 (NAME)     기능 : 회원 등록, 회원 조회     가상의 시나리오 : 데이터베이스를 선정하지 않는다.               일반적인 웹 어플리케이션 계층 구조      웹 컨트롤러 : MVC에서의 컨트롤러   도메인 객체 : 회원, 주문, 쿠폰 등 주로 데이터베이스에 저장되고 관리되는 비즈니스 도메인 객체   서비스 : 도메인 객체를 이용해 핵심 비즈니스 로직을 구현   리포지토리 : 데이터베이스에 접근해 도메인 객체를 데이터베이스에 저장하고 관리   클래스 의존 관계      MemberRepository : 데이터베이스를 선정되지 않았기에 인터페이스로 구현, 클래스를 변경 가능하도록 설계   스프링 빈과 @Autowired를 통한 패키지 내 컨테이너 객체 간의 의존성 주입 (Dependency Injection)   멤버 생성 : main.java.Spring.MemberManagement.Domain.Member.java   public class Member {     private Long ID;     private String NAME;      public Long getID() {         return ID;     }      public String getNAME() {         return NAME;     }      public void setID (Long ID){ this.ID = ID; }      public void setNAME (String NAME){ this.NAME = NAME; } }   레포지토리 생성 : main.java.Spring.MemberManagement.Repository.MemberRepository.java   public interface MemberRepository {     Member save(Member M);     Optional&lt;Member&gt; findByID(Long ID);     Optional&lt;Member&gt; findByNAME(String NAME);     List&lt;Member&gt; findAll(); }   레포지토리 인터페이스 생성 : main.java.Spring.MemberManagement.Repository.MemoryMemberRepository.java   @Repository public class MemoryMemberRepository implements MemberRepository {     private Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();     private static long sequence = 0L;      @Override     public Member save(Member M) {         M.setID(++sequence);         store.put(M.getID(), M);         return M;     }      @Override     public Optional&lt;Member&gt; findByID(Long ID) {         return Optional.ofNullable(store.get(ID));     }      @Override     public Optional&lt;Member&gt; findByNAME(String NAME) {         return store.values().stream().filter(M -&gt; M.getNAME().equals(NAME)).findAny();     }      @Override     public List&lt;Member&gt; findAll() {         return new ArrayList&lt;&gt;(store.values());     } }   서비스 작성 : main.java.Spring.MemberManagement.Service.MemberService.java   @Service public class MemberService {     private final MemberRepository memberRepository;      @Autowired     public MemberService(MemberRepository memberRepository) {         this.memberRepository = memberRepository;     }      public Long join (Member M) {         validateName(M);         memberRepository.save(M);          return M.getID();     }      private void validateName(Member M) {         memberRepository.findByNAME(M.getNAME()).ifPresent(m -&gt; {             throw new IllegalStateException(\"이미 존재하는 회원입니다.\");         });     }      public List&lt;Member&gt; findMembers(){         return memberRepository.findAll();     }      public Optional&lt;Member&gt; findOne(Long memberID) {         return memberRepository.findByID(memberID);     } }   레포지토리 테스트 케이스 생성 : test.java.Spring.MemberManagement.Repository.MemoryMemberRepositoryTest.java   public class MemoryMemberRepositoryTest {     MemoryMemberRepository R = new MemoryMemberRepository();      @AfterEach     public void afterEach() {         R.clearStore();     }      @Test     public void save(){         Member M = new Member();         M.setNAME(\"Spring\");          R.save(M);          Member Result = R.findByID(M.getID()).get();          assertThat(M).isEqualTo(Result);     }      @Test     public void findByName() {         Member M1 = new Member();         M1.setNAME(\"M1\");         R.save(M1);         Member M2 = new Member();         M2.setNAME(\"M2\");         R.save(M2);         Member Result = R.findByNAME(\"M1\").get();         assertThat(Result).isEqualTo(M1);     }      @Test     public void findAll() {         Member M1 = new Member();         M1.setNAME(\"M1\");         R.save(M1);         Member M2 = new Member();         M2.setNAME(\"M2\");         R.save(M2);          List&lt;Member&gt; Result = R.findAll();          assertThat(Result.size()).isEqualTo(2);     } }   서비스 테스트 케이스 생성 : test.java.Spring.MemberManagement.Service.MemberServiceTest.java   public class MemberServiceTest {     MemoryMemberRepository R;     MemberService S;      @BeforeEach     public void beforeEach() {         R = new MemoryMemberRepository();         S = new MemberService(R);     }      @Test     void Register() {         Member M = new Member();         M.setNAME(\"Hello\");         Long I = S.join(M);         Member Result = S.findOne(I).get();         assertThat(M.getNAME()).isEqualTo(Result.getNAME());     }      @Test     public void Exception() {         Member M1 = new Member();         M1.setNAME(\"M1\");         R.save(M1);         Member M2 = new Member();         M2.setNAME(\"M2\");         R.save(M2);          S.join(M1);          IllegalStateException e = assertThrows(IllegalStateException.class, () -&gt; S.join(M2));         assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");     } }   멤버 컨트롤러 생성 : main.java.Spring.MemberManagement.Controller.MemberController.java   @Controller public class MemberController {     private final MemberService S;      @Autowired     public MemberController(MemberService S){         this.S = S;     }      @GetMapping(value = \"/members/new\")     public String createForm() {         return \"member/createMemberForm\";     }      @PostMapping(\"/members/new\")     public String create(MemberForm F) {         Member M = new Member();         M.setNAME(F.getNAME());          S.join(M);         return \"redirect:/\";     }      @GetMapping(\"/members\")     public String list(Model MD){         List&lt;Member&gt; M = S.findAllMembers();         MD.addAttribute(\"M\", M);         return \"members/memberList\";     } }   홈 화면 컨트롤러 생성 : main.java.Spring.MemberManagement.Controller.HomeController.java   @Controller public class HomeController {     @GetMapping(\"/\")     public String home(){         return \"home\";     } }   회원 등록 컨트롤러 생성 : main.java.Spring.MemberManagement.Controller.MemberController.java   @Controller public class MemberController {     private final MemberService S;      @Autowired     public MemberController(MemberService S){         this.S = S;     }      @GetMapping(value = \"/members/new\")     public String createForm() {         return \"members/createMemberForm\";     }      @PostMapping(\"/members/new\")     public String create(MemberForm F) {         Member M = new Member();         M.setNAME(F.getNAME());          S.join(M);         return \"redirect:/\";     }      @GetMapping(\"/members\")     public String list(Model MD){         List&lt;Member&gt; members = S.findMembers();         MD.addAttribute(\"members\", members);         return \"members/memberList\";     } }   멤버 폼 생성 : main.java.Spring.MemberManagement.Controller.MemberForm.java   public class MemberForm {     private String NAME;      public MemberForm(String NAME) {         this.NAME = NAME;     }      public String getNAME() {         return NAME;     } }   홈 화면 생성 : main.java.resources.templates.home.html   &lt;!DOCTYPE HTML&gt; &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;body&gt; &lt;div class=\"container\"&gt;     &lt;div&gt;         &lt;h1&gt;Hello Spring&lt;/h1&gt;         &lt;p&gt;회원 기능&lt;/p&gt;         &lt;p&gt;             &lt;a href=\"/members/new\"&gt;회원 가입&lt;/a&gt;             &lt;a href=\"/members\"&gt;회원 목록&lt;/a&gt;         &lt;/p&gt;     &lt;/div&gt; &lt;/div&gt;   회원 등록 화면 생성 : main.java.resources.templates.createMemberForm.html   &lt;!DOCTYPE HTML&gt; &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;body&gt; &lt;div class=\"container\"&gt;   &lt;form action=\"/members/new\" method=\"post\"&gt;     &lt;div class=\"form-group\"&gt;       &lt;label for=\"NAME\"&gt;이름&lt;/label&gt;       &lt;input type=\"text\" id=\"NAME\" name=\"NAME\" placeholder=\"이름 입력 :\"&gt;     &lt;/div&gt;     &lt;button type=\"submit\"&gt;등록&lt;/button&gt;   &lt;/form&gt; &lt;/div&gt; &lt;!-- /container --&gt; &lt;/body&gt; &lt;/html&gt;   회원 목록 화면 생성 : main.java.resources.templates.memberList.html   &lt;!DOCTYPE html&gt; &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;body&gt;   &lt;div class=\"container\"&gt;     &lt;div&gt;       &lt;table&gt;         &lt;thead&gt;         &lt;tr&gt;           &lt;th&gt;#&lt;/th&gt;           &lt;th&gt;이름&lt;/th&gt;         &lt;/tr&gt;         &lt;/thead&gt;         &lt;tbody&gt;           &lt;tr th:each=\"member : ${members}\"&gt;             &lt;td th:text=\"${member.ID}\"&gt;&lt;/td&gt;             &lt;td th:text=\"${member.NAME}\"&gt;&lt;/td&gt;           &lt;/tr&gt;         &lt;/tbody&gt;       &lt;/table&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;   스프링 AOP 생성 : main.java.Spring.MemberManagement.AOP.TimeTraceAOP.java      AOP : 어떤 로직을 기준으로 메인/서브 관점을 나눠 그 관점을 기준으로 각각을 모듈화               Aspect  : 관심사를 모듈화한 것     Target : Aspect를 적용하는 클래스나 메서드     Advice : 부가 기능을 담은 구현체     JoinPoint : Advice가 적용될 시점     PointCut : JoinPoint가 실행될 지점을 정의         핵심 관심사항 (Core Concern) : 회원 가입, 회원 조회의 기능   공통 관심사항 (Cross-cutting Concern) : 회원 가입, 회원 조회의 기능이 실행하는 데에 걸리는 시간   @Component @EnableAspectJAutoProxy public class TimeTraceAOP {     public Object execute(MethodInvocationProceedingJoinPoint JP) throws Throwable{         long start = System.currentTimeMillis();          System.out.println(\"시작: \" + JP.toString());          try {             return JP.proceed();         }finally {             long finish = System.currentTimeMillis();             long timeMs = finish - start;              System.out.println(\"종료: \" + JP.toString() + \" \" + timeMs + \"ms\");         }     } }      프록시 (Proxy) 방식의 AOP : 회원 컨트롤러에서 회원 서비스를 호출할 때 프록시 회원 서비스 호출          프록시 Controller &gt; Controller &gt; 프록시 Service &gt; 실제 Service &gt; 프록시 Repos &gt; 실제 Repos      @Autowired // MemberController의 생성자에 추가해 프록시 주입 확인     public MemberController(MemberService memberService){         this.memberService = memberService;         System.out.println(\"memberService = \" + memberService.getClass());     }  ","categories": [],
        "tags": ["BackEnd"],
        "url": "/spring1/",
        "teaser": null
      },{
        "title": "[Language] 2. 자바 (Java)",
        "excerpt":"자바 (Java) : 객체지향 프로그래밍 언어 (Object-Oriented Programming Language)      객체지향 프로그래밍 (OOP) : 초기부터 객체지향 방법론에 의거해 객체 지향 프로그램 언어로 설계   플랫폼 독립적 : 동일한 프로그램 (byte code)이 여러 운영체제에서 실행 가능   자바 가상 머신 (Java Virtual Machine) : 서로 다른 플랫폼에서 동일한 자바 실행 환경 제공     플랫폼 종속적 : 자바에서 소스 파일을 통해 생성된 바이트 코드를 CPU에 맞게 바이너리 코드로 해석한 후 실행            바이트 코드 (byte code) : JVM이 이해할 수 있는 언어로 변환된 자바 소스 코드       바이너리 코드 (binary code) : 컴퓨터가 이해할 수 있는 1bit 크기의 0과 1로 이루어진 이진 코드              클래스 로더 (Class Loader) : JVM 내로 .class 파일을 로드하고 이를 실행 엔진에 배치     메소드 영역에 저장되는 데이터 : FQCN / 클래스, 인터페이스, enum / 메소드와 변수   (1) 로딩 (Loading) : JVM이 시작할 때, 3개의 클래스 로더가 순서대로 동작      BootStrap ClassLoader : JDK 클래스 파일 (코어 자바 API) 로딩   Platform ClassLoader : JAVA_HOME/lib/ext 또는 java.ext.dirs에 위치한 클래스 파일 로딩   System ClassLoader : classPath나 modulePath에 위치한 클래스 파일 로딩   마지막까지 클래스를 찾지 못하면, ClassFoundException   (2) 링크 (Linking) : 로드된 .class 파일을 검사하고 이를 메소드 영역에 넣음     검증 (Verify) : .class 파일 형식이 유효한지 검사   준비 (Preparation) : 클래스 변수 (static 변수)와 기본값에 필요한 메모리를 준비   교체 (Resolve) : 심볼릭 메모리 래퍼런스를 메소드 영역에 있는 실제 래퍼런스로 교체   (3) 초기화 (Initialization) : static 변수 또는 static 블록 내부의 값을 기본값으로 할당   실행 엔진 (Execution Engine) : 클래스 로더에 의해 배치된 클래스의 바이트 코드를 실행     자바 인터프리터 (Java Interpreter) : JVM에서 바이트 코드를 한줄씩 명령어 단위로 읽어 번역   JIT 컴파일러 : 인터프리터 방식으로 실행하다가, 적절한 시점에 바이트 코드 전체를 바이너리 코드로 번역해 실행   가비지 콜렉터 (Garbage Collector) : 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제해 메모리를 관리   런타임 데이터 에리어 (Runtime Data Area) : 운영체제에서 프로그램 수행을 위해 할당한 메모리 공간     PC 레지스터 (PC Register) : 쓰레드 (Thread)가 시작될 때 생성되는 공간            쓰레드가 현재 실행할 스택 프레임을 가리키는 포인터 생성           JVM stack : 프로그램 실행 과정에서 임시로 할당할 데이터를 저장 (메소드 호출 시 마다 각각의 스택 프레임 생성)   Native method stack : 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행   힙 (Heap) : 모든 쓰레드가 공유하는 객체 저장            new로 생성된 객체와 배열 혹은 String 관련 자원이 저장 / GC에 의해 관리       Permanent Generation : 생성된 객체들의 정보의 주소값 저장                    리플렉션 (Reflection) 으로 동적으로 클래스가 로드될 때 사용           클래스 로더에 의해 로드된 클래스, 메소드 등에 대한 메타 정보가 저장 : JVM에 의해 사용                       New/Young : 생명 주기가 짧은 객체를 GC의 대상으로 하는 영역 (Minor GC 발생)                    Eden : 객체들이 처음 생성되는 공간 (첫번째 GC가 발생)           Survivor 0, 1 : Eden에서 참조되는 객체들이 저장 (Major GC 발생 : Minor GC에 비해 느림)                       Old : 생명 주기가 긴 객체를 GC의 대상으로 하는 영역                    New/Young에서 일정 시간 참조되고 있는 객체들이 저장                           메소드 영역 (Method Area) : 클래스를 메모리에 처음 올릴 때 초기화하는 클래스 이름, static 메소드나 변수 저장            Runtime Constant Pool : 상수 자료형을 저장해 참조 (중복 방지)           자바 네이티브 인터페이스 (Java Native Interface) : 자바 네이티브 코드로 작성된 함수 사용 방법 제공     자바 네이티브 코드 (Java Native Code) : 다른 언어로 작성된 라이브러리를 JVM 내에서 호출하는 코드   네이티브 메소드 라이브러리 (Native Method Library) : 네이티브 실행 프로그램을 만들 때 사용되는 라이브러리   변수 (variable) : 데이터를 저장하는 공간     원시 자료형 (Primitive type) : 선언 시 메모리 주소 위치 (JVM stack)에 실제 값이 저장            boolean : true / false (초기값 : false)       문자 (char) : ''를 이용해 표시 (초기값 : '\\0'=0)       바이트 (byte) : 데이터를 나타내는 바이트 값 (초기값 : 0)       정수 (short, int, long) : 2, 4, 8바이트 크기 내의 정수 (초기값 : 0)       실수 (float, double) : 4, 8바이트 크기 내의 실수 (초기값 : 0.0)           래퍼런스 자료형 (Reference type) : 선언 시 메모리 주소 위치에 실제 값이 가리키는 다른 주소를 저장            실제 값은 Heap에 저장       배열, 클래스, 인터페이스에 대한 래퍼런스              자바는 주소값의 추상화를 금지함, Call by value만 가능 (C/C++ : 주소값 저장 (*) 및 추출 (&amp;) 가능)       var : 데이터 타입을 명시하지 않아도 지역 변수의 타입을 자동으로 추론하는 키워드            지역 변수만 사용 가능 (static 적용 불가)       선언과 함께 명시적인 초기화를 반드시 해야 함       NULL로 초기화할 수 없음       람다 표현식과 같이 사용할 수 없음           var s = 'String'; var n = 100;   변수의 스코프 (Scope) : 변수가 유효한 범위     접근 지정자 (access modifier) : 접근 가능한 수준 지정            public : 어느 클래스에서든 해당 클래스에 대해 접근 가능       protected : 해당 패키지와 같은 패키지 내에 있는 클래스와 상속받은 클래스가 해당 클래스에 접근 가능       default : 해당 클래스와 같은 패키지 내에 있는 클래스만이 해당 클래스에 대해 접근 가능       private : 해당 클래스 및 그 클래스를 포함한 클래스만이 해당 클래스에 대해 접근 가능           변수의 라이프타임 (LifeTime) : 변수가 메모리 영역에 저장되어 있는 시간     인스턴스 변수 (static block과 static method를 제외한 클래스 전체) : 객체가 생성되어 메모리에 존재하는 동안   클래스 변수 (클래스 전체) : 클래스가 초기화되고 프로그램이 끝날 때까지   로컬 변수 (변수가 선언된 블록의 내부) : 변수 선언 이후부터 블록을 벗어날 때까지   변수의 형변환 (Type Conversion) : 현재의 타입을 다른 타입올 바꾸는 것     boolean을 제외한 나머지 기본 자료형 간의 타입 변환이 가능       타입 프로모션 (Type Promotion) : 범위가 작은 데이터 타입의 값을 더 큰 범위의 데이터 타입에 할당 (묵시적 형변환)            byte &lt; short &lt; int &lt; long &lt; float &lt; double           int intN = 23; long longN = intN;      캐스팅 (Casting) : 범위가 큰 데이터 타입의 값을 더 작은 범위의 데이터 타입으로 할당 (명시적 형변환)   int n = 100; c = (char) n;      업캐스팅 (Up-Casting) : 부모-자식 관계의 객체에서 자식 객체를 부모 객체로 형변환 (묵시적 형변환)   다운캐스팅 (Down-Casting) : 부모-자식 관계의 객체에서 부모 객체를 자식 객체로 형변환 (명시적 형변환)   class MyClass {   String name;   String ID;    public MyClass(String name){     this.name = name;   } }  class StudentClass extends MyClass {   String grade;    public StudentClass(String name){     super(name);   } }  public class UpClass {   public Static void main(String[] args){     MyClass P;     StudentClass S = new StudentClass(\"I\");          P = S; // 업캐스팅 발생      System.out.println(P.name); // 컴파일 오류 없음      S = (StudentClass) P;   // 다운캐스팅 발생      System.out.println(S.name); // 컴파일 오류 없음   } }   배열 (Array) : 인덱스 (Index)와 그 인덱스에 대응하는 데이터들로 이루어진 선형 자료구조     배열의 생성 : 배열 공간을 할당받는 과정 (배열에 대한 래퍼런스 변수 선언 + 배열 생성)            래퍼런스 변수 : 메모리 상에 생성된 인스턴스를 가리키는 데에 사용되는 변수 (배열의 주소 값을 가짐)       new : 클래스의 새로운 객체를 생성할 때, 객체를 저장할 메모리를 할당하고 생성자를 호출해 객체를 초기화       = : 스택의 래퍼런스 변수가 힙의 배열 데이터를 가리킴           int[] intArray; intArray = new int [10]; int[] intArray = new int [10]; int[] intArray = {1,2,3,4,5,6,7,8,9};  int[][] intArray2; int intArray2 = new int[2][3]; int intArray2 = { {1, 2, 3}, {4, 5, 6} };      .length 필드 : 배열이 가진 길이 (원소의 개수)를 반환   len = intArray.length  len1 = intArray2.length     // 2차원 배열이 가진 행의 개수 len2 = intArray2[n].length  // 2차원 배열 중 n번째 행이 가진 열의 개수      비정방형 배열 : 행마다 열의 개수가 서로 다른 배열   int[][] intArray3 = new int[3][]; intArray3[0] = new int[1]; intArray3[1] = new int[2]; intArray3[2] = new int[3]; int intArray3 = { {0}, {1,2}, {3,4,5} };  int intArray3[][] = { {0}, {1,2}, {3,4,5} };      메소드의 배열 반환 : 실제 배열에 대한 래퍼런스가 반환   int makeArray() {     int t = new int[4];     return t; }  int[] intArr = makeArray();      객체 배열 : 객체에 대한 래퍼런스를 원소로 갖는 배열   Person[] people = new Person[20];  for(int i = 0; i &lt; people.length; i++){     people[i] = new Person();     people[i].age = 20 + i; }   객체 (Object) : 프로그램에서 사용되는 데이터 혹은 식별자에 의해 참조되는 공간     new : 객체를 생성하는 연산자   P = new Person(\"A\"); P.age = 30;      생성자 : 객체가 생성될 때 자동으로 호출되는 메소드 (객체에 필요한 초기화 수행)            this : 객체 자신을 참조           class MyClass {     int id;      public MyClass (int x) { // 생성자는 클래스 이름과 동일한 이름을 가짐         this.id = x;     }      public void MyFunc (int id) {         this.id = id;     }  }      this() : 동일한 클래스 내의 다른 생성자를 호출할 때 사용 (반드시 생성자의 첫 문장에서 사용되어야 함)   public MyClass {     String title;     int price;     int id = 0;      public MyClass(String title, int price, int id) {         this.title = title;         this.price = price;         this.id = id;         id += 1;     }      public MyClass(String title, int price, int id) {         this.title = title;         this.price = price;         this.id = id;         id += 1;     }      public MyClass(String title, int price) {         this(title, price, id);         id += 1;     }      public static void main(String[] args) {         MyClass mart1 = new MyClass(\"apple\", 100, 1);         MyClass mart2 = new MyClass(\"banana\", 200);     } }      가비지 컬렉션 (garbage Collection) : new로 할당받고 사용하지 않는 객체의 메모리 공간을 자동으로 JVM에 반환            소멸자 (delete)로 객체의 소멸을 명시해야 하는 C++과 달리, 자바는 소멸자가 필요 없음           클래스 (Class) : 객체를 생성하기 위해 변수와 메소드를 정의하는 틀     필드 (Field) : 객체의 상태 혹은 속성 (인스턴스 변수, static 변수)   public class MyClass {     String name;     static long id; }      메소드 (method) : 객체의 행동 (인스턴스 메소드, static 메소드)   public class MyClass {     string name;     long id;      string getName() {         return name;     }          long getID() {         return id;     }      void setName(String name) {         this.name = name;     }      void setID(long id) {         this.id = id;     } }      생성자 (Constructor) : 객체를 생성한 후에 필요한 초기화 작업을 수행하는 메소드   public class MyClass {     string name;     long id;      MyClass(String name, long id) {         this.name = name;         this.id = id;     } }      초기화 블럭 (Initializer) : 객체를 생성한 후에 필요한 초기화 작업을 세분화            클래스 초기화 블럭 : 클래스가 최초로 로딩될 때       인스턴스 초기화 블럭 : 인스턴스가 생성되었을 때           public class MyClass {     string name;     static long id;         // 클래스 초기화 블럭     static {         id = 1;     }         // 인스턴스 초기화 블럭     {         name = \"이름\";         id += 1;     } }      캡슐화 (Encapsulation) : 변수나 메소드는 반드시 클래스 내에서만 구현 가능 / 클래스 안의 내부 클래스 구현 가능     public class (클래스 이름) {     public static void main(String[] args {         ...     }      class (내부 클래스 1 이름) {         ...     }      static class (내부 클래스 2 이름) {         ...     }      void (내부 함수 이름)() {         ...     }     ... }       상속 (Inheritance) : 부모 클래스에 정의된 필드와 메소드를 자식 클래스가 물려받는 것     public class Person {    Person() { ... } ... } public class Student extends Person {   super(); // 부모 클래스의 생성자를 호출   ... }       instanceof : 객체의 타입을 검사하는 연산자 (상속 관계 &amp; 구현 관계 모두 포함)     ``` class Lee extends Student implements Person { … }     Lee lee = new Lee(); assertThat(lee instanceof Lee).isTrue(); assertThat(lee instanceof Student).isTrue(); assertThat(lee instanceof Animal).isTrue(); assertThat(lee instanceof Person).isTrue();       ```    main() : 해당 클래스를 자바 어플리케이션에서 실행하는 메소드     접근 제어자 public  : 다른 모든 클래스에서 호출 가능 (클래스 외부의 JVM에 의해 호출되어야 하므로)   static : 프로그램 시작부터 메모리에 저장됨 (프로그램이 시작할 때부터 JVM에 의해 호출되어야 하므로)   void : 종료 코드를 등록하기 위해 int를 반환해야 하는 ```C``와 달리, 종료 코드를 등록할 필요 없음   String[] args : 명령줄에 주어진 모든 인자를 문자열로 처리해 main()에 전달   public class (클래스 이름) {     public static void main(String[] args {         ...     } }      static : 모든 객체에 공통으로 사용하기 위해 정적으로 선언 (프로그램 시작부터 메모리에 저장)          static 메소드는 static 멤버만 사용할 수 있고, this 키워드를 사용할 수 없음      final : 오직 한 번만 할당할 수 있어 항상 같은 값을 가지는 entity를 정의할 때 사용하는 키워드     final 클래스 : 클래스가 상속받을 수 없음   public final class MyClass { ... }      final 메소드 : 오버라이딩으로 수정할 수 없음   public final class MySuperClass {      protected final void MyFunc() { ... } } public final class MyClass extends MySuperClass {      protected final void MyFunc() { ... } // 컴파일 오류 }      final 변수 : 한번 값을 할당하면 수정할 수 없는 상수 정의   static float Pl = 3.141592;   어노테이션 (Annotation) : 컴파일 &amp; 실행 과정에서 코드를 어떻게 처리할지 알리는 메타데이터     클래스나 메소드 위에 붙으며, @로 시작 : 어노테이션의 유무나 어노테이션에 설정한 값을 통해 클래스를 다르게 실행   @Override // 메소드를 오버라이딩 (상속받은 부모 클래스나 인터페이스에서 해당 메소드가 없으면 컴파일 오류)   자바 모듈 (Java Module) : 클래스, JAR, 패키지 수준의 코드 그룹화 제공     하나의 자바 어플리케이션은 하나 이상의 .class 파일로 구성   다수의 클래스 파일을 .jar 파일로 압축해 배포 및 실행 가능   서로 관련 있는 클래스들은 하나의 패키지로 묶어서 관리   JDK의 Scanner 클래스 : 자바의 키 입력 (Key input)     String next() : 문자열 타입으로 반환   Byte nextByte() : 바이트 타입으로 반환   short nextShort(), int nextInt(), long nextLong() : 정수 타입 (short, int, long)으로 반환   float nextFloat(), double nextDouble() : 실수 타입 (float, double)으로 반환   String nextLine() : 한 줄 전체 (\\n)를 일고 문자열 타입으로 반환   import java.util.Scanner; Scanner scan = new Scanner(System.in); String name = scan.nextLine();      자바 표준 입력 스트림 system.in : 입력되는 키 값을 바이트 정보로 반환 (문자 정보로 변환)     InputSteamReader rd = new InputSteamReader(System.in); // 키보드 입력 스트림 생성 int s = rd.read(); // 키보드로부터 문자 하나를 읽고 이를 s에 저장      예외 처리 (Exception handling) : 발생한 예외에 대해 작성한 프로그램 내에서 대응하는 것     예외 (Exception) : 프로그램 실행 중에 발생하는 런타임 오류 (Runtime error)            Checked Exception : 컴파일러에 의해 예외 발생을 인지 (컴파일 오류)       Unchecked Exception : JVM에서 예외 발생을 인지 (예외 객체 생성 후 처리)              자바에서 자주 발생하는 예외          NullPointerException : Null 래퍼런스를 참조할 때 발생     ClassCastException : 변환할 수 없는 타입응로 객체를 변환할 때 발생     IOException : 입출력 동작 중에 인터럽트가 발생할 때 발생     NumberFormatException : 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환할 때 발생     IllegalArgumentException : 잘못된 인자를 전달할 때 발생     ArrayIndexOutOfBoundsException : 배열의 범위를 벗어나 접근할 때 발생     NoSuchMethodException : 런타임 시점에 존재하지 않는 메소드를 호출할 때 발생         try-catch-finally : 발생한 예외에 대한 예외처리를 하는 구문            try : 오류가 발생할 것으로 예상되는 부분       catch : 발생할 오류에 관련된 예외에 대해 대응할 부분       finally : 예외 발생 여부에 상관없이 반드시 실행되어야 하는 부분       throws: 예외 처리의 의무를 현재 예외가 발생한 메소드에서 그 메소드를 호출한 메소드로 전달           public void funcA() {     try {         ...     } catch (Exception e) { // 예외가 발생할 때 생성된 예외 객체와 타입이 일치하면, 래퍼런스 변수가 생성된 예외 객체를 가리킴         ...     } finally {         ...     } }  public void funcB() throws Exception { // throws로 예외 처리를 Exception로 전달     ... }  ","categories": [],
        "tags": ["Language"],
        "url": "/java1/",
        "teaser": null
      },{
        "title": "[Github Pages] 1. 개발자에게 개발 블로그는 왜 필요한가요?",
        "excerpt":"   내가 아직 취업 시장에 발도 담구지 않은 대학생인데 내가 개발 블로그의 필요성에 대해 논하는 것이 의미가 있는 걸까? 라는 의문이 들어 작년에 작성한 글에서는 이 부분을 짚어보지 않았다. 하지만 이 부분을 뺀 채로 블로그를 운영하다보니, 처음에 내가 가졌었던 생각이나 느낌이 희석되면서, 여러 가지를 이유로 들며 블로그 운영을 게을리한 것 같다. 그래서 지난 1년간 내가 작성한 내용을 다시 정리하기 앞서, 이 부분에 대해 이야기하고자 한다.    1. 블로그에 글을 쓰는 과정 또한 하나의 공부가 될 수 있다.  사실 글을 쓰는 과정은 엄청나게 귀찮다. 글을 쓰기 위한 소재도 미리 준비해야 하고, 그 소재에 대해 모르는 부분을 공부해야 하고, 내가 잘못된 내용을 적는 게 아닌지 검토하는 과정 또한 거쳐야 하고… 하지만 내가 이전에 공부하거나 경함한 내용을 자세하고 정확히 설명하기 위해 노력하면서, 그 내용에 대한 나의 이해도가 올라가는 것 같다. 이전에 블로그에 글을 쓰기 전의 나는 수업 끝나면 다시 책을 펴보지 않았지만, 지금은 블로그에 글을 쓰기 위해서라도 최대한 기록을 남기려고 노력한다. 이러면서 내가 단순히 개념으로 머릿속에 집어넣은 내용을 블로그의 문장이나 예시로 설명하면서, 내용을 이해하는 것을 넘어서 개념을 응용하는 능력 또한 증진되는 것 같다.       글을 쓰는 것과 같이 누군가에게 무언가를 설명하려고 노력하는 행위를 나만 성장하는 데에 있어 도움이 된다고 느낀 건 아닌지, 실용주의 프로그래머라는 책에서는 프로그래머가 고무 오리 인형에게 코드 한 줄씩 설명하는 고무 오리 디버깅 (rubber duck debugging)으로 무언가를 설명해본 경험의 중요성을 강조한다. 이처럼 무언가를 설명해보는 경험이 계속 축적되다보면, 나중엔 무엇을 배우든간에 그것을 어떻게 설명해볼지에 대해 미리 생각해보게 될 것이다.    그리고 당연하지만, 글은 하나의 기록이고 그 자체로 나의 history가 된다. 자신이 공부하고 경험한 것을 기록하는 것은, 당연하지만 내가 기억하는 것보다 더 오래 보존된다. 나는 공부를 하거나 이런저런 자료를 참고한 것을 모으는 방법에 대해 늘 고민하곤 했는데 (예를 들면 즐겨찾기에 등록하는 것이나 PDF를 저장하는 것. 2가지 모두 단점이 명확해 중간에 그만두었다), 역시 코드의 주석처럼 글을 쓸 때 바로바로 참고한 내용을 링크를 걸어주는 방법이 제일 즉각적이고 직관적인 것 같다. 또한 만약 생각이나 회고을 적어둔 경우에는 내가 이런 생각을 했구나, 하면서 나중에 참고하기도 좋다.   2. 블로그를 운영하는 것이 성장의 동기가 될 수 있다.  나는 어렸을 때부터 무언가를 수집하는 것을 좋아했다. 초등학교 때는 TCG 게임의 카드들을 수집해 컬렉터 앨범을 만드는 것을 좋아했고, 중학교 때에는 코인 홀더에 담을 프루프를 사기 위해 용돈을 모아본 적도 있다. 블로그에 글을 쓰는 것 또한 내가 인터넷이나 서적 곳곳에 퍼져 있는 지식들을 수집해 하나의 모음집을 만든다고 느꼈기에 처음 개설하였을 때부터 블로그를 운영하는 데에 애착이 갔다.       그래서 나는 Blog-driven, 즉 블로그를 운영하기 위해 공부하고 경험하면서 나 또한 성장한다는 개념에 대해 긍정적으로 생각한다. 대다수의 사람들이 보통 블로그에 글을 쓰면서 Blog-driven이 이루어진다고 생각하는데, 나는 Blog-driven이 더 포괄적인 개념이라고 생각한다. 블로그를 계속해서 살아있는 상태로 유지하려면 단순히 블로그에 글을 쓰는 것만이 아닌, 블로그를 개선하고 유지보수하는 과정 또한 필요하다. 지난 1년간 블로그를 운영하면서 알게 모르게 시행착오를 거친 부분이 꽤 되는데 웹 개발을 공부하면서 이를 블로그에 대입해 생각해보기도 하고, 블로그에 적용시켜볼 계획도 세우기도 하는 식으로 앞으로 나아가는 데에 큰 도움이 되었던 것 같다.    3. 운영하는 블로그가 개발자에게 새로운 기회를 줄 수 있다.  내가 이번에 대학교 4학년이 되면서 느낀 점이 있다면, 나를 포장하고 홍보하는 것 또한 정말 중요하다는 것이다. 수능은 모든 학생을 일렬로 세우고 점수로 평가하지만, 사회에는 어떤 절대적인 기준이 존재하지 않으므로 사람들이 나를 평가할 수 있는 input data를 내가 스스로 가공해 제공할 필요성이 있다. 특히 개발자는 다른 직업보다 정보를 활용하는 능력이 뛰어나다보니, Github 프로필을 만들거나 포트폴리오 사이트를 만드는 것과 같이 나에 대한 정보를 공유하는 것 또한 매우 활발하다.       요즘 IT 기업들이 지원자의 개발 블로그나 Github의 주소를 요구하는 것 또한 그런 맥락일 것이다. 기업 입장에서는 모든 점에서 뛰어난 인재를 채용하고자 하겠지만, 그것은 매우 소수이다. 그래서 기업은 지원자의 잠재력 또한 확인해 평가하고자 노력한다. 그리고 이런 부분은 개발과 직접적으로 관련되어 있지만 단순한 결과물의 집합체인 이력서나 포트폴리오보다는, 성장하는 데에 있어 중요한 가치를 엿볼 수 있는 개발 블로그나 Github에 잘 들어나는 것 같다.      Reference         코드쓰는사림 님이 작성하신, 개발자가 블로그를 운영해야 할 이유     productuidev 님이 작성하신, 개발자 취업준비 (포트폴리오/블로그)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog1/",
        "teaser": null
      },{
        "title": "[Github Pages] 2. 개발 블로그는 어디에 만들어야 하나요?",
        "excerpt":"   글을 시작하기 앞서 말할 부분이 있다. 이번 포스트의 내용은 나의 주관적인 판단이 들어간 서술이 많다. 나야 보시다시피 Github Pages를 사용하지만 다른 사람들은 여러 이유로 다양한 플랫폼을 사용할 것이고, 그 부분을 지적하거나 문제시하는 게 아님을 분명히 밝히고 싶다. 이 글은 어디까지나 개발 블로그로 사용되는 여러 플랫폼에 대해 이야기해보는 과정을 통해 개발 블로그를 처음 만드는 개발자들이 이런 부분을 고려했으면 좋겠다, 는 취지로 작성된 것이다.    1. 네이버 블로그     한때는 블로그, 하면 네이버? 라고 할 만큼 국내에서 가장 많이 쓰였던 블로그 플랫폼이다. 나도 개발 관련은 아니지만 작년까지 네이버 블로그를 운영했었다. 그런 점에서 가지는 네이버 블로그의 장점은 (국내 한정) 보편성이다. 보편적으로 쓰이는 만큼 사용자 수가 많고, 대다수가 한번씩은 네이버 블로그에 글 정도는 올려보게 되는 것이다. 그리고 이전의 올드한 디자인도 개선된 편이고 카테고리 사용도 간편하다. (이번에 새로 도입된 웹 에디터는 좀 불편했다.)    하지만, 네이버 블로그의 가장 큰 문제는 역시 구글에서 검색했을 때 노출이 잘 되지 않는다는 것이다. 사실상 이 문제가 다른 모든 장점을 덮고도 남는다고 무방하다. 네이버라는 하나의 생태계에서 자체적으로 생산되는 컨텐츠를 검색할 수 있다는 것이 네이버 검색이 우리나라에서 널리 쓰이는 이유이겠지만, 개발자들 대다수가 구글을 통해 검색하는 만큼 다른 개발자들에게 내 글을 노출시키기 어렵다. (물론 블로그에 글을 올리는 목적이 조회수는 아니지만 내 글을 읽어주는 독자가 있다는 것, 그것이 적어도 내 의욕을 좌지우지하는 것 같다.)    2. 티스토리        Example         이동욱 님이 운영하시는, 기억보단 기록을      2006년에 창립되어 네이버처럼 국내에서 보편적으로 많이 쓰이는 블로그 플랫폼이다. 옛날엔 초대장 시스템이 있어서 사용자들의 접근성이 다소 떨어졌는데, 이게 사라지고 나서는 많이들 사용하는 것 같다. 예전에는 다음이 운영했는데, 다음이랑 카카오가 합병된 이후로는 카카오가 운영중인 것 같다.    개발자의 시선에서는 코드 삽입도 지원하고, 플러그인도 다양해 커스터마이징도 가능하고, 구글 노출도 되고, 거기다가 구글 애드센스도 달 수 있고… 정말 안 쓸 이유가 없다. 그렇기에 정말 많은 개발 블로그들이 개설되어 있고, 나 역시도 구글링할 때에 제일 많이 들어가는 플랫폼 중 하나이다. 그래서 초심자가 가장 무난하게 개발 블로그를 시작한다면, 티스토리에서 할 것을 권하고 싶다.    아, 생각해보니 티스토리가 이런 팔방미인이 될 수 있었는지를, (TMI지만) 간략하게나마 적어두어야 할 것 같다. 티스토리가 등장하는 2000년대 중반은 막 우리나라에서 블로그라는 개념이 퍼져나가는 태동기였다. 그때는 상술한 네이버 블로그나 지금은 사라진 다음 블로그처럼 IT 기업들이 운영하는 서비스형 블로그들이 주를 이루었는데, 블로그를 정말 자유롭게 이용하기엔 회사의 약관이나 운영방침과 같은 제약이 있어 차질이 생기곤 했다. (카카오가 운영하는 티스토리 또한 이 문제에 자유롭지는 않다.)    그래서 정재훈 씨가 처음 개발하고, 이후에는 태터앤컴퍼니 (TNC)에서 외국에 존재하던 설치형 블로그를 현지화해 출시한 프로그램이 태터툴즈이었다. 태터툴즈는 기존의 설치형 블로그의 장점을 유지하면서, 한국어에 최적화된 점에서 굉장히 주목을 받았고, 그 TNC가 다음과 합작해 만든 블로그 서비스가 바로 티스토리이다. 이런 알련의 과정 속에서 탄생한 티스토리는 설치형 블로그와 서비스형 블로그의 장점이 적절히 혼합되어 있다.    참고로 TNC는 2008년 국내 최초로 구글에 인수되었고 (!), 태터툴즈는 태터툴즈 사용자 커뮤니티였던 태터네트워크재단 (TNF)에서 개발을 전담해 텍스트큐브 (TextCube)로 리브랜딩되어 현재도 운영중…이면 좋겠지만, 정식 버전은 2014년 2월에 나온 1.10.10에서 멈춘 것 같고 베타 버전도 2.0 베타 3이 마지막인 것 같다. (텍스트큐브 Github)    3. 브런치        Example         옛날개발자 님이 운영하시는, 에디의 기술블로그      브런치는 2015년에 카카오가 글쓰기에 최적화된 플랫폼을 만든다는 야심찬 목표를 갖고 오픈한 블로그 플랫폼이다. 이곳에 글을 올리려면 작가 신청을 하고 에디터팀의 승인 심사에 합격해야 한다고 한다. 그래서 브런치에서 개발 블로그를 몇개 보긴 했는데도, 솔직히 난 소설 글쓰기 플랫폼으로 알고 있었다…    하술할 미디엄을 어느 정도 벤치마킹한 것으로 보이는데, 미디엄과 달리 코드 삽입이 안되서 이미지로 캡쳐해야 한다는 점이 너무 아쉽다. 디자인이랑 폰트가 워낙 깔끔해서 글쓰기엔 특화된 느낌은 확실히 강한데, 개발 블로그로 사용하기에는 한계점이 명확해 보인다.   4. 미디엄        Example         Moon 님이 운영하시는, medium     박상권 님이 운영하시는, medium      미디엄은 2012년 에반 윌리엄스가 만든 소셜 네트워크 서비스이다. 플랫폼을 처음 보았을 때에는 트위터나 링크드인과 같은 소셜 네트워크 서비스의 느낌이 강해 보였는데, 글을 작성하려 할 때 나오는 메모장 화면이 직관적이라 굉장히 좋았다. (미디엄이 글 쓸 때 나오는 한글 폰트가 구리다는 얘기가 많은데, 확장 프로그램 깔면 해결되는 부분이라 생각해 일단 나는 고려하지 않았다.)    그런데 내가 안쓰는 이유는… 사실 처음 블로그를 만들 때 미디엄에 대해 몰랐다! 원래부터 국내 사용자 수가 적다보니 미디엄을 개발 블로그로 쓰는 분들은 더 적은 거 같다. 그리고 카테고리랑 검색 기능이 없으니, 앞서도 얘기했지만 SNS 같은 느낌이 계속 드는 것 같아서 좀 손이 잘 가지 않는다.   5. Notion        Example         younho9 님이 운영하시는, notion      나는 옛날부터 노트에 무언가를 적는 것을 선호해서 스마트폰을 산 뒤로 애플 메모, 네이버 메모, 마이크로스프트 원노트, 에버노트 순으로 메모 앱을 사용했는데 뭔가 아쉬운 점이 한두 개씩은 있엇다. 그런데 노션을 2019년즘에 처음 사용하고 나서는 너무 만족해서 쭈욱 사용하고 있다.    단점을 말하기 앞서… 확실히 짚고 가야할 것이 있다. 노션은 블로그가 아닌 메모장이다. 그런데 메모장을 블로그로 사용하려면 그게 잘 될까? 이것저것 템플릿을 잘 가져와 쓴다고 해도, 메모장이라는 근본적인 한계가 명확하다고 생각한다. 다음은 내가 직접 써보면서 느낀 단점들이다.      페이지 주소가 직관적이지 않고, 페이지 제목이 바뀌면 새로운 주소를 가지게 되어 글을 다시 공유해야 한다.   하나의 페이지이기 때문에 카테고리, 글 검색, 댓글 기능이 부재되어 있다.   페이지가 무거우면 페이지를 불러오는 그 로딩 과정이 매우 길다.   그러면 노션 블로그를 호스팅하면 되지 않을까? 할텐데, 도메인과 호스팅 비용이 상당히 든다. 당장 무료로 쓸 수 있는 옵션이 이렇게 많은데, 노션이 좋다고 계속해서 돈을 지출하는 것은 좀 과하지 않을까?   6. 벨로그     벨로그는 2018년 velopert 님이 개설한 개발자에 특화된 블로그 서비스이다. 유저 수가 소수였던 초창기와 달리, 지금은 국내 많은 개발자들이 유입되면서 개발자 생태계가 잘 구축되어 있고, 올라오는 정보의 양과 질 모두 좋은 편이다. 또한 코드 삽입, 마크다운 에디터 등 개발자에 특화된 요소들이 눈에 띄는 요소이다. 모두 같은 디자인이고 커스터마이징할 수 있는 요소가 없다는 부분이 단점이긴 하지만, 앞서 말한 티스트리처럼 초심자가 개발 블로그를 처음으로 만든다고 한다면 벨로그가 가장 이상적이라 생각한다.    7. 워드프레스 블로그     상술한 티스토리의 TMI 파트에도 잠깐 등장한 워드프레스는 2003년 출시된 오픈소스 기반 CMS이다. 전세계에 있는 정말 많은 사이트나 블로그들이 워드프레스를 기반으로 되어 있고, 다양한 플러그인과 테마 또한 존재한다. 그래서 2018년에 네이버 블로그에서 워드프레스 블로그로 이전을 시도한 적이 있었는데… 결과는 실패였다.    그때 실패한 가장 큰 이유는 그때 군생활이여서 무언가를 공부할 여건이 도저히 되지 않았다는 것이었다. 워드프레스를 처음 접했을 때 생각보다 시간이 걸리고 이에 대해 공부할 부분도 꽤 된다. 그리고 처음에 플러그인을 게임 애드온처럼 이것저것 설치했는데 버전 충돌이 생겨서, 다시 제거하고 하나씩 학습해보고… 거기다가 PHP나 자바스크립트에 대한 공부 또한 필수적이다. 이런 것을 개발자들은 학습곡선 (Learning Curve)이 계속 길어진다고 표현하던데… 정말 맞는 말이라고 생각한다.   8. Github Pages        Example         한재엽 님이 운영하시는, JBEE.io     이종립 님이 운영하시는, 기억 보조용 위키      Github Blog라는 하나의 서비스가 존재하는 건 아니고, Github가 제공하는 Github Pages를 이용해 Github 저장소에 블로그나 웹 사이트 같은 웹 서비스를 호스팅하는 방식이다. 아무래도 지금 내가 사용하고 있는 거기도 하고 지난 1년간 공부하고 경험한 것도 있기에 이 부분을 조금 상세히 언급해보고자 한다.      긍정적인 점            커스터마이징의 자유도가 엄청나게 높다. 나처럼 Github Pages용 오픈 소스 테마를 이용해도 되고 아예 처음부터 설계해 만드는 것 또한 가능하다. 구글 검색에 내 블로그를 노출시킬 수도 있고, 구글 애드센스를 통해 광고를 달아줄 수도 있다. 요약하면, 개발자가 가지고 놀기에 정말 좋다!       Github에 저장소로 올라가는 방식으므로 Github와 연동이 된다. 로컬에서 블로그를 쉽게 편집하고 관리할 수 있으며, commit과 push로 글을 등록하면 된다. Github 저장소에 백업이 되어 있기 때문에 (당연하게도) 이를 원격지에서 다운받아 사용할 수도 있고, 필요한 경우 롤백하는 것도 가능하다.       마크다운 형식으로 작성하는 것을 지원하고, 코드 블룩이나 인용 블록 또한 지원한다. 게시글 하나하나가 .md 파일이라 나중에 플랫폼을 이전한다 하더라도 이를 다시 활용하는 것 또한 가능하다.              복합적인 점            워드프레스 블로그만큼은 아니지만, 다른 것들에 비해 진입장벽이 존재한다. 처음에 웹 사이트의 소스 코드를 올리거나 수정하는 작업이 필요하므로 최소한 git이랑 markdown을 어떻게 사용하는지는 알아야 한다. 블로그를 이것저것 건드려보려고 한다면 백엔드 관련 지식이 요구되고, 커스터마이징을 해보려면 간단한 프론트엔드 관련 지식 또한 필요해진다. 물론 웹 개발자를 지망한다면 이런 일련의 과정을 한번 하는 것도 도움이 된다.       Github 저장소에 올라가는 방식이므로 저장소 내의 소스 코드가 모두 공개된다. 블로그를 노출시키고 싶지만 블로그 내부까지 노출시키고 싶지 않는다면, 유료 걔정으로 전환해서 비공개로 전환해야 한다.       하나의 Github 저장소는 용량과 트래픽에 제한이 존재한다. (1GB의 최대 용량, 월 100GB의 트래픽 제한) 제한을 넘어서 사용하려면 Cloudflare과 같은 CDN을 추가로 사용해야 한다. 일단은 한도 내에서만 쓰면 무료인 것은 장점이지만, 한도를 넘어버린다면 돈을 써야하니 용량이 있는 파일을 올리는 것과 같은 경우에 주의할 필요가 있다.              부정적인 점            정적 페이지로 빌드한는 것만 지원한다. 그래서 댓글 기능을 추가할 때 외부 데이터베이스와 연동이 되지 않아 이를 위한 플러그인을 별도로 설치해야 한다. (Github가 소스 관리를 위한 서비스이니… 동적 호스팅 서비스는 AWS와 같은 클라우드 벤더 등을 사용하자.)       벨로그처럼 작성하는 문서 서식을 바로 렌더링해서 볼 수 없다. 프리뷰 플러그인을 사용한다 치더라도, 플러그인으로 형성된 화면과 렌더링된 화면이 일치하지 않아 결국엔 플러그인을 잘 안쓰게 된다.       글을 쓸 때 표나 이미지를 넣는 게 불편하다. 나 같은 경우에는 html과 css를 사용해 넣는데, 해당 문법을 알아도 표를 일일이 만드는 것은 굉장히 귀찮다. 이미지 같은 경우에는 외부 사이트에 업로드해 이를 호스팅하는데 그것 또한 좀 번거로운 작업이다.              나는 Github Pages 블로그를 운영하는 것은 장단점이 매우 명확하고, 개개인마다의 호불호가 엄청 갈릴 수 밖에 없다고 생각한다. 실제로 Github Pages 블로그를 운영하시다가 다른 블로그 플랫폼으로 이주하시는 분들도 많이 보았고 나 또한 블로그를 개설하면서, 그리고 개설된 블로그를 운영하면서도 이주할지말지에 대해 많이 고민했었다.     그래도 내가 Github Pages 블로그를 운영하는 데에는 git을 이용해 블로그를 관리할 수 있다는 것과 블로그 운영을 통해 웹 개발의 전반적인 과정을 학습해볼 수 있다는 점이 가장 큰 이유인 것 같다. Github Pages 블로그를 개설할 때에는, 정말 아무것도 모르는 감자 (…)라서 많이 헤맸다. 그래서 처음에는 블로그와 연동되는 git에 대해 공부하고자 Do it! 지옥에서 온 문서 관리자 깃 &amp; 깃허브 입문이라는 도서를 구매해서 공부해보고, 그 다음에는 블로그를 커스터마이징해보려고 Do it! HTML+CSS+자바스크립트 웹 표준의 정석이라는 도서를 구매해서 공부해보고 이를 최대한 적용해보는 식으로 실습하였다. 이렇게 블로그를 성장시키려고 노력하는 과정 속에서 나 또한 많이 성장할 수 있었고, 앞으로도 이런 blog-driven이 잘 이루어졌으면 하는 것이 내 바램이다.      Reference         productuidev 님이 작성하신, 개발자 취업준비 (포트폴리오/블로그)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog2/",
        "teaser": null
      },{
        "title": "[Github Pages] 3. Github Pages 블로그 소개",
        "excerpt":"   사실 이전 포스트에서 Github Pages에 대한 내용이 있어 좀 중복되는 느낌이 들 수도 있다. 하지만, 이 포스트에서는 Github Pages의 원리를 짚어보고자 작성한 것이니 혹시 모르는 사람들은 한번 읽어보자.    Github Pages 블로그란?      정적 웹사이트 생성기 (SSG; Static Site Generator)   많은 사람들이 Github Pages로 블로그를 사용하고 있어 이를 블로그 서비스로 인식하기 쉽지만, 사실 Github Pages의 실체는! 바로 Github에서 제공하는 정적 웹 사이트 호스팅 서비스이다. 그리고 정적 웹 사이트 호스팅 서비스를 가능하게 하는 것이 바로 SSG란 것이다.    SSG로 생성된 사이트는 모든 웹 페이지를 미리 생성하고, 방문자로부터 요청이 들어오면 미리 만든 웹 페이지를 그대로 응답해준다. 그러므로 서버와 클라이언트 모두 렌더링을 위한 작업이 거의 없기 때문에, SSG로 생성된 웹 사이트는 속도가 매우 빠른 장점을 가진다. 그리고 SSG로 생성된 사이트는 미리 만들어놓은 수많은 웹 페이지로 이루어져 있는 구조라 검색엔진 최적화 (SEO; Search Engine Optimization)가 뛰어나 검색엔진이 사이트를 크롤링하는 데에 적합하다.    그러나 빌드할 때마다 모든 웹 페이지를 생성하는 작업을 매번 하다보니, 컨텐츠를 자주 업데이트하는 웹 사이트나 규모가 커 빌드 시간이 오래 걸리는 웹 사이트에서는 큰 비효율성이 발생해 SSG보다는 다른 렌더링 기술을 사용한다. 그래서 SSG는 개인 블로그와 같이 컨텐츠의 변경이 자주 일어나지 않은, 소규모 웹 사이트를 제작할 때 많이 쓰이는 기술이다. (SSG 외에도 SPA, SSR과 같은 렌더링 기술이 있는데, 달레 님께서 SPA와 SSG, 그리고 SSR이라는 글에서 잘 정리해주셨으니 참고하길 바란다.)    지금 현재 내가 사용하고 있는 Github Pages 테마인 Minimal Mistakes는 Jekyll을 정적 웹사이트 생성기로 사용해 웹 사이트를 정적으로 생성한다. Jekyll 외에도 Hexo, Hugo와 같은 여러 정적 웹사이트 생성기들이 존재하는데, 이들을 간단하게 비교해보자.      Jekyll            Ruby 기반       가장 많이 쓰이고, 한글 래퍼런스 많음       Github Pages에서 공식으로 지원 : push한 글들이 별도의 빌드 과정 없이 알아서 Publish       글이 많아질수록 전체 빌드 속도가 느려짐              Hexo            Node.js (javascript) 기반       (javascript를 써서 그런지) 한글 래퍼런스 많음       Hexo로 블로그를 만들 때 참고할 만한 글              Hugo            Golang 기반       런타임에 다른 의존성이 필요하지 않아, 빌드 과정을 포함해도 빌드 속도가 빠른 편       한글 래퍼런스는 상대적으로 적음       Hugo로 블로그를 만들 때 참고할 만한 글              지킬 (Jekyll)      사실 SSG 중에 Jekyll이 좋은 거 같아 골랐다기보단, Minimal Mistakes 테마가 내 마음에 들어서 설치했는데 구글링해보니 다들 Jekyll을 쓰더라…의 흐름으로 쓰게 된 거고, Jekyll 말고도 다른 SSG가 있는 것을 알게 된 이후에도 어차피 다 같은 SSG인데 Jekyll 말고 굳이 다른 거를 배워서 쓸 필요성을 못 느껴서 (물론 Jekyll이 문제가 많다고 느끼면 다른 SSG를 사용할지에 대해 고민해봐야 할 것이다.) Jekyll을 계속 사용하고 있긴 하다. 일단 Jekyll이 어떤 방식으로 동작하는지 정리해보겠다. (사실 SSG와 동일한 원리인데, 이를 구체화한 것으로 생각하면 된다.)    Jekyll은 동적 웹 사이트 (Dynamic Web Site)과 동일하게, 레이아웃에 해당하는 templates과 컨텐츠에 해당하는 contents를 분리해 저장한다. (이때 Jekyll에서 templates을 작성할 때 사용하는 언어가 Liquid이고, contents를 작성할 때 사용하는 언어가 markdown이다.) 하지만 동적 사이트와 달리, Jekyll은 templates와 contents을 합친 HTML 문서를 미리 빌드해 저장하고, 방문자가 요청을 보내면 정적 컨텐츠에 해당하는 HTML 문서를 전송한다.    그래서 Jekyll은 웹 사이트를 운영하기 위한 HTML 관련 지식을 몰라도, .md 파일로 문서를 작성하면 HTML 파일로 이를 변환해주는 작업을 해주며 변환된 결과물을 토대로 웹 사이트를 구축해서 서비스해준다.   깃허브 페이지 (Github Pages)   상술하였듯 Github Pages는 Github에서 제공하는 정적 사이트 호스팅 서비스로, 무료 계정에 한해 하나의 Github Pages를 무료로 제공한다. Github Pages는 연동된 Github 저장소에서 HTML, CSS, JavaScript와 같은 정적 컨텐츠를 가져와 그대로 배포하는 방식으로 작동한다. 만약 Github 저장소가 Jekyll 디렉토리의 형태로 존재한다면, Github Pages는 해당 저장소가 Jekyll로 작성된 것임을 알고 이를 Jekyll로 빌드해 배포한다.       Reference         SW developer 님이 작성하신, GitHub Pages 블로그 따라하기     Wheel 님이 작성하신, 지킬 (Jekyll)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog3/",
        "teaser": null
      },{
        "title": "[Github Pages] 4. Github Pages 블로그 개설",
        "excerpt":"   이 내용은 작년 9월 말부터 작성한 Minimal Mistakes으로 Github Blog 만들기’의 내용 일부분을 재구성한 것이다. 해당 포스트도 완성도 있는 글이고, 처음 블로그를 설정하시는 분들 또한 도움을 얻을 것이라 생각되나… 그때쯤 작성한 글들 대부분이 너무 나열식으로 쓰였고, 출처에 대한 언급이 많이 부실해 (모르는 부분이 있어 찾으려 하면 출처가 없어서 나도 찾지 못한다…), 부족한 점들을 보완하기 위해 다시 작성되었다.  그리고 현재 작성자의 실행 환경의 OS가 MacOS임을 미리 밝혀둔다. 아마 근시일 내에는 기기를 바꿀 계획이 없으니, 동일한 OS를 사용하시는 분들은 그대로 진행해주시면 된다.    1. Ruby 설치  macOS는 Ruby가 기본적으로 설치되어 있으니, 터미널을 실행하고 다음 명령어를 입력해 Ruby의 설치 여부를 확인한다.   ruby -v // ruby X.X.X 출력 : 정상 설치 // \"zsh: command not found: ruby\" 출력 : 설치 오류   2. Jekyll 설치  터미널 창에 gem install 명령어를 입력해 Jekyll을 설치한다. 참고로 gem은 분산 패키지로, 라이브러리의 작성, 공개, 설치를 도와주는 시스템이다.   gem install jekyll   그리고 터미널 창에 다음 명령어를 입력해 Jekyll가 정상적으로 설치되었는지 확인한다.   jekyll -v // jekyll X.X.X 출력 : 정상 설치 // \"zsh: command not found: jekyll\" 출력 : 설치 오류   3. Jekyll theme 선택  이전 포스트에서 Jekyll은 레이아웃에 해당하는 templates과 컨텐츠에 해당하는 contents를 합쳐 HTML 문서로 미리 빌드해 저장하고, 이를 방문자에게 보여준다고 설명한 바 있다. 그런데 대부분의 블로거들은 레이아웃의 중요성은 알지만 이를 어떻게 구성해야할지 몰라 막막할 것이다. 그런 블로거들을 위해 존재하는 것이 Jekyll theme이다.    Jekyll theme은 다른 사람들이 미리 작업해놓은 templates으로, 많은 Jekyll theme들이 무료로 공개되어 있다. 무료 Jekyll 중에 사람들이 많이 사용하는 것이 minimal-mistakes이다. 간결하고 깔끔한 디자인과 꾸준한 업데이트, 그리고 무엇보다 엄청난 양의 한글 래퍼런스 (…)로 인해 나 역시도 minimal-mistakes을 기반으로 블로그를 개설하였기에, 앞으로 진행할 블로그 개설 역시 minimal-mistakes를 기반으로 진행한다.    먼저 minimal-mistakes Github 페이지에서 .zip 파일을 다운로드한 후 압축을 해제한다. 그리고 아래 사진을 참고하여 필요한 파일 및 디렉토리만 남기고 나머지는 삭제한다. (아, 기존에 존재하지 않는 _post와 _page 디렉토리는 추후에 사용할 예정이니 미리 생성해두자.)      4. 로컬에서 웹 호스팅  터미널 창에 다음 명령어를 입력해 Gemfile을 설치하기 위한 bundler를 사용해보자. 그러면 .jekyll-cache 폴더와 Gemfile.lock 파일이 생성된다.   gem install bundler   bundler 설치가 완료되면, 터미널 창에 다음 명령어를 입력해 Gemfile을 검사해 필요한 목록을 설치할 수 있다.   bundle install   이제 터미널 창에 다음 명령어를 입력하여 블로그를 로컬에서 호스팅해보자.   bundle exec jekyll serve   http://127.0.0.1:4000으로 접속하면 minimal-mistakes이 적용된 블로그 화면을 확인할 수 있다.   5. GitHub Pages에서 웹 호스팅   이제 Github에 (Github ID).github.io의 형식으로 원격 저장소를 생성하자. 다음은 내 블로그가 저장된 원격 저장소 이미지이다.      그리고 지금까지 정리한 내용들을 포함한 디렉터리를 github에 push하면, https://(Github ID).github.io를 주소로 하는 블로그가 생성된 것을 확인해볼 수 있다. 그리고 https://github.com/(Github ID)/(Github ID).github.io/actions에서 블로그가 빌드된 기록을 확인할 수 있다. 만약 원격 저장소에서 푸시된 내용에 대한 빌드 작업이 실패한다면, 그 내용의 배포가 진행되지 않은 것을 확인해볼 수 있다.      Reference         SW developer 님이 작성하신, GitHub Pages 블로그 따라하기     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog4/",
        "teaser": null
      },{
        "title": "[Github Pages] 5. Github Pages 블로그 설정 & 포스트",
        "excerpt":"   솔직히 블로그 설정을 건드는 부분은 내가 아는 정보들을 그대로 나열할 수 밖에 없다고 생각한다… 그래도 내가 시행착오를 겪었던 경험을 떠올리면서 하나하나 풀어서 작성하려 하였으니, 미숙한 글이지만 남들에게 도움이 되었으면 정말 좋겠다… 그리고 Github Pages이나 Minimal Mistakes으로 처음 블로그를 운영하시는 분들의 시선에 맞춰 html, css에 대한 자세한 내용은 다른 포스트로 옮겼으니 참고해주셨으면 한다.    1. 블로그 기본 설정     위의 디렉터리에서 _config.yml이라는 파일을 열어보면 다음과 같이 구성되어 있는데, 오른쪽의 주석을 참조해서 나만의 블로그를 커스텀마이징해보자. 이걸 어떻게 적용하는지 잘 모르겠다, 싶은 사람은 내 블로그에 적용된 것을 예시로 보면서 작업해보자.   minimal_mistakes_skin    :         # 블로그의 전체적인 스킨 지정                                     # (Minimal Mistakes에서 기본적으로 제공)                                    # \"default\" \"air\", \"aqua\", \"contrast\", \"dark\"                                    # \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"  # Site Settings locale                   : \"ko-KR\" # 블로그에 쓰일 로컬 언어 지정 title                    :         # 메타 태그에 들어갈 블로그의 제목 지정 subtitle                 :         # 블로그의 제목 하단에 위치할 부제목 지정 name                     :         # 블로그 저자 이름 지정 description              :         # SEO 향상을 위한 meta description 태그 지정 url                      :         # 블로그 url                                     # \"https://(github ID).github.io\" repository               :         # github repository url                                    # \"https://github.com/(github ID)/(github ID).github.io\" teaser                   :         # 관련 포스트나 검색 등에 들어갈 미리보기 이미지 지정                                    # (\"assets/images/\"로 연결) logo                     :         # 블로그의 제목 옆에 들어갈 로고 이미지 지정                                    # (\"assets/images\"로 연결) masthead_title           :         # 블로그 프로필 상단에 위치할 사이트 제목 지정 breadcrumbs              : true    # 브래드크럼 사용 여부 지정 words_per_minute         : 200     # 포스트를 읽는 데 걸리는 시간을 계산히기 위한 분당 읽는 글자의 지정   2. 블로그 레이아웃 설정  이제 조금은 삭막한(?) 블로그의 레이아웃을 뜯어고칠 차례이다. 우선은 이전처럼 _config.yml 파일을 아래와 같이 자신이 원하는 대로 수정하면 된다.   ## 블로그 좌측 사이드바에 위치할 프로필 설정 author:   name             :       # 저자 이름 지정   avatar           :       # 저자 이미지 지정   bio              :       # 저자 바이오그래피 지정   location         :       # 저자 위치 지정   email            :       # 저자 이메일 지정   links:                   # 저자 관련 사이트 링크 지정     - label:               # 사이트 분류 지정       icon:                # 사이트 아이콘 지정       url:                 # 사이트 url 지정  ## 블로그 하단에 위치할 꼬리말 설정 footer:   links:                   # 블로그 관련 사이트 링크 지정     - label:               # 사이트 분류 지정       icon:                # 사이트 아이콘 지정       url:                 # 사이트 url 지정   (1) 네비게이션 바   다음은 기본 테마를 보면서 혹은 자기가 기능을 적용하면서 불편한 점들을 확인하고, 직접 테마의 요소들을 뜯어고치는 건데… 이건 사람마다 달라서 뭐라고 말을 못하겠다. 그래서 나 같은 경우에 어떤 부분이 불편했고, 그래서 수정했는지 얘기해보고자 한다. 우선은 블로그 상단의 네비게이션 바에 내가 보기에 불필요한 카테고리들이 있었다. 그래서 카테고리, 태그만 남기기 위해  _data/navigation.yml 파일을 수정하였다.  _pages 디렉토리를 보면 여기에 적용할 수 있는 여러 요소들이 있는데, 직접 입맛에 맛게 적용해보면 된다.   main:   - title: (카테고리)        # 화면에 보여질 세부 항목의 이름 지정     url: /(카테고리)/        # _pages 내에 정해진 양식 파일이나 특정 링크로 연결   (2) 블로그 너비 및 폰트 크기   그리고 블로그에 포스트를 쓸 때에 한쪽에는 VS Code를, 다른 쪽에는 로컬에서 호스팅한 블로그를 보기 위한 사파리 브라우저를 띄워 놓곤 했는데, 그때마다 기본으로 설정된 블로그 너비랑 폰트 크기가 글을 읽기에 굉장히 불편했다. 그래서 _sass/minimal_mistakes/_variables.scss 파일과 _sass/minimal_mistakes/_reset.scss 파일을 다음과 같이 수정해보았다.   // 블로그 너비 설정 /*    Grid    ========================================================================== */  $right-sidebar-width-narrow: 200px !default;    // default 200px $right-sidebar-width: 300px !default;           // default 300px $right-sidebar-width-wide: 400px !default;      // default 400px   ## 블로그 폰트 크기 설정 html {   /* apply a natural box layout model to all elements */   box-sizing: border-box;   background-color: $background-color;   font-size: 16px;                    // Default 16px;    @include breakpoint($medium) {     font-size: 16px;                  // Default 18px;   }    @include breakpoint($large) {     font-size: 16px;                  // Default 20px;   }    @include breakpoint($x-large) {     font-size: 16px;                  // Default 22px;   }    -webkit-text-size-adjust: 100%;   -ms-text-size-adjust: 100%; }   (3) 블로그 아이콘   또 블로그 주소 창에 같이 뜰 아이콘이 아무것도 안 뜨니 뭔가 내 블로그 같다는 느낌이 안들었다. 그래서 이것 또한 _includes/_head/custom.html 파일에 내가 원하는 아이콘을 넣었다.   &lt;!-- start custom head snippets --&gt;  &lt;!-- insert favicons. use https://realfavicongenerator.net/ --&gt; &lt;link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/assets/logo.ico/apple-touch-icon.png\"&gt; &lt;link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/assets/logo.ico/favicon-32x32.png\"&gt; &lt;link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/assets/logo.ico/favicon-16x16.png\"&gt; &lt;link rel=\"mask-icon\" href=\"/assets/logo.ico/safari-pinned-tab.svg\" color=\"#ffffff\"&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#ffffff\"&gt; &lt;meta name=\"theme-color\" content=\"#ffffff\"&gt;   내가 수정한 것은 이정도? 인데 자잘하게 더 파고들면 커스텀마이징할 레이아웃 요소가 정말 많다. html, css, yml 파일을 건드는 것이라 그리 어렵지도 않고, 한번 배워두면 생각보다 쓸 때도 많다. 아래는 Minimal Mistakes Themes의 디렉토리 구조에 주석을 단 것인데, 커스텀마이징이 필요할 때 이를 참고하기 좋은 것 같다.   minimal-mistakes ├── _data                                 # 테마를 커스터마이징하기 위한 파일을 저장하는 디렉터리  | |                                       # (yml, yaml, json, csv, tsv 파일을 자동으로 읽어들어 site.data로 사용) | ├── navigation.yml                      # 상단 메뉴바를 커스터마이징하기 위한 파일 | └── ui-text.yml                         # 언어별로 어떤 텍스트로 표시되는지 나열하는 파일 | ├── _site                                 # 재사용되는 html 파일을 저장하는 디렉터리 (공통된 컴포넌트들 보관) | ├── search                              # 검색 엔진을 커스터마이징한 내용을 저장하는 디렉터리 | ├── analytics-providers | └── custom.html                         # 분석 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일 | ├── comments-providers | └── custom.html                         # 댓글 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일 | ├── head | └── custom.html                         # head를 커스터마이징한 내용을 저장하는 파일 | ├── footer | └── custom.html                         # footer를 커스마이징한 내용을 저장하는 파일 | ├── nav_list                            # 메뉴 상단바의 리스트에 대한 helper 파일 | ├── archive-single.html                 # 아카이브 문서에서 단일 문서를 표현하는 방법을 저장하는 파일 | ├── author-profiles.html                # author profile link애 대한 내용을 저장하는 파일 | ├── author-profile-custom-links.html    # author profile link를 커스마이징한 내용을 저장하는 파일 | ├── breadcrumbs.html                    # breadcrumbs에 대한 내용을 저장하는 파일 | ├── single-page | ├── page__taxonomy.html                 # 단일 문서에서 태그와 카테고리를 표현하는 방법을 저장하는 파일 | ├── tag-list.html                       # 단일 문서에서 태그 리스트를 표현하는 방법을 저장하는 파일 | └── category-list.html                  # 단일 문서에서 카테고리 리스트를 표현하는 방법을 저장하는 파일 ├── _posts                                # 블로그에 포스트한 md 파일을 저장하는 디렉터리 ├── _includes ├── _layouts                              # 각 문서의 디자인과 직접적으로 연결된 전체적인 레이아웃 디렉토리 ├── _sass                                 # minimal-mistakes.scss에 임포트할 수 있는 scss 파일을 저장하는 스타일시트 디렉터리 ├── assets                                # css, js, 이미지 파일을 저장하는 디렉터리 | ├── _css | ├── _images | └── _js  ├── _config.yml                           # 블로그를 구성하기 위한 기본적인 설정값을 설정하는 yml 파일 ├── Gemfile                               # 사용할 gem 플러그인 목록 ├── index.html                            # 블로그 처음 홈 페이지 └── package.json   3. 블로그 포스트 작성 및 머릿말 작성  _posts 폴더에 XXXX(YEAR)-XX(MONTH)-XX(DAY)-(NAME).md을 생성해보자. 이때 YEAR, MONTH, DAY는 포스트가 작성된 연도, 월, 일이 되고 NAME은 포스트의 경로가 된다. 그리고 파일 상단에 위치할 머릿말을 작성하기 위해 아래와 같이 ---에 둘러싸인 내용을 작성해보자.   --- title: \"[Blog] macOS에서 Minimal Mistakes로 깃허브 블로그 만들기\"  categories:     - Github.io  tag:     [HTML, JavaScript, SCSS, Ruby]  toc: true toc_sticky: true  date: 2022-09-26 lastmod: 2022-09-26 ---                              양식 이름             양식 설명                                         title             포스트 제목                               categories             포스트 카테고리                               tags             포스트 태그                               toc             우측 상단의 목차                               toc_label             목차 이름                               toc_icon             목차 아이콘                               toc_sticky             목차 고정 여부                               date             포스트 작성일                               lastmod             포스트 수정일                               author_profile             프로필 창 표시 여부                 우리가 글을 작성하는 데에 사용할 Markdown은 텍스트 기반의 마크업 (MarkUp) 언어로, 특수기호와 문자를 활용한 매우 간단한 구조의 문법을 사용해 보다 빠르게 컨텐츠를 작성할 수 있다! Github의 README.md가 대표적인 예시인데, Github Pages 역시 이를 활용해 문서를 작성하는 데에 사용한다. 마크다운 문법은 여기서 상세히 설명하고 있으니 참고하자.   4. 블로그 포스트 내에 문자 박스 양식 넣어보기  추가로 minimal-mistakes theme의 css로 설정된 스타일 요소를 class로 불러와 적용할 수 있는데, 그중 하나인 상자 양식을 활용해보자. Markdown (.md) 파일이니까 html 태그들을 쓰면 그대로 화면에 표현할 수 있다.   &lt;p class=\"notice--primary\"&gt;   &lt;strong&gt;     이 항목은 현재 작성중입니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다. &lt;/p&gt;  &lt;p class=\"notice--info\"&gt;   &lt;strong&gt;     이 항목은 macOS 기반으로 작성되었습니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다. &lt;/p&gt;  &lt;p class=\"notice--danger\"&gt;   &lt;strong&gt;     이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다. &lt;/p&gt;  &lt;p class=\"notice--warning\"&gt;   &lt;strong&gt;     이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다. &lt;/p&gt;                  이 항목은 현재 작성중입니다.             &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.                    이 항목은 macOS 기반으로 작성되었습니다.             &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.                    이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.             &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.                    이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.             &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.          Reference         Jekyll 디렉토리 구조 (번역)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog5/",
        "teaser": null
      },{
        "title": "[Github Pages] 6. Github Pages 블로그 기능 추가",
        "excerpt":"   이 게시물은 Github Pages 블로그, 혹은 Minimal Mistakes 테마에 없는 기능들을 추가해나간 기록들이다. html이나 css를 다룰 줄 알면 금방 할 수 있는, 혹은 다 구글링하면 나오는 내용들이긴 하지만 내가 어떻게 문제를 인식하여 어떤 과정을 거쳐 이를 해결하였는지, 에 대해 자세히 쓰고 싶었다. 그래서 이 게시물은 다른 게시물들과 달리, 내가 블로그에서 부족하다고 느낀 점들을 계속 조금씩이라도 보충해나갈 계획이다.    1. 블로그 댓글 (feat. disqus, giscus)  앞서 서술한 게시물을 보면 Github Pages는 정적 웹 사이트 호스팅 서비스라는 말이 있다. 모든 웹 페이지를 미리 생성하고, 방문자로부터 요청이 들어오면 미리 만든 웹 페이지를 그대로 응답한다는 건데, 사용자와 동적으로 정보를 주고받아야 하는 댓글 등의 기능은 불가능하다는 것이다.    그래서 처음에는 댓글 플랫폼인 disqus를 통해 이를 해결하고자 하였다. 방법은 간단한데, 사이트에 가입하고 무료 플랜을 구독한 다음에 _config.yml를 다음과 같이 수정해주기만 하면 된다.   comments:   provider               : \"disqus\" # 댓글 제공자 지정   disqus:     shortname            :          # disqus ID 지정   그런데 disqus에서 제공하는 기능인 ‘SNS로 댓글 달기’은 개발자 친화적인 기능은 아니였고, 또 나중에는 광고가 노출되기 시작했다. 그래서 대안으로 찾은 게 giscus인데, GitHub Discussions로 작동하고, 마크다운도 지원하면서 대댓글이나 반응과 같은 자잘한 기능들이 마음에 들었다.      적용하는 방법도 Github 앱을 저장소에 설치한 뒤에 html 파일에 아래의 스크립트를 넣어주기만 하면 되는데, 나 같은 경우에는 Minimal Mistakes 테마에서 _includes/social_share.html 파일에 해당 구문을 넣어 적용시켰다.   &lt;section class=\"page__share\"&gt;   &lt;script src=\"https://giscus.app/client.js\"     data-repo=\"pocj8ur4in/pocj8ur4in.github.io\"     data-repo-id=\"R_kgDOICGarA\"     data-category=\"Q&amp;A\"     data-category-id=\"DIC_kwDOICGarM4CZ65L\"     data-mapping=\"pathname\"     data-strict=\"1\"     data-reactions-enabled=\"0\"     data-emit-metadata=\"1\"     data-input-position=\"top\"     data-theme=\"dark_dimmed\"     data-lang=\"ko\"     data-loading=\"lazy\"     crossorigin=\"anonymous\"     async&gt;   &lt;/script&gt; &lt;/section&gt;   2. 블로그 Google 검색 노출 및 검색 설정  아무래도 블로그를 운영하다 보면 다른 사람들의 반응이 궁금할 때가 많은데, 아무것도 설정하지 않은 블로그는 검색되지 않는다는 사실을 깨닫고 해결책을 찾아보았다. Google Search Console에서 내 도메인을 입력한 다음에 소유권 확인을 위해 다운받은 .HTML파일을 root에 위치시키만 하면 며칠 안으로 아래와 같이 적용된다.      추가로 블로그 포스트들이 검색 엔진에 검색되는 것을 가능하도록 진행할 작업들이 있는데, 먼저 _config.yml 파일에서 아래 설정들을 true로 설정한다.   search                   : # 블로그 검색 여부 지정 search_full_content      : # 블로그의 내용 검색 여부 지정   그리고 웹 크롤링을 위해 sitemap.yml과 robots.txt 파일을 생성해 root에 위치시키면 된다.   # 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용 User-agent: * Allow: /  # 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 차단 User-agent: * Disallow: /  # 구글 검색 로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용 User-agent: Googlebot Disallow: /  # 네이버 검색로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용 User-agent: Yeti Disallow: /  Sitemap: https://pocj8ur4in.github.io/sitemap.xml   만약에 블로그의 방문자 수 통계를 보고 싶다면, Google Analytics를 가입한 후 애널리틱스 데이터 스트림을 설정하면 된다. 이때, 측정 ID를 복사한 후 _config.yml 파일을 다음과 같이 수정하면 된다.   # Analytics analytics:   provider               : \"google-gtag\"   google:     tracking_id          : \"(측정 ID)\"   ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog6/",
        "teaser": null
      },{
        "title": "[vocawik] 1. 07/10 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #1. init: git 저장소 생성 ~ #3. init: 멀티모듈 프로젝트 세팅에 대한 내용입니다.    #1. init: git 저장소 생성   가장 먼저 진행할 작업은 작업물의 변경점과 버전을 관리하는 버전 관리 시스템 (VCS; Version Control System)을 도입할 것이다. 변경점 관리를 통해 협업하는 과정에서 누가 어떤 내용을 언제 수정했는지 확인할 수 있고, 버전 관리를 통해 작업하는 과정에서 작업물의 백업과 복구를 간편하게 수행할 수 있다. 여기서는 배포할 코드와 작업할 코드를 나눠 프로젝트를 진행할 수 있는 브랜치 (branch) 개념이 있고 대부분의 개발자에게 이미 익숙할 git을 사용하겠다.      .git 디렉터리를 생성하였다.   git이 관리하지 않을 파일을 지정하기 위해 .gitignore 파일을 생성하고, 그 내용은 gitignore.io을 참고해 작성하였다.   추가로 앞으로 있을 수 있는 협업에서의 원활한 의사소통을 위한 커밋 메세지 컨벤션 (commit message convention) 을 정하여, git에 커밋하는 메시지 제목과 내용에 반영하고자 한다. 여기서는 유다시티 커밋 메시지 스타일 가이드를 참고해 다음과 같은 원칙을 정하였다.   - message structure   - type: subject   - body  - type   - init : 초기 업무   - chore : 빌드 업무 및 패키지 매니저 수정   - feat : 새로운 기능 도입   - fix : 버그 수정   - docs : 문서 수정   - style : 코드 포맷팅 (크드 변경이 없는 경우)   - refactor : 코드 리펙토링   - test : 테스트 코드 추가  - subject   - 제목에 해당하는 subject는 현재시제로 50자 내외에서 작성한다.  - body   - 본문에 해당하는 body는 부연설명이 필요한 경우에만 작성한다.   그리고 Git 원격 저장소를 웹에 호스팅하는 서비스인 Git 웹 호스팅 서비스를 도입할 것이다. 이를 통해 협업하는 과정에서 작업 내용을 빠르게 공유하고, webhook 기능을 통해 pull이나 pull request 같은 이벤트에 반응하여 작업이 실행되게 할 수 있다. 여기서는 데비옵스 (DevOps) 파이프라인 자동화 툴인 Github Actions나 업무의 생성, 진행상황, 해결을 추적하는 이슈 트래커 툴인 Github Issue 등의 서비스를 지원하고 대부분의 개발자에게 이미 익숙할 Github를 사용하겠다.      github 계정에 프로젝트를 저장할 원격 저장소를 만들고, 현재 로컬 저장소의 내용을 원격 저장소에 푸시하였다.   #2. init: 프로젝트 생성   이제 웹 어플리케이션을 구현하기 위한 기술을 정할 차례이다. 사실 이 부분은 개발자 조직과 비즈니스 기획을 고려해 의사결정을 해야 하는 게 맞겠지만, 나에게 러닝커브가 적고 라이브러리 및 래퍼런스가 많이 존재하는 Java를 프로그래밍 언어로, Spring Boot를 웹 프레임워크로, Gradle을 의존성 관리 도구로 사용할 계획이다.      Gradle을 빌드하기 위한 build.gradle 파일의 plugins와 repositories를 작성하였다.            .gradle 파일을 작성하는 방법은 해당 포스트와 해당 포스트를 참고하였다.           // Gradle 플러그인 plugins {     id 'java'      // Spring Framework 기반의 자바 애플리케이션의 개발 및 실행을 지원하는 프레임워크     id 'org.springframework.boot' version '3.1.1'      // Spring Boot 기반의 Gradle 프로젝트에서 의존성 버전을 관리하고 정의하는 플러그인     id 'io.spring.dependency-management' version '1.1.0' }  // Gradle 빌드 스크립트에서 Maven Central Repository를 프로젝트의 의존성 해결을 위한 저장소로 사용 repositories {     mavenCentral() }   #3. init: 멀티모듈 프로젝트 세팅   프로젝트의 내부를 기존의 rootProject인 vw-backend에 sub 모듈인 api, core, domain 모듈을 포함시킨 멀티모듈 구조로 변경하였다.      sub 모듈들을 하나의 디렉토리에서 관리할 수 있도록 settings.gradle 파일을 작성하였다.   // rootProject : Gradle 프로젝트 구조에서 최상위 프로젝트를 나타내는 객체 // - .name : 루트 프로젝트의 이름을 지정 rootProject.name = 'vw-backend'  // - include : 하위 프로젝트의 디렉토리 이름을 지정해 해당 디렉토리 안에 있는 빌드 스크립트를 실행 include 'vw-api' include 'vw-core' include 'vw-domain'      build.gradle에 subprojects와 allprojects 블록을 추가해 하위 모듈과 전체 모듈을 제어할 수 있도록 하였다.   // plugins {} : Gradle 플러그인 // - Gradle 7.0 이상에선 apply plugin: '(plugin-id)' 대신 plugins { id '(plugin-id)' } 사용을 권장 plugins {     // 'java' : Gradle에 내장된 Java 플러그인을 프로젝트에 적용     id 'java'      // 'org.springframework.boot' : Spring Framework 기반의 자바 애플리케이션의 개발 및 실행을 지원하는 프레임워크     id 'org.springframework.boot' version '3.1.1'      // 'io.spring.dependency-management' : Spring Boot 기반의 Gradle 프로젝트에서 의존성 버전을 관리하는 플러그인     id 'io.spring.dependency-management' version '1.1.0' }  // allprojects {} : Gradle 빌드 스크립트에서 모든 프로젝트에 공통으로 적용되는 설정을 지정 allprojects {     // group : 모든 프로젝트의 고유한 식별자인 group을 지정     group = 'vocawik'      // version : 모든 프로젝트의 릴리스 또는 빌드 버전을 나타내는 version을 지정     version = '0.0.1-SNAPSHOT'      // sourceCompatibility : 모든 프로젝트의 소스 호환성을 Java 17로 설정     sourceCompatibility = '17'      // 모든 프로젝트의 Gradle 빌드 스크립트에서 Maven Central Repository를 프로젝트의 의존성 해결을 위한 저장소로 사용     repositories {         mavenCentral()     } }  // subprojects {} : Gradle 빌드 스크립트에서 하위 프로젝트에 공통으로 적용되는 설정을 지정 subprojects {     apply plugin: 'java'     apply plugin: 'org.springframework.boot'     apply plugin: 'io.spring.dependency-management'      // java-library : Java 소스 코드를 컴파일하고 라이브러리 파일 (JAR) 형태로 빌드하는 플러그인     apply plugin: 'java-library'      // 멀티모듈 프로젝트에서 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성화     bootJar.enabled = false     jar.enabled = true      dependencies {       ...     }      // configurations {} : Gradle 빌드 스크립트에서 의존성 구성을 정의     configurations {         compileOnly {             // - extendsFrom : 특정 구성이 다른 구성을 확장하도록 지정             extendsFrom annotationProcessor         }     } }      반복 코드를 어노테이션으로 자동완성하는 lombok 라이브러리를 사용하기 위해 subprojects에 의존성을 추가하였다.   스프링 어플리케이션에서 Junit 기반 테스트가 가능하도록 subprojects에 의존성을 추가하였다.   해당 포스트를 참고해 lombok을 테스팅 환경에서 사용할 수 있도록 subprojects에 의존성을 추가하였다.   JUnit5 API를 테스팅 환경에서 사용할 수 있도록 subprojects에 의존성을 추가하였다.       // dependencies {} : Gradle 빌드 스크립트에서 프로젝트 의존성을 정의     // - implementation : 컴파일 및 런타임 의존성 선언     // - testImplementation : 테스트 코드를 작성하고 실행하기 위해 필요한 의존성 정의     // - api : 컴파일 및 런타임 시에, 그리고 프로젝트를 사용하는 다른 모듈에서 해당 의존성을 사용할 수 있도록 선언     // - compileOnly : 컴파일 시에만 필요한 의존성 정의     // - runtimeOnly : 런타임 시에만 필요한 의존성 정의     // - testCompileOnly : 테스트 코드 컴파일 시에만 필요한 의존성 정의     // - testRuntimeOnly : 테스트 실행 시에만 필요한 의존성 정의     // - annotationProcessor : 컴파일 시에 어노테이션 프로세서 활성화     // - testAnnotationProcessor : 테스트 코드 컴파일 시에 어노테이션 프로세서 활성화     dependencies {         // 'org.projectlombok:lombok' : Lombok 에노테이션을 사용해 소스 코드를 자동으로 생성         compileOnly 'org.projectlombok:lombok'         annotationProcessor 'org.projectlombok:lombok'         testCompileOnly 'org.projectlombok:lombok'         testAnnotationProcessor 'org.projectlombok:lombok'          // 'org.springframework.boot:spring-boot-starter-test' : Spring Boot 어플리케이션의 단위 테스트, 통합 테스트, 모의 객체 등을 지원         testImplementation 'org.springframework.boot:spring-boot-starter-test'          // 'org.junit.jupiter:junit-jupiter-api:5.8.1' : Java 프로그래밍 언어를 위한 단위 테스트 프레임워크         testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'         testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'     }      해당 포스트를 참고해 Java 단위 테스트를 위한 JUnit5 프레임워크를 위해 build.gradle을 변경하였다.       // tasks.named : 특정 이름을 가진 task를 선택하고 해당 task에 대한 구성을 수행     tasks.named('test') {         // useJUnitPlatform : test task에 JUnit Platform을 사용하도록 지정         useJUnitPlatform()     }      Task 'wrapper' not found in project ':project' 오류를 해결하고자, 해당 포스트를 참고하여 build.gradle의 subprojects에서 gradle wrapper를 사용해서 빌드 환경을 맞추었다.   task wrapper(type: Wrapper) {     gradleVersion = '7.4'         distributionUrl = distributionUrl.replace(\"bin\", \"all\") }      위 오류를 해결하는 과정에서 Cannot add task 'wrapper' as a task with that name already exists 오류가 발생해, 해당 포스트를 참고하여 build.gradle의 subprojects에서 gradle wrapper 형식을 변경하였다.       // wrapper {} : Gradle 빌드 도구를 프로젝트에 내장시켜 빌드 환경의 일관성을 유지하는 Gradle Wrapper의 설정을 정의     wrapper {         // gradleVersion : 사용할 Gradle 버전을 지정         gradleVersion = '7.4'          // distributionUrl : Gradle 빌드 도구의 다운로드 위치를 지정         // (기존 다운로드 URL에서 \"bin\"을 \"all\"로 변경하여 Gradle의 모든 버전을 다운로드)         distributionUrl = distributionUrl.replace(\"bin\", \"all\")     }      :prepareKotlinBuildScriptModel Task fails in a Java project 오류를 해결하고자, 해당 포스트를 참고하여 build.gradle의 subprojects에서 prepareKotlinBuildScriptModel을 새로운 empty task로 추가하였다.       // 'prepareKotlinBuildScriptModel'라는 이름의 empty task 등록     tasks.register('prepareKotlinBuildScriptModel'){}  ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw1/",
        "teaser": null
      },{
        "title": "[vocawik] 2. 07/11 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #4. init: spotless 적용 ~ #8. init: sonarqube 적용에 대한 내용입니다.    #4. init: spotless 적용   Junit의 코드 포맷팅 및 유지보수를 위해 해당 게시글을 참고해 spotless 플러그인을 추가하였다.   plugins {     ...      // 'com.diffplug.spotless' : 코드 파일의 포맷팅 규칙을 정의하고, 코드에 적용될 자동 포맷팅 작업을 설정     id 'com.diffplug.spotless' version '6.16.0' }      sub 모듈에도 해당 플러그인이 적용되도록 해당 게시글을 참고해 외부 스크립트 spotless.gradle 파일을 생성하였다.   spotless {     // Spotless 플러그인의 버전을 6.16.0으로 설정     version = \"6.16.0\"      // Java 소스 파일(**/*.java)에 대한 포맷팅과 스타일을 지정     java {         target(\"**/*.java\")          // importOrder() : import문의 순서 정렬         importOrder()          // removeUnusedImports() : 사용되지 않는 import문 제거         removeUnusedImports()          // googleJavaFormat().aosp() : Google Java 스타일 가이드에 따른 코드 포맷팅         googleJavaFormat().aosp()          // trimTrailingWhitespace() : 라인 끝의 공백 제거         trimTrailingWhitespace()          // endWithNewline() : 파일의 맨 마지막에 빈 줄 추가         endWithNewline()     } }      그리고 sub 모듈에서도 spotless 플러그인이 적용될 수 있도록 root 모듈에 spotless.gradle 파일을 적용시켰다.   // apply from : Gradle 빌드 스크립트에서 외부 스크립트 파일을 프로젝트에 적용 apply from: \"$rootDir/spotless.gradle\"   #5. init: git hook과 gradle을 통한 spotless 자동화   앞서 spotless를 적용하긴 했는데, spotless를 실행하는 것은 코드를 작성하고 이를 커밋하는 과정에서 까먹기 쉬운 작업이다. 그래서 이 게시글처럼 git hook으로 커밋을 하기 전에 spotless를 적용하는 것을 자동화하였다.    그런데 .git는 처음에 .gitignore을 통해 제외하기로 한 디렉토리이다. 나 혼자 작업을 진행한다면 위의 내용으로 충분하겠지만, 협업에서는 모두가 같은 내용을 적용하는 것이 중요하다. 그래서 root에 pre-commit 파일을 두고, gradle task를 이용해 빌드가 이루어질 때 pre-commit 파일을 .git에 이동하는 것을 추가하였다.       // 'pre-commit'을 '.git/hooks' 디렉토리에 설치     task installGitHooks(type: Copy) {         from new File(rootProject.rootDir, 'pre-commit')         into { new File(rootProject.rootDir, '.git/hooks') }     }      // 'installGitHooks'을 'build' 작업의 의존성으로 설정     build.dependsOn installGitHooks      pre-commit 파일은 깃 스테이지에 올라간 파일들에 대해 spotlessApply를 실행하고 변경된 파일들을 다시 추가한다.   # 스테이지에 올라간 파일 목록 가져오기 stagedFiles=$(git diff --staged --name-only)  # spotlessApply 실행 ./gradlew spotlessApply  # 각 파일에 대해 주석 처리 for file in $stagedFiles; do   # 파일인 경우에만 주석 처리   if test -f \"$file\"; then     # 파일을 스테이지에 추가     git add \"$file\"   fi done   #6. init: 모듈 내 application.yml 설정   해당 게시글을 참고하여 이전에 설장한 멀티모듈 내에 프로퍼티 설정을 관리하고 환경변수를 주입할 수 있는 application.yml 파일을 생성하였다. 일단 다음과 같은 템플릿을 만들어 적용시켰는데, 추후에 필요한 경우 이를 수정할 생각이다.    --- # 개발 (dev) 프로파일 spring:   config:     activate:       on-profile: dev  --- # 스테이징 (staging) 프로파일 spring:   config:     activate:       on-profile: staging  --- # 운영 (production) 프로파일 spring:   config:     activate:       on-profile: production       지난번에 작업하였을 때에 멀티모듈을 동작시키는 과정에서 외부 모듈의 yml 파일들을 가져오지 못하는 경우가 있었다. 그래서 XXXApplication.java의 XXXApplication 클래스에 System.setProperty를 통해 시스템 프로퍼티를 가져와 이를 설정으로 가져오게끔 하였다.   package vw.api;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class ApiApplication {     public static void main(String[] args) { // 추가된 부분         System.setProperty(                 \"spring.config.name\", \"application, application-domain, application-core\");          SpringApplication.run(ApiApplication.class, args);     } }   #7. init: jacoco 설정   해당 게시글을 참고해 sub 모듈에 코드 커버리지 도구인 Jacoco를 도입하였다. Jacoco도 spotless처럼 외부 스크립트를 통해 관리하고자 하였다.   subprojects {     // 'jacoco' : Java 코드의 코드 커버리지를 측정     apply plugin: 'jacoco'      apply from: \"$rootDir/jacoco.gradle\" }      추후 SonarQube의 연동을 위해 jacocoTestReports task를 설정하였다. html, csv, xml 형태로 저장할 수 있게 해주고, xml 파일은 저장하는 경로를 다르게 설정하였다.   jacoco {     toolVersion = '0.8.9' // Jacoco 도구 버전 설정 }  test {     finalizedBy jacocoTestReport // 테스트가 완료된 후에 jacocoTestReport 태스크 실행 }  jacocoTestReport {     dependsOn test // jacocoTestReport 태스크가 실행되기 전에 test 태스크 실행     reports {         html.enabled true // HTML 형식의 보고서 생성         csv.enabled true // CSV 형식의 보고서 생성         xml.enabled true // XML 형식의 보고서 생성     }      def Qdomains = []      for (qPattern in '*.QA'..'*.QZ') { // Q 패턴을 가진 도메인을 Qdomains에 추가         Qdomains.add(qPattern + '*')     }      afterEvaluate {         classDirectories.setFrom(                 files(classDirectories.files.collect {                     fileTree(dir: it, excludes: [] + Qdomains)                         // Q 패턴을 가진 도메인을 제외한 classDirectories 설정                 })         )     }      finalizedBy 'jacocoTestCoverageVerification'         // jacocoTestCoverageVerification 태스크가 실행된 후에 jacocoTestReport 태스크 실행 }      violationRules {         rule {             enabled = true             excludes = [] + Qdomains // Q 패턴을 가진 도메인을 제외하고 규칙을 적용         }     } }       원하는 코드 커버리지를 설정하고, 커버리지를 만족하는지 여부를 확인하는 데에 쓰일 수 있는 jacocoTestCoverageVerification task를 설정하려 했으나, 커버리지를 만족시키기 위해 설정해야 하는 기준을 판단하기 어려워 다음의 내용은 일단 제외하였다.   jacocoTestCoverageVerification {     violationRules {         rule {             limit {                 counter = 'BRANCH'                 value = 'COVEREDRATIO'                 minimum = 0.90             }              limit {                 counter = 'LINE'                 value = 'COVEREDRATIO'                 minimum = 0.80             }              limit {                 counter = 'LINE'                 value = 'TOTALCOUNT'                 maximum = 200             }         }     } }      대신 QueryDSL가 자동으로 생성하는 QDomain 클래스를 코드 커버리지에서 제외하였다.   jacocoTestCoverageVerification {     def Qdomains = []      for (qPattern in '*.QA'..'*.QZ') { // Q 패턴을 가진 도메인을 Qdomains에 추가         Qdomains.add(qPattern + '*')     }     ...      그런데 ./gradlew test --console verbose으로 실행해도 빌드가 성공하지 않았는데, jacoco의 버전을 올려보라는 답변을 적용해 해결하였다.   jacoco {     toolVersion = '0.8.7' -&gt; '0.8.9' }      #8. init: sonarqube 적용  해당 게시글을 참고해, Jacoco와 비슷한 코드 커버리지 도구인 sonarqube를 프로젝트 내에 도입하였다.   plugins {      // 'org.sonarqube' : 정적 코드 분석을 통해 버그, 취약점, 코드 스멜 등을 감지하고,     // 이를 바탕으로 한 보고서를 생성하여 소프트웨어의 품질을 관리     id 'org.sonarqube' version '4.0.0.2929'     ... }  apply from: \"$rootDir/sonarqube.gradle\" ...      pull request가 종료되면서 개발 서버에 빌드 파일이 배포되기 전에 소나큐브가 실행되는 것을 목표로 하므로, 차후 작성된 github action에 이를 반영할 것이다.  ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw2/",
        "teaser": null
      },{
        "title": "[vocawik] 3. 07/12 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #9. init: Swagger3 적용 ~ #10. init: Github Actions를 통한 CI/CD 파이프라인 자동화에 대한 내용입니다.    #9. init: Swagger3 적용   REST 웹 서버로 요청되는 URL 리스트를 문서화 및 테스트 할 수 있는 Swagger3를 Api 모듈 내에 도입하였다.           처음엔 Springfox3 라이브러리의 Swagger를 사용하였는데 Springfox3가 실행되지 않는 오류가 발생했다. 개발자 포럼에서도 자주 언급되는 유명한 이슈인데, Spring Boot 2.6 이상의 환경에서 발생하는 이 오류는 아직까지도 해결되지 않았다고 한다. Spring Boot 버전을 2.6 이하로 낮추는 것이 제일 안전한 방법이겠지만, 다른 해결책이 없나 구글링해보았더니 이 포스트에서 @EnableSwagger2 어노테이션 대신 @EnableWebMvc 어노테이션을 이용해 문제를 해결하길래 나도 적용해서 해결했다.     그런데 @EnableWebMvc 어노테이션을 추가하는 건 어떤 의미를 가질까? 라는 질문에 해당 포스트의 내용을 참고해 답변해본다면, @EnableWebMvc는 Spring 프레임워크에서 여러 Config 값을 알아서 설정해주는데 아래의 오류를 일으키는 this.condition 부분도 알아서 설정해주는 것 같다.       Caused by: java.lang.NullPointerException: Cannot invoke \"org.springframework.web.servlet.mvc. condition.PatternsRequestCondition.getPatterns()\" because \"this.condition\" is null            그러나 Springfox3 라이브러리의 Swagger는 2020년 이후로 업데이트가 중지되었다는 것을 알게 되었고, 이를 대체하면서 최근까지도 업데이트가 이루어진 Spingdoc 라이브러리의 Swagger를 적용하게 되었다.      dependencies {     // 'org.springdoc:springdoc-openapi-starter-webmvc-ui'     // : SpringDoc OpenAPI를 통해 자동으로 API 문서를 생성하여 Swagger UI를 통해 보여줌     implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0'  }      다음과 같이 SwaggerConfig 클래스를 통해 Swagger UI를 통해 보여질 OpenAPI 문서를 정의하였다.   package vw.api.config;  import io.swagger.v3.oas.annotations.OpenAPIDefinition; import io.swagger.v3.oas.annotations.info.Info; import lombok.RequiredArgsConstructor; import org.springdoc.core.models.GroupedOpenApi; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  // 제목, 버전과 같은 OpenAPI 문서의 정보 정의 @OpenAPIDefinition(info = @Info(title = \"vocawik api\", version = \"v1\")) @RequiredArgsConstructor @Configuration public class SwaggerConfig {     @Bean     public GroupedOpenApi groupedOpenApi() {         String[] paths = {\"/v1/**\"};          // GroupedOpenApi : 그룹화된 OpenAPI 스펙을 담은 객체         return GroupedOpenApi.builder().group(\"vocawik\").pathsToMatch(paths).build();     } }          http://localhost:8080/swagger-ui/index.html로 접속해보면 Swagger 페이지가 정상적으로 출력된다.      Swagger와 별개로 스프링부트 어플리케이션을 실행할 때 나오는 SPRING.JPA.OPEN-IN-VIEW 경고 메세지가 신경쓰였다. OSIV (Open Session In View) 설정이 true일 경우엔 지나치게 오랜 기간 데이터베이스 커넥션을 유지해 시스템 장애를 일으킬 수 있다고 한다. 그러나 OSIV가 꺼져 있으면 모든 지연 로디을 트랜잭션 안에서 처리하는 문제가 발생해 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해야 된다. 일단 이 점들을 인지하고 있다가, 추후에 문제가 터지면 이 부분을 고쳐야할 checklist로 적어두었다.     jpa:    # SPRING.JPA.OPEN-IN-VIEW 로그 오류 해결    open-in-view: false      #10. init: Github Actions를 통한 CI/CD 파이프라인 자동화   지속적 통합 및 배포를 위한 CI/CD 파이브라인에 대해 고민해볼 시간이다. Travis, Jenkins, github actions와 같은 CI/CD 관리 도구들이 있는데, 이 게시글을 참고했을 때 비교적 소규모 프로젝트인 나의 경우에는 Jenkins에 비해 github action를 사용하는 것이 바람직해 보였다. 일단 Github Action과 Github Flow와 관련해서 해당 게시글과 해당 게시글을 참고하였다.   2명 이상의 작업을 진행할 때는 원격에서 feature 브랜치를 두어 이를 공유하고 dev 브랜치에서 병합될 때에도 github flow를 동작시키는 게 맞겠지만, 나 혼자 작업하는 것이니 편의상 생략하였다. 또한 협업에서는 보통 개발 서버와 운영 서버, 즉 2개 이상의 서버를 두어 개발하는데, 이 역시도 비용상의 문제로 로컬 서버를 개발 서버로 하고 이를 운영 서버로 배포하는 흐름으로 할 것이니 미리 양해를 구한다.      master 브랜치는 함부로 수정할 수 없도록 해당 게시글을 참고하여 Branch protection rules를 생성하였다.   CI 및 CD 파이프라인의 자동화를 위한 CI&amp;CD Pipeline.yml을 작성하였다. 이제 작업물을 push가 이루어질 때, 빌드와 테스트 작업 혹은 빌드와 테스트 및 배포 작업이 자동화되어 실행된다.            해당 게시글을 참고하여 Github Actions에서 Gradle을 캐싱할 수 있도록 하였다.       해당 게시글을 참고하여 AWS를 통한 배포 자동화 (CI)를 위해 빌드된 프로젝트를 미리 압축하도록 하였다.           # Github Actions의 workflow 이름 정의 name: CI&amp;CD Pipeline  # 이벤트 트리거 설정 on:   push:     branches:       - master  # 실행 환경 설정 jobs:   push:     runs-on: ubuntu-latest     strategy: # matrix : 동일한 workflow를 여러 가지 다른 환경에서 실행시킴       matrix:         java-version: [ 17 ]      steps:       # 레포지토리를 체크아웃하여 워크스페이스에 가져옴       - name: Check Out The Repository         uses: actions/checkout@v3        # Java 환경 설정       - name: Set up Java         uses: actions/setup-java@v3         with:           java-version: $           distribution: 'corretto'        # 버전 정보 추출       - name: Get the version         id: get_version         run: |           RELEASE_VERSION_WITHOUT_V=\"$(cut -d'v' -f2 &lt;&lt;&lt; ${GITHUB_REF#refs/*/})\"           echo ::set-output name=VERSION::$RELEASE_VERSION_WITHOUT_V        # gradlew 스크립트에 실행 권한 부여       - name: Grant execute permission for gradlew         run: chmod +x ./gradlew         shell: bash        # Spotless 코드 포매터를 실행해 코드 스타일 확인       - name: Check spotless         run: ./gradlew spotlessCheck        # Gradle로 vw-api 모듈 빌드       - name: Execute Gradle build         run: ./gradlew :vw-api:build --no-daemon        # Docker 빌드 툴인 Docker Buildx 설정       - name: Set up Docker Buildx         uses: docker/setup-buildx-action@v2        # Docker Hub에 로그인       - name: Login to Docker Hub         uses: docker/login-action@v2         with:           username: $           password: $        # Docker 이미지 빌드 및 Docker Hub에 푸시       - name: Build and push         uses: docker/build-push-action@v3         with:           context: ./vw-api           push: true           tags: $/$        # 빌드된 Docker 이미지의 디제스트 값 출력       - name: Image digest         run: echo $        # EC2 인스턴스 내에서 Docker 컨테이너를 실행하여 애플리케이션을 실행       - name: Application Run         uses: appleboy/ssh-action@v0.1.6         with:           host: $           username: $           key: $           script: |             # 이전에 실행 중인 도커 컨테이너 중지             sudo docker stop $              # 이전에 실행 중인 도커 컨테이너 강제로 삭제             sudo docker rm -f $              # 최신 도커 이미지를 Docker Hub에서 EC2 인스턴스로 가져옴             sudo docker pull $/$:latest              # 새로운 도커 컨테이너 실행             sudo docker run -p $:8080 \\               --name $ \\               -d $/$              # 모든 미사용 도커 이미지를 삭제             sudo docker image prune -a -f               # gradlew 스크립트의 권한 변경       - name: gradlew permission change         run: sudo chmod 755 gradlew        # Sonaqube 분석       - name: Sonaqube Analysis         run: ./gradlew test sonarqube           -Dsonar.host.url=$           -Dsonar.projectKey=$           -Dsonar.projectName=$-$           -Dsonar.login=$      지난번에 프로젝트를 진행했을 때 도커 허브에 올라온 빌드 파일을 실행했을 때 기본 Manifest 속성이 없다는 오류가 나오면서 정상적으로 작동이 되지 않는 것을 확인하였다. 이를 찾아보니 내가 이전에 참고했던 해당 게시글처럼 오류를 해결한 경우도 있지만, 이 둘을 반대로 진행한 이 포스트와 같은 경우도 있음을 확인하였다. 왜 그럴까?            BootJar task와 Jar task는 빌드를 통해 jar 파일을 만드는 작업이다. 그런데 이 둘이 동시에 존재하는 이유는 Jar은 의존성이 포함되지 않고 소스 코드의 클래스 파일과 리소스 파일만 포함한 Plain Jar을, BootJar은 의존성까지 포함해 어플리케이션 실행이 가능한 executable Jar을 만들기 때문이다.       그러므로, 도커 이미지에 올라간 것은 Plain Jar라 실행이 되지 않는 것이라고 추측해볼 수 있다. 그래서 이를 고려해 build.gradle 파일을 수정하였다.           bootJar.enabled = true jar.enabled = false      그런데 이번엔 Execution failed for task ':bootJar'.이란 오류가 발생했다. 프로젝트의 build.gradle 파일을 보니 application이 없는 모듈들에도 bootJar task를 실행시키는 것으로 되어 있어 수정하였다. 그리고 Core 모듈에서 test하는 부분 때문에 빌드가 안되는 현상이 일어나 일단 그 부분에 해당하는 클래스를 제외하였다.   bootJar.enabled = false   여기까지가 해당 커밋에서 반영된 내용이다. 그리고 아래부터는 그 외부에서 이루어진 작업들로, 솔직히 이 부분은 여러 차례 시행착오가 있었는데 이를 남기지 않으면 분명 나중에 다시 고생할 것 같아 글로 남긴다. 이 포스트가 내가 작업한 내용에 제일 근접하면서도 깔끔히 정리된 듯 하니 참고하면 좋을 듯 하다.      도커 허브에 저장소를 생성하고, 계정에 대한 토큰을 발급받아 GitHub 저장소에 secret key로 등록시켰다.            해당 포스트에서는 도커 허브와 AWS ECR을 비교하고 있는데, 우리의 경우에는 필자가 조금 더 익숙한 도커 허브를 사용할 계획이다.                 해당 포스트와 해당 포스트를 참고하여, AWS EC2를 구축하였다. EC2의 인스턴스 유형은 프리티어인 t2.micro로, 용량은 15GB로 운영 체제는 우분투로 설정하였다. (linux 기반 EC2는 자잘한 오류가 많다고 한다.)  다음은 EC2 인스턴스 생성과 관련하여 설정한 부분이다.            IntelliJ나 터미널 등의 SSH 클라이언트 접속을 위한 프라이빗 키 파일을 생성하였다.       인스턴스에 대한 보안 그룹을 생성해, 인바운드 규칙과 아웃바운드 규칙을 지정하였다.       탄력적 IP 주소를 할당받아, 이를 인스턴스에 연결하였다.       IAM 역할을 변경하여 추후 연결할 데이터베이스 서버와 이미지 서버에 접근할 수 있게끔 하였다.       해당 AWS RDS의 파라미터 그룹을 변경하여 저장하였다.                 SSH에 접속하는 과정에서 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!라는 오류 메시지를 띄우면서, RSA 공유키 충돌 문제가 발생하였다. 그래서 이 게시글을 참고하여 known_hosts 파일을 지웠다.   rm /root/.ssh/known_hosts       SSH 클라이언트에 접속하여 사용자가 root 권한을 빌린다.   sudo su      패키지를 최신으로 업데이트하기 위해 이에 대한 확인 및 실행을 주기적으로 한다.            패키지를 업데이트할 때나 패키지를 설치할 때마다 계속 핑크색 화면이랑 이런저런 log가 계속 나오는 게 신경쓰여 해당 게시글을 needrestart를 제거하고, Kernel Hint와 daemon 재시작 권고 설정 역시 비활성화하였다.           apt update &amp;&amp; sudo apt upgrade      그런데 일괄적으로 업데이트가 안되는 패키지가 있길래, 업그레이드 가능한 패키지를 확인하고 이를 개별로 설치하였다.   apt list --upgradable apt install &lt;패키지명&gt;      디스크별 용량을 주기적으로 확인해두자. 지난번 프로젝트를 진행할 때 이 부분을 신경 쓰지 못해서 EC2를 한번 지워야 하는 경우가 있었다.   df -h      AWS 서비스를 관리할 수 있도록 AWS CLI를 설치하였다. 이전에 IAM 역할을 잘 변경했다면, s3나 rds 명령어도 잘 작동될 것이다.   apt install awscli      SpringBoot 프로젝트를 빌드할 수 있도록 JDK를 설치하였다.   apt install openjdk-17-jdk java -version javac -version      추가로 vim ~/.bashrc으로 JDK의 환경변수를 설정하고, source ~/.bashrc로 이를 적용하였다. (변경된 내용은 echo $JAVA_HOME로 확인해볼 수 있다.)   export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which java)))) export PATH=$PATH:$JAVA_HOME/bin      아래의 명령어를 이용하여 도커를 설치하였는데, Job for docker.service failed because the control process exited with error code라는 오류가 발생하면서 도커가 실행되지 않아 해당 게시글을 통해 해결하였다.   apt install docker.io  systemctl start docker systemctl enable docker      이전에 프리티어가 메모리가 1기가밖에 안되어 소나큐브를 실행만 하면 계속 튕기는 일이 발생하였다. 사실 이런 일은 처음이라 감도 못 잡았다가 이 게시글로 어떤 일이 벌어지는지 대충이나마 이해하게 되었다. 그래서 이번에는 해당 게시글로 Swap File을 이용해 EC2 메모리 부족 현상을 해결해보고자 하였다.            스왑된 메모리는 free 명령어로 확인해볼 수 있다.       top 명령어로 메모리 할당량을 프로세스 별로 확인해볼 수 있다.           dd if=/dev/zero of=/swapfile bs=128M count=16 chmod 600 /swapfile mkswap /swapfile swapon /swapfile      스왑된 메모리가 자동으로 마운트가 가능할 수 있도록 vi /etc/fstab으로 /etc/fstab 파일의 맨 밑줄에 해당 명령어를 작성하였다.   /swapfile swap swap defaults 0 0      그리고 톰캣을 설치하였는데, 이 게시글에 잘 정리되어 있어 이를 그대로 작업하였다. (아, JAVA 환경변수는 이미 설정하였으므로 해당 부분만 제외하였다.)            톰캣을 매번 재시작할 수 있도록 이 게시글을 참고하였는데, 스크립트를 실행하는 과정에서 files have no installation config라는 오류가 발생하였다. 구글링해본 결과 Install 섹션을 활성화해야 한다고 하여 아래의 내용을 스크립트 파일에 추가하였다.           [Install] WantedBy=multi-user.target      여러 개의 도커 컨테이너의 실행을 한 번에 관리할 수 있도록 도커 컴포즈를 설치하였다.   curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose  docker-compose --version      도커로 SonarQube를 설치하였다. (사실 도커로 설치하지 않고 sonarqube를 설치한다면 아래의 작업들을 모두 진행해야 한다. 왜 아냐고? 다 했으니까… 근데 내가 설치한 자바 버전이랑 차이가 있어서 계속 오류가 났다.)            Java 설치, 환경설정       DB 설치       SonarQube에서 요구하는 DB table 생성       DB 계정 생성 및 권한설정       SonarQube 설치       SonarQube에 DB 정보 설정           docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube      그리고 이에 맞춰 Github workflow를 수정하였는데, Permission denied(public key)라는 문구를 띄우면서 Github Actions이 제대로 동작하지 않아 여러 커밋을 보냈다. 근데 원인은 Actions secrets and variables를 잘못 작성한 것이였다; 꼭, -BEGIN-와 -END- 부분도 지우지 말고 넣자.   -----BEGIN OPENSSH PRIVATE KEY----- ... -----END OPENSSH PRIVATE KEY-----      해당 포스트를 참고하여, 아래 이미지와 같이 EC2에 연결할 데이터베이스를 위해 AWS RDS를 구축하였다.            해당 RDS의 RDBMS는 MysSQL로 설정하였다.           EC2와 RDS의 연동을 위해 해당 게시글을 참고하여, EC2에 mysql-client를 설치하였다. 아래 이미지는 sudo mysql_secure_installation로 mysql를 초기화하였을 때 나오는 초기 설정으로, 래퍼런스가 정리되어 있지 않길래 나중에 필요할 때 확인할 수 있도록 첨부하였다.         mysql-client를 통해 EC2에서 RDS에 원격으로 접속되는 것까지 확인하였다.         그리고 ECR에 연결되는 거는 잘 되는데, 외부 접속이 계속 안되서 정말 머리깨지는 줄 알았다. 내가 해주고 싶은 말은, 꼭 라우팅 테이블을 확인하자.         추가로 GitHub Actions 또한 이를 반영해 동작하게 하기 위해, 해당 포스트를 참고하여 yml 파일을 수정하였다.  ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw3/",
        "teaser": null
      },{
        "title": "[vocawik] 4. 07/13, 07/17 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #11. init: Thymeleaf 적용 ~ #13. init: lombok.config 파일 추가에 대한 내용입니다.    #11. init: Thymeleaf 적용   서버에서 클라이언트에게 응답할 브라우저 화면을 만들어줄 차례이다. MVC 구조에서 뷰 (View) 에 해당되는 역할인데, 대다수의 웹 사이트들이 JSP나 Thymeleaf를 사용하는 것으로 알고 있어 이에 대해 정리하고자 한다.   JSP (JavaServer Pages)는 HTML 코드에 Java 코드를 넣어 동적인 웹 페이지를 생성하는 Java 기반 서버 사이드 템플릿 엔진 (Server Side Template Engine)이다. 확장자는 .jsp를 사용한다. 파일을 보면 HTML 문서 내에 &lt;% ... %&gt;에 둘러싸인 부분이 있는데 이를 서블릿 클래스로 변환하고 컴파일해 실행한다. 이때 JSP 파일을 서블릿 클래스로 변환하고 실행시켜 주는 역할을 하는 것이 바로 Tomcat과 같은 서블릿 컨테이너 (Servlet Container)이다. 말로 적으면 난해하니 아래 순서대로 하나씩 보자.      웹 클라이언트 : 웹 서버에 웹 페이지 요청   웹 서버 : 요청받은 웹 페이지에 해당되는 JSP 실행   JSP : JSP를 서블릿 코드 (.java)로 변환   웹 서버 : 서블릿 코드를 컴파일해 실행 가능한 bytecode (.class)로 변환   웹 서버 : 실행 결과로 생성된 HTML 문서를 웹 클라이언트에 응답   웹 클라이언트 : 브라우저에서 HTML 문서를 웹 페이지 형태로 출력   Thymeleaf은 html, xml, js, css 등을 처리할 수 있는 Java 템플릿 엔진이다. Thymeleaf의 주요 목적은 유지관리가 수월한 템플릿을 작성하는 것인데, html 태그에 속성 (th:~)을 직접 추가하면 Thymeleaf가 html 파일을 파싱하여 웹 페이지에 동적으로 값을 추가하거나 처리할 수 있다. 이런 템플릿은 Natural Template을 통해 제공되는데, 이는 서버 사이드 렌더링에 필요한 데이터가 없어도 프로토타입을 볼 수 있도록 해주는 것을 의미한다. 그래서 JSP와 달리 서버의 도움 없이도 뷰를 볼 수도 있다. 또한 thymeleaf는 .war로만 export가 가능한 JSP와 달리 .jar로 export가 가능해 이 역시 서버의 도움 없이 브라우저에 화면을 띄워볼 수 있다.      Thymeleaf은 Gradle를 통해 의존성을 추가하면 따로 설정할 부분 없이 바로 적용해볼 수 있다. (아무래도 Thymeleaf는 처음 사용해본 거라 Thymeleaf의 기본 문법이나 내부 동작 과정까지는 쓰지 못했는데 추후에 이 부분은 별개의 포스트로 추가해야겠다…)   dependencies {     // 'org.springframework.boot:spring-boot-starter-thymeleaf' : Java 기반 서버 사이드 렌더링 템플릿 엔진     implementation 'org.springframework.boot:spring-boot-starter-thymeleaf:3.1.1'     ... }   #12. init: Spring Security 적용   Spring Security는 인증과 권한에 대한 기능을 제공하는 Java Spring의 하위 프레임워크이다. 개발을 하면서 보안 분야는 시간이 많이 소요되는 활동 중 하나인데, Spring Security를 통해 미리 구현된 내부 로직으로 인증 및 권한에 필요한 기능과 옵션들을 제공받아 사용할 수 있다.           인증 (Authentication) : 해당 사용자가 본인이 맞는지를 확인하는 절차     인가 (Authorization) : 인증된 사용자가 요청된 자원에 접근 가능한지 결정하는 절차         여기서는 프로젝트에 적용 및 간단한 설정만 하고 추후 필요한 기능이 생갈 때 필요한 로직을 가져오겠다. 사용할 모듈에 의존성을 추가해주자.   dependencies {     // 'org.springframework.boot:spring-boot-starter-security'     // : 사용자 인증 및 권한 부여를 처리하여 보안 설정의 커스텀마이징을 가능하게 함     implementation 'org.springframework.boot:spring-boot-starter-security' }      그리고 SecurityConfig 클래스를 생성해 기본적인 설정을 해주자.   package vw.api.config;  import lombok.AllArgsConstructor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.web.SecurityFilterChain;  @Configuration @AllArgsConstructor @EnableWebSecurity public class SecurityConfig {     @Bean     public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {         httpSecurity                 // HTTP 기본 인증을 비활성화                 .httpBasic()                 .disable()                 // CORS (Cross-Origin Resource Sharing) 설정을 비활성화                 .cors()                 .disable()                 // CSRF (Cross-Site Request Forgery) 공격 방어를 비활성화                 .csrf()                 .disable()                 // 세션 관리를 상태 없음 (STATELESS)로 설정                 .sessionManagement()                 .sessionCreationPolicy(SessionCreationPolicy.STATELESS);          // 구성된 HttpSecurity 객체 반환         return httpSecurity.build();     } }    #13. init: lombok.config 파일 추가   jacoco에서 Lombok의 @Data 주석이 달린 도메인 클래스의 코드 커버리지가 0%로 나온다. 이는 lombok에서 생성한 코드에 @lombok.Generated를 붙이면 되는데 이를 lombok.config 파일로 할 것이다.   # Lombok이 자동으로 생성한 코드에 @Generated 어노테이션을 자동으로 추기 lombok.addLombokGeneratedAnnotation = true     추가로 이렇게 직접 하나씩 작업해보다가 몇 가지 의문이 든 부분이 있는데, 이를 여기에 적어둘까 한다.   먼저 현재까지 내가 작업한 배포 과정이 정말 사이트를 운영하는 데에 정말 적합한지? 에 대한 고찰이다. 일단 내 처음 계획은, master 브랜치에 작업한 내용을 병합하기 위한 PR이 종료될 때 -&gt; github action에서 도커 허브로 이미지를 올리고 -&gt; AWS 인스턴스 내의 도커에서 올라간 이미지에 대한 컨테이너를 실행하는 것이다. 원래는 난 내 로직이 괜찮다고 생각했는데, 내가 간과한 부분이 하나 있었다.   AWS 인스턴스 내에서 도커를 설치하고 이미지에 대한 컨테이너를 실행하는 것은 괜찮은데, 새로운 이미지에 대한 컨테이너를 실행해야 할 때가 문제이다. 이전 이미지에 대한 컨테이너를 종료하고 이를 삭제한 다음에 새로운 이미지에 대한 컨테이너를 실행하는 과정에서 약간의 소요 시간이 생기지 않을까?   약간의 딜레이가 뭐가 문제인건데?, 라고 생각할 수도 있겠지만, 구글이나 아마존 같이 세계를 대상으로 실시간으로 동작하는 사이트들이 이러면 어마어마한 손실이 날 것이다. 그래서 이들은 무중단 배포 (Zero-downtime Deployment) 전략을 통해 서비스를 중단되지 않는 상태로 유지하려 한다. (개념에 대한 자세한 내용과 세부 전략은 이 포스트를 참고해주길 바란다.) 여기서 등장하는 게 로드밸런서 (LoadBalancer)인데,  nginx나 HAProxy와 같은 제품들이 존재하고, AWS 역시 이를 지원하니 실제 운영 서버를 만들 때 이를 적용해볼 생각이다.   그리고 또 든 생각은, 내가 앞으로 만들 프로젝트가 모놀리식이 아닌 마이크로 서비스에 가깝게 구현되려면 어떻게 해야 하는가? 에 대한 고찰이다. 뜬금없지만 문득 그런 생각이 든 이유는, “마이크로서비스는 작은 서비스들을 많이 만들자는 거 아냐? 그러면 서비스 단위로 모듈을 나눠야 하는 게 맞는 거 아닌가?” 라는 의문이 들었기 때문이다.   응용 계층은 어쩔 수 없다고 하더라도, 그 아래는 서비스 단위로 UserService, WikiService 이런 식으로 존재해도 되는 거 아닌가? 라고 생각을 했는데, 이러면 공통으로 사용 가능한, Common 코드가 불필요하게 반복될 수 있을 것 같았다. 예를 들어 사용자가 원하는 이미지를 클라우드에 업로드하는 기능이 있다고 가정하면, 사용자 프로필로도 사용될 수 있을 것이고, 게시물에도 사용될 수 있을 것이고… 암튼 많이 사용될 건데 이를 일일이 넣는 것은 전혀 객체지향적이지 않다. 그러므로 이미지를 클라우드에 업로드하는 기능과 같이 중복될 수 있는 코드들은 초기 설계 및 구현할 때나 리팩토링할 때 무조건 분리해서 재사용하는 식으로 해야 할 필요성을 느끼게 되었다.  ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw4/",
        "teaser": null
      },{
        "title": "[vocawik] 5. 07/18 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #14. init: 멀티모듈 infra 모듈 추가 ~ #15. init: domain 이벤트 publisher 및 aop 추가에 대한 내용입니다.    #14. init: 멀티모듈 infra 모듈 추가   현재 api, core, domain의 멀티모듈 구조에 infra 영역에 해당하는 모듈을 추가하기로 하였다. core 모듈에서 실제 구현 기술에 해당하는 부분을 분리시켜 core 모듈에 최대한 논리적인 개념만 남겨 core 모듈로의 과도한 의존성을 줄이고, domain, api 모듈에 중복될 수 있는 구현 기술들을 infra 모듈에서 제공하는 기술로 도메인 혹은 프레젠테이션 영역에 필요한 기능을 개발하도록 하였다.      setting.gradle로 infra 모듈을 빌드하였다.   rootProject.name = 'vw-backend'  // - include : 하위 프로젝트의 디렉토리 이름을 지정해 해당 디렉토리 안에 있는 빌드 스크립트를 실행 include 'vw-api' include 'vw-core' include 'vw-domain' include 'vw-infra' // 추가된 부분      build.gradle에 infra의 의존성을 추가하였다.   dependencies {     ...     implementation project(':vw-domain')     implementation project(':vw-core')     implementation project(':vw-infra') // 추가된 부분 }      domain, api 모듈에서 해당 기술을 사용할 수 있도록 각 모듈에 의존성을 추가하고, core 모듈에 존재하는 논리적인 개념을 사용할 수 있도록 해당 모듈에 core 모듈의 의존성을 추가하였다.   #15. init: domain 이벤트 publisher 및 aop 추가      도메인 이벤트는 바운디드 컨텐스트 간에 정보를 주고받는 수단으로 활용되면서, Aggregate 간의 일괄성을 유지하는 데에 사용되는 방법이다. 이를 적용할 수 있도록 먼저 스프링 비동기 처리를 활성화하자.   package vw.domain.common.config;  import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.AsyncConfigurer; import org.springframework.scheduling.annotation.EnableAsync;  @EnableAsync // 스프링 비동기 처리 활성화 @Configuration // 해당 클래스를 스프링의 설정 클래스로 지정 public class EnableAsyncConfig implements AsyncConfigurer {     // 'AsyncConfigurer' : 비동기 처리에 필요한 구성 요소를 제공 }      ApplicationEventPublisher를 활용해 도메인 이벤트를 발행 및 처리할 수 있는 BaseEventPublisher 클래스를 생성하였다.            raise : 도메인 이벤트를 발행       set : 도메인 이벤트를 설정       reset : 도메인 이벤트를 제거           package vw.domain.common.event;  import org.springframework.context.ApplicationEventPublisher;  public class BaseEventPublisher { // ApplicationEventPublisher를 활용하여 도메인 이벤트를 발행 및 처리     private static ThreadLocal&lt;ApplicationEventPublisher&gt; publisherLocal = new ThreadLocal&lt;&gt;();      public static void raise(DomainEvent event) { // 도메인 이벤트를 발행         // 이벤트가 null인 경우에는 종료         if (event == null) return;          // 현재 스레드의 ApplicationEventPublisher를 사용하여 이벤트를 발행         if (publisherLocal.get() != null) {             publisherLocal.get().publishEvent(event);         }     }      public static void set(             ApplicationEventPublisher publisher) { // 현재 스레드의 ApplicationEventPublisher를 설정         publisherLocal.set(publisher);     }      public static void reset() { // 현재 스레드의 ApplicationEventPublisher를 제거         publisherLocal.remove();     } }      ApplicationEventPublisherAware으로 트랜잭션과 관련된 메서드 실행 시 도메인 이벤트 처리하는 BaseEventPublisherAspect 클래스를 생성하였다.   package vw.domain.common.event;  import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression; import org.springframework.context.ApplicationEventPublisher; import org.springframework.context.ApplicationEventPublisherAware; import org.springframework.stereotype.Component;  @Aspect //  해당 클래스가 AOP의 Aspect 역할을 수행함을 표시 @Component // 해당 클래스를 스프링의 컴포넌트로 등록 @ConditionalOnExpression(         \"${ableDomainEvent:true}\") // 지정된 표현식 ${ableDomainEvent:true}이 true인 경우에만 해당 Aspect가 활성화 public class BaseEventPublisherAspect         implements ApplicationEventPublisherAware { // AOP를 사용해 트랜잭션과 관련된 메서드 실행 시 도메인 이벤트 처리      private ApplicationEventPublisher publisher;     private ThreadLocal&lt;Boolean&gt; threadLocal = new ThreadLocal&lt;&gt;();      @Around(             \"@annotation(org.springframework.transaction.annotation.Transactional)\")                     // @Transactional이 적용된 메서드를 감싸는 Aspect를 정의     public Object handleEvent(ProceedingJoinPoint joinPoint)             throws Throwable { // @Transactional이 적용된 메서드를 감싸는 방식으로 도메인 이벤트를 처리하는 Aspect 클래스          Boolean appliedValue = threadLocal.get();         boolean nested;          if (appliedValue != null &amp;&amp; appliedValue) { // 중첩된 트랙잭션이 있는지 확인             nested = true;         } else {             nested = false;             threadLocal.set(Boolean.TRUE);         }          // 중첩된 트랜잭션에 속하지 않으면, 이벤트 발행을 위한 ApplicationEventPublisher를 설정         if (!nested) BaseEventPublisher.set(publisher);          try {             // 원본 메서드 실행             return joinPoint.proceed();         } finally {             // 중첩된 트랜잭션에 속하지 않은 경우, 설정을 초기화             if (!nested) {                 BaseEventPublisher.reset();                 threadLocal.remove();             }         }     }      @Override     public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {         // Spring으로부터 ApplicationEventPublisher를 주입받아 멤버 변수에 할당         this.publisher = eventPublisher;     } }     추상 클래스인 DomainEvent를 통해 이벤트가 발행되었을 때 이벤트가 발생한 시간을 기록할 수 있도록 하였다.   package vw.domain.common.event;  import java.time.LocalDateTime; import lombok.Getter;  @Getter public abstract class DomainEvent {     private final LocalDateTime timestamp; // 이벤트 발생 시간      public DomainEvent() {         this.timestamp = LocalDateTime.now();     } }  ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw5/",
        "teaser": null
      },{
        "title": "[vocawik] 6. 07/19, 07/20 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #16. init: Exception 및 ErrorCode 추가 ~ #18. feat(domain): User 도메인 설정에 대한 내용입니다.    #16. init: Exception 및 ErrorCode 추가  만약 사용자가 잘못된 방식이나 접근을 하였을 때, 서버에서는 이에 대한 예외 처리를 할 것이다. 하지만 표준으로 명시된 예외 처리 메시지를 띄우는 것은 사용자 친화적인 방식이 아닐 뿐더러, 우리 서비스의 취약점을 노출시킬 수 있다. 예를 들어 사용자가 회원가입을 할 때 서버 내에 중복된 아이디를 제출하였다고 가정하자. 그렇다면 JDBC API는 SQLException을 발생시킬 것인데, 이를 그대로 사용자에게 전달한다면 예외 발생만 알 수 있을 뿐, 왜 발생했는지 알 수 없는 상황이 발생한다. 그러므로 예외 (Exception) 및 이에 대한 에러 코드 (ErrorCode)를 커스텀마이징할 필요성이 있다.   public void register() throws SQLException {     ... }      BaseCodeException는 런타임 오류를 처리하는 RuntimeException를 상속해 어떤 클래스가 실행 중일 때 발생할 수 있는 Exception를 처리할 클래스이다. 만약 어떤 예외가 발생한다면 이에 대한 원인 (baseErrorCode의 ErrorReason)을 반환한다 (getErrorReason).   package vw.core.exception;  import vw.core.dto.BaseErrorReason;  public class BaseCodeException extends RuntimeException { // 실행 시 발생하는 예외를 나타냄 (RuntimeException 상속)     private BaseErrorCode baseErrorCode; // 예외 발생 시에 해당 예외의 원인을 BaseErrorCode 객체에 저장      public BaseErrorReason getErrorReason() { // 해당 예외의 원인을 반환         return this.baseErrorCode.getErrorReason();     } }      이를 위해 오류의 원인을 나타내는 DTO 클래스 BaseErrorReason를 작성하였다. 앞으로는 public enum GlobalErrorCode implements BaseErrorReason { ... }와 같이 BaseErrorReason를 주입받아 오류의 원인을 커스텀마이징할 것이다.   package vw.core.dto;  import lombok.Builder; import lombok.Getter;  @Getter @Builder public class BaseErrorReason { // 오류의 원인을 나타내는 DTO     private final Integer status; // HTTP 상태 코드     private final String code; // HTTP 상태 코드 (문자열)     private final String reason; // 오류의 원인 }      에러의 원인을 반환할 인터페이스인 BaseErrorCode를 작성하였다. 추가로 예외에 대한 설명을 문자열 형태로도 반환할 수 있게끔 getExplainError()를 작성하였는데, 이는 다음에 설명할 부분인 ExplainError라는 커스텀 어노테이션을 생성하는 것과 이어져 그때 한번에 설명하겠다.   package vw.core.exception;  import vw.core.dto.BaseErrorReason;  public interface BaseErrorCode {     public BaseErrorReason getErrorReason(); // 에러의 원인을 반환      String getExplainError() throws NoSuchFieldException; // 예외에 대한 설명을 문자열로 반환     // NoSuchFieldException : Reflection을 사용하여 Field를 접근하려고 할 때, 해당 필드가 존재하지 않는 경우에 발생 }      오류에 대한 응답을 나타내는 DTO 클래스 BaseErrorResponse를 작성하였다. 근데 사실 이를 활용해서 프론트에 응답을 하는 게 맞는데, 이에 대한 생각이 못해버려 BaseErrorReason으로만 처리하는 방식으로 다 구현해놓았다. 지금 다시 생각해보면 BaseErrorReason 객체와 오류가 발생한 시간 및 경로를 포함하는 BaseErrorResponse를 활용하는 게 맞고, 이를 처리할 핸들러 클래스르 나중에 변경해두어야 겠다…   package vw.core.dto;  import java.time.LocalDateTime; import lombok.Getter;  @Getter public class BaseErrorResponse { // 오류에 대한 응답을 나타내는 DTO     private final boolean success = false;      private final Integer status; // HTTP 상태 코드     private final String code; // HTTP 상태 코드 (문자열)     private final String reason; // 오류의 원인     private final LocalDateTime timeStamp; // 오류가 발생한 시간     private final String path; // 오류가 발생한 경로      public BaseErrorResponse(BaseErrorReason baseErrorReason, String path) {         this.status = baseErrorReason.getStatus();         this.code = baseErrorReason.getCode();         this.reason = baseErrorReason.getReason();         this.timeStamp = LocalDateTime.now();         this.path = path;     }      public BaseErrorResponse(int status, String code, String reason, String path) {         this.status = status;         this.code = code;         this.reason = reason;         this.timeStamp = LocalDateTime.now();         this.path = path;     } }   #17. init: JPA Auditing 추가   JPA를 사용하여 도메인을 관계형 데이터베이스 테이블에 매핑하다 보면, 도메인들이 공통으로 가지는 필드 및 칼럼들 (ex. 생성자, 수정자, 생성일자, 수정일자, 식별자 등)이 존재한다. 특히 생성자, 수정자, 생성일자, 수정일자는 우리가 DB에 create나 update할 때마다 시간 데이터를 넣어주어야 하는데 이에 대한 코드를 따로 작성할 필요 없이 자동으로 사람이나 시간을 매핑하여 데이터베이스의 테이블에 넣어주는 기능이 바로 JPA Auditing이다.      사실 spring-boot-starter-data-jpa만 추가해도 Auditing에는 문제는 없다. 정확히 말하면 @CreatedDateTime, @LastModifiedDateTime 어노테이션만 추가하면 된다. 그렇지만 @CreatedBy, LastModifiedBy와 같이 생성자, 수정자를 저장하려면 AuditorAware를 스프링 빈으로 등록해야 된다. 이를 위해 JPA를 설정하는 데 활용할 클래스인 JpaConfig를 미리 만들어두자.   package vw.domain.common.config;  import org.springframework.boot.autoconfigure.domain.EntityScan; import org.springframework.context.annotation.Configuration; import org.springframework.data.jpa.repository.config.EnableJpaAuditing; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import vw.domain.DomainPackageLocation;  @Configuration @EnableJpaAuditing @EntityScan(basePackageClasses = DomainPackageLocation.class) // // Entity 스캔을 위한 기본 패키지 위치를 설정 @EnableJpaRepositories(         basePackageClasses = DomainPackageLocation.class) // JPA 저장소를 활성화하기 위한 기본 패키지 위치를 설정 public class JpaConfig { // JPA 설정     // JPA Auditing 활성화 }      추가로 JPA 저장소를 활성화하기 위해 DomainPackageLocation 클래스를 엔티티를 스캔할 위치에 작성하였다.   package vw.domain;  public class DomainPackageLocation {}   #18. feat(domain): User 도메인 설정   회원에 관련된 정보를 저장하고 이를 활용한 서비스를 구현하기 위한 회원 (User) 도메인을 구현하였다. 회원 도메인에서는 회원가입, 회원정보 조회/수정, 회원탈퇴, 로그인 등의 기능을 구현할 것이고, 이를 위해 먼저 회원 엔티티와 회원 레포지토리를 설계하였다.      엔티티 클래스는 각 엔티티에 대한 식별자 및 여러 개의 칼럼들을 기본으로 갖되, 하나의 객체로 묶을 수 있으면 임베디드 타입 (@Embedded, @Embeddable) 혹은 Enum 타입을 활용할 것이고, 회원 엔티티 클래스 User는 이에 기반해 작성되었다. 그리고 Builder 패턴을 통해 각 객체를 생성 가능하게 하여 필요한 데이터를 동적으로 설정할 수 있게 하였다.   package vw.domain.user.entity;  import jakarta.persistence.*; import lombok.AccessLevel; import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.extern.slf4j.Slf4j;  @Getter @Entity @Table(name = \"tbl_user\") @Slf4j @NoArgsConstructor(access = AccessLevel.PROTECTED) public class User { // 회원 엔티티     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     @Column(name = \"user_index\")     private int index; // 회원 식별자      @Enumerated(EnumType.STRING)     @Column(name = \"user_userType\")     private UserType userType = UserType.TYPE_NORMAL; // 회원 유형 정보      @Enumerated(EnumType.STRING)     @Column(name = \"user_userState\")     private UserState userState = UserState.STATE_NORMAL; // 회원 상태 정보      @Embedded private UserAuth userAuth; // 회원 인증 정보      @Embedded private UserProfile userProfile; // 회원 프로필 정보      @Embedded private UserToogle userToogle; // 회원 토글 정보      @Builder     public User(             UserAuth userAuth,             UserProfile userProfile,             UserToogle userToogle) { // Builder 패턴으로 User 객체를 생성 가능하게 함         this.userAuth = userAuth;         this.userProfile = userProfile;         this.userToogle = userToogle;     } }       그리고 User 엔티티 객체들을 관리할 레포지토리 클래스로 UserRepository을 작성하였다. 인터페이스를 생성한 후 JpaRepository&lt;Entity 클래스, PK 타입&gt;을 상속시키면 된다. 또한 @EnableJpaRepositories으로 JPA Repository 빈을 활성화해 JPA CRUD를 활용할 수 있게끔 하고 JPA를 사용하기 위한 설정을 자동으로 처리할 수 있게 하였다.   package vw.domain.user.repository;  import java.util.Optional; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import vw.domain.user.entity.User;  @EnableJpaRepositories public interface UserRepository extends JpaRepository&lt;User, Long&gt; { // 회원 레포지토리 \tOptional&lt;User&gt; findUserByUserAuth_Id(String id); // 아이디로 회원을 조회  \tBoolean existsUserByUserAuth_Id(String id); // 아이디로 회원 존재 여부를 조회  \tBoolean existsUserByUserProfile_Nickname(String nickname); // 닉네임으로 회원 존재 여부를 조회  \tBoolean existsUserByUserProfile_Email(String email); // 이메일로 회원 존재 여부를 조회 }   ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw6/",
        "teaser": null
      },{
        "title": "[vocawik] 7. 07/21 진행 내용",
        "excerpt":"   vocawik 프로젝트의 #19. feat(domain): BaseDateTime 엔티티 추가 ~ #23. fix(domain): User 도메인 제약조건 추가에 대한 내용입니다.    #19. feat(domain): BaseDateTime 엔티티 추가      JPA Auditing을 User 엔티티에 적용하고자 생성 시간 (CreatedDate)과 수정 시간 (LastModifiedDate)을 칼럼으로 갖는 BaseDateTime 엔티티를 생성하였다. 이 때 MappedSuperclass를 통해 JPA Entity 클래스들이 BaseTimeEntity를 상속할 때 내부 필드도 컬럼으로 인식하도록 설정하였다.   package vw.domain.common.model;  import jakarta.persistence.Column; import jakarta.persistence.EntityListeners; import jakarta.persistence.MappedSuperclass; import java.time.LocalDateTime; import lombok.Getter; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedDate; import org.springframework.data.jpa.domain.support.AuditingEntityListener;  @Getter @MappedSuperclass // JPA Entity 클래스들이 BaseTimeEntity를 상속할 때 내부 필드도 컬럼으로 인식하도록 설정 @EntityListeners(AuditingEntityListener.class) public abstract class BaseDateTime { // 생성 및 수정 시간 엔티티     @Column(name = \"baseDateTime_created\", updatable = false)     @CreatedDate     private LocalDateTime created; // 생성 시간      @Column(name = \"baseDateTime_lastModified\")     @LastModifiedDate     private LocalDateTime lastModified; // 수정 시간 }   #20. feat(infra): feign 적용   페인 (Feign) 클라이언트는 REST 호출을 도와주는 Http 클라이언트 바인더 (Client Binder)이다. JPA가 인터페이스만으로 DB에 접근하는 방식을 축소시키는 것처럼, Feign을 적용하면 번거로운 RestTemplate과 같은 호출 방식을 인터페이스 하나만으로 축소시킬 수 있다.      페인 클라이언트는 REST 호출 방식에 영향을 주므로 Api, Domain 모듈 모두에 영향을 준다고 생각하였다. 그래서 Infra 모듈에 의존성을 추가해 양 측 모두에서 사용할 수 있게끔 하였다.   dependencies {     // 'org.springframework.cloud:spring-cloud-starter-openfeign' : 클라이언트 사이드 HTTP 요청을 쉽게 작성할 수 있도록 도와줌     api 'org.springframework.cloud:spring-cloud-starter-openfeign'      // 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8' : Optional, LocalDate 등의 JDK 8 추가 데이터 유형들을 지원     api 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8'      // 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310' : Java 8에 추가된 날짜 및 시간 API를 JSON 형식으로 직렬화 및 역직렬화하는 JSR-310 지원     api 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'      // 'io.github.openfeign:feign-jackson' : OpenFeign을 사용할 때 JSON 데이터를 직렬화하고 역직렬화에 활용되는 Jackson 지원     api 'io.github.openfeign:feign-jackson:12.2'      implementation project(':vw-core') }      그리고 Feign 클라이언트가 응답을 디코딩할 때 사용할 디코더를 정의하기 위해 Feign 클라이언트에 대한 설정 클래스 FeignConfig를 작성하였다.   package vw.infra.config.feign;  import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import feign.Logger; import feign.Retryer; import feign.codec.Decoder; import feign.jackson.JacksonDecoder; import java.util.concurrent.TimeUnit; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import vw.infra.outer.api.BaseFeignClientPackage;  @Configuration @EnableFeignClients(         basePackageClasses = BaseFeignClientPackage.class) // 해당 클래스가 위치한 패키지 밑에서 Feign 클라이언트를 탐색 public class FeignConfig { //  Feign 클라이언트가 응답을 디코딩할 때 사용할 디코더 정의     @Bean     public Decoder feignDecoder() {         return new JacksonDecoder(                 customObjectMapper()); // JSON 응답을 객체로 디코딩하기 위한 JacksonDecoder를 사용하도록 설정     }      public ObjectMapper customObjectMapper() { // ObjectMapper 객체를 커스터마이징 (객체 직렬화/역직렬화 설정을 변경)         ObjectMapper objectMapper = new ObjectMapper();          objectMapper.registerModule(                 new JavaTimeModule()); // 시간 관련 클래스들을 JSON으로 변환하고, JSON 데이터를 해당 클래스들로 역직렬화 가능하게 함          // JSON 직렬화 시에, Java Date나 Calendar 객체를 타임스탬프 형태로 출력하지 않음 -&gt; 일반적인 문자열 형태로 날짜를 표시         objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);          // JSON 역직렬화 시에, 알 수 없는 필드가 포함되어 있을 경우에도 역직렬화 작업을 진행시킴 -&gt; 해당 필드를 무시하고 나머지 필드들을 역직렬화         objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);          // JSON 역직렬화 시에, 날짜와 시간을 JSON 데이터에 포함된 그대로의 타임존으로 유지         objectMapper.configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false);          // JSON 역직렬화 시에, 알 수 없는 enum 값을 null로 처리함         objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, true);          return objectMapper; // 커스텀마이징한 ObjectMapper 객체를 반환     }      @Bean     Retryer.Default retryer() { // 재시도 (Retry) 설정         return new Retryer.Default(                 100L,                 TimeUnit.SECONDS.toMillis(3L),                 5); // 0.1초의 간격으로 시작해 최대 3초의 간격으로 점점 증가하며, 최대5번 재시도     }      @Bean     Logger.Level feignLoggerLevel() { // Feign의 로그 레벨을 설정         return Logger.Level.FULL; // FULL 레벨로 설정해 모든 요청과 응답에 대한 자세한 로그를 출력     } }      이때 FeignConfig 클래스의 feignLoggerLevel()에서 eign의 로그 레벨을 설정하고 있는데, Feign은 DEBUG 레벨로만 로그를 남길 수 있다. 그러므로 반드시 로그 레벨이 아래처럼 DEBUG로 설정이 되어 있어야 한다.   logging:   level:     com.mangkyu.openfeign.app.openfeign: DEBUG # feign에 대한 로깅 수준을 DEBUG로 설정 (가장 상세한 로그를 출력)   #21. feat(infra): redis 적용   레디스 (redis)는  “키-값” 구조의 비정형 데이터를 저장하고 관리하는 비관계형 데이터베이스 관리 시스템이다. 레디스는 인메모리 데이터베이스이면서 다양한 자료구조를 갖고 있어 다른 DBMS에 비해 더 빠르고 간단한 방법으로 데이터를 정렬할 수 있다. 이는 우리가 구현하고자 하는 회원가입의 인증 이메일 전송에서 필요한 정보들 (이메일, 인증 키)를 저장하기에 적합하다.      redis는 아마 서비스를 담당하는 Domain 모듈에서만 활용될 것으로 추측되지만, 우리 어플리케이션 외부에 존재하는 DBMS이다. 그러므로 외부 서비스를 담당할 Infra 모듈에 의존성을 추가하고 Redis 설정 클래스 또한 여기에 위치시키되, 이를 통해 구현될 레포지토리는 Domain 모듈에 위치시킬 생각이다.       dependencies {         // 'org.springframework.boot:spring-boot-starter-data-redis' : Redis에 필요한 모든 의존성들을 관리         api 'org.springframework.boot:spring-boot-starter-data-redis'     }      레디스에 대한 설정 클래스인 RedisConfig를 작성하였다. 여기에서는 Redis 연결 설정을 위한 Bean인 redisConnectionFactory와 Redis 데이터를 처리하는 데 사용될 RedisTemplate에 대한 Bean인 redisTemplate을 추가하였다.   package vw.infra.config.redis;  import java.time.Duration; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.connection.RedisStandaloneConfiguration; import org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.repository.configuration.EnableRedisRepositories; import org.springframework.data.redis.serializer.StringRedisSerializer;  @Configuration @EnableRedisRepositories( // redis와 관련된 Spring Data Repositories 활성화         basePackages = \"vw\") public class RedisConfig {     @Value(\"${spring.data.redis.host}\")     private String redisHost; // redis 호스트 주소      @Value(\"${spring.data.redis.port}\")     private int redisPort; // redis 포트 번호      @Value(\"${spring.data.redis.password}\")     private String redisPassword; // redis 비밀번호      @Bean // Redis 연결 설정을 위한 Bean 생성     public RedisConnectionFactory             redisConnectionFactory() { // RedisConnectionFactory : redis와의 연결을 관리하는 인터페이스         RedisStandaloneConfiguration redisStandaloneConfiguration =                 new RedisStandaloneConfiguration(redisHost, redisPort);          if (redisPassword != null &amp;&amp; !redisPassword.isBlank()) // redis에 비밀번호가 설정되어 있지 않으면 비밀번호를 설정         redisStandaloneConfiguration.setPassword(redisPassword);          // LettuceClientConfiguration을 생성하여 Redis 연결 설정 구성         LettuceClientConfiguration lettuceClientConfiguration =                 LettuceClientConfiguration.builder() // LettuceClientConfiguration의 builder 패턴 생성                         .commandTimeout(Duration.ofSeconds(1)) // redis 명령의 최대 실행 시간을 1초로 설정                         .shutdownTimeout(Duration.ZERO) // Redis 클라이언트의 종료 시간을 0초로 설정 (무한 대기)                         .build();          // LettuceConnectionFactory를 생성하여 Redis 연결 수립         return new LettuceConnectionFactory(                 redisStandaloneConfiguration, lettuceClientConfiguration); // 내장 혹은 외부의 redis 연결     }      @Bean // RedisTemplate을 Bean으로 생성     public RedisTemplate&lt;?, ?&gt; redisTemplate() { // RedisTemplate : Redis 데이터를 처리하는 데 사용         RedisTemplate&lt;byte[], byte[]&gt; redisTemplate = new RedisTemplate&lt;&gt;();         redisTemplate.setConnectionFactory(redisConnectionFactory());          // 일반적인 key:value일 경우에 직렬화         redisTemplate.setKeySerializer(new StringRedisSerializer());         redisTemplate.setValueSerializer(new StringRedisSerializer());          // Hash를 사용할 경우에 직렬화         redisTemplate.setHashKeySerializer(new StringRedisSerializer());         redisTemplate.setHashValueSerializer(new StringRedisSerializer());          return redisTemplate; // RedisConnection에서 넘겨준 byte 값 객체 직렬화     } }      앞서 내가 필요로 하는 기능인 회원가입 인증 이메일 전송에 필요한 데이터들은 휘발성이 강하면서도 빠른 접근을 요한다. 그러므로 레디스를 캐시로 사용할 수 있도록 redisCacheManager 클래스를 통해 캐시 기능을 활성화하고 이에 대한 설정을 작성하였다.   package vw.infra.config.redis;  import java.time.Duration; import org.springframework.cache.CacheManager; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.StringRedisSerializer;  @EnableCaching // 캐시 기능 활성화 @Configuration public class RedisCacheConfig {     @Bean     @Primary     public CacheManager redisCacheManager(RedisConnectionFactory cf) { // 기본 CacheManager를 설정         // redis 캐시의 기본 설정을 구성         RedisCacheConfiguration redisCacheConfiguration =                 RedisCacheConfiguration.defaultCacheConfig()                         .serializeKeysWith( // redis에서 키를 String으로 직렬화하도록 설정                                 RedisSerializationContext.SerializationPair.fromSerializer(                                         new StringRedisSerializer()))                         .serializeValuesWith( // redis에서 값을 JSON 형태로 직렬화하도록 설정                                 RedisSerializationContext.SerializationPair.fromSerializer(                                         new GenericJackson2JsonRedisSerializer()))                         .entryTtl( // Cache의 기본 TTL (Time-To-Live)을 1시간으로 설정                                 Duration.ofHours(1L));          // RedisConnectionFactory를 사용하여 RedisCacheManager를 생성         return RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(cf)                 .cacheDefaults(                         redisCacheConfiguration) // redis 캐시의 기본 설정을 지정한 RedisCacheConfiguration으로                 // 설정                 .build();     }      // OIDC (OpenID Connect) : 인증 및 권한 부여를 위한 프로토콜     @Bean     public CacheManager oidcCacheManager(RedisConnectionFactory cf) { // OIDC CacheManager를 설정         // OIDC Cache의 redis 캐시 설정을 구성         RedisCacheConfiguration redisCacheConfiguration =                 RedisCacheConfiguration.defaultCacheConfig()                         .serializeKeysWith( // redis에서 키를 String으로 직렬화하도록 설정                                 RedisSerializationContext.SerializationPair.fromSerializer(                                         new StringRedisSerializer()))                         .serializeValuesWith( // redis에서 값을 JSON 형태로 직렬화하도록 설정                                 RedisSerializationContext.SerializationPair.fromSerializer(                                         new GenericJackson2JsonRedisSerializer()))                         .entryTtl( // OIDC Cache의 기본 TTL을 7일로 설정                                 Duration.ofDays(7L));          // RedisConnectionFactory를 사용하여 RedisCacheManager를 생성         return RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(cf)                 .cacheDefaults(                         redisCacheConfiguration) // OIDC Cache 설정을 지정한 RedisCacheConfiguration으로 설정                 .build();     } }      그리고 레디스가 캐시 타입으로 지정될 수 있도록, 그리고 레디스에 대한 설정을 Github Secret을 통해 넣을 수 있게끔 yml 파일을 수정하자.   spring:   cache:     type:       redis # 캐시 타입을 redis로 지정     redis:       cache-null-values: true # 캐시에 null 값도 저장   data:     redis:       host: ${REDIS_HOST:localhost} # Redis 호스트 주소 설정 (환경 변수가 설정되지 않은 경우 기본값 localhost)       port: ${REDIS_PORT:6379} # Redis 포트 번호 설정 (환경 변수가 설정되지 않은 경우 기본값 6379)       password: ${REDIS_PASSWORD:} # Redis에 접속할 때 사용할 비밀번호 설정 (환경 변수가 설정되지 않은 경우 기본값 빈 문자열)   당연히 레디스를 설정하는 것만으로 끝나면 안된다! Redis 자체는 우리 어플리케이션 외부에 존재하므로, 실제로 개발을 진행중인 로컬 환경과 원격에 올라가 있는 AWS 환경에 Redis를 설치하고 이를 실행시켜 Redis를 우리 서비스에서 사용할 수 있게 하자.   #22. fix: IllegalArgumentException at PropertyPlaceholderHelper 해결   IllegalArgumentException at PropertyPlaceholderHelper는 사실 로컬에서 발생하는 오류는 아니다. Github Actions를 통해 돌리다 보면 어느 시점에서 어플리케이션이 죽었는데, 이때 발생한 오류다. gradle의 빌드 시에 application의 properties를 참조하지 못하는 부분이 있는 것 같았는데 알고 보니 하위 서비스를 scanBasePackages에 넣으면 안되는 것이었다… (같은 이름의 파일을 중복해서 읽어서 문제가 생기는 것? 으로 보인다.)   @SpringBootApplication( // '@SpringBootApplication' : 스프링 부트 애플리케이션의 주요 구성 요소들을 자동으로 설정         scanBasePackages = { // 'scanBasePackages={}' : Spring이 Component Scan을 수행할 패키지들을 지정             \"vw.api\"             // , \"vw.domain\", \"vw.infra\" // 제외한 부분         })   그리고 멀티모듈 프로젝트에서 자주 발생하는 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성 문제를 이때 같이 해결하였다. 매번 멀티모듈 프로젝트를 진행할 때마다 발생하는 부분인데, Core나 Infra 모듈처럼 어플리케이션이 없는 모듈은 순수 Jar 파일을 생성해야 하는 것 같다…?       // 멀티모듈 프로젝트에서 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성     bootJar.enabled = false     jar.enabled = tru   #23. fix(domain): User 도메인 제약조건 추가   원래 제약 조건은 DB 단에서 직접 설정해주곤 했었는데, JPA에서 엔티티를 자동으로 생성해주는 것을 보고 직접 코드로 넣어두는 것이 더 효율적으로 보여 이를 추가하였다.   - nullable // 빈 값 금지 - unique // 중복된 값 금지 - length // 길이 제한  ","categories": [],
        "tags": ["vocawik"],
        "url": "/vcw7/",
        "teaser": null
      },{
        "title": "[Docker] 2. Docker",
        "excerpt":"도커 (Docker) : 컨테이너 기반 가상화 (Container-based Virtualization)      Q. 도커를 쓰는 이유? : 비교적 효율적인 가상화 방식 + 통일된 개발 환경 + 배포의 동시성     Virtualization : 응용 프로그램 실행 시 운영체제 수준 가상화 방식이 성능 손실이 더 적고 빠르게 동작한다.   Development : 운영체제에 상관없이 같은 환경에서 개발할 수 있게 해준다.   Deployment : 서비스 환경과 응용 프로그램을 같이 배포할 수 있게 한다.           분산 어플리케이션을 클라우드 환경으로 이주한다고 가정하면,                IaaS : 서비스로서의 인프라                        어플리케이션을 구성하는 각 컴포넌트가 모두 가상 머신에서 독립적으로 동작             이주 과정은 쉽지만, 가상 머신의 성능을 모두 활용하지 못하며 운영비가 비쌈                             PaaS : 서비스로서의 플랫폼                        어플리케이션을 구성하는 각 컴포넌트가 클라우드 서비스 제공자의 매니지드 서비스에 종속             운영비가 저렴하고 관리가 쉬우나, 이주 과정이 복잡함                                       … 도커를 활용한다면? : 각 컴포넌트를 컨테이너로 이주하고, 쿠버네티스 등으로 전체 어플리케이션 관리 가능       공식 홈페이지에서 .dmg 파일을 다운로드 후 설치   터미널 창에 다음 명령어를 입력해 도커가 정상적으로 설치되었는지 확인   docker version // 현재 도커의 버전 확인  Client:  Cloud integration: ~  Version:           ~  API version:       ~  Go version:        ~  Server: ~  Engine:   Version:          ~   API version:      ~   Go version:       ~     Q. 클라이언트와 서버의 버전 정보가 따로 구성되어 있는 이유?         도커가 클라이언트와 서버의 역할을 각각 수행할 수 있음                리눅스 터미널에 도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 출력                  도커 컴포넌트 (Docker Component) : 도커 엔진을 중심으로 여러 컴포넌트를 조합해 구성           도커 엔진 (Docker Engine) : 도커 이미지를 생성하고 컨테이너를 관리             로컬 이미지 캐시 담당 : 새로운 이미지가 필요할 때 이미지를 다운로드하거나, 기존 이미지를 사용       Docker API을 통해 맡은 기능 수행 → 도커 명령행 인터페이스 (Docker CLI)에서 도커 API 호출                도커 레지스트리 (Docker REgistry) : 도커 이미지를 공개하고 공유             Docker 공식 레지스트리 서비스로 Docker Hub가 있음       클라우드 사업자 또한 AWS ECR, GCP Artifact Registry 등의 컨테이너 레지스트리 제공                도커 컴포즈 (Docker Compose) : 여러 컨테이너를 하나의 서비스로 정의해 컨테이너의 묶음으로 관리             여러 개의 컨테이너 구성 정보를 코드로 정의한 파일을 읽어 컨테이너를 순차적으로 생성                도커 머신 (Docker Machine) : 가상 호스트에 도커 엔진을 설치하여 호스트를 관리             여러 운영체제나 클라우드 환경에서 도커를 동일하게 실행하기 위해 도커의 실행 환경을 자동으로 생성                도커 스왐 (Docker Swarm) : 여러 도커 호스트를 클러스터화해 관리             Manger가 클러스트를 관리하거나 API를 제공하고, Node가 컨테이너를 실행           도커 명령어 (Docker Command) : docker &lt;command&gt; 형식으로 구성     리눅스 터미널에 도커 명령어를 입력하면 도커 서버에서 이에 해당되는 작업 수행   항상 root 권한으로 실행되기에 $ sudo를 앞에 붙어야 함   sudo usermod -aG docker $USER # 현재 사용자를 docker 그룹에 추가                                               docker 명령어                 명령어 형식                 명령어 설명                                                             docker search                 $ docker search [이미지]                 도커 허브에서 이미지 검색                                           docker pull                 $ docker pull [사용자명/] 이미지 [:태그]                 도커 허브에서 이미지 다운로드 사용자명을 지정해 도커 허브에서 해당 사용자가 올린 이미지을 다운로드 태그로 버전을 지정해 다운로드 (latest : 최신 버전)                                           docker images                 $ docker images                 사용 가능한 모든 이미지 목록 확인                                           docker rmi                 $ docker rmi 이미지 [:태그]                 다운로드한 이미지 삭제 태그로 버전을 지정해 다운로드 (latest : 최신 버전)                                           docker run                 $ docker run [옵션] [실행할 이미지]                 이미지를 컨테이너로 생성한 뒤 컨테이너 실행 입력받은 이미지가 현재 없다면, 해당 이미지를 도커 허브에서 다운로드 실행할 파일을 지정해 직접 실행 가능 (여기서 빠져나오면 컨테이너가 정지)                                             docker run 옵션                 옵션 설명                                                             -d                 백그라운드 모드 (detached mode)                                           -p [호스트 포트:컨테이너 포트]                 호스트와 컨테이너의 포트를 연결 (port forwarding) http://호스트 IP:호스트 포트로 컨테이너의 포트 접속                                           -v [호스트의 디렉터리]                 호스트의 디렉터리를 컨테이너의 디렉터리에 연결 (mount)                                           -e [환경변수]                 컨테이너 내에서 사용할 환경변수 설정 (environment variable)                                           --name [컨테이너 이름]                 컨테이너 이름 설정 (container name)                                           -rm                 프로세스 종료 시 컨테이너 자동으로 제거 (remove container)                                           -link [컨테이너 이름:주소]                 컨테이너와 컨테이너 연결 (link container) [주소:포트번호]로 컨테이너에 접속                                           -it                 리눅스 터미널 입력을 위한 옵션 (interactive / Pseudo-tty)                                                                      docker ps               $ docker ps [옵션]               실행중인 모든 컨테이너 목록 확인 -a 옵션으로 정지된 컨테이너까지 모두 검색                                         docker start               $ docker start [컨테이너 이름 | 컨테이너 ID]               정지된 컨테이너 재시작                                         docker stop               $ docker exec [컨테이너 이름 | 컨테이너 ID]               실행 중인 컨테이너 정지                                         docker attach               $ docker attach [컨테이너 이름 | 컨테이너 ID]               실행 중인 컨테이너에 접속                                         docker exec               $ docker exec [컨테이너 이름 | 컨테이너 ID] [명령] [매개 변수]               컨테이너 외부에서 컨테이너 내의 명령 실행                                         docker diff               $ docker diff [컨테이너 이름 | 컨테이너 ID]               컨테이너가 실행되면서 변경된 파일 목록 확인 A : 추가된 파일 C : 변경된 파일 D : 삭제된 파일                                         docker cp               $ docker cp [컨테이너 이름 | 컨테이너 ID] [:컨테이너 경로] [호스트 경로]               컨테이너의 파일을 호스트의 디렉토리로 복사                                         docker attach               $ docker attach [컨테이너 이름 | 컨테이너 ID]               실행 중인 컨테이너에 접속                                         docker rm               $ docker exec [컨테이너 이름 | 컨테이너 ID]               생성된 컨테이너 삭제                                         docker commit               $ docker commit [옵션] [컨테이너 이름 | 컨테이너 ID] [이미지 이름] [:태그]               컨테이너를 이미지 파일로 생성                                         docker build               $ docker build [옵션] [도커 파일 경로] [--tag 이미지 이름 : 이미지 태그]                도커 파일에 설정된 내용대로 도커 이미지 생성 --tag 뒤에 이미지 이름와 이미지 태그를 설정할 수 있음                                         docker history               $ docker history [이미지 이름 | 이미지 ID] [:태그]               도커 파일에 설정된 내용대로 이미지 히스토리 생성                                         docker inspect               $ docker inspect [이미지나 컨테이너 이름 | 이미지나 컨테이너 ID]               이미지나 컨테이너의 세부 정보 출력                              ","categories": [],
        "tags": ["Docker"],
        "url": "/docker2/",
        "teaser": null
      },{
        "title": "[Docker] 3. Docker Container",
        "excerpt":"도커 컨테이너 (Docker Container) : 도커에서 제공하는 컨테이너 기술      해당 부분에서 이어지는 내용입니다. 이전 내용에서는 가상화의 한 종류인 컨테이너 기술에 대해 서술하였다면, 이번에는 도커를 중심으로 하여 컨테이너에 대해 다뤄보겠습니다.    도커 컨테이너는 도커가 관리하는 독립적인 가상 리소스를 가진다.     컨테이너 안에는 어플리케이션과 그 어플리케이션의 실행 환경 (호스트명, IP 주소, 디스크 드라이브 등)이 들어있음            각 컨테이너는 독립적인 환경을 가지되, 실행되는 컴퓨터의 CPU, 메모리, 운영체제를 공유함                    격리 (isolation)와 밀집 (density)의 조건을 동시에 충족           빌드 - 공유 - 실행의 workflow으로 소프트웨어 배포를 단순화하기에 적합                                 컨테이너 내부 어플리케이션이 실행중이여야 컨테이너의 상태도 실행 중이 된다.            컨테이너가 Existed인 상태에서는 CPU 자원이나 메모리를 사용하지 않는다.           컨테이너가 종료되어도, 컨테이너는 사라지지 않고 그대로 남아있다.            나중에 다시 컨테이너를 실행하거나, 내부 파일이나 로그를 확인해볼 수 있다.       컨테이너를 백그라운드에서 계속 동작하도록 하려면, -d (--detach)           컨테이너는 기본적으로 외부 환경에 노출되지 않는다.            도커는 호스트 컴퓨터의 네트워크 계층에 끼어들어 네트워크 트래픽 중 필요한 것을 컨테이너에 전달       컨테이너의 포트를 호스트 컴퓨터에 공개하려면, --publish                    도커가 호스트 컴퓨터를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너에 전달                           도커 컨테이너 또한 별도의 환경 변수 (Environment variable)를 가질 수 있다.     호스트 운영체제의 것을 가져오는 것이 아닌, IP 주소나 호스트 이름처럼 도커로부터 부여받음   도커 이미지 (Docker Image) : 컨테이너의 실행에 필요한 모든 파일과 설정값 정보를 포함     상태값을 가지지 않음 (변하지 않는 값들을 저장) ↔ 컨테이너 : 이미지가 실행된 살태 (변하는 값들을 저장)   이미지 레이어 : 도커 이미지는 여러 Read-Only 레이어로 구성되고, 파일 추가 및 생성 시 새로운 레이어 생성            이미지 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일로, 여러 이미지와 컨테이너에서 공유함       유니온 파일 시스템 (Union File Systems)읕 통해 여러 개의 레이어를 하나의 파일 시스템으로 활용                   docker image ls에서 도커 이미지의 SIZE는 논리적 용량이지 실제로 차지하는 디스크 용량이 아니다!                 docker system df를 통해 이미지 전체 용량의 총합을 볼 수 있다.              컨테이너 레이어 : 컨테이너가 실행되면 이미지 레이어 위에 읽기-쓰기 (Read-Write) 레이어를 추가            컨테이너를 실행하면서 생성되거나 변경된 내용을 저장           이미지 경로 : URL 방식으로 관리 -&gt; 뒤에 태그 (/tag)를 붙임   Q. 도커 이미지를 쓰는 이유? : 도커 이미지와 도커 컨테이너들을 클래스나 인스턴스처럼 활용한다.     도커는 해시 값 (= 컨테이너 ID)과 임의의 이름 (= 컨테이너 이름)를 통해 컨테이너를 구분하고 이들을 환경변수로 관리    운영자가 지금까지 운영한 서버를 도커 이미지로 배포하고 도커 컨테이너에 설치한다면,    도커 파일 : 지금까지 서버를 운영한 기록   도커 이미지 (도커 파일 + 실행 시점) : 지금부터 설치된 서버가 가질 초기값   도커 컨테이너 (도커 파일 + 환경 변수) : 지금부터 설치된 서버가 운영될 장소      도커 안에서는 서버 역시 하나의 소프트웨어처럼 사용할 수 있고, 생성할 수 있는 컨테이너의 개수에도 제한이 없다.   도커 허브 (Docker Hub) : 도커 이미지를 서버에 공유하는 도커 레지스트리 서비스      도커 허브 계정을 생성한 후, 터미널을 통해 도커 허브에 접속   docker login --username pocj8ur4in Password: Login Succeeded      도커 이미지의 다운로드를 위한 이미지 참조 (Image Reference)는 네 개의 요소로 구성            이미지가 저장된 레지스트리 도메인 (기본값은 도커 허브)       이미지 작성자 계정 ID       이미지 레포지토리 ID       이미지 태그 (기본값은 latest)           docker.io/diamol/golang:latest      이미지에 새로운 이미지 참조를 부여하여, 한 이미지에 여러 개의 참조를 갖게 할 수도 있음   docker image tag new-tag pocj8ur4in/vw-api:latest   사설 도커 레지스트리 (Private Docker Registry) : 로컬에 전용 레지스트리를 설치 및 운영  ","categories": [],
        "tags": ["Docker"],
        "url": "/docker3/",
        "teaser": null
      },{
        "title": "[Docker] 4. Docker File",
        "excerpt":"도커 파일 (Dockerfile) : 서버 운영 기록을 코드로 저장한 파일을 특정 시점의 도커 이미지로 빌드           눈송이 서버 (Snowflakes Server) : 각 서버마다 운영 기록이 달라 서로 모양이 다른 서버들이 공존하는 상황       … 서버 간의 운영체제, 컴파일러, 설치된 패키지 등의 차이로 발생하는 문제 개선을 위해 서버 운영 기록을 저장하자!    도커 파일을 생성하는 과정은 테스트 주도 개발의 순환에 부합하다고 볼 수 있다.     테스트 주도 개발 (Test Driven Development) : 선 테스트 후 개발 사이클을 반복하는 개발 방법론       테스트를 작성한다. → 도커 파일을 만든다.   테스트에 실패하고 코드를 수정한다. → 도커 이미지의 빌드에 실패하고 도커 파일을 수정한다.   테스트에 성공한다면, 코드를 리펙터링한다. → 도커 이미지의 빌드에 성공한다면, 도커 파일의 내용을 리펙터링한다.   처음으로 되돌아간다.    DSL (Domain-Specific Language) : 도커 파일을 작성할 때 쓰는 언어 (도커 이미지의 생성 과정 표현)     생성 과정을 표현? : 도커 파일은 일련의 인스트럭션을 실행된 결과로 도커 이미지를 생성한다.         도커 파일의 인스트럭션과 이미지 레이어는 1:1의 관계를 가진다.                FROM : 다른 컨테이너 이미지를 빌드의 시작점으로 지정             AS: 컨테이너에 이름을 붙일 수 있음                ENV : 컨테이너 내에서 사용될 환경 변수를 지정            WORKDIR : 컨테이너 이미지의 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정            COPY : 로컬의 파일 시스템 내 파일, 디렉터리를 컨테이너 이미지로 복사             --from= : 해당 파일이 호스트 컴퓨터가 아닌 다른 컨테이너의 파일임을 알려줌                CMD : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정            RUN : 빌드 과정에서 컨테이너 안에서 명령을 실행한 다음에 그 결과를 이미지 레이어에 저장       Q. 도커 파일을 쓰는 이유?   A1. 동일한 환경에서 어플리케이션을 실행 가능하게 한다.     모든 빌드 과정은 도커 컨테이너 내부에서 이루어지며, 각 컨테이너는 모든 도구를 정확한 버전으로 갖추고 있다.            신규 개발자의 적응 기간, 빌드 서버의 관리 부담, 개발자 간의 도구 버전의 차이로 인한 빌드 실패를 줄일 수 있다.           A2. 멀티 스테이지 환경에서 각 단계는 자신만의 캐시를 가져 성능을 향상시킬 수 있다.     도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.            만약 해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당하는 단계 안으로 국한된다.       이어지는 다음 단계는 캐시를 재사용하면서 시작되므로, 캐시 재사용을 통해 빌드 단계에서 시간 절약이 가능하다.           A3. 멀티 스테이지 스크립트를 통해 최종 산출물의 크기를 가능한 한 작게 유지할 수 있다.     최종 산출물인 도커 이미지에 불필요한 도구를 제외하여 어플리케이션의 의존 모듈 자체를 줄일 수 있다.  ","categories": [],
        "tags": ["Docker"],
        "url": "/docker4/",
        "teaser": null
      },{
        "title": "[JPA] 1. JPA",
        "excerpt":"개발자가 SQL을 직접 다룰 때의 문제           DB는 객체 구조와는 다른 데이터 중심의 구조를 가져 객체를 DB에서 직접 저장하거나 조회할 수 없음             개발자가 객체지향 어플리케이션과 DB 중간에서 SQL과 JDBC API를 이용해 변환해야 함       객체를 DB에 CRUD하기 위해서 너무 많은 SQL과 JDBC API를 코드로 작성해야 함                DAO를 이용해 SQL를 은닉해도 결국엔 SQL에 의존적인 개발이 될 수 밖에 없음             개발자가 엔티티를 신뢰하고 사용할 수 없음… 이게 진정한 계층 분할?              그럼, JPA는 어떻게 문제를 해결하였는가?          객체를 DB에 저장하고 관리할 때 JPA가 제공하는 API 사용                저장 → persist() : 객체를 DB에 저장하면, INSERT SQL를 생성해서 DB에 전달         조회 → find() : 객체 하나를 DB에서 조회하면, SELECT SQL를 생성해서 DB에 전달         수정 → 객체를 조회해 값을 변경하면, 트랜잭션을 커밋할 때 UPDATE SQL를 생성해 DB에 전달         연관 객체 조회 → 연관된 객체를 사용하는 시점에 SELECT SQL를 실행                  객체와 관계형 데이터베이스의 패러다임 불일치     객체지향 프로그래밍 : 추상화, 캡슙화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치 제공   비즈니스 요구사항을 정의한 도메인 모델 또한 객체로 모델링 → 객체와 관계형 데이터베이스는 지향하는 바가 다르다!           상속 : 객체는 상속이라는 기능을 가지지만, 테이블은 상속이라는 기능이 없음             데이터베이스 모델링의 슈퍼타입-서브타입 관계를 이용한다고 해도, 매번 2가지 SQL를 만들어야 함                연관관계 : 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조에 접근해서 조회             그러나 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 이용해서 연관된 테이블을 조회       그럼 객체를 테이블에 맞추어 모델링하면? : 외래 키와 참조의 예 → 객체지향의 장점을 잃어버릴 수 있다!                객체 그래프 탐색 : 객체에서 회원이 소속된 팀을 조회할 때에는 참조를 사용해 연관된 팀을 탐색             그런데 참조를 통해 팀을 탐색할 수 있을지 없을지 알 수 없음 → 너무나 큰 제약사항                    결국 DAO를 통해 SQL을 직접 확인하기 위해 상황에 따른 여러 메소드를 만들어야 함                                비교 : 데이터베이스는 기본 키의 값으로 각 row를 구분하지만, 객체는 동일성 비교, 동등성 비교를 활용             동일성 비교 (==) : 객체 인스턴스의 주소 값을 비교, 동등성 비교 (equals()) : 객체 내부의 값을 비교                    기본 키 값이 같은 객체를 2번 조회했을 때, 이 객체들이 다른 인스턴스면 동등하되 동일하지 않다.                              그럼, JPA는 어떻게 문제를 해결하였는가?          상속 → 자바 컬렉션에 객체를 저장하듯이 JPA에 객채를 저장하면 이를 두 테이블에 나눠 저장     연관관계 → 개발자가 관계를 설정해 객체를 저장하면, 참조를 외래 키로 변환해 INSERT SQL 전달     객체 그래프 탐색 : 실제 객체를 사용하는 시점까지 DB 조회를 미루는 지연 로딩 이용     비교 : 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장      JPA (Java Persistence API) : 자바 진영의 ORM 기술 표준     ORM (Object-Relational Mapping) : 객체와 관계형 DB를 매핑   왜 JPA를 사용해야 하는가?     생산성 : 반복되는 CRUD용 SQL 코드를 작성하는 대신, 자바 컬렉션에 객체를 저장하듯 JPA에 객체를 전달하면 됨   유지보수 : 매번 SQL과 JDBC API 코드를 변경할 필요 없음   패러다임의 불일치 해결 : ORM 프레임워크가 상속, 연관관계, 객체 그래프 탐색, 비교 등의 문제를 대신 해결   성능 : 어플리케이션과 DB 사이에서 동작하면서 다양한 성능 최적화 기회를 제공   데이터 접근 추상화 및 벤더 독립성 : DB 접근 계층을 제공해서 특정 DB 기술에 종속되지 않음      References          자바 ORM 표준 JPA 프로그래밍     ","categories": [],
        "tags": ["JPA"],
        "url": "/jpa1/",
        "teaser": null
      },{
        "title": "[MicroService] 1. MicroService",
        "excerpt":"비즈니스 민첩성 : 자신의 특화된 서비스를 빠르게 제공하고, 피드백을 반영해 서비스를 빠르게 개선      빠른 배포 주기 : 비즈니스 민첩성을 간접적으로 보여주는 지표 → 어떻게 빠른 비즈니스 속도를 가질 수 있을까?   클라우드 인프라 (Cloud Infra)의 등장 : 아마존의 AWS, 구글의 구글 클라우드 플랫폼     비용 측면 : 클라우드의 사용량에 따라 비용을 유연하게 조정할 수 있음 → 사용한 만큼만 비용을 지불   어플리케이션 측면 : 어플리케이션을 여러 개의 블록처럼 관리해 효율성을 극대화            사용량 증가에 따른 성능 및 가용성을 Scale-up, Scale-out → 특정 부분만 탄력성 있게 확장 가능           어떤 서비스가 클라우드 인프라에 적합할까 : 클라우드 프랜들리? 클라우드 네이티브?     클라우드 프렌들리 (Cloud Friendly) : 시스템을 하나의 큰 덩어리로 만들어 클라우드 인프라에 올리는 것   클라우드 네이티브 (Cloud Native) : 시스템을 여러 개의 블록 단위로 나누어 클라우드 인프라에 올리는 것   마이크로서비스 (MicroService) : 여러 서비스 인스턴스가 하나의 비즈니스 어플리케이션 구성     서비스가 갖는 저장소가 각각 다르므로 업무 단위로 모듈 경계가 명확하게 구분            확장하거나 변경할 때에는 특정 기능별로 독립적으로 작업한 뒤에 빌드해서 배포하면 됨       각 서비스가 독립적이기에 서로 다른 언어, 데이터, 기술로도 개발 가능 → 폴리글랏 (Polyglot)              마이크로서비스 이전에는? : 모노리스 (Monolith)         전체 시스템이 하나의 단위로 개발되는 일체식 어플리케이션     일반적으로 클라이언트, 어플리케이션, 데이터베이스의 3-tier 시스템으로 구성     아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 함     단일 프로세스에서 실행되므로, 확장이 필요할 경우에 전체 어플리케이션을 동시에 확장해야 함                로드밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 스케일 아웃                  마이크로서비스를 위한 조건은 무엇인가?           업무 기능 중심 팀             콘웨이 법칙 (Conway’s law) : 시스템을 개발할 때 항상 시스템의 모양이 팀 의사소통 구조를 반영                    마이크로서비스를 만드는 팀은 역할이나 기술이 아닌, 업무 기능을 중심으로 한 팀이 되어야 함                       기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자, 테스터 등 다양한 역할의 인원으로 구성                    서비스를 처음부터 끝까지 만들기 위한 모든 단계의 역할을 갖추고 있음           같은 공간, 같은 시간을 공유하기에 의사소통이 원활하고 빠르게 진행할 수 있음           여러 기능들이 모여 있다는 의미에서 다기능 팀 (Cross-Functional Team)이라고도 부름                                자율적인 분권 거버넌스             각 마이크로서비스 팀은 빠르게 서비스를 만드는 것을 최우선 목적으로 함                    중앙의 강력한 표준이나 절차 준수를 강요받지 않음           스스로 효율적인 방법론과 도구, 기술을 찾아 적용 → 폴리글랏 프로그래밍, 폴리글랏 저장소                                제품 중심의 생명 주기             개발 모델이 프로젝트 단위가 아니라 제품 단위로 구성됨 → 개발 조직과 운영 조직이 결합       소프트웨어를 완성해야 할 기능들의 집합이 아닌, 비즈니스를 제공하는 제품 (Product)로 봄                    우선 빠르게 개발한 뒤에 반응을 보고 개선하는 방식으로 개발           프로젝트 형태의 워터풀 (WaterFall) 개발 방식이 아닌, 제품 중심의 에자일 (Agile) 개발 방식 채용           2~3주 단위의 스프린트 (Sprint)를 통해 소프트웨어에 피드백을 즉각적으로 반영                                CI/CD 파이프라인의 자동화             개발과 운영을 동시에 수행하는 데비옵스 (DevOps)를 궁극적으로 가능하게 함       각각의 CI/CD 파이프라인 프로세스는 CI/CD 파이프라인 도구를 통해 자동화가 이루어짐                    ‘Infrastructure as Code’ : 코드를 이용해 인프라 구성부터 어플리케이션 빌드 및 배포를 정의                                분권 데이터 관리             폴리글랏 저장소 (Polyglot Persistence) 접근법 : 서비스별로 데이터베이스를 갖도록 설계                    각각의 저장소가 서비스별로 분산되어 있으며, 다른 서비스에 API를 통해 접근함                       결과적 일관성 (Eventual Consistency) : 일시적으로 다른 두 서비스의 데이터가 결국엔 동일해짐                    여러 트랜잭션을 하나로 묶지 않고, 별도의 로컬 트랙잭션을 수행           각 저장소 내 데이터의 비즈니스 정합성을 위해 데이터 일관성이 다른 부분을 보상 트랙잭션으로 맞춤                                내결함성을 고려한 설계             내결함성 (Fault Tolerance) : 시스템은 언제든 실패할 수 있는 가능성이 존재한다.                    시스템이 실패해서 더는 진행할 수 없을 때에도, 자연스럽게 대응할 수 있도록 설계하여야 함                       다양한 실패에 대비해 완벽히 테스트할 수 있는 환경을 마련해야 함       시스템의 실패를 감지하고 대응하기 위한 실시간 모니터링 체계 또한 갖춰야 함       장애를 일부러 발생시키는 카오스 몽키 (Chaos Monkey)를 만들어 아키텍처 동작을 점검하기도 함              Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice1/",
        "teaser": null
      },{
        "title": "[MicroService] 2. MSA",
        "excerpt":"마이크로서비스 아키텍처 (MSA) : 마이크로서비스를 접목한 아키텍처 구조      클라우드 인프라와 접목해 아마존, 넷플릭스에 의해 구체화 → 비즈니스 성공 사례   각 서비스는 개별 프로세스에서 실행되며, HTTP API를 통해 통신   각 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용해 독립적으로 배포      마이크로서비스 아키텍처 (MSA)와 서비스 지향 아키텍처 (SOA)의 비교         SOA : 컴포넌트를 모아 비즈니스적으로 의미있고 완결적인 서비스 단위로 모듈화                SOA와 MSA의 공통점 : 비즈니스 서비스의 집합으로 시스템을 개발         SOA와 MSA의 차이점 : 이론적인 SOA와 달리, MSA는 클라우드 인프라와 접목해 구체화                     MSA 내부 아키텍처 : API, 비즈니스 로직, 이벤트 발행, 데이터 처리의 구조화 등 MSA 내부 구조를 정의한 것   MSA 외부 아키텍처 : 인프라, 플랫폼, 어플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것   리액티브 선언 (The Reactive Manifesto) : 어플리케이션이 요청에 즉각 응답하고 가동되길 기대     응답성 (Responsive) : 사용자에게 신뢰성 있는 응답을 빠르고 적절히 제공하는 능력   탄력성 (Resilient) : 장애가 발생하더라도 시스템 전체에 영향을 주지 않고 복구하는 능력   유연성 (Elastic) : 사용량에 변화가 있더라도 그에 비례해 자원을 조절해 균일한 응답성을 제공하는 능력   메시지 기반 (Message Driven) : 비동기 메시지로 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향   → 4가지 요건을 만족하는 시스템을, 급변하는 상황을 적응할 수 있는 리엑티브 시스템 (Reactive System)이라 정의   강결합에서 약결합의 아키텍처로의 변화     소프트웨어 아키텍처 : 소프트웨어를 구성하는 요소와 그 구성 요소 간의 관계를 정의한 것            아키텍처를 정의하는 과정 : 시스템 구축을 위한 여러 비기능 요건들을 만족하는 해결 방법을 찾는 과정                    비기능 요건 : 시스템 성능, 시스템 가용성, 보안, 유지보수성, 확장성 등                       마이크로서비스 아키텍처는 ‘클라우드’라는 가상화된 인프라를 활용한 것이므로, 이를 고려해 설계해야 함           아키텍처 유연성 (Architecture Flexibility) : 시스템 자체가 변화 및 확장에 언제든지 대응할 수 있는 능력            시스템을 구성하는 구성 요소 간의 관계들이 느슨하게 결합되어 언제든지 대체되거나 확장될 수 있음       리액티브 시스템이 리액티브하기 위해서 반드시 갖춰야 할 특성 중 하나       클라우드 인프라 자체가 유연성과 확장성을 갖추므로, 어플리케이션 아키텍처 또한 아키텍처 유연성이 필요                과거 : 아키텍처 구성 요소들이 특정 벤더의 제품에 전적으로 의존            유명한 제품군을 사용함으로 품질이 보장될 수 있음       특정 기술에 락인 (lock-in)되어 시스템을 쉽게 변경하거나 확장하기 어려움           현재 : 클라우드 환경 아래에서 사용하는 오픈 소스 기반 제품들이 충분한 기능, 품질, 호환성을 제공            아키텍처 설계가 필요한 레이어에서 적절한 솔루션을 선택하고 이를 조합하는 개방적 방식으로 변화       클라우드 기반 어플리케이션의 구축에 필요한 인프라 및 어플리케이션 영역에 다양한 제품들이 등장           MSA 패턴 : MSA의 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 스타일 혹은 패턴     인프라 구성 요소 : 마이크로서비스를 지탱하는 인프라스트럭처를 구축하는 데에 필요한 구성 요소   플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴   어플리케이션 패턴 : 마이크로서비스 어플리케이션을 구성하는 데에 필요한 패턴   인프라 구성 요소를 서비스 유형별로 나누어 해당되는 제품 중 하나를 의사결정 → 클라우드 인프라     IaaS (Infrastructure as a Service) : 가상 머신, 스트리지, 네트워크 등 인프라 제공            고객이 관리할 수 있는 범위가 가장 넓은 클라우드 컴퓨팅 서비스       AWS 등 퍼플릭 클라우드 공급 업체 (CSP)가 준비한 환경을 고객이 선택할 수 있음       가상화된 물리적 자원을 UI 형태의 대시보드 혹은 API 형태로 제공       고객은 서버와 스트리지에 접근할 수 있지만, 클라우드 내 가상 데이터 센터를 통해 리소스를 전달받는 형태       개발자는 운영체제와 어플리케이션을 직접 관리해야 함 : 개발자와 인프라 관리자의 역할이 분담       예시 : AWS EC2, AWS S3           CaaS (Container as a Service) : 업로드, 구성, 실행, 확장, 중지할 수 있는 컨테이너 제공            가상 머신이 아닌 컨테이너를 기본 리소스로 활용해 어플리케이션을 개발, 실행, 관리       컨테이너화된 어플리케이션을 빌드하고 배포하는 개발 환경은 퍼플릭 클라우드 공급 업체 (CSP)가 제공       예시 : Kubernetes Service, AWS ECS           PaaS (Platform as a Service) : 어플리케이션에 미들웨어, 런타임까지 탑재한 플랫폼을 제공            가상화된 클라우드 위에 원하는 서비스를 개발할 수 있도록 개발 환경을 미리 구축해 서비스 형태로 제공       고객은 개발 환경을 고려할 필요 없이 어플리케이션 자체에 집중할 수 있음       어플리케이션이 플랫폼에 종속되어 개발되므로, 다른 플랫폼으로의 이식이 어려울 수도 있음       예시 : Lambda, AWS Elastic Beanstalk           시스템의 기반이 되는 인프라 레이어의 구축 → 베어메탈 장비 혹은 가상 인프라 환경을 통한 구축     가상 인프라 환경 : 하이퍼바이저 (Hypervisor)의 사용 여부 및 게스트 OS 유무에 따라 나뉨            가상 머신 (VM) : 하이퍼바이저를 통해 하나의 시스템에서 여러 운영체제를 사용                    운영체제 패치 및 관련 라이브러리 설치로 인한 오버헤드가 지속적으로 발생                       컨테이너 (Container) : 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성                    도커 (Docker) : 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 제어                            이식성 : 도커만 실행할 수 있으면 호스트 커널에 상관없이 동일하게 사용               신속성 : 크기가 작고 가벼워 빠른 배포가 가능 + 문제 발생 시 다시 가동하면 됨               재사용성 : 동일한 환경을 재사용해 쉽게 설정 가능 → 서버 환경 구축이 쉬워짐                                               컨테이너 오케스트레이션 (Container Orchestration) : 컨테이너 관리 기술                    컨테이너 배치 및 복제, 확장 및 축소, 장애 복구 컨테이너 간 통신, 로드밸런싱 등           쿠버네티스 (Kubernetes) : Pod, Deployment, Replica Sets 정보 확인 가능                            각 컨테이너가 요구하는 자원을 쿠버네티스에 요청하면 노드에 맞춰 자동 배치               컨테이너 이상을 점검해, 실패하면 컨테이너를 자동으로 교체하고 리스케줄링               일정량의 CPU 및 메모리 사용량을 초과하면 자동으로 수평 확장                                                   마이크로서비스의 운영과 관리를 지원할 클라우드 플랫폼 (미들웨어)의 구축 → 플랫폼 패턴     데비옵스 (DevOps) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화            소프트웨어를 빠르게 개발하게끔 지원하는 빌드, 테스트, 배포를 위한 자동화 환경       지속적 제공 (CI) : 빌드된 소스 코드의 실행 파일을 실행 환경에 반영하기 전에 진행       지속적 배포 (CD) : 저장소에 빌드한 소스 코드의 실행 파일을 실행 환경까지 자동으로 배포              자동 빌드 및 배포 절차         매일 자신이 작성한 소스 코드와 이를 테스트할 테스트 코드를 형상관리 시스템에 보낸다. (Push)     매일 빌드 도구에서 형상관리 서버의 코드를 가져와 (Pull) 통합하고, 자동으로 빌드하고 테스트를 수행한다.     테스트 수행 결과를 리포트에 기록하고, 빌드된 소스 코드를 스테이징 환경에 자동으로 배포한다.     테스터가 스테이징 환경에서 테스트를 수행할 때 혹은 리포트 결과에 문제가 있으면, 소스 코드를 수정한다.         빌드·배포 파이프라인의 설계 : 빌드·배포 과정동안 수행해야 할 업무 (task)를 정의한 것            리포지토리에서 소스 코드를 가져와 빌드해 실행 파일을 만드는 작업       이전 작업이 성공하면, 다음 작업이 자동으로 수행히게끔 위의 작업들을 관리하는 작업       실행할 어플리케이션을 실행 환경에 배포하는 작업           → IaaS를 통해 빌드·배포 파이프라인의 절차를 완벽하게 자동화할 수 있음          Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice2/",
        "teaser": null
      }]
