var store = [{
        "title": "[HTML] HTML & HTML 태그",
        "excerpt":"HTML (HyperText Mark-up Language) : 웹 문서의 구조를 기술하는 마크업 언어         하이퍼링크 (hyperlink) : 문서 내 어떤 요소와 다른 요소 간의 비선형적 (nonlinear) 연결   하이퍼텍스트 (hypertext) : 하이퍼링크를 통해 상호 연결되어 네트워크처럼 구성된 문서   &lt;html&gt; &lt;head&gt; \t&lt;div style=\"color: blue; font-size: 15px;\"&gt; \t\tHello World! \t&lt;/div&gt; &lt;/head&gt; &lt;/html&gt;    \t \t\t \t\t\tHello World! \t\t \t      HTML 요소 (HTML Elements) : HTML 문서나 웹 페이지를 이루는 개별적인 부분            HTML 태그 (HTML Tags) &lt;tag&gt;&lt;/tag&gt; : 요소의 시작과 끝을 나타내 문서의 구조를 명시하는 마크업 기호                    HTML 속성 (HTML Attributes) &lt;tag element=\"\"&gt; : 여는 태그 내에서 명령어를 구체화하는 속성                            HTML 변수 (HTML Arguments) &lt;tag element=\"value\"&gt; : 태그 내의 속성에 해당되는 인자                                                   HTML 내용 (HTML Contents) : HTML 문서를 통해 화면에 표시될 내용   # HTML 전역 속성 (HTML Global Attributes) : 모든 HTML 요소에서 사용 가능한 속성   class와 id  : CSS나 JavaScript에서 요소를 선택하거나 접근할 때 사용하는 속성     클래스 (class=\"\") : HTML 문서에서 정의된 요소의 별칭   아이디 (id=\"\") : HTML 문서에서 정의된 고유한 식별자   &lt;div class=\"class\"&gt; \t&lt;div id=\"id\"&gt; \t  class &amp; id \t&lt;/div&gt; &lt;/div&gt;   lang : 웹 문서의 텍스트가 어떤 언어로 작성되었는지 나타내는 속성   &lt;p lang=\"ko\"&gt;한글&lt;/p&gt; &lt;p lang=\"en\"&gt;english&lt;/p&gt;   한글  english   style : 요소에 적용할 CSS을 나타내는 속성   &lt;div style=\"color: white; font-size: 15px; background-color: black;\"&gt; \t&lt;a href=\"https://pocj8ur4in.github.io\" target=\"_blank\" title=\"pocj8ur4in\"&gt;   \t  pocj8ur4in \t&lt;/a&gt; &lt;/div&gt;             pocj8ur4in      title : 요소의 설명을 나타내는 속성   &lt;p title=\"pocj8ur4in\"&gt;pocj8ur4in&lt;/p&gt;   pocj8ur4in   # 범위 관련 HTML 태그   &lt;html&gt;&lt;/html&gt; : HTML으로 작성된 문서임을 선언하는 태그     &lt;!DOCTYPE html&gt; : 마크업 언어에서의 문서 형식을 정의하는 태그            DTD 태그 (Document Type Definition)       웹 브라우저의 렌더링 엔진이 관용 모드 (Quirks Mode)가 아닌 표준 모드로 렌더링       HTML5`` :&lt;!DOCTYPE html&gt;```으로 선언           &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; ... &lt;/html&gt;   &lt;head&gt;&lt;/head&gt; : 웹 문서의 속성을 선언하는 태그     실제 웹 브라우저 화면 상에는 출력되지 않는 HTML 문서의 정보들을 넣음   &lt;!DOCTYPE html lang=\"ko\"&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; ... &lt;/head&gt; ... &lt;/html&gt;   &lt;body&gt;&lt;/body&gt; : 웹 문서의 모양을 선언하는 태그     실제 웹 브라우저 화면 상에는 출력되는 HTML 문서의 레이아웃을 넣음   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; ... &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt;   # 메타 정보 관련 태그     메타 정보 (meta data) : 웹 서버와 웹 브라우저 간 상호 교환되는 정보   &lt;title&gt;&lt;/title&gt; : 웹 문서의 제목을 선언하는 태그     브라우저의 제목 표시줄이나 페이지 탭에 표시되는 제목을 출력   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; \t&lt;title&gt;웹 문서의 제목&lt;/title&gt; &lt;/head&gt; &lt;/html&gt;   &lt;base /&gt; : 웹 문서에 포함된 모든 상대 URL들에 대한 기준 URL를 선언하는 태그     상대 URL를 사용하는 다른 HTML 요소보다 앞에 위치해야 함   한 문서에 하나의 &lt;base&gt;만을 사용 가능   문서 내에 &lt;base&gt;가 존재하지 않으면, 해당 문서의 기준 URL는 (현재 위치).(상대 URL)   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; \t&lt;base href=\"기준 URL (절대 경로, 상대 경로 모두 가능)\" \ttarget=\"_self (현재 창에서 열기) | _blank (새로운 창에서 열기)\" /&gt; &lt;/head&gt; &lt;/html&gt;   &lt;link /&gt; : 현재 웹 문서와 외부 리소스 간의 관계를 정의하는 태그     HTML, CSS, 아이콘 등을 가져옴    \t \t\t \t\t\tlink 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\trel \t\t\t현재 웹 문서와 외부 소스 간의 관계 \t\t \t\t \t\t\thref \t\t\t외부 소스의 주소 \t\t \t\t \t\t\ttype \t\t\t외부 소스의 타입 \t\t \t   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;link \trel=\"manifest\"\t\t\t&lt;!--? 현재 웹 문서와 웹 익스텐션이 포함하는 manifest.json을 연결할 때 --&gt; \thref=\"manifest.json\"/&gt; &lt;link \trel=\"canonical\"\t\t\t&lt;!--? 검색 엔진을 위한 대표 URL를 설정하는 rel 변수 --&gt; \thref=\"대표 URL\"/&gt;\t\t\t&lt;!--? 웹 문서 내 URL는 다르나 동일한 내용의 웹 문서가 있을 때 사용 --&gt; &lt;link \trel=\"shortcut icon\"\t\t&lt;!--? 브라우저 탭에 표시될 아이콘을 설정하는 rel 변수 --&gt; \thref=\"PUBLIC_URL%/favicon.ico\" \ttype=\"image/x-icon\" \tsizes=\"16x16\"/&gt; &lt;link\t\t\t\t\t&lt;!--? 애플 메타 태그 (apple meta tag) --&gt; \trel=\"apple-touch-icon\"\t\t&lt;!--? '홈 화면에 추가' 기능을 사용할 때 표시될 웹 사이트의 아이콘을 설정하는 rel 변수 --&gt; \thref=\"%PUBLIC_URL%/img/apple-icon-57.png\" \tsizes=\"12x57\"/&gt; &lt;link \trel=\"apple-touch-startup-icon\"\t&lt;!--? '홈 화면에 추가' 기능을 사용할 때 로딩 시 스타트업 이미지을 설정하는 rel 변수 --&gt; \tsizes=\"320x460\"\t\t\t&lt;!--? 단, 이미지의 크기가 각 기기에 맞게끔 정확히 맞춰져 있어야 제대로 화면에 표시 --&gt; \thref=\"%PUBLIC_URL%/img/apple-icon-320.png\"/&gt; &lt;/head&gt; &lt;/html&gt;   &lt;style&gt;&lt;/style&gt; : 현재 웹 문서의 스타일 정보를 정의하는 태그     CSS 선택자, 속성, 값을 설정    \t \t\t \t\t\tstyle 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\ttype \t\t\t외부 소스의 타입 \t\t \t   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;style&gt; \tbody { background-color: #fff; } \tdiv { color: #000; } &lt;/&gt; &lt;/head&gt; &lt;/html&gt;   &lt;meta /&gt; : 기타 메타데이터 요소들을 선언하는 태그     검색 엔진 등이 웹 페이지를 읽을 때 해당 서비스에서 이 페이지를 어떻게 표시할지 설명    \t  \t\t  \t\t\tmeta 태그의 속성 값  \t\t\t설명  \t\t  \t  \t  \t\t  \t\t\tname  \t\t\t메타 정보의 이름 선언 : 웹 서버가 웹 브라우저의 요청에 대해 응답할 정보들을 지정하는 속성  \t\t \t\t  \t\t\thttp-equiv  \t\t\tHTTP 문서의 초기 정보 선언 : 웹 서버가 웹 문서 내에 HTML 응답 헤더를 넣어 웹 브라우저가 초기 정보를 지정하는 속성  \t\t  \t\t  \t\t\tcontent  \t\t\t메타 정보의 내용 선언 : name 변수와 http-equiv 태그를 선언할 때 같이 포함되어야 할 내용을 지정하는 속성  \t\t  \t   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt;  &lt;meta  name=\"description\"\t\t\t\t&lt;!--? 웹 브라우저의 검색 결과에 표시될 웹 문서의 설명을 선언하는 name 변수 --&gt;  content=\"설명\"/&gt;\t\t\t\t&lt;!--? content 값은 공백을 포함해 최대 150글자여야 함 --&gt;      &lt;meta  name=\"keywords\"\t\t\t\t&lt;!--? 웹 브라우저의 검색 엔진에 의해 검색될 검색 키워드를 선언하는 name 변수 --&gt;  content=\"키워드1, 키워드2,...\"/&gt;       &lt;meta  name=\"date\"\t\t\t\t\t&lt;!--? 웹 문서가 작성된 날짜를 선언하는 name 변수 --&gt;  content=\"2022-09-21T17:38:06+09:00\"/&gt;\t\t&lt;!--? content 값은 \"연도-월-일T시:분:초+(GMT)\" 형식으로 작성 --&gt; \t\t\t\t\t\t&lt;!--? GMT는 그리니치 표준시와 현 국가/지역 사이의 시차를 의미 --&gt;   &lt;meta  name=\"robots\"\t\t\t\t\t&lt;!--? 검색 로봇을 제어하는 name 변수 --&gt;  content=\"robots의 content 변수1,...\"/&gt;\t\t&lt;!--? Index : 해당 문서를 포함해 링크가 걸린 곳을 수집 대상으로 지정 --&gt; \t\t\t\t\t\t&lt;!--? Noindex : 해당 문서를 수집 대상에서 제외 --&gt; \t\t\t\t\t\t&lt;!--? Follow : 해당 문서를 수집 대상으로 지정 --&gt; \t\t\t\t\t\t&lt;!--? Nofollow : 해당 문서를 포함해 링크가 걸린 곳을 수집 대상에서 제외 --&gt; \t\t\t\t\t\t&lt;!--? All : 'Index, Follow'와 동일 --&gt; \t\t\t\t\t\t&lt;!--? None : 'Noindex, Nofollow'와 동일 --&gt;  &lt;meta  name=\"viewport\"\t\t\t\t&lt;!--? 모든 장치에서 웹 문서가 잘 보이도록 뷰 포트를 설정하는 name 변수 --&gt;  content=\"width=device-width,  initial-scale=1.0\"/&gt;   &lt;meta\t\t\t\t\t\t&lt;!--? twitter : 트위터의 '미리보기'을 설정하는 name 변수 --&gt;  name=\"twitter:card\"\t\t\t\t&lt;!--? twitter:card : 트위터 미리보기를 표시 --&gt;  content=\"summary\"/&gt;       &lt;meta  name=\"twitter:url\"\t\t\t\t&lt;!--? twitter:url : 트위터 미리보기에서 표시될 웹 페이지 주소 --&gt;  content=\"website_url\"/&gt;       &lt;meta  name=\"twitter:title\"\t\t\t\t&lt;!--? twitter:title : 트위터 미리보기에서 표시될 웹 페이지 제목 --&gt;  content=\"website_name\"/&gt;        &lt;meta  name=\"twitter:description\"\t\t\t&lt;!--? twitter:description : 트위터 미리보기에서 표시될 웹 페이지 설명 --&gt;  content=\"website_description\"/&gt;        &lt;meta  name=\"twitter:image\"\t\t\t\t&lt;!--? twitter:image : 트위터 미리보기에서 표시될 웹 페이지 이미지 --&gt;  content=\"website_image\"/&gt;       &lt;meta\t\t\t\t\t\t&lt;!--? apple-mobile-web-app : 사파리 '홈 화면에 추가'을 설정하는 name 변수 --&gt;  name=\"apple-mobile-web-app-title\"\t\t&lt;!--? 홈 화면에 추가 기능을 사용할 때 표시될 웹 사이트의 이름 --&gt;  content=\"website_name\"/&gt;       &lt;meta  name=\"apple-mobile-web-app-capable\"\t\t&lt;!--? 홈 화면에 추가 기능을 사용할 때 브라우저의 UI 사용 여부 --&gt;  content=\"yes\"/&gt;       &lt;meta  name=\"apple-mobile-web-app-status-bar-style\"\t&lt;!--? 홈 화면에 추가 기능을 사용할 때 표시될 상태바의 색상 --&gt;  content=\"black-translucent\"/&gt; \t\t\t&lt;!--? default : 회색, black : 검정, black-translucent : 반투명 --&gt;       &lt;meta  http-equiv=\"X-UA-Compatible\"\t\t\t&lt;!--? 웹 문서를 렌더링할 IE 버전을 명시해 웹 호환성을 지정하는 http-equiv 변수 --&gt;  content=\"X-UA-Compatible의 content 변수\"/&gt;\t&lt;!--? IE=5,7,8,EmulateIE7,EmulateIE8 : 각 버전에 해당하는 렌더링 방식 사용 --&gt; \t\t\t\t\t\t&lt;!--? IE=edge : 항상 최신 표준 모드로 렌더링 --&gt; \t\t\t\t\t\t&lt;!--? IE=edge, chrome=1: ~, Chrome이 설치되어 있다면 Chrome으로 렌더링 --&gt; \t  &lt;meta  charset=\"문자 인코딩 방식\"/&gt;\t\t\t&lt;!--? 웹 브라우저의 문자 인코딩 방식 ('호환성 보기') 을 지정하는 http-equiv 변수 --&gt; \t\t\t\t\t\t&lt;!--? EUC-KR (ISO-2022-KR) : ISO-숫자 타입 문자 인코딩 (한글을 2비트로 변환) --&gt; \t\t\t\t\t\t&lt;!--? UTF-8,16,32 : 유니코드 변환 포맷 인코딩 (모든 문자를 8,16,32비트로 변환) --&gt;   &lt;meta  http-equiv=\"content-security-policy\"\t\t&lt;!--? XSS, 데이터 삽입 공격을 대비해 웹 문서 컨텐츠 정책을 명시하는 http-equiv 변수 --&gt;  content=\"CSP 지시문\"/&gt;\t\t\t\t&lt;!--? default-src : 모든 컨텐츠는 현재 도메인에서만 제공 (디폴트 설정) --&gt; \t\t\t\t\t\t&lt;!--? connect-src : 연결 가능한 URL 제한 --&gt; \t\t\t\t\t\t&lt;!--? script-src : 스크립트 관련 권한 집합 제어 --&gt; \t\t\t\t\t\t&lt;!--? style-src : 스타일시트 관련 권한 집합 제어 --&gt; \t\t\t\t\t\t&lt;!--? img-src : 이미지 관련 권한 집합 제어 --&gt; \t\t\t\t\t\t&lt;!--? font-src : 웹 글꼴을 제공할 수 있는 URL 지정 --&gt; \t\t\t\t\t\t&lt;!--? frame-src : 상위 iframe 도메인에서 하위 iframe 도메인을 확인하고 제어 --&gt;       &lt;meta  http-equiv=\"content-security-policy\"  content=\"CSP 지시문 CSP 옵션\"/&gt;\t\t\t&lt;!--? *.trusted.com : 접근 허용할 도메인 지정 --&gt; \t\t\t\t\t\t&lt;!--? 'none' : 모든 도메인 차단 --&gt; \t\t\t\t\t\t&lt;!--? 'self' : 현재 도메인만 허용 --&gt; \t\t\t\t\t\t&lt;!--? 'unsafe-inline' : 소스 코드 내 인라인 자바스크립트 및 CSS 허용 --&gt; \t\t\t\t\t\t&lt;!--? 'nonce-암호화된 문자' : 암호화된 방식으로 인라인 자바스크립트 및 CSS 허용 --&gt;   &lt;meta  http-equiv=\"content-script-type\"\t\t&lt;!--? 웹 문서에 사용된 프로그래밍 언어를 명시하는 http-equiv 변수 --&gt;  content=\"text/프로그래밍 언어\"/&gt;       &lt;meta  http-equiv=\"default-style\"\t\t\t&lt;!--? 웹 문서에 우선적으로 적용할 스타일 시트를 지정하는 http-equiv 변수 --&gt;  content=\"스타일시트\"/&gt;       &lt;meta  http-equiv=\"refresh\"\t\t\t\t&lt;!--? 웹 문서를 새로고침하는 시간 간격을 지정하는 http-equiv 변수 --&gt;  content=\"시간 간격\"; url=\"\"/&gt;\t\t\t&lt;!--? url=\"\" : 새로고침한 후 이동할 주소 지정 --&gt;       &lt;meta  http-equiv=\"cache-control\"\t\t\t&lt;!--? 웹 캐시 사용 여부를 지정하는 http-equiv 변수 --&gt;  content=\"no-cache\"/&gt;\t\t\t\t&lt;!--? no-cache : 사용자의 웹 브라우저가 항상 캐시를 읽지 않고 페이지를 갱신 --&gt;       &lt;meta  http-equiv=\"pragma\"\t\t\t\t&lt;!--? 현재 웹 문서를 캐시로 저장할지 여부를 지정하는 http-equiv 변수 --&gt;  content=\"no-cache\"/&gt;\t\t\t\t&lt;!--? no-cache : 사용자의 웹 브라우저가 항상 캐시를 읽지 않고 페이지를 갱신 --&gt;       &lt;meta  http-equiv=\"expires\"\t\t\t\t&lt;!--? 현재 웹 문서의 웹 캐시 만료일을 지정하는 http-equiv 변수 --&gt;  content=\"캐시 만료일\"/&gt;       &lt;meta  http-equiv=\"장면 전환 http-equiv 변수\"\t\t&lt;!--? 특정 상황에서의 장면 전환 효과를 지정하는 http-equiv 변수 --&gt;  content=\"revealtrans(duration=수행할 시간,\t&lt;!--? page-enter : 현재 페이지 접속 시  --&gt;  transition=수행할 방법)\"/&gt;\t\t\t&lt;!--? page-exit : 현재 페이지 종료 시 --&gt; \t\t\t\t\t\t&lt;!--? site-enter : 현재 사이트 접속 시 --&gt; \t\t\t\t\t\t&lt;!--? site-exit : 현재 사이트 종료 시 --&gt;       &lt;meta  http-equiv=\"origin-trial\"\t\t\t&lt;!--? 웹 개발자가 웹 문서에 실험단계인 속성을 명시하는 http-equiv 변수 --&gt;  content=\"....\"/&gt;       &lt;meta\t\t\t\t\t\t&lt;!--? 오픈그래프 태그 (OpenGraph Tag) --&gt;  property=\"og:오픈그래프 변수\"\t\t\t&lt;!--? SNS에 게시될 때 데이터 설정을 최적화하는 property 변수 --&gt;  content=\"오픈그래프 변수에 해당되는 값\"/&gt;\t\t&lt;!--? og 필수 변수 --&gt; \t  \t\t\t\t\t&lt;!--? title : 웹 사이트 제목 --&gt; \t\t\t\t\t\t&lt;!--? type : 웹 문서의 타입 --&gt; \t\t\t\t\t\t&lt;!--? image : 웹 문서에 표현될 이미지 --&gt; \t\t\t\t\t\t&lt;!--? url : 웹 문서의 대표 URL --&gt; \t\t\t\t\t\t&lt;!--? og 옵션 변수 --&gt; \t\t\t\t\t\t&lt;!--? description : 웹 문서 내에 표현될 설명 --&gt; \t\t\t\t\t\t&lt;!--? locale : 웹 문서 내에 표현될 언어 --&gt; \t\t\t\t\t\t&lt;!--? locale:alternate : 웹 문서 내에 표현될 다국적 언어 --&gt; \t\t\t\t\t\t&lt;!--? site_name : 웹 문서 내에 표현될 카테고리 제목 --&gt; \t\t\t\t\t\t&lt;!--? audio : 웹 문서에 포함되는 오디오 파일 URL --&gt; \t\t\t\t\t\t&lt;!--? video : 웹 문서에 포함되는 비디오 파일 URL --&gt; \t\t\t\t\t\t&lt;!--? og 오브젝트 변수 --&gt; \t\t\t\t\t\t&lt;!--? width : 웹 문서에 표현될 오브젝트의 가로 길이 --&gt; \t\t\t\t\t\t&lt;!--? height : 웹 문서에 표현될 오브젝트의 세로 길이 --&gt; \t\t\t\t\t\t&lt;!--? url : 웹 문서에 표현될 오브젝트의 URL --&gt; \t\t\t\t\t\t&lt;!--? secure_url : 웹 문서에 표현될 오브젝트의 HTTPS URL --&gt; \t\t\t\t\t\t&lt;!--? alt : 표현될 오브젝트에 대한 설명 --&gt; &lt;/head&gt; &lt;/html&gt;   # 컨텐츠 구분 관련 태그   &lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt; : 문서 정보 계층을 구조화하는 태그     문서나 구분된 영역의 제목을 설정 (Heading)            숫자가 낮을 수록 높은 단계의 제목           &lt;h1&gt;h1&lt;/h1&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;h4&gt;h4&lt;/h4&gt; &lt;h5&gt;h5&lt;/h5&gt; &lt;h6&gt;h6&lt;/h6&gt;   \th1  \th2  \th3  \th4  \th5  \th6    &lt;header&gt;&lt;/header&gt; : 문서의 헤더를 선언하는 태그     헤더 (header) 영역 : 일반적으로 로고, 제목, 검색 등이 포함   &lt;header&gt; &lt;h1&gt;제목&lt;/h1&gt; ... &lt;/header&gt;  header { display: block; }   &lt;footer&gt;&lt;/footer&gt; : 문서의 푸터를 선언하는 태그     푸터 (footer) 영역 : 일반적으로 작성자, 저작권, 관련 문서 등이 포함   &lt;footer&gt; &lt;p&gt;작성자&lt;/p&gt; ... &lt;/footer&gt;  footer { display: block; }   &lt;main&gt;&lt;/main&gt; : 문서의 주요 컨텐츠 영역을 선언하는 태그     한 문서에 하나의 &lt;main&gt; 태그만을 선언 가능   IE에서 지원하지 않음   &lt;main&gt; &lt;h1&gt;주요 컨텐츠&lt;/h1&gt; ... &lt;/main&gt;  main { display: block; }   &lt;article&gt;&lt;/article&gt; : 독립적으로 구분되거나 재사용 가능한 영역을 선언하는 태그     &lt;h1&gt;~&lt;h6&gt; 태그를 포함해 식별   작성한 날짜와 시간을 &lt;time&gt; 태그의 datetime 속성으로 작성   &lt;article&gt; &lt;h2&gt;독립 영역 1&lt;/h2&gt; ... &lt;/article&gt; &lt;article&gt; &lt;h2&gt;독립 영역 2&lt;/h2&gt; ... &lt;/article&gt;  article { display: block; }   &lt;section&gt;&lt;/section&gt; : 문서의 일반적인 영역을 선언하는 태그     &lt;h1&gt;~&lt;h6&gt; 태그를 포함해 식별   &lt;section&gt; &lt;h2&gt;일반 영역 1&lt;/h2&gt; ... &lt;/section&gt; &lt;section&gt; &lt;h2&gt;일반 영역 2&lt;/h2&gt; ... &lt;/section&gt;  section { display: block; }   &lt;aside&gt;&lt;/aside&gt; : 문서의 별도 컨텐츠 영역을 선언하는 태그     사이드 (aside) 영역 : 일반적으로 광고나 사이드바로 설정   &lt;aside&gt; &lt;h4&gt;별도 컨텐츠&lt;/h4&gt; ... &lt;/aside&gt;  aside { display: block; }   &lt;nav&gt;&lt;/nav&gt; : 다른 페이지로 이동하기 위한 링크를 선언하는 태그     일반적으로 바로가기, 목차, 색인 등으로 설정   &lt;a&gt; 태그로 링크 선언   &lt;nav&gt; \t&lt;a href=\"/html/\"&gt;HTML&lt;/a&gt; | \t&lt;a href=\"/html/css/\"&gt;CSS&lt;/a&gt; | \t&lt;a href=\"/html/css/js/\"&gt;JavaScript&lt;/a&gt; &lt;/nav&gt; &lt;nav&gt;     &lt;ol&gt;         &lt;li&gt;&lt;a href=\"#\"&gt;HTML&lt;/a&gt;&lt;/li&gt;         &lt;li&gt;&lt;a href=\"#\"&gt;CSS&lt;/a&gt;&lt;/li&gt;         &lt;li&gt;&lt;a href=\"#\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt;     &lt;/ol&gt; &lt;/nav&gt;  aside { display: block; }   &lt;div&gt;&lt;/div&gt; : 아무것도 나타내지 않은 컨텐츠 영역을 선언하는 태그     일반적으로 CSS와 연게해 꾸미는 목적으로 사용   &lt;div&gt; &lt;h2&gt;아무것도 나타내지 않은 컨텐츠 영역&lt;/h2&gt; ... &lt;/div&gt;  div { display: block; }   # 인라인 텍스트 관련 태그   &lt;p&gt;&lt;/p&gt; : 하나의 문단을 선언하는 태그   &lt;p align=\"center\"&gt;문단 1 : 가운데 정렬&lt;/p&gt; &lt;p align=\"right\"&gt;문단 2 : 오른쪽 정렬&lt;/p&gt;    \t문단 1 : 가운데 정렬  \t문단 2 : 오른쪽 정렬    p { display: block; }   &lt;hr&gt; : 문단을 분리하는 가로줄을 넣는 태그   ↓ 가로줄 &lt;hr&gt; ↑ 가로줄    \t↓ 가로줄 \t \t↑ 가로줄   hr { display: block; }  &lt;a&gt;&lt;/a&gt; : 하이퍼링크를 생성하는 태그   \t \t\t \t\t\ta 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tdownload \t\t\t이 요소가 리소스를 다운로드하는 용도인가? (boolean) \t\t \t\t \t\t\thref \t\t\t링크된 문서를 입력 \t\t \t\t \t\t\ttarget \t\t\t링크된 문서를 어떻게 열지 지정 \t\t \t\t \t\t\tname \t\t\t링크의 이름을 지정 (문서 내에서도 이 이름을 이용해 이동 가능) \t\t \t   &lt;a   href=\"https://pocj8ur4in.github.io\"   target=\"_blank\"   title=\"pocj8ur4in\"&gt;     pocj8ur4in &lt;/a&gt;             pocj8ur4in      a { display: inline; }   &lt;code&gt;&lt;/code&gt; : 소스 코드를 넣는 태그     `을 3번 쓰는 것으로 대체 가능   &lt;code&gt; \tprint(\"Hello World!\") &lt;code&gt;    \tprint(\"Hello World!\")    code { display: inline; }   &lt;time&gt; : 날짜나 시간을 나타내기 위해 선언하는 태그   &lt;p&gt;Hello World!&lt;time datetime=\"유효한 날짜나 시간\"&gt;&lt;/p&gt;  time { display: inline; }   &lt;span&gt;&lt;/span&gt; : 아무것도 나타내지 않는 컨텐츠 영역을 선언하는 태그     일반적으로 CSS와 연게해 꾸미는 목적으로 사용   &lt;p&gt;Hello &lt;span style=\"color:blue\"&gt;World&lt;/span&gt;!&lt;/p&gt;    \tHello World!    span { display: inline; }   &lt;br&gt; : 줄바꿈을 선언하는 태그     Enter 키를 2번 입랙한 것으로 대체 가능   &lt;br&gt;       br { display: inline; }   # 목록 관련 태그   &lt;li&gt;&lt;/li&gt; : 목록을 표시할 때 각 항목들을 선언하는 태그     &lt;ol&gt;과 &lt;ul&gt;은 &lt;li&gt;의 부모            &lt;li&gt;는 단독으로 사용할 수 없음            \t \t\t \t\t\tli 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tvalue \t\t\t숫자로 항목의 순서 지정 \t\t \t   &lt;!--? 잘못된 사용 --&gt; &lt;li&gt;X&lt;/li&gt; &lt;li&gt;Y&lt;/li&gt; &lt;li&gt;Z&lt;/li&gt;   li { display: list-item; }   &lt;ul&gt;&lt;/ul&gt; : 순서 없는 목록을 선언하는 태그   &lt;ul&gt; \t&lt;li&gt;X&lt;/li&gt; \t&lt;li&gt;Y&lt;/li&gt; \t&lt;li&gt;Z&lt;/li&gt; &lt;/ul&gt;    \t \t\tX \t\tY \t\tZ \t   ul { display: block; }   &lt;ol&gt;&lt;/ol&gt; : 순서 있는 목록을 선언하는 태그     정렬된 목록의 항목 순서는 해당 항목의 중요도를 의미할 수 있음    \t \t\t \t\t\tli 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tstart \t\t\t숫자로 항목에 매겨진 번호의 시작 값 지정 \t\t \t\t \t\t\ttype \t\t\t항목에 매겨진 번호의 유형 지정 \t\t \t   &lt;ol&gt; \t&lt;li&gt;X&lt;/li&gt; \t&lt;li&gt;Y&lt;/li&gt; \t&lt;li&gt;Z&lt;/li&gt; &lt;/ol&gt;    \t \t\tX \t\tY \t\tZ \t   ol { display: block; }   &lt;dl&gt;&lt;/dl&gt; : 용어 (&lt;dt&gt;&lt;/dt&gt;)와 정의 (&lt;dd&gt;&lt;/dd&gt;) 쌍의 영역을 선언하는 태그     &lt;dd&gt;와 &lt;dt&gt;는 &lt;dl&gt;의 자식            &lt;dd&gt;와 &lt;dt&gt;는 단독으로 사용할 수 없음           키 (key)와 값 (value)의 형태를 표현할 때 사용   &lt;dl&gt;   &lt;dt&gt;용어 1&lt;/dt&gt;&lt;dd&gt;정의 1&lt;/dd&gt;   &lt;dt&gt;용어 2&lt;/dt&gt;&lt;dd&gt;정의 2&lt;/dd&gt; &lt;/dl&gt;    \t   \t\t용어 1정의 1   \t\t용어 2정의 2 \t   dl, dt, dd { display: block; }   # 표 관련 태그   &lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt; : 표를 만드는 태그     데이터 표(&lt;table&gt;)의 행(&lt;tr&gt;), 머리글 열(&lt;th&gt;)과 내용 열(&lt;td&gt;)을 생성    \t \t\t \t\t\ttable 태그 \t\t\t설명 \t\t \t \t \t\t \t\t\ttr \t\t\t표의 행 표현 \t\t \t\t \t\t\tth \t\t\t표의 머리말 열 표현 \t\t \t\t \t\t\ttd \t\t\t표의 내용 열 표현 \t\t \t    \t \t\t \t\t\ttable 컨텐츠 구분 \t\t\t설명 \t\t \t \t \t\t \t\t\tcaption \t\t\t표의 제목 부분 기술 \t\t \t\t \t\t\tcol \t\t\t표의 열 정보 기술 \t\t \t\t \t\t\tthead \t\t\t표의 헤더 부분 기술 \t\t \t\t \t\t\ttbody \t\t\t표의 본문 부분 기술 \t\t \t\t \t\t\ttfoot \t\t\t표의 푸터 부분 기술 \t\t \t    \t \t\t \t\t\ttable 관련 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tabbr \t\t\tth : 표에서 열에 대한 설명 \t\t \t\t \t\t\tscope \t\t\tth : 어느 부분의 머리말인지 명시 col / row : 자신의 열 / 자신의 행 colgroup / rowgroup : 모든 열 / 모든 행 \t\t \t\t \t\t\tcolspan \t\t\t표에서 병합하려는 열의 수 \t\t \t\t \t\t\trowspan \t\t\t표에서 병합하려는 행의 수 \t\t \t   &lt;table&gt;   &lt;caption&gt;OO고등학교 시간표&lt;/caption&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt; &lt;/th&gt;       &lt;th&gt;월&lt;/th&gt;       &lt;th&gt;화&lt;/th&gt;       &lt;th&gt;수&lt;/th&gt;       &lt;th&gt;목&lt;/th&gt;       &lt;th&gt;금&lt;/th&gt;      &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;1교시&lt;/th&gt;       &lt;td&gt;수학&lt;/td&gt;       &lt;td rowspan=\"2\"&gt;국어&lt;/td&gt;       &lt;td&gt;수학&lt;/td&gt;       &lt;td&gt;과학&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2교시&lt;/th&gt;       &lt;td rowspan=\"2\"&gt;사회&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;       &lt;td&gt;국어&lt;/td&gt;       &lt;td rowspan=\"3\"&gt;음악&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;3교시&lt;/th&gt;       &lt;td&gt;수학&lt;/td&gt;       &lt;td rowspan=\"2\"&gt;미술&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;4교시&lt;/th&gt;       &lt;td&gt;체육&lt;/td&gt;       &lt;td&gt;사회&lt;/td&gt;       &lt;td&gt;영어&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;    \tOO고등학교 시간표 \t \t\t \t\t\t  \t\t\t월 \t\t\t화 \t\t\t수 \t\t\t목 \t\t\t금 \t\t \t \t \t\t \t\t\t1교시 \t\t\t수학 \t\t\t국어 \t\t\t수학 \t\t\t과학 \t\t\t영어 \t　　 \t\t \t\t\t2교시 \t\t\t사회 \t\t\t영어 \t\t\t국어 \t\t\t음악 \t　　 \t\t \t\t\t3교시 \t\t\t수학 \t\t\t미술 \t\t\t영어 \t\t \t\t \t\t\t4교시 \t\t\t체육 \t\t\t사회 \t\t\t영어 \t　　 \t   table { display: table; } tr { display: table-row; } th, td { display: table-cell; }   # 멀티미디어 관련 태그   &lt;img&gt; : 이미지를 삽입하는 태그   \t \t\t \t\t\timg 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t이미지 파일의 경로를 지정 절대 경로 : http:// 또는 https:// 상대 경로 : /path/filename \t\t \t\t \t\t\talt \t\t\t이미지가 출력되지 않을 경우 이미지에 대한 설명을 제공 \t\t \t\t \t\t\ttitle \t\t\t이미지에 대한 추가 정보를 제공  (마우스가 접근하면 말풍선으로 표시) \t\t \t\t \t\t\twidth, height \t\t\t이미지의 가로, 세로의 길이를 지정 (HTML5 : 픽셀만 지정 가능, %는 CSS 대체) \t\t \t\t \t\t\tborder \t\t\t이미지의 경계선의 두께를 지정 (기본값 : 1px) \t\t \t   &lt;img src=\"https://cdn.pixabay.com/photo/2020/10/21/04/01/leaves-5672036_1280.png\"   alt=\"leaves-5672036_1280.png\"   title=\"이미지\"   height=\"360px\"   width=\"360px\"   border=\"0px\"&gt;      img { display: inline; }   &lt;audio&gt; : 오디오를 삽입하는 태그    \t \t\t \t\t\taudio 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t삽입할 오디오의 주소 지정 \t\t \t\t \t\t\tautoplay \t\t\t오디오의 자동 재생 여부 지정 \t\t \t\t \t\t\tcontrols \t\t\t오디오의 소리 조절, 시간대 탐색, 일시정지 및 재시작을 할 수 있는 컨트롤러 생성 \t\t \t\t \t\t\tloop \t\t\t비디오의 재시작 여부 지정 \t\t \t\t \t\t\tpreload \t\t\t웹 문서를 열 때 동영상, 메타데이터 로드 여부 지정 auto : 모두 로드 metadata : 메타데이터만 로드 none : 모두 로드하지 않음 \t\t \t   audio { display: inline; }   &lt;video&gt; : 비디오를 삽입하는 태그    \t \t\t \t\t\tvideo 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t삽입할 비디오의 주소 지정 \t\t \t\t \t\t\tposter \t\t\t삽입할 비디오 썸네일 이미지의 주소 지정 \t\t \t\t \t\t\ttype \t\t\t삽입할 비디오의 타입 지정 \t\t \t\t \t\t\theight \t\t\t비디오의 출력 영역 높이 지정 \t\t \t\t \t\t\twidth \t\t\t비디오의 출력 영역 너비 지정 \t\t \t\t \t\t\tposter \t\t\t비디오 포스터 프레임의 주소 지정 \t\t \t\t \t\t\tautoplay \t\t\t비디오의 자동 재생 여부 지정 \t\t \t\t \t\t\tcontrols \t\t\t비디오의 소리 조절, 시간대 탐색, 일시정지 및 재시작을 할 수 있는 컨트롤러 생성 \t\t \t\t \t\t\tloop \t\t\t비디오의 재시작 여부 지정 \t\t \t\t \t\t\tpreload \t\t\t웹 문서를 열 때 동영상, 메타데이터 로드 여부 지정 auto : 모두 로드 metadata : 메타데이터만 로드 none : 모두 로드하지 않음 \t\t \t      video { display: inline; }   &lt;figure&gt;&lt;/figure&gt; : 이미지나 다이어그램 영역을 삽입하는 태그     &lt;figcation&gt; : &lt;figure&gt;에 포함되어 이미지나 다이어그램의 설명을 추가하는 태그   &lt;figure&gt;   &lt;figcaption&gt;     figure   &lt;/figcaption&gt;   &lt;img     src=\"https://cdn.pixabay.com/photo/2020/10/21/04/01/leaves-5672036_1280.png\"     alt=\"leaves-5672036_1280.png\"     title=\"이미지\"     height=\"360px\"     width=\"360px\"&gt; &lt;/figure&gt;    \t \t\tfigure \t \t   figure { display: block; } figcation { display: inline; }   # 프레임 관련 태그   &lt;iframe&gt;&lt;/iframe&gt; : 웹 문서 안에 박스형으로 프레임을 넣어 문서 안의 문서를 표현하는 태그     중첩된 브라우저 프레임 : 다른 HTML 문서를 현재 HTML 문서에 삽입    \t \t\t \t\t\tiframe 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tname \t\t\t프레임의 이름 지정 \t\t \t\t \t\t\tsrc \t\t\t삽입할 웹 문서의 주소 지정 \t\t \t\t \t\t\theight \t\t\t프레임의 높이 지정 \t\t \t\t \t\t\twidth \t\t\t프레임의 너비 지정 \t\t \t\t \t\t\tsandbox \t\t\t일기 전용으로 삽입 (Boolean) allow-form : 양식 제출 가능 allow-scripts : 스크립트 실행 가능 allow-same-origin : 같은 도메인의 리소스 사용 가능 \t\t \t\t \t\t\tframeborder \t\t\t프레임 테두리 표시 여부 지정 (Boolean) \t\t \t\t \t\t\tallowfullscreen \t\t\t프레임의 전체 화면 모드 전환 여부 지정 \t\t \t   &lt;div&gt; \t&lt;iframe \t\tsrc=\"https://github.com/pocj8ur4in\" \t\twidth=\"360\" \t\theight=\"360\" \t\tscrolling=\"no\" \t\tframeborder=\"1\" \t\tallowfullscreen=\"true\" \t\tallow=\" \t\t\tclipboard-write; \t\t\tencrypted-media; \t\t\tpicture-in-picture; \t\t\tweb-share\" \t\tsandbox=\" \t\t\tallow-same-origin \t\t\tallow-popups \t\t\tallow-scripts\" \t\t&gt; \t&lt;/iframe&gt; &lt;/div&gt;    \t \t   iframe { display: inline; }   # 스크립트 관련 태그   &lt;script&gt;&lt;/script&gt; : 외부 스크립트 파일을 참조하는 태그     외부 스크립트 파일 : javascript, CSS    \t \t\t \t\t\tscript 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tsrc \t\t\t삽입할 외부 스크립트의 주소 지정 \t\t \t\t \t\t\tasync \t\t\t스크립트의 비동기적 실행 여부 (Boolean) \t\t \t\t \t\t\tdefer \t\t\t문서 파싱 후 작동 여부 (Boolean) \t\t \t\t \t\t\ttype \t\t\t삽입할 외부 스크립트의 타입 지정 \t\t \t\t \t\t\tframeborder \t\t\t프레임 테두리 표시 여부 지정 (Boolean) \t\t \t\t \t\t\tallowfullscreen \t\t\t프레임의 전체 화면 모드 전환 여부 지정 \t\t \t   &lt;script type=\"application/ld+json\"&gt;\t&lt;!--? 구조화된 JSON-LD 데이터 스니펫 : 제목, 작성자 및 세부 정보를 Google이 수집 --&gt;   {     \"@context\": \"https://schema.org\",            \"@type\": \"website\",       \"name\": \"website_name\",       \"author\": {         \"@type\": \"Person\",         \"name\": \"Person_name\"       },       \"description\": \"website_description\",       \"url\": \"website_url\"   } &lt;/script&gt;   script { display: none; }   # 양식 관련 태그   &lt;form&gt;&lt;/form&gt; : 웹 서버에 제출하기 위한 양식의 입력값을 받는 태그     &lt;form&gt;이 다른 &lt;form&gt;을 자식 요소로 포함할 수 없음      form 태그가 동작하는 과정         사용자가 브라우저를 통해 폼이 있는 웹 문서에 방문     사용자가 브라우저를 통해 폼의 내용을 입력     폼 안에 있는 모든 데이터를 웹 서버로 전송     웹 서버는 전송받은 폼 데이터의 처리를 위해 웹 프로그램으로 전달     웹 프로그램에서 데이터를 처리하고, 결과에 따른 새로운 웹 문서를 웹 서버로 전달     웹 서버는 전송받은 새로운 웹 문서를 브라우저로 전송     브라우저는 전송받은 새로운 웹 문서를 표현       \t \t\t \t\t\tform 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tname \t\t\t폼을 식별하기 위한 고유한 이름 지정 \t\t \t\t \t\t\taccept-charset \t\t\t폼 전송에 사용할 문자 인코딩 방식 지정 \t\t \t\t \t\t\tautocomplete \t\t\t자동 완성 기능을 사용할지 여부 지정 (ON | OFF) \t\t \t\t \t\t\taction \t\t\t입력 양식에 입력된 값을 저장할 데이터베이스 문서 지정 (해당 문서는 PHP나 ASP로 작성) \t\t \t\t \t\t\tnovalidate \t\t\t양식 데이터의 유효성을 검사하지 않을지 지정 \t\t \t\t \t\t\ttarget \t\t\taction에서 지정한 스크립트 파일을 현재 창이 아닌 다른 위치에 열도록 지정 \t\t \t\t \t\t\tmethod \t\t\tHTTP 메소드 (웹 서버와의 통신 방식) 지정 (GET | POST) \t\t \t   &lt;html&gt;   &lt;body&gt;     &lt;form       action = \"http://localhost:4000/form.jsp\"       accept-charset=\"utf-8\"       name = \"person_info\"       method = \"get\"&gt;      &lt;/form&gt;   &lt;/body&gt; &lt;html&gt;  form { display: block; }   &lt;label&gt;&lt;/label&gt; : 양식에 이름을 지정하는 태그     &lt;label for=\"\"&gt; : label의 for의 값과 양식의 id의 값이 같으면 연결하는 속성   &lt;label&gt; 가능 요소 : &lt;button&gt;, &lt;input&gt;, &lt;progress&gt;, &lt;select&gt;, &lt;textarea&gt;   &lt;label for=\"input-label\"&gt;   input-text &lt;/label&gt;  &lt;input type=\"text\" id=\"input-text\"&gt;  &lt;label for=\"checkbox-label\"&gt;   checkbox-text &lt;/label&gt;  &lt;input type=\"checkbox\" id=\"checkbox-text\"&gt;    \tinput-text \t \tcheckbox-text \t   label { display: inline; }   &lt;input&gt; : 입력값을 입력받을 필드를 선언하는 태그    \t \t\t \t\t\tinput 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tname \t\t\t입력값 필드을 식별하기 위한 고유한 이름 지정 \t\t \t\t \t\t\ttype \t\t\t입력값 필드의 종류를 지정 \t\t \t    \t \t\t \t\t\tinput type 변수 \t\t\t설명 \t\t \t \t \t\t \t\t\ttext \t\t\t한 줄의 문자열 생성 (기본 변수) \t\t \t\t \t\t\tpassword \t\t\t비밀번호 생성 \t\t \t\t \t\t\trange \t\t\t지정한 범위의 숫자 생성 \t\t \t\t \t\t\tcheckbox \t\t\t선택/해제할 수 있는 항목 (중복 가능) 생성 \t\t \t\t \t\t\tradio \t\t\t선택/해제할 수 있는 항목 (중복 불가) 생성 \t\t \t\t \t\t\tsubmit \t\t\t클릭할 경우 입력값을 전송하는 버튼 생성 \t\t \t\t \t\t\tsearch \t\t\t클릭할 경우 입력값을 검색하는 버튼 생성 \t\t \t\t \t\t\treset \t\t\t클릭할 경우 입력값을 초기화하는 버튼 생성 \t\t \t\t \t\t\tfile \t\t\t파일을 업로드하는 버튼 생성 \t\t \t\t \t\t\thidden \t\t\t입력값 없이 폼과 함께 전송해야 하는 정보를 감쌈 (hidden flied) \t\t \t   &lt;input type=\"text\" name=\"text\"&gt;    \t   &lt;input type=\"password\" name=\"password\"&gt;    \t   &lt;input type=\"range\" name=\"range\"&gt;    \t   &lt;input type=\"checkbox\" name=\"checkbox\" value=\"1\"&gt;1 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"2\"&gt;2 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"3\"&gt;3 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"4\"&gt;4 &lt;input type=\"checkbox\" name=\"checkbox\" value=\"5\"&gt;5    \t1  \t2  \t3  \t4  \t5   &lt;input type=\"radio\" name=\"radio\" value=\"1\"&gt;1 &lt;input type=\"radio\" name=\"radio\" value=\"2\"&gt;2 &lt;input type=\"radio\" name=\"radio\" value=\"3\"&gt;3 &lt;input type=\"radio\" name=\"radio\" value=\"4\"&gt;4 &lt;input type=\"radio\" name=\"radio\" value=\"5\"&gt;5    \t1  \t2  \t3  \t4  \t5   &lt;input type=\"submit\" name=\"submit\"&gt;    \t   &lt;input type=\"search\" name=\"search\"&gt;    \t   &lt;input type=\"reset\" name=\"reset\"&gt;    \t   &lt;input type=\"file\" name=\"file\"&gt;    \t      input { display: inline-block; }   &lt;button&gt;&lt;/button&gt; : 클릭 가능한 버튼을 생성하는 태그    \t \t\t \t\t\tbutton 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tautofocus \t\t\t페이지가 로드될 때 자동으로 포커싱 여부 (Boolean). 문서 내에 고유해야 함 \t\t \t\t \t\t\tdisabled \t\t\t버튼의 비활성화 여부 (Boolean) \t\t \t\t \t\t\tname \t\t\t폼 데이터와 함께 전송될 버튼의 이름을 지정 \t\t \t\t \t\t\ttype \t\t\t버튼의 종류를 지정 (button, reset, submit) \t\t \t   &lt;button name=\"button\"&gt; \t버튼 &lt;/button&gt;    \t버튼    button { display: inline-block; }   &lt;textarea&gt;&lt;/textarea&gt; : 여러 줄의 문자열 값을 입력받는 태그    \t \t\t \t\t\ttextarea 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tautofocus \t\t\t페이지가 로드될 때 자동으로 포커싱 여부 (Boolean). 문서 내에 고유해야 함 \t\t \t\t \t\t\tautocomplete \t\t\t자동 완성 기능을 사용할지 여부 지정 (ON | OFF) \t\t \t\t \t\t\tdisabled \t\t\t텍스트 에이리어의 비활성화 여부 (Boolean) \t\t \t\t \t\t\trows \t\t\t텍스트 에이리어의 행의 개수을 지정 \t\t \t\t \t\t\tcols \t\t\t텍스트 에이리어의 열의 개수을 지정 \t\t \t\t \t\t\tmaxlength \t\t\t텍스트 에이리어에 입력 가능한 최대 문자 수 \t\t \t\t \t\t\tplaceholder \t\t\t텍스트 에이리어에 입력할 문자열에 대한 힌트 \t\t \t\t \t\t\treadonly \t\t\t읽기 전용 여부 (Boolean) \t\t \t   &lt;textarea cols=\"50\" rows=\"10\"&gt;&lt;/textarea&gt;    \t      textarea { display: inline-block; }   &lt;progress&gt;&lt;/progress&gt; : 작업의 진행률을 표시하는 태그    \t \t\t \t\t\tprogress 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tmax \t\t\t작업의 총량 지정 \t\t \t\t \t\t\tvalue \t\t\t작업의 진행량 지정 \t\t \t   &lt;progress value=\"70\" max=\"100\"&gt;70 %&lt;/progress&gt;    \t70 %      progress { display: inline-block; }   &lt;select&gt;&lt;/select&gt; : 드롭다운 목록을 생성하는 태그     드롭다운 항목(&lt;option&gt;)의 드롭다운 목록(&lt;select&gt;) 제공    \t \t\t \t\t\tselect 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tautocomplete \t\t\t자동 완성 기능을 사용할지 여부 지정 (ON | OFF) \t\t \t\t \t\t\tdisabled \t\t\t드롭다운 목록의 비활성화 여부 (Boolean) \t\t \t\t \t\t\tmultiple \t\t\t다중으로 선택할지 여부 (Boolean) \t\t \t\t \t\t\tname \t\t\t드롭다운 목록의 이름 지정 \t\t \t\t \t\t\tsize \t\t\t드롭다운 목록에서 한 번에 볼 수 있는 행의 개수 \t\t \t   select { display: inline-block; }   &lt;option&gt;&lt;/option&gt; : 드롭다운 목록에 대한 드롭다운 항목을 생성하는 태그     &lt;option&gt;는 선택적 빈 태그로 사용 가능   &lt;optgroup&gt;으로 그룹화 가능    \t \t\t \t\t\toption 속성 \t\t\t설명 \t\t \t \t \t\t \t\t\tdisabled \t\t\t드롭다운 항목의 비활성화 여부 (Boolean) \t\t \t\t \t\t\tlabel \t\t\t드롭다운 항목의 제목 지정 (생략되면 포함된 텍스트를 표시) \t\t \t\t \t\t\tselected \t\t\t옵션이 선택되었음을 표시 (Boolean) \t\t \t\t \t\t\tvalue \t\t\t양식으로 제출될 값 (생략되면 포함된 텍스트를 값으로 사용) \t\t \t   &lt;form&gt;     &lt;select&gt;         &lt;option&gt;a&lt;/option&gt;         &lt;option&gt;b&lt;/option&gt;         &lt;option&gt;c&lt;/option&gt;         &lt;option&gt;d&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select autofocus&gt;         &lt;option&gt;e&lt;/option&gt;         &lt;option&gt;f&lt;/option&gt;         &lt;option&gt;g&lt;/option&gt;         &lt;option&gt;h&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select disabled&gt;         &lt;option&gt;i&lt;/option&gt;         &lt;option&gt;j&lt;/option&gt;         &lt;option&gt;k&lt;/option&gt;         &lt;option&gt;l&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select multiple&gt;         &lt;option&gt;m&lt;/option&gt;         &lt;option&gt;n&lt;/option&gt;         &lt;option&gt;o&lt;/option&gt;         &lt;option&gt;p&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt; &lt;form&gt;     &lt;select name=\"select box\" size=\"2\"&gt;         &lt;option&gt;q&lt;/option&gt;         &lt;option&gt;r&lt;/option&gt;         &lt;option&gt;s&lt;/option&gt;         &lt;option&gt;t&lt;/option&gt;     &lt;/select&gt; &lt;/form&gt;                 a         b         c         d                     e         f         g         h                     i         j         k         l                     m         n         o         p                     q         r         s         t        option, optgroup { display: block; }   &lt;fieldset&gt;&lt;/fieldset&gt; : 같은 목적의 양식을 그룹화하는 태그     &lt;legend&gt; 태그로 제목을 지정할 수 있음   &lt;form&gt;   &lt;fieldset&gt;     &lt;legend&gt;커피 사이즈&lt;/legend&gt;     &lt;label&gt;         &lt;input type=\"radio\" name=\"size\" value=\"t\" /&gt;         톨     &lt;/label&gt;     &lt;label&gt;         &lt;input type=\"radio\" name=\"size\" value=\"g\" /&gt;         그란데     &lt;/label&gt;     &lt;label&gt;         &lt;input type=\"radio\" name=\"size\" value=\"v\" /&gt;         벤티     &lt;/label&gt;   &lt;/fieldset&gt; &lt;/form&gt;           커피 사이즈                       톨                            그란데                            벤티           fieldset, legend { display: block; }  ","categories": [],
        "tags": ["HTML"],
        "url": "/html1/",
        "teaser": null
      },{
        "title": "[Python] 파이썬 기초 문법",
        "excerpt":"파이썬 (Python) : 소스 코드를 한 줄씩 읽는 인터프리터 언어 (Interpreter Language)      대화식 프로그래밍 (&gt;&gt;&gt;) : 사용자가 입력하면 인터프리터가 바로 번역 및 처리 작업을 한 후 결과를 응답   블록 처리 규칙 : 괄호 ({}) 대신 들여쓰기 (Indentation)를 블럭 단위로 사용            : : 제어문이나 함수나 클래스의 이름의 끝을 표현           순수 객체 지향 : 변수, 클래스, 함수, 상수 등 모든 것을 객체로 취급   변수 (Variable) : 객체를 저장할 수 있는 메모리 공간     객체 (Object) : 어떠한 상태 (State)와 행동 (Behavior)을 가지고 있는 데이터            객체의 상태는 속성값 (Value), 객체의 행동은 메소드 (Method)으로 메모리에 저장됨           &gt;&gt;&gt; x = 100 # x는 100의 값을 가짐      None : 변수에 아무런 값이 존재하지 않는 것을 표현   &gt;&gt;&gt; y = None  # y는 어떤 값도 가지지 않음   연산자 (Operator) : 변수 및 특정한 값들에 대한 작업을 위해 사용되는 기호     산술 연산자 (Arithmetic~) : 더하기 (+), 빼기 (-), 곱하기 ( *), 나누기 (/), 나머지 (%), 제곱 (**), 몫 (//)   할당 연산자 (Assignment~) : 대입 (=), 산술하고 대입 (+=, -=, *=, /=, %=)   비교 연산자 (Comparison~) : 같음 (==), 같지 않음 (!=), 큼 (&gt;), 크거나 같음 (&gt;=), 작거나 같음 (&lt;=), 작음 (&lt;)   논리 연산자 (Logical~) : 모두 참 (and), 하나라도 참 (or), 결과와 반대로 (not)   식별 연산자 (Identity~) : 두 변수가 같은 객체 메모리이면 (is), 두 변수가 같은 객체 메모리가 아니면 (is not)   멤버 연산자 (Member~) : 객체 내에 해당 값이 포함되면 (in), 객체 내에 해당 값이 포함되지 않으면 (not in)   비트 연산자 (Bitwise~) : 비트 AND 연산 (&amp;), 비트 OR 연산 (|)   자료형 (Data type) : 저장되는 데이터의 종류에 따른 변수의 형태   &gt;&gt;&gt; type(1) &lt;class 'int'&gt;                               # 수치) 정수  &gt;&gt;&gt; type(3.14) &lt;class 'float'&gt;                             # 수치) 실수  &gt;&gt;&gt; type(1+2j) &lt;class 'complex'&gt;                           # 수치) 복소수  &gt;&gt;&gt; type('hello') &lt;class 'str'&gt;                               # 문자열  &gt;&gt;&gt; type(False) &lt;class 'bool'&gt;                              # 부울  &gt;&gt;&gt; type([1,2,3,4,5]) &lt;class 'list'&gt;                              # 리스트  &gt;&gt;&gt; type((1,2,3,4,5)) &lt;class 'tuple'&gt;                             # 튜플  &gt;&gt;&gt; type({1,2,3,4,5}) &lt;class 'set'&gt;                               # 집합  &gt;&gt;&gt; type({1:10,2:20,3:30,4:40,5:50}) &lt;class 'dict'&gt;                              # 딕셔내리  수치 (Numbers) : 수학에서 사용하는 수를 표현하는 자료형      정수 (int) : 양수, 음수, 0 등의 정수를 표현            파이썬은 메모리가 허용하는 범위에서 지원 가능한 수까지 지원       b, o, x : 2진수, 8진수, 16진수로 표현           num1 = 0 num2 = -1 num3 = 10 # 10진수의 10 num4 = 0b10 # 2진수의 10, 10진수로 표현하면 2 num5 = 0x10 # 16진수의 10, 10진수로 표현하면 16      실수 (float) : 유리수와 무리수 등의 실수를 표현            e : 10의 거듭제곱을 표현           num1 = 3.14 # 3.14로 출력 num2 = 3.14e2 # 314.0로 출력 num3 = 3.14e-3 # 0.00314로 출력      복소수 (complex) : 복소수를 표현 (실수부 + 허수부 (j) 로 구성)            .real : 복소수의 실수부를 실수형 상수로 표현       .imag : 복소수의 허수부를 실수형 상수로 표현       complex(x, y) : 복소수형 상수를 표현           num1 = 1+2j num2 = num1.real # 1.0으로 표현 num3 = num2.imag # 2.0으로 표현 num4 = complex(1,2) # (1+2j)로 표현   부울 (bool) : 참 또는 거짓을 표현하는 자료형 (첫 글자는 대문자로 시작)     True : 참을 표현 (1의 값을 가짐)   False : 거짓을 표현 (0의 값을 가짐)   bool1 = True bool2 = False   시퀀스 (Sequence) : 자료들이 순서를 가지고 나열되어 있는 자료형      인덱싱 (Indexing) : 인덱스에 해당하는 요소 하나를 취함          인덱스 (Index) : 위치를 가리키는 정수값 (0부터 시작)       data[0], data[1], data[2]       슬라이싱 (Slicing) : 자료에서 일정 범위에 해당하는 부분을 취함     data[1:2] data[3:] data[-1:]      print('hello'[::2]) # 홀수 번째 문자들만 추출한 문자열 print('hello'[::-1]) # 거꾸로 된 문자열        연결 (+) : 두 개의 자료를 순서 있게 연결해 새로운 자료로 만듬     data = 'hello'[0] + 'hello'[4]       반복 (*) : 자료를 일정한 횟수로 반복해 새로운 자료로 만듬     data = [1, 2, 3, 4, 5] * 3       data = 'hello' * 2       len : 자료를 구성하는 요소의 개수 / 길이 출력     data = len([1, 2, 3, 4, 5])      data = len('hello')       ìn: 자료에 값이 있는지 확인     data = 1 in data      data = 'e' in 'hello'         문자열 (str) : 한 글자 이상의 문자, 숫자, 기호를 표현   str1 = `hello` str2 = \"World\" str3 = \"\"\" hello World \"\"\" str4 = \"hello 'World'\" str5 = 'hello \"World\"'      이스케이프 문자 : 키보드로 입력하기 어려운 기호를 나타내기 위한 문자          \\n : 줄바꿈     \\t : 탭     \\\\ : \\     \\' : '     \\\" : \"         리스트 (list) : 값을 변경할 수 있는 여러 개의 데이터를 하나의 변수로 표현   &gt;&gt;&gt; li1 = [ 1, 'two', 3, 3, 'five' ]        # 리스트 &gt;&gt;&gt; li2 = [  ]                              # 빈 리스트      튜플 (tuple) : 값을 변경할 수 없는 여러 개의 데이터를 하나의 변수로 표현   &gt;&gt;&gt; tp1 = ( 1, 2, 3, 4, 4 )                 # 튜플 &gt;&gt;&gt; tp2 = (  )                              # 빈 튜플   논시퀀스 (Non-Sequence) : 자료들이 순서를 가지지 않고 나열되어 있는 자료형     집합 (set) : 값을 변경할 수 있고 여러 개의 데이터를 중복되지 않게 하나의 변수로 표현하는 자료형   &gt;&gt;&gt; st1 = { 1, 2, 3, 4, 5 }                 # 집합 &gt;&gt;&gt; st2 = set()                             # 빈 집합      딕셔내리 (dict) : 서로 대응되고 중복되지 않는 키와 값으로 데이터를 표현하는 자로형   &gt;&gt;&gt; dc1 = { 1:\"one\", 2:\"two\" }              # 딕셔내리 &gt;&gt;&gt; dc2 = {}                                # 빈 딕셔내리  for i in range(10): dc2[i] = str(i)  print(dc2) # {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9'}   제어문 (control flow) : 프로그램의 흐름을 지시하는 문장     조건문 if : 조건이 참인 경우에 실행할 문장을 지정해 수행            else : 조건이 거짓인 경우에 실행할 문장을 지정해 수행       elif : else if. 여러 개의 조건을 순차적으로 체크하기 위해 사용           if condition1:     statement1 elif condition2:     statement2 else:     statement3      반복문 for : 반복할 블록을 특정한 범위를 지정해 반복해 수행            continue : 현재 반복중인 블록의 나머지 부분을 실행하지 않고 다음 반복문을 수행       break : 반복문을 수행하지 않고 블록 밖으로 탈출       else : 반복문이 모두 수행되었을 때 수행           range = [1,2,3,4,5,6,7,8,9]  for i in range:        print(i)      반복문 while : 반복할 블록을 특정한 조건을 지정하고, 조건이 참이면 반복해 수행            continue : 현재 반복중인 블록의 나머지 부분을 실행하지 않고 다음 반복문을 수행       break : 반복문을 수행하지 않고 블록 밖으로 탈출           while condition:     if condition1:         break     if condition2:         continue     statement1 else:     statement2      반복 가능한 (iterable) 데이터 : 문자열, 리스트, 튜플, 집합, 딕셔내리, 바이트          __iter__ 메소드를 가지고 있음 : 반복자를 반환                반복자 (iterator) : __next__ 메소드를 통해 컨테이너의 개별 요소를 반복                  임포트 (import) : 모듈에 있는 함수들을 활용하기 위해 가져오는 것      모듈 (module) : 이미 만들어진 함수들을 하나의 파이썬 파일에 묶어둔 것     import mod       패키지 (package) : 모듈을 계층적인 디렉터리 형태로 구성한 것         디렉터리를 파이썬 패키지로 인식하려면 계층적으로 이루어져 있는 각 디렉토리마다 __init__.py 파일이 필요            pack 디렉토리에 mod.py와 __init__.py (내용 : version = 1.0)이 있는 구조       import pack.mod           import time # 파이썬 내장 모듈인 time 모듈 : time.sleep() 함수를 활용하기 위해 임포트  print('장비를 정지합니다.') time.sleep(5) print('안 되잖아?') time.sleep(5) print('어, 정..정지가 안 돼. 정지시킬 수가 없어.')      from : 계층구조를 모두 표시하지 않고 패키지나 모듈의 함수 호출   from 모듈 import 함수 from 패키지 import 모듈      as : 이름이 복잡하거나 계층구조가 복잡한 모듈에 이름을 붙어서 호출   import 모듈 as 별명   클래스 (class) : 객체지향 프로그래밍에서 특정 객체의 생성을 위해 변수와 메소드를 정의하는 공간 (namespace)          객체지향 프로그래밍 (OOP) : 프로그램을 객체 단위로 나누고 이들 간의 상호 작용으로 서술하는 방식                객체 (object) : 하나의 역할을 수행하는 멤버 (변수와 메소드)의 집합                        변수 (variable) : 데이터를 저장하기 위해 할당된 메모리 공간             메소드 (method) : 특정 작업을 수행하는 일련의 문장을 하나로 묶은 것                                         클래스 멤버 (class member) : 클래스에 정적으로 선언된 변수와 메소드            클래스 내에서 변수와 메소드를 선언           인스턴스 멤버 (instance member) : 클래스에 동적으로 선언된 변수와 메소드            클래스의 메소드 내에서 변수와 메소드를 선언              인스턴스 멤버는 클래스 멤버를 참조할 수 있지만, 클래스 멤버는 인스턴스 멤버를 참조할 수 없다.          클래스 멤버 : 클래스가 메모리에 로드될 때 생성     인스턴스 멤버 : 인스턴스가 생성될 때, 즉 클래스가 메모리에 로드된 이후에 생성       … 인스턴스가 생성될 때 클래스는 항상 메모리에 로드되어 있다. 그러나, 클래스의 생성이 인스턴스의 존재를 보장하지 않는다.    class myClass:   def func(self, name): # 클래스 메소드는 첫번째 인자가 반드시 self이여야 함     self.name = name     print(name + ' : ' + var)  obj = myClass() var = obj.var obj.func(var) # '클래스 멤버 : 클래스 멤버' 출력      클래스 생성자 init  : 클래스의 인스턴스 객체가 생성될 때 제일 먼저 호출되어 실행 (인스턴스 멤버 초기화)   클래스 소멸자 del : 클래스의 인스턴스 객체가 메모리에서 제거될 때 자동적으로 호출   class myClass:   def __init__(self):     self.var = '클래스 멤버'     print('&gt; myClass 클래스 시작') # '&gt; myClass 클래스 시작' 출력  ...    def __del__(self):     print('&gt; myClass 클래스 종료') # '&gt; myClass 클래스 종료' 출력  obj = myClass() ... del obj      클래스 상속 (class inherit) : 부모 클래스가 가진 멤버나 메소드를 상속받는 자식 클래스가 사용할 수 있게 하는 것   class subClass (myClass):   함수 (function) : 소스 코드에서 일정한 동작을 수행하는 코드     사용자 정의 함수 def( parameter ) : 함수 이름과 인수로 함수 정의            인자 (parameter) : 함수 호출 시 입력받을 값                    인자의 이름와 값을 넣어 호출할 수 있음 : 넣지 않으면 입력한 순서대로 배정           인자는 기본값을 지정할 수 있음 : 기본값이 있는 인자는 기본값이 없는 인자 뒤에 와야 함           가변 인자 : 개수를 정하지 않고 입력하는 값을 모두 인자로 사용 (* : 튜플로 저장, ** : 딕셔내리로 저장)                       반환값 (return value) : 반환문 return으로 반환할 값 정의                    반환문을 만날 경우, 해당 함수를 종료하고 반환값을 반환                           # 사용자 정의 함수 선언 def function_name( p1 = 2, p2) :     return p1  # 사용자 정의 함수 호출 &gt;&gt;&gt; user_func = function_name( p1 = 3, p2 = 4 )      전역 변수 (global) : 코드 전반에 걸쳐 유효한 변수   def function():   global param   param = 23      내장 함수 (Built-in Functions) : 다른 파이썬 모듈의 임포트 없이 사용할 수 있는 함수   &gt; dir(__builtins__) # 파이썬에서 사용할 수 있는 내장 함수를 확인   print() : 인자로 입력된 객체 값을 화면에 출력     end=\"\" : 출력되는 값 뒤에 추가될 값 지정 (기본값 : \\n)   x = 100 print(x) print(x, end = \"\") # 맨 뒤에 줄바꿈이 되지 않은 문장 출력      포맷 문자열 : 변하는 값을 포함하는 문자열을 표현하기 위해 사용되는 기호          %s : 문자열에 대응     %c : 문자나 기호 1개에 대응     %d : 정수에 대응     %f : 실수에 대응      input() : 키보드로 입력된 객체 값을 문자열로 반환     인수로 입력된 문자열은 화면에 출력   x = input('&gt; 값을 입력하세요 : ') print('입력된 값 : ' + x)   type() : 인자로 입력된 객체 값의 자료형을 반환   print(type(1))                           # &lt;class 'int'&gt; print(type(3.14))                        # &lt;class 'float'&gt; print(type(1+2j))                        # &lt;class 'complex'&gt; print(type('hello'))                     # &lt;class 'str'&gt; print(type(False))                       # &lt;class 'bool'&gt; print(type([1,2,3,4,5]))                 # &lt;class 'list'&gt; print(type((1,2,3,4,5)))                 # &lt;class 'tuple'&gt; print(type({1,2,3,4,5}))                 # &lt;class 'set'&gt; print(type({1:10,2:20,3:30,4:40,5:50}))  # &lt;class 'dict'&gt;   divmod() : 첫번째 정수 인자를 두번째 정수 인자로 나눈 결과 (몫, 나머지)를 튜플 형태로 반환   a = 11 b = 3 c, d = divmod(a, b) # c와 d에 3, 2 저장   hex()/bin()/int() : 10진수를 16진수로 / 10진수를 2진수로 / 2진수나 16진수를 10진수로 변환해 반황   b = 0b11110000; h = 0xf0 print(int(b)) # 240 print(int(h)) # 240 print(bin(int(b))) # 0b11110000 print(hex(int(h))) # 0xf0   abs() : 인자로 입력된 수치형 값의 절대값을 반환   print(abs(-3)) # 3  print(abs(-3.14)) # 3.14   max()/min(): 인자로 입력된 시퀀스형 값의 최댓값 / 최솟값을 반환   print(max(pneumonoultramicroscopicsilicovolcanoconiosis)) # s print(min(pneumonoultramicroscopicsilicovolcanoconiosis)) # p print(max([1, -3, 2, 0, -5, 6])) # 6 print(min(1, -3, 2, 0, -5, 6)) # -5   round() : 인자로 입력된 수치형 값의 반올림한 값을 반환   print(round(3.14)) # 3   int()/float()/str() : 인자를 실수형 값으로 / 정수형 값으로 / 문자열로 변환   print(int(3.14)) # 3 print(float(i(3.14))) # 3.0 print(int('3')) # 오류 print(float('3.14')) # 오류 print(str(3.14)) # 3.14   filter() : 첫번째 인자인 함수에 두번째 인자인 반복 가능한 데이터의 값을 순서대로 넣어 참인 것만 리스트로 반환   def positive(x):     return x &gt; 0  print(list(filter(positive, [1, -3, 2, 0, -5, 6]))) # [1, 2, 6]   .count() : 문자열이나 리스트에서 인자로 입력된 특정 문자(열)의 개수를 반환   print('hello world'.count('l')) # 3 print('hello world'.count('he')) # 1 print('hello world'.count(' ')) # 1   .find() : 문자열에서 인자로 입력된 특정 문자(열)이 처음 나오는 위치를 나타내는 인덱스 반환     두번째 인자를 입력할 경우, 두번째 인자에 해당되는 인덱스부터 탐색   print('hello world'.find('l')) # 2 print('hello world'.find('he')) # 0 print('hello world'.find('l', 6)) # 9   .split() : 문자열을 인자로 입력된 문자(열)로 나눈 결과를 리스트로 반환     구분자 (separator)로 들어올 인자가 없으면, 공백을 기준으로 문자열을 나눔   print('http://naver.com'.split('/')) # 'http:', '/', '/', 'naver', '.com' print('hello world'.split()) # 'hello', 'world'   .join() : 인자로 입력된 리스트의 모든 요소를 연결된 문자열을 반환   print('/'.join(['2022', '12', '25'])) # 2022/12/25   replace() : 문자열에서 인자로 입력된 특정 문자(열)을 다른 문자(열)로 바꾼 문자열을 반환   print('hello world'.replace('l', 'L') # heLLo worLd   sorted() : 인자로 입력된 문자열이나 리스트, 딕셔내리의 요소를 오름차순으로 정렬한 리스트를 반환     reverse = true : 문자를 내림차순으로 정렬   print(sorted(input())) # 입력된 문자열을 오름차순으로 정렬 print(sorted(input(), reverse = true)) # 입력된 문자열을 오름차순으로 정렬      key = : 딕셔내리의 특정 기준을 바탕으로 오름차순으로 정렬   dc2 = {} for i in range(10):   for j in range(10, 0):     dc2[i] = str(j)  def f1(x):   return x[0]  def f2(x):   return x[1]  ret_dc2 = sorted(dc2.items(), key = f1 | f2) # key | value를 기준으로 정렬   range() : 인자로 범위를 지정해 순차적인 정수 리스트를 반환     인자가 1개 : 0부터 (인자 - 1)까지 순차적인 정수 리스트   인자가 2개 : (첫번째 인자)부터 (두번째 인자 - 1)까지 순차적인 정수 리스트   print(range(10)) print(range(10, 20))   .reverse()/reversed() : 인자로 입력된 리스트를 거꾸로 함 / 거꾸로 한 리스트를 반환   listData = list(range(5)) listData.reverse()  print(listData) # 4,3,2,1,0 print(reversed.(listData)) # 0,1,2,3,4   append() : 인자로 입력된 값을 리스트의 맨 마지막 요소로 추가   listData = list(range(5)) listData.append(7)  print(listData) # 0,1,2,3,4,7   insert() : 리스트의 첫번째 인자의 인덱스에 해당되는 위치에 두번째 인자로 입력된 값을 삽입   listData = ['0', '1', '2', '3', '4']  listData.insert(2, '7') print(listData)  # 0,1,7,2,3,4   remove()/del() : 리스트나 딕셔내리의 특정 요소를 / 인덱스가 인자인 요소를 삭제   listData = ['0', '1', '2', '3', '4']  listData.remove('1') print(listData) # 0,2,3,4  del listData[3] print(listData) # 0,2,3   sum() : 임의의 정수가 요소인 리스트에서 모든 요소의 합을 반환   print(sum(list(range(5))))   clear() : 딕셔내리의 모든 요소를 제거한 빈 딕셔내리로 바꿈   dc2 = {} or i in range(10): dc2[i] = str(i)  dc2.clear()  print(dc2) # {}   keys()/values()/items() : 딕셔내리의 키 / 값 / 모두를 추출해 반환     list()로 변환하지 않으면 print()에 넣으면 dict_keys([...]), dict_values([...]) dict_items([...])로 출력   dc2 = {} or i in range(10): dc2[i] = str(i)  print(list(dc2.keys())) print(list(dc2.values())) print(list(dc2.items()))   all()/any() : 리스트의 모든 요소가 True이면 False / False면 True   listData = [False, False, True, True] print(all(listData)) print(any(listData)) print(all(listData[::2])) print(any(listData[::2]))   lambda  : 함수 이름 없이 한줄로 함수를 정의   f = lambda x: x * x print(f(8)) # 64  f = lambda x, y: x + y print(f(8,9)) # 17   map() : 인자를 바꾸어 함수를 반복해 호출한 결과를 나열   f = lambda x: x * x args = [1,2,3,4,5] ret = map(f, args) print(list(ret))   파일 입출력 (file input &amp; output) : 텍스트나 바이너리 파일을 읽고 쓰는 것      open : 파일 열기 (파일이 없는 경우 생성)            r, rt : 읽기 모드 (파일을 읽을 때 사용)       w, wt : 쓰기 모드 (파일을 편집할 때 사용)       a, at : 추가 모드 (파일의 마지막에 내용을 추가할 때 사용)              파일이 해당 디렉토리에 존재하지 않는 경우, 새로운 파일이 생성됨    파일 객체 = open(파일 이름, 모드)  f1 = open(\"readme1.txt\", 'r') f2 = open(\"readme2.txt\", 'w') f3 = open(\"readme3.txt\", 'a')      .read()/.readline()/.readlines() : 파일을 모두 문자열로 / 한줄씩 문자열로 / 한줄을 요소로 한 리스트로 읽기   f = open(\"readme.txt\", 'r') data1 = f.read() data2 = f.readline() data3 = f.readlines()      .write()/.writelines() : 파일에 입력받은 인자를 전부 / 한줄씩 쓰기   f = open(\"readme.txt\", 'w') data1 = '&gt; 다음은 입력된 값입니다.' data2 = input('&gt; 파일에 입력할 값 : ') f.write(data1 + data2)      .close : 열려 있는 파일을 닫기   f.close()      with ~ as  : 파일을 열고 파일에 대한 처리가 끝나면 자동으로 파일을 닫음   with open('readme.txt', 'w') as f:   ...  ","categories": [],
        "tags": ["Python"],
        "url": "/python1/",
        "teaser": null
      },{
        "title": "[Algorithm] 1. 알고리즘과 복잡도",
        "excerpt":"알고리즘 (Algorithm) : 어떠한 문제를 해결하기 위한 절차나 방법      입력 (input) : 외부에서 제공된 자료가 존재하거나 존재하지 않아야 함   출력 (output) : 최소 1개 이상의 결과를 가져야 함   알고리즘의 복잡도 (Complexity) : 알고리즘의 성능을 나타내는 척도   공간 복잡도 (Space Complexity) : 문제를 해결할 때 걸리는 공간과 입력의 함수 관계     특정한 크기의 입력에 대해 알고리즘이 얼마나 많은 메모리를 차지하는가?   알고리즘을 위해 필요한 메모리의 양   시간 복잡도 (Time Complexity) : 문제를 해결할 때 걸리는 시간과 입력의 함수 관계     특정한 크기의 입력에 대해 알고리즘이 얼마나 오래 걸리는가?   알고리즘을 위해 필요한 연산의 횟수   만약 프로그램을 비효율적으로 작성해 시간 제한 (Time Limit)를 넘기면, 시간 초과 (Time Limit Exceeded)   빅 오 표기법 (Big-O) : 최악의 경우만을 고려해 시간 복잡도를 계산     가장 빠르게 증가할, 즉 가장 높은 차수의 항만을 고려하고 계수와 나머지 차수의 항들은 계산에서 제외   만약 크기 N의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 N의 식을 가지면, 점근적 시간 복잡도는 O(N)   공통 시간 복잡도 표 (Common Time Complexity Table)   \t \t\t \t\t\t빅 오 표기법 \t\t\t설명 \t\t \t    \t                      O(1)             상수 시간                               O(logN)             로그 시간                               O(N)             선형 시간                               O(N * logN)             로그 선형 시간                               O(N^2)             2차 시간                               O(N^3)             3차 시간                               O(N^4)             4차 시간                    만약 시간 제한이 1초인 문제를 해결할 때, 시간 복잡도 …인 알고리즘을 설계해야 한다.         N의 범위가 500인 경우 : O(N^3)     N의 범위가 2,000인 경우 : O(N^2)     N의 범위가 100,000인 경우 : O(N * logN)     N의 범위가 10,000,000인 경우 : O(N^3)              수행 시간 측정 Code by Python       import time start_time = time.time() # 측정 시작 ... end_time = time.time() # 측정 종료 print(end_time - start_time) # 수행 시간 출력  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/algorithm1/",
        "teaser": null
      },{
        "title": "[Algorithm] 2. 구현",
        "excerpt":"구현 (Implementation) : 알고리즘을 소스 코드로 바꾸는 과정      구현은 결국 모든 범위의 문제 유형을 포괄하는 개념   문제 해결 분야의 구현 유형은 ‘풀이를 떠오르는 것은 쉽지만 소스 코드로 옮기기 어려운 문제’ 의미   대체로 사소한 조건 설정이 많은 문제일수록 구현이 까다로움      Python으로 구현할 때 고려할 제약 사항 : 변수 표현 범위            Python은 프로그래머가 직접 정수형 변수 자료형을 지정할 필요가 없고 아주 큰 수의 연산 역시 기본으로 지원       실수형 변수는 유효 숫자에 따라 연산하기에 원하는 결과가 나오지 않을 수 있음                Python의 리스트 크기 : Python에서 여러 변수를 사용할 때 리스트를 이용할 때, 제한된 메모리를 초과할 수 있음                                     list의 길이              메모리 사용량                                              1,000              약 4KB                                  1,000,000              약 4MB                                  1,000,000,000              약 40MB                        BOJ 4673번. 셀프 넘버 (S5)   import sys read = sys.stdin.readline  li = [0 for i in range(10001)]  for i in range(1, 10000):     n = i     while 0 &lt; n &lt;= 10000:         li[n] += 1         if n &lt; 10:             n += n         elif 10 &lt;= n &lt; 100:             n += n % 10 + n // 10         elif 100 &lt;= n &lt; 1000:             n += n // 100 + n % 100 // 10 + n % 100 % 10         elif 1000 &lt;= n &lt; 10000:             n += n // 1000 + n % 1000 // 100 + n % 1000 % 100 // 10 + n % 1000 % 100 % 10         else:             n += n // 10000 + n % 10000 // 1000 + n % 10000 % 1000 // 100 + n % 10000 % 1000 % 100 % 10  for i in range(1, 10000):     if li[i] == 1:         print(i)   BOJ 2563번. 색종이 (S5)   import sys read = sys.stdin.readline  M = [[0 for c in range(100)] for r in range(100)]  N = int(read())  for i in range(N):     X, Y = map(int, read().split())     for j in range(X - 1, X + 9):         for k in range(Y - 1, Y + 9):             M[j][k] = 1  S = 0  for j in range(100):     for k in range(100):         S += M[j][k]  print(S)   BOJ 16926번. 배열 돌리기 1 (S1)   import sys read = sys.stdin.readline  M = [[0 for c in range(100)] for r in range(100)]  N = int(read())  for i in range(N):     X, Y = map(int, read().split())     for j in range(X - 1, X + 9):         for k in range(Y - 1, Y + 9):             M[j][k] = 1  S = 0  for j in range(100):     for k in range(100):         S += M[j][k]  print(S)   BOJ 16926번. 배열 돌리기 1 (S1)   import sys read = sys.stdin.readline  N, M, R = map(int, read().split())  B = [list(map(int, read().split())) for i in range(N)]  C = 0  # 회전의 개수 if (N / 2) &gt;= (M / 2):     C = M // 2 else:     C = N // 2  for i in range(R):  # 입력받은 회전만큼     for j in range(C):  # 동그라미 개수만큼         n = N - j * 2  # 동그라미의 열의 개수         m = M - j * 2  # 동그라미의 줄의 개수          for l in range(m - 1):             t = B[j][j + l]             B[j][j + l] = B[j][j + l + 1]             B[j][j + l + 1] = t          for l in range(n - 1):             t = B[j + l][M - 1 - j]             B[j + l][M - 1 - j] = B[j + l + 1][M - 1 - j]             B[j + l + 1][M - 1 - j] = t          for l in range(m - 1):             t = B[N - 1 - j][M - 1 - j - l]             B[N - 1 - j][M - 1 - j - l] = B[N - 1 - j][M - 2 - j - l]             B[N - 1 - j][M - 2 - j - l] = t          for l in range(n - 2):             t = B[N - 1 - j - l][j]             B[N - 1 - j - l][j] = B[N - 2 - j - l][j]             B[N - 2 - j - l][j] = t   BOJ 1002번. 터렛 (S3)   import sys import math read = sys.stdin.readline  T = int(read())  for i in range(T):     N = read().split()     N = [int(n) for n in N]      Z = math.sqrt((N[0] - N[3]) ** 2 + (N[1] - N[4]) ** 2)      if Z == 0 and N[2] == 0 and N[5] == 0:         print(1)     elif N[2] + N[5] &gt; Z &gt; abs(N[2] - N[5]):  # 접점 2개         print(2)     elif (N[2] + N[5] == Z or abs(N[2] - N[5]) == Z) and Z != 0:  # 접점 1개         print(1)     elif N[2] + N[5] &lt; Z or abs(N[2] - N[5]) &gt; Z:  # 접점 0개         print(0)     elif Z == 0 and N[2] == N[5]:         print(-1)   BOJ 25206번. 너의 평점은 (S5)   import sys read = sys.stdin.readline  EntireSubject = 0.0 EntireSubjectNum = 0.0  for i in range(20):     Subject = read().split()     Subject[1] = float(Subject[1])      if Subject[2] == \"A+\":         EntireSubject += Subject[1] * 4.5     elif Subject[2] == \"A0\":         EntireSubject += Subject[1] * 4.0     elif Subject[2] == \"B+\":         EntireSubject += Subject[1] * 3.5     elif Subject[2] == \"B0\":         EntireSubject += Subject[1] * 3.0     elif Subject[2] == \"C+\":         EntireSubject += Subject[1] * 2.5     elif Subject[2] == \"C0\":         EntireSubject += Subject[1] * 2.0     elif Subject[2] == \"D+\":         EntireSubject += Subject[1] * 1.5     elif Subject[2] == \"D0\":         EntireSubject += Subject[1] * 1.0     elif Subject[2] == \"F\":         EntireSubject += Subject[1] * 0.0      if Subject[2] != \"P\":         EntireSubjectNum += Subject[1]  print(EntireSubject / EntireSubjectNum)   BOJ 1193번. 분수 찾기 (S5)   import sys read = sys.stdin.readline  X = int(read())  x = 1 y = 1 z = 1  for i in range(X - 1):     if x == 1 and y % 2 == 1:         y += 1         z = 0     elif y == 1 and x % 2 == 0:         x += 1         z = 1     elif z == 0:         x += 1         y -= 1     elif z == 1:         x -= 1         y += 1  # 출력 print(str(x) + \"/\" + str(y))   BOJ 1004번. 어린 왕자 (S3)   import sys import math  read = sys.stdin.readline  T = int(read())  for t in range(T):     x1, y1, x2, y2 = map(int, read().rstrip().split())      N = int(read())     L1 = []      for n in range(N):         L2 = list(map(int, read().rstrip().split()))         L1.append(L2)      ans = 0      for n in range(N):         cnt = 0          for m in range(2):             if m == 0:                 D = math.sqrt((x1 - L1[n][0]) ** 2 + (y1 - L1[n][1]) ** 2)                 if D &lt; L1[n][2]:                     cnt += 1             else:                 D = math.sqrt((x2 - L1[n][0]) ** 2 + (y2 - L1[n][1]) ** 2)                 if D &lt; L1[n][2]:                     cnt += 1          if cnt == 1:             ans += 1      print(ans)   BOJ 1316번. 그룹 단어 체커 (S5)   import sys read = sys.stdin.readline  N = int(read()) ans = N  for n in range(N):     S = read().rstrip()     L = []      for s in S:         if L.__contains__(s) == 0:             L.append(s)         elif L[-1] == s:             continue         else:             ans -= 1             break  print(ans)   BOJ 2941번. 크로아티아 알파벳 (S5)   import sys read = sys.stdin.readline  C = list(read().rstrip()) ans = 0 c = 0  while c &lt; len(C):     if C[c] == \"c\" and c + 1 != len(C):         if C[c + 1] == \"=\" or C[c + 1] == \"-\":             ans += 1             c += 1         else:             ans += 1     elif C[c] == \"d\" and c + 1 != len(C):         if C[c + 1] == \"z\" and c + 2 != len(C):             if C[c + 2] == \"=\":                 ans += 1                 c += 2             else:                 ans += 1         elif C[c + 1] == \"-\":             ans += 1             c += 1         else:             ans += 1     elif (C[c] == \"l\" or C[c] == \"n\") and c + 1 != len(C):         if C[c + 1] == \"j\":             ans += 1             c += 1         else:             ans += 1     elif (C[c] == \"s\" or C[c] == \"z\") and c + 1 != len(C):         if C[c + 1] == \"=\":             ans += 1             c += 1         else:             ans += 1     else:         ans += 1     c += 1  print(ans)   BOJ 24313번. 알고리즘 수업 - 점근적 표기 1 (S5)   import sys read = sys.stdin.readline  A, B = map(int, read().rstrip().split()) C = int(read()) N = int(read())  if A &gt; 0 and C &gt; 0:     if A &gt; C:         print(\"0\")     elif A == C:         if B &gt; 0:             print(\"0\")         else:             print(\"1\")     else:         if A * N + B &lt;= C * N:             print(\"1\")         else:             print(\"0\") elif A &gt; 0 &gt;= C:     print(\"0\") elif A == 0:     if B &lt;= C * N:         print(\"1\")     else:         print(\"0\") elif A &lt; 0 &lt; C:     if A * N + B &lt;= C * N:         print(\"1\")     else:         print(\"0\") elif A &lt; 0 and C == 0:     if A * N + B &lt;= C * N:         print(\"1\")     else:         print(\"0\") elif A &lt; 0 and C &lt; 0:     if A &gt; C:         print(\"0\")     elif A == C:         if B &gt; 0:             print(\"0\")         else:             print(\"1\")     else:         if A * N + B &lt;= C * N:             print(\"1\")         else:             print(\"0\")  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/algorithm2/",
        "teaser": null
      },{
        "title": "[Linux] 홈브류 (Homebrew)",
        "excerpt":"홈브류 (Homebrew) : 패키지 관리 어플리케이션 (Package Management Application)      일반적으로 커맨드라인 도구나 시스템 패키지 설치에 사용   cask Package : GUI 어플리케이션 설치도 가능하게 해주는 Homebrew 확장 패키지   mas Package : App Store 어플리케이션 설치도 가능하게 해주는 Homebrew 확장 패키지   Homebrew 설치     터미널 실행 후 다음 명령어를 입력   /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"      터미널 창에 다음 명령어를 입력해 Homebrew가 정상적으로 설치되었는지 확인   brew --version // \"Homebrew X.X.X\" 출력 : 정상 설치 // \"zsh: command not found: brew\" 출력 : 설치 오류   cask Package 설치     터미널 창에 다음 명령어를 입력   brew install cask      터미널 창에 다음 명령어를 입력해 cask Package가 정상적으로 설치되었는지 확인   brew list   mas Package 설치     터미널 창에 다음 명령어를 입력   brew install mas      터미널 창에 다음 명령어를 입력해 mas Package가 정상적으로 설치되었는지 확인   brew list   Homebrew 명령어                              Homebrew 명령어 이름             Homebrew 명령어 설명                                         brew --version             Homebrew의 버전 정보 확인                               brew doctor             Homebrew 설치 환경을 검사                               brew update             Homebrew를 최신 버전으로 업데이트                               brew list             설치된 패키지를 확인                               brew upgrade             설치된 모든 패키지를 업데이트                               brew search (패키지명)             해당 패키지가 설치되어 있는지 검색                               brew install (패키지명)             해당 패키지를 최신 버전으로 설치                               brew info (패키지명)             해당 패키지의 정보 확인                               brew upgrade (패키지명)             해당 패키지를 업데이트                               brew uninstall (패키지명)             해당 패키지를 삭제                               brew outdated             최신 버전이 존재하는 패키지 확인                               brew cleanup (패키지명)             해당 패키지의 구버전에 해당하는 파일 삭제                 cask 명령어     기존 brew 명령어 뒤에 --cask를 추가   mas 명령어                              mas 명령어 이름             mas 명령어 설명                                         mas version             mas의 버전 정보 확인                               mas list             mas로 설치된 패키지 확인                               mas upgrade             mas로 설치된 모든 패키지를 최신 버전으로 업데이트                               mas search (검색어)             앱스토어에서 해당 검색어와 일치하는 패키지 검색                               mas install (패키지 ID)             해당되는 ID를 가진 패키지를 최신 버전으로 설치                               mas upgrade (패키지 ID)             해당되는 ID를 가진 패키지를 최신 버전으로 업데이트                               mas uninstall (패키지명)             mas로 설치된 해당 패키지를 삭제                               mas outdated             mas로 설치된 패키지 중 최신 버전이 존재하는 패키지 확인                ","categories": [],
        "tags": ["Linux"],
        "url": "/homebrew1/",
        "teaser": null
      },{
        "title": "[CSS] CSS & CSS 속성",
        "excerpt":"CSS (Cascading Style Sheet) : 웹 문서가 표현되는 방법을 기술하는 스타일시트 언어           레이아웃 및 디자인 정보로 인해 HTML 문서의 구조화가 어려워진 문제를 해결하기 위해 CSS 탄생           (1) Inline Style : HTML 태그의 style 속성으로 태그의 속성을 일일이 적용   &lt;p style=\"color: blue\"&gt;     hello world &lt;/p&gt;   (2) Inline Style Sheet : HTML 문서 내 &lt;style&gt; 태그로 한 문서의 스타일 적용   &lt;head&gt;     &lt;style&gt;         body { background-color: black; }     &lt;/style&gt; &lt;/head&gt;   (3) Linking Style Sheet : 내용에 스타일 정보를 분리해 별도의 스타일시트 (.css) 파일을 만들고 HTML 문서와 연결   &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;  CSS 스타일시트 (CSS Style Sheet) : 스타일을 선언하고 태그를 선택하는 CSS RuleSet의 집합     CSS 선택자 (CSS Selector) : 어떤 HTML 태그나 HTML 속성을 꾸밀지 지정   CSS 선언 (CSS declaration) : CSS 선택자에 대한 CSS 속성과 CSS 값을 정의            CSS 속성 (CSS Attributes) : 선택자가 지정한 것을 어떤 속성으로 꾸밀지 지정       CSS 변수 (CSS Arguments) : 지정된 속성을 어떻게 나타낼지 지정           CSS 선택자 {     CSS 속성 : CSS 값; /* CSS 선언 */ }  CSS 선택자 { /* 세미클론 (;)으로 선언을 구분해 여러 번의 선언 가능 */     CSS 속성1 : CSS 값1;     CSS 속성2 : CSS 값2; }   CSS 선택자 { /* 작은따옴표 ('') 혹은 큰따옴표 (\"\")으로 값의 공백 처리 */     CSS 속성1 : 'CSS 값1';     CSS 속성2 : \"CSS 값2\"; }      ! 같은 CSS 선택자나 CSS 속성이 선언되었다면? : CSS RuleSet에 대한 우선순위의 필요성    캐스케이딩 (Cascading) : 같은 CSS 선언이 여러 번 선언하였다면, 나중에 선언된 것을 적용     나중에 선언된 것이 먼저 선언된 것을 덮어버림 (Override)   CSS 선택자 { /* 나중에 선언된 CSS 속성1의 값2가 적용된다. */     CSS 속성1 : CSS 값1;     CSS 속성1 : CSS 값2; }     전역적인 것을 먼저 적용하고, 그 다음에 지역적인 것을 적용            부모 태그에서 선언된 속성은 자식 태그로 상속되어, 부모 자식에서 선언된 값이 적용된다.       자식 태그에서 상속받은 속성을 다시 선언되면, 자식 태그에서 선언된 값이 적용된다.           &lt;p style=\"color: red\"&gt;     &lt;span style=\"color: blue\"&gt;         CSS 우선순위 : span의 font-color 속성이 p의 font-color 속성보다 높다.     &lt;/span&gt; &lt;/p&gt;                 CSS 우선순위 : span의 font-color 속성이 p의 font-color 속성보다 높다.         CSS 명시도 (Specificity) : 작성된 순서가 아닌, CSS 선언에 적용되는 가중치에 따라 우선순위 적용     가중치는 네 가지 기준을 숫자로 표현 (0,0,0,0) : 제일 앞의 숫자가 높을수록 높은 우선순위를 가짐            명시도가 동일할 경우, 나중에 선언된 것을 우선해 적용 (Cascading)           p..div &gt; span { color : green;} /* 몀시도 : 0,1,0,2 */ b span {color : red;} /* 명시도 : 0,0,0,2 */      첫번째 0 : 인라인 스타일 (inline style)의 개수   세번째 0 : 클래스, 가상 클래스, 속성 선택자의 개수   두번째 0 : ID 선택자의 개수   네번째 0 : 태그 선택자, 가상 요소 선택자의 개수   !important : 기존의 우선순위를 무시하고 해당 CSS 선언을 우선해 적용   CSS 선택자 { */     CSS 속성1 : CSS 값1 !important;     CSS 속성1 : CSS 값2; }  CSS 선택자 (CSS Selector) : HTML 문서에 스타일을 입힐 요소를 선택하는 문자     여러 종류의 선택자를 중첩 가능 (p.span)   여러 종류의 선택자를 space 키로 구분해 동시에 선택 가능  (p.span p.img)   CSS 선택자 {     CSS 속성 : CSS 값; }   전체 선택자 * : 모든 요소를 선택하는 선택자   * {   color: blue; }   태그 선택자 tag : 해당 태그의 요소를 선택하는 선택자   tag {   color: aqua; }   아이디 선택자 #id : 해당 아이디의 요소를 선택하는 선택자   #tag {   color: red; }   클래스 선택자 .class : 해당 클래스의 요소를 선택하는 선택자   .class {   color: green; }   후손 선택자 (selector1) (selector2) : 해당 선택자의 모든 하위 요소 중 하나를 지정해 선택하는 선택자   div tag {      color: yellow; } ... &lt;div&gt;     &lt;tag&gt;         hello world     &lt;/tag&gt; &lt;/div&gt; &lt;div&gt;     &lt;span&gt;         &lt;tag&gt;             hello world         &lt;/tag&gt;     &lt;/span&gt; &lt;/div&gt;   자손 선택자 (selector1)&gt;(selector2) : 해당 선택자의 자식 요소 중 하나를 지정해 선택하는 선택자   div &gt; tag{      color: purple; } ... &lt;div&gt;     &lt;tag&gt;         hello world     &lt;/tag&gt; &lt;/div&gt;   형제 선택자 (selector1)~(selector2) : 해당 선택자의 형제 요소 중 하나를 지정해 선택하는 선택자   div ~ tag{      color: pink; } ... &lt;div&gt;     hello world &lt;/div&gt; &lt;tag&gt;     ! &lt;/tag&gt;   인접 형제 선택자 (selector1)+(selector2) : 선택자의 형제 중 바로 다음에 오는 요소를 선택하는 선택자   div + tag{      color: gray; } ... &lt;div&gt;     hello world &lt;/div&gt; &lt;tag&gt;     ? &lt;/tag&gt; &lt;tag&gt;     ! &lt;/tag&gt; /* 첫번째 형제 요소인 \"?\"가 회색으로 출력 */   속성 선택자 [attr] : 태그에 해당 속성이 명시된 요소들을 모두 선택하는 선택자     [attr = \"A\"] : 해당 속성이 명시된 요소들 중 값이 일치하는 것들만 선택   [attr ~= \"B\"] : 해당 속성이 명시된 요소들 (띄어쓰기로 여러 값이 저장된 요소 포함) 중 값이 일치하는 것들만 선택   [attr ^= \"C\"] : 해당 속성이 명시된 요소들 중 값을 접두사로 가지는 것들만 선택   [attr $= \"D\"] : 해당 속성이 명시된 요소들 중 값을 접미사로 가지는 것들만 선택   [attr *= \"E\"] : 해당 속성이 명시된 요소들 중 값을 포함하는 것들만 선택   tag[attributes]{      color: white; } ... &lt;tag attributes=\"true\"&gt;     hello world &lt;/tag&gt;  tag[attributes=\"attr\"]{      color: yellow; } ... &lt;tag attributes=\"attr\"&gt;     hello world &lt;/tag&gt;   가상 클래스 선택자 (Pseudo-class Selector) : 가상 클래스를 선택하는 선택자     앵커 가상 클래스 : 어떤 요소에 대한 스타일을 추가하는 선택자            link : 사용자가 이전에 방문하지 않은 요소에 대한 스타일을 추가하는 선택자       visited : 사용자가 이전에 방문하였던 요소에 대한 스타일을 추가하는 선택자       :hover : 사용자가 해당 요소에 커서를 접근시킬 때의 동적인 스타일을 추가하는 선택자       :active : 사용자가 해당 요소를 클릭할 때의 동적인 스타일을 추가하는 선택자       :focus : 사용자가 해당 요소에 키보드로 포커싱할 때의 동적인 스타일을 추가하는 선택자           a:link {     color: black; } a:visited {     color: gray; } a:hover {     color: red; } a:active {     color: gray; } a:focus {     color: yellow; }      순서 가상 클래스 : 순서가 존재하는 요소의 특정 항목에 대한 스타일을 추가하는 선택자            :first-child : li의 첫번쩨 요소에 대한 스타일를 추가하는 선택자       :last-child : li의 마지막 요소에 대한 스타일를 추가하는 선택자       :nth-child(n) : li의 n번쩨 요소에 대한 스타일를 추가하는 선택자           ol li:first-child {     border-top: none; } ol li:last-child {     border-top: none; } ol li:nth-child(2) {     border-top: none; }   가상 요소 선택자 (Pseudo-element Selector) : 가상 요소를 선택하는 선택자     선택된 요소의 태그 안에 가상 요소가 자식 요소로 위치 (::before &gt; 컨텐츠 &gt; ::after 순)   선택자::가상 요소 {     property: value; }      ::before : 요소 내용의 앞에 새 컨텐츠를 추가하는 선택자   tag::before {     content: \"Hello, \"; }      ::after : 요소 내용의 뒤에 새 컨텐츠를 추가하는 선택자   tag::after {     content: \"World! \"; }      ::first-letter : 요소의 첫번째 글자를 선택하는 선택자   tag::first-line {   color: orange; }      ::first-line : 요소의 첫번째 줄을 선택하는 선택자   tag::first-line {   color: orange; }      현재까지 배운 것을 토대로 여러 HTML 문서로 이루어진 가상의 웹사이트를 디자인한다고 가정해보자.         태그나 문서에 스타일을 적용하는 경우를 배제하고, 스타일시트에 모든 스타일 정보가 존재한다 가정하자.     모든 HTML문서가 &lt;body&gt;, &lt;main&gt;, &lt;section&gt;, &lt;p&gt;만 존재하고, 다음의 구조를 이룬다.       &lt;body&gt;   &lt;main&gt;     &lt;section&gt;       &lt;p&gt; Hello World! &lt;/p&gt;     &lt;/section&gt;   &lt;/main&gt; &lt;/body&gt;            그리고 스타일시트에는 다음과 같은 CSS 선택자만 사용한다고 가정하자.                문서의 전반적인 스타일을 적용하기 위한 &lt;body&gt;를 지정할 선택자         메인 컨텐츠의 스타일을 적용하기 위한 &lt;main&gt;를 지정할 선택자         세부 컨텐츠의 스타일을 적용하기 위한 &lt;section&gt;를 지정할 선택자         문단의 스타일을 적용하기 위한 &lt;p&gt;를 지정할 선택자                   A는 모든 문서의 “Hello World!”를 빨간색으로 적용하고 싶어서 태그에 스타일을 적용했다.     p {    color:green; }       그런데 B가 특정 문서의 “Hello World!”를 초록색으로 적용하고 싶어서 id와 #를 사용했다.     &lt;p id=\"sec2\"&gt; Hello World! &lt;/p&gt;      #sec {    color:green; }       A가 그걸 보고     p {    color:green; }            CSS는 시대가 요구하는 의도대로 설계되었으나, 기존의 설계와 새로운 요구사항에 괴리가 발생                문서를 잘 표현하기 위해 설계된 방법 vs 어플리케이션을 잘 표현하기 위해 설계된 방법                        이를 절충하기 위해 기존의 의도와는 다른 방식으로 CSS를 사용해 화면을 표현                                     CSS가 웹 문서를 웹 사이트에 표현하는 데에서 시작되어 대규모 웹 서비스를 만드는 데에 한계점 존재                그러므로, 이를 극복하기 위한 최신 기술들을 꾸준히 학습하고, 프로젝트에 도입해야 된다!                          CSS 변수 (CSS variables) : CSS 사용자 속성 (CSS 일반 속성과 동일한 문법으로 변수를 정의 가능)            var() 함수 : CSS 변수값을 읽는 데에 사용       :root : CSS 변수를 전역 변수로 정의           .ex {     --variable-name: value; }  :root {        --variable-name: value; }   # 박스 모델 (Box Model) 관련 CSS 속성     모든 HTML 엘리멘트들은 박스 모양으로 구성되어 있음            마진 영역 (Margin Area)       테두리 영역 (Border Area)       패딩 영역 (Padding Area)       컨텐츠 영역 (Content Area)                         마진 영역 (Margin Area)                      테두리 영역 (Border Area)                              패딩 영역 (Padding Area)                                      컨텐츠 영역 (Content Area)                                               width, height : 박스의 가로, 세로 길이를 지정하는 속성   &lt;div style=\"     position: relative;     background-color: black;     margin-left: auto;     margin-right: auto;     width: 200px;     height: 200px;\"&gt;     &lt;div style=\"         position: absolute;         background-color: white;         margin-left: auto;         margin-right: auto;         width: 70%;         height: 70%;\"&gt;     &lt;/div&gt; &lt;/div&gt;                margin : 마진에 값을 부여하는 속성     margin-top: : 위쪽 마진에 값을 부여하는 속성   margin-right: : 오른쪽 마진에 값을 부여하는 속성   margin-bottom: : 아랫쪽 마진에 값을 부여하는 속성   margin-left: : 왼쪽 마진에 값을 부여하는 속성   .box {     margin: xx yy zz ww;     /* xx는 위쪽 마진, yy는 오른쪽 마진, zz는 아랫쪽 마진, ww는 왼쪽 마진 */     margin-top: xx;     margin-right: yy;     margin-bottom: zz;     margin-left: ww; }                 margin-top                                       margin-left                                              테두리 영역 (Border Area)                                      패딩 영역 (Padding Area)                                              컨텐츠 영역 (Content Area)                                                                margin-right                         margin-bottom        padding : 패딩에 값을 부여하는 속성     padding-top: : 위쪽 패딩에 값을 부여하는 속성   padding-right: : 오른쪽 패딩에 값을 부여하는 속성   padding-bottom: : 아랫쪽 패딩에 값을 부여하는 속성   padding-left: : 왼쪽 패딩에 값을 부여하는 속성   .box {     padding: xx yy zz ww;     /* xx는 위쪽 패딩, yy는 오른쪽 패딩, zz는 아랫쪽 패딩, ww는 왼쪽 패딩 */     padding-top: xx;     padding-right: xx;     padding-bottom: xx;     padding-left: xx; }                 마진 영역 (Margin Area)                  테두리 영역 (Border Area)              padding-top                                        padding-left                                          컨텐츠 영역 (Content Area)                           padding-right                  padding-bottom                  border : 테두리에 값을 부여하는 속성                                               border: 속성                 설명                                                             기본값                 medium, none, color                                           상속 여부                 N                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  border: 값                                     설명                                                                                                                                                                 border-width                                                                                                                                                                                                                                 border-width: 값                                                     테두리의 두께 정도 지정                                                                                                                                                                                                                                                 medium                                                     기본값                                                                                                                                                       thick                                                     기본값보다 굵게                                                                                                                                                       thin                                                     기본값보다 얇게                                                                                                                                                       %, px, em, rem                                                     직접 테두리의 두께 정도 지정                                                                                                                                                                                                                                                                                   border-style                                                                                                                                                                                                                                 border-style: 값                                                     테두리의 모양 지정                                                                                                                                                                                                                                                 none                                                     테두리를 생성하지 않음 (기본값)                                                                                                                                                       dashed, dotted, double, groove, hidden, inset,  outset, ridge, solid                                                     여러 모양의 테두리를 생성                                                                                                                                                                                                                                                                                   border-color                                     테두리의 색상 지정                                                                                                       border-radius                                     %, px, em, rem 등으로 테두리의 모서리에 대한 둥근 정도 지정                                                                                      top-left-x                                             top-right-x                                             bottom-right-x                                             bottom-left-x                                             top-left-y                                             top-right-y                                             bottom-right-y                                             bottom-left-y                                                                                                                                                                                                                                         &lt;div style=\"     background-color: black;     text-align: center;     margin-left: auto;     margin-right: auto;     padding-top: 2%;     padding-bottom: 2%;     \"&gt;     &lt;div style=\"         border: dashed 5px red;         margin-left: 5%;         margin-right: 5%;         border-radius: 25%;         padding-bottom: inherit;\"&gt;     dashed 5px red (border-radius: 25%)         &lt;div style=\"             border: dotted 3px blue;             margin-left: inherit;             margin-right: inherit;             padding-bottom: inherit;\"&gt;         dotted 3px blue             &lt;div style=\"                 border: double 7px green;                 margin-left: inherit;                 margin-right: inherit;                 padding-bottom: inherit;\"&gt;             double 7px green                 &lt;div style=\"                     border: solid 3px gray;                     margin-left: inherit;                     margin-right: inherit;                     padding-bottom: inherit;\"&gt;                     solid 3px gray                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt;             dashed 5px red (border-radius: 25%)                  dotted 3px blue                          double 7px green                                      solid 3px gray                                               box-sizing : 박스 크기의 기준을 지정하는 속성                                               box-sizing: 속성                 설명                                                             기본값                 content-box                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  box-sizing: 값                                     설명                                                                                                                                                                 content-box                                     컨텐츠 영역을 기준으로 지정                                                                                                       border-box                                     테두리 영역을 기준으로 지정                                                                                                                                                           .cb {     box-sizing: content-box; } .bb {     box-sizing: border-box; } .iib {     box-sizing: initial; } .ihb {     box-sizing: inherit; }   # 배경 관련 CSS 속성   background-color : 배경의 색상을 지정하는 속성                                               background-color: 속성                 설명                                                             기본값                 transparent                                           상속 여부                 N                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  background-color: 값                                     설명                                                                                                                                                                 transparent                                     배경색 없음                                                                                                       color                                     배경색 지정                                                                                                                                                           &lt;div style=\"     position: relative;     background-color: black;     width: 200px;     height: 200px;\"&gt;     &lt;div style=\"         position: absolute;         background-color: white;         margin-left: auto;         margin-right: auto;         width: 70%;         height: 70%;\"&gt;         &lt;div style=\"             position: absolute;             background-color: black;             margin-left: auto;             margin-right: auto;             width: 70%;             height: 70%;\"&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt;                                  background-image : 배경 이미지를 지정하는 속성                                               background-image: 속성                 설명                                                             기본값                 none                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  background-image: 값                                     설명                                                                                                                                                                 none                                     배경 이미지 사용 안함                                                                                                       url(\"\")                                     배경 이미지 URL 지정                                                                                                                                                              background-attachment : 배경 이미지의 스크롤 여부를 지정하는 속성            scroll : 내용을 스크롤하면 배경 이미지는 스크롤되지 않음       fixed : 배경 이미지가 움직이지 않음       local : 내용을 스크롤하면 배경 이미지는 스크롤       initial : 현재의 속성값을 기본값으로 지정       inherit : 부모 요소의 속성값 상속           background-position : 배경 이미지의 위치를 지정하는 속성            x y : 가로와 세로 위치 지정 (left-right, center, top-bottom, %, length)       initial : 현재의 속성값을 기본값으로 지정       inherit : 부모 요소의 속성값 상속           background-size : 배경 이미지의 크기를 지정하는 속성            length : 배경 이미지의 가로와 세로 크기나 백분율을 직접 지정       cover : 가로/세로 비율을 유지하면서, 배경을 다 채울 수 있도록 이미지 조절       contain : 가로/세로 비율을 유지하면서, 배경을 벗어나지 않도록 이미지 조절       initial : 현재의 속성값을 기본값으로 지정       inherit : 부모 요소의 속성값 상속           &lt;div style=\"background-image: https://cdn.pixabay.com/photo/2020/10/21/04/01/leaves-5672036_1280.png;\"&gt;     background-image &lt;/div&gt;   overflow : 컨텐츠가 요소의 크기를 벗어날 때의 처리 방법을 지정하는 속성                                               overflow: 속성                 설명                                                             기본값                 visible                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  overflow: 값                                     설명                                                                                                                                                                 visible                                     박스를 넘어가도 내용을 표시                                                                                                       hidden                                     박스를 넘어간 부분은 표시하지 않음                                                                                                       scroll                                     무조건 스크롤바 표시                                                                                                       auto                                     박스를 넘어가면 스크롤바 표시                                                                                                                                                           &lt;div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: visible;         margin-right: 5%;\"&gt;             visible     &lt;/div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: hidden;         margin-right: 5%;\"&gt;             hidden     &lt;/div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: scroll;         margin-right: 5%;\"&gt;             scroll     &lt;/div&gt;     &lt;div style=\"         width: 20%;         height: 150px;         background-color: black;         float: left;         overflow: auto;         margin-right: 5%\"&gt;             auto     &lt;/div&gt; &lt;/div&gt;                         자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.                           자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.                           자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.                           자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다.         z-index : 요소들의 수직 위치를 지정하는 속성     숫자가 클수록 위에, 숫자가 작을수록 아래에 위치   // 수직 위치를 역순으로 배치 &lt;div style=\"     width: 100px; \theight: 100px; \tposition: absolute;     top: 30px; \tleft: 210px;     background-color: red;     z-index: 1;\"&gt;&lt;/div&gt; &lt;div style=\"width: 100px; \theight: 100px; \tposition: absolute;     top: 60px; \tleft: 270px;     background-color: blue;\"&gt;&lt;/div&gt; &lt;div style=\"width: 100px; \theight: 100px;     position: absolute;     top: 90px; \tleft: 240px;     background-color: green;     z-index: -1;\"&gt;&lt;/div&gt;   # 글자 관련 CSS 속성   color : 글자의 색상을 지정하는 속성                                               color: 속성                 설명                                                             기본값                 #000000                                           상속 여부                 Y                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  color: 값                                     설명                                                                                                                                                                 color                                     색상 지정                                                                                                                                                           &lt;div style=\"color:red\"&gt;     hello world &lt;/div&gt;       hello world   font-size : 글자의 크기를 지정하는 속성                                               font-size: 속성                 설명                                                             기본값                 medium                                           상속 여부                 Y                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  font-size: 값                                     설명                                                                                                                                                                 medium                                     웹 브라우저에서 정한 기본값                                                                                                       xx-small, x-small, small, large, x-large, xx-large                                     기본값에 대한 상대적인 크기                                                                                                       smaller, larger                                     부모 요소의 글자 크기에 대한 상대적인 크기                                                                                                       px                                     글자 크기를 직접 지정                                                                                                       %, em                                     부모 요소의 글자 크기에 대한 상대적인 글자 크기의 비율을 직접 지정                                                                                                       rem                                     최상위 요소의 글자 크기에 대한 상대적인 글자 크기의 비율을 직접 지정                                                                                                                                                           &lt;div style=\"font-size: xx-small\"&gt;xx-small&lt;/div&gt; &lt;div style=\"font-size: x-small\"&gt;x-small&lt;/div&gt; &lt;div style=\"font-size: small\"&gt;small&lt;/div&gt; &lt;div style=\"font-size: medium\"&gt;medium&lt;/div&gt; &lt;div style=\"font-size: large\"&gt;large&lt;/div&gt; &lt;div style=\"font-size: x-large\"&gt;x-large&lt;/div&gt; &lt;div style=\"font-size: xx-large\"&gt;xx-large&lt;/div&gt;        xx-small     x-small     small     medium     large     x-large     xx-large   &lt;div style=\"font-size: smaller\"&gt;smaller&lt;/div&gt; &lt;div&gt;medium&lt;/div&gt; &lt;div style=\"font-size: larger\"&gt;larger&lt;/div&gt;        smaller     medium     larger   &lt;div style=\"font-size: 10px\"&gt;     10px     &lt;i style=\"font-size: 200%;\"&gt;         20px         &lt;span style=\"font-size: 0.8em\"&gt;             16px             &lt;b style=\"font-size: 1rem\"&gt;                 1rem             &lt;/b&gt;         &lt;/span&gt;     &lt;/i&gt; &lt;/div&gt;        10px              20px                      16px                              1rem                              font-family : 글꼴을 지정하는 속성                                               font-family: 속성                 설명                                                             기본값                 웹 브라우저의 기본 글꼴                                           상속 여부                 Y                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  font-family: 값                                     설명                                                                                                                                                                 font                                     글꼴 이름 / 글꼴 유형                                                                                                                                                           &lt;div style=\"font-family: (지정할 글꼴);\"&gt;     지정된 글꼴로 출력합니다. &lt;/div&gt;   &lt;div style=\"font-family: (지정할 글꼴1), (지정할 글꼴2);\"&gt;     지정된 글꼴1로 출력하되 (i) 해당 글꼴이 존재하지 않는다면 (ii) 표현할 수 없다면, 지정된 글꼴2로 출력합니다. &lt;/div&gt;   font-weight : 글자의 굵기 정도를 지정하는 속성     나타낼 수 있는 굵기의 정도는 글꼴마다 다름                                               font-weight: 속성                 설명                                                             기본값                 normal                                           상속 여부                 Y                                           애니메이션 여부                 Y                                           문법                                                                                                                                                                  font-weight: 값                                     설명                                                                                                                                                                 normal                                     보통 굵기 (400)                                                                                                       bold                                     굵은 굵기 (700)                                                                                                       bolder                                     상속된 값보다 굵은 크기                                                                                                       lighter                                     상속된 값보다 얇은 크기                                                                                                       number                                     굵기 정도를 직접 지정                                                                                                                                                           &lt;div style=\"font-weight: normal\"&gt;     &lt;div style=\"font-weight: lighter\"&gt;normal-lighter&lt;/div&gt;     normal     &lt;div style=\"font-weight: bolder\"&gt;normal-bolder&lt;/div&gt; &lt;/div&gt; &lt;div style=\"font-weight: bold\"&gt;     &lt;div style=\"font-weight: lighter\"&gt;bold-lighter&lt;/div&gt;     bold     &lt;div style=\"font-weight: bolder\"&gt;bold-bolder&lt;/div&gt; &lt;/div&gt;                 normal-lighter         normal         normal-bolder                   bold-lighter         bold         bold-bolder        # 텍스트 관련 CSS 속성   text-align : 텍스트를 정렬하는 속성                                               text-align: 문법                 설명                                                             left                 왼쪽 정렬                                           right                 오른쪽 정렬                                           center                 가운데 정렬                                           justify                 양쪽 정렬                              &lt;div style=\"text-align: left;\"&gt;바다는 크레파스보다 진한 푸르고 육중한 비늘을 무겁게 뒤채면서, 숨을 쉰다.&lt;/div&gt; &lt;div style=\"text-align: right;\"&gt;중립국으로 가는 석방 포로를 실은 인도 배 타고르호는, 흰 페인트로 말쑥하게 칠한 삼천 톤의 몸을 떨면서, 물건처럼 빼곡이 들어찬 동지나 바다의 훈김을 헤치며 미끄려져 간다.&lt;/div&gt; &lt;div style=\"text-align: center;\"&gt;석방 포로 이명준(李明俊)은, 오른편의 곧장 갑판으로 통한 사닥다리를 타고 내려가, 배 뒤쪽 난간에 가서, 거기에 기대어 선다.&lt;/div&gt; &lt;div style=\"text-align: justify;\"&gt;담배를 꺼내 물고 라이터를 켜댔으나 바람에 이내 꺼지고 하여, 몇 번이나 그르친 끝에, 그 자리에 쭈그리고 앉아서 오른팔로 얼굴을 가리고 간신히 댕긴다.&lt;/div&gt;        바다는 크레파스보다 진한 푸르고 육중한 비늘을 무겁게 뒤채면서, 숨을 쉰다.     중립국으로 가는 석방 포로를 실은 인도 배 타고르호는, 흰 페인트로 말쑥하게 칠한 삼천 톤의 몸을 떨면서, 물건처럼 빼곡이 들어찬 동지나 바다의 훈김을 헤치며 미끄려져 간다.     석방 포로 이명준(李明俊)은, 오른편의 곧장 갑판으로 통한 사닥다리를 타고 내려가, 배 뒤쪽 난간에 가서, 거기에 기대어 선다.     담배를 꺼내 물고 라이터를 켜댔으나 바람에 이내 꺼지고 하여, 몇 번이나 그르친 끝에, 그 자리에 쭈그리고 앉아서 오른팔로 얼굴을 가리고 간신히 댕긴다.   text-decoration : 텍스트을 꾸미는 선을 지정하는 속성                                               text-decoration: 속성                 설명                                                             기본값                 none                                           상속 여부                 N                                           애니메이션 여부                 N                                           문법                                                                                                                                                                  text-decoration: 값                                     설명                                                                                                                                                                 none                                     선을 만들지 않음                                                                                                       line-through                                     취소선 생성                                                                                                       overline                                     윗줄 생성                                                                                                       underline                                     밑줄 생성                                                                                                                                                           &lt;div style=\"text-decoration: none\"&gt;none&lt;/div&gt; &lt;div style=\"text-decoration: line-through\"&gt;line-through&lt;/div&gt; &lt;div style=\"text-decoration: overline\"&gt;overline&lt;/div&gt; &lt;div style=\"text-decoration: underline\"&gt;underline&lt;/div&gt; &lt;div style=\"text-decoration: line-through overline underline\"&gt;text-decoration&lt;/div&gt;        none     line-through     overline     underline     text-decoration   columns : 여러 개의 문단을 만드는 속성                                               columns: 속성                 설명                                                             기본값                 auto                                           속성값                 문단의 최대 개수 or 문단의 최소 가로 길이                               &lt;div style=\"columns: 3;\"&gt;자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.&lt;/div&gt;        자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.   &lt;div style=\"columns: 150px;\"&gt;자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.&lt;/div&gt;        자기가 무엇에 홀려 있음을 깨닫는다. 그 넉넉한 뱃길에 여태껏 알아보지 못하고, 숨바꼭질을 하고, 피하려 하고 총으로 쏘려고까지 한 일을 생각하면, 무엇에 씌었던 게 틀림없다. 큰 새 작은 새는 좋아서 미칠 듯이, 물속에 가라앉을 듯, 탁 스치고 지나가는가 하면, 되돌아오면서, 그렇다고 한다. 무덤을 이기고 온, 못 잊을 고운 각시들이, 손짓해 본다. 내 딸아. 비로소 마음이 놓인다. 옛날, 어느 벌판에서 겪은 신내림이, 문득 떠오른다. 그러자, 언젠가 전에, 이렇게 이 배를 타고 가다가, 그 벌판을 지금처럼 떠올린 일이, 그리고 딸을 부르던 일이, 이렇게 마음이 놓이던 일이 떠올랐다. 거울 속에 비친 남자는 활짝 웃고 있다.   # 애니메이션 관련 CSS 속성   transform: : 요소의 형태를 변화시키는 속성   transform: rotate( angle )  /* 요소를 angle (각의 크기)만큼 회전 (단위 : deg, turn) */ transform: rotateX( angle ) /* 가로를 축으로 회전 */ transform: rotateY( angle ) /* 세로를 축으로 회전 */  transform: translate( Xpx, Ypx ) /* 요소를 가로축, 세로축 기준으로 이동 */ transform: translateX( px ) /* 가로축을 기준으로 이동 */ transform: translateY( px ) /* 세로축을 기준으로 이동 */  transform: scale( X ) /* 가로와 세로를 모두 X배만큼 확대 */ transform: scale( X, Y ) /* 가로로 X배만큼 확대, 세로로 Y배만큼 확대 */ transform: scaleX( X ) /* 가로로 X배만큼 확대 */ transform: scaleY( Y ) /* 세로로 Y배만큼 확대 */  transform: skewX( Xdeg ) // 가로 뱡향으로 비틈 transform: skewY( Ydeg ) // 세로 뱡향으로 비틈 transform: skewX( Xdeg, Ydeg ) // 가로 뱡향으로 X도만큼, 세로 방향으로 Y도만큼 비틈   animation : 요소에 애니메이션 효과를 넣는 속성   @keyframes name { /* 애니메이션에 이름을 붙이고, 어떤 모양에서 어떤 모양으로 바꿀지 지정 */ 0% { ... } /* 시작할 때 요소의 모양 지정 */ n% { ... } /* n%일 때 요소의 모양 지정 */ 100% { ... } /* 끝날 때 요소의 모양 지정 */}  animation-name: /* 어떤 이름의 @keyframes를 사용할지 지정 */;   animation-duration: /* 애니메이션이 진행될 시간 지정 (단위: s 또는 ms) */;  animation-timing-function: /* 애니메이션의 진행 속도 지정 */   /* cubic-bezier(n,n,n,n) 함수 : 애니메이션을 3차원 베지에 곡선에 맞게 표현 */   /* linear : cubic-bezier(0,0,1,1). 애니메이션 효과가 처음부터 끝까지 일정한 속도로 진행 */   /* ease : 기본값. cubic-bezier(0.25,0.1,0.25,1). 애니메이션 효과가 천천히 시작되어 빨라졌다가 다시 느려짐 */   /* ease-in : cubic-bezier(0.42,0,1,1). 애니메이션 효과가 천천히 시작됨 */   /* ease-out : cubic-bezier(0,0,0.58,1). 애니메이션 효과가 천천히 끝남 */   /* ease-in-out : cubic-bezier(0.42,0,0.58,1). 애니메이션 효과가 천천히 시작되어 천천히 끝남 */   /* steps(1,...) 함수 : 애니메이션을 스텝에 맞게 끝어서 표현 */   /* step-start : steps(1,start). 시작하는 지점에 스텝 */   /* step-end : steps(1,end). 끝나는 지점에 스텝 */  animation-delay: /* 애니메이션이 시작하기 전에 대기하는 시간 지정 (단위: s 또는 ms) */;  animation-iteration-count: /* 애니메이션이 반복하는 횟수 지정 */;  animation-direction: /* 애니메이션이 진행하는 방향 지정 (normal | reverse | alternate | alternate-reverse) */;  animation-fill-mode: /* 애니메이션 종료 후의 상태 지정 (none | forwards | backwards | both) */;  animation-play-state : /* 애니메이션의 진행 여부 지정 (running | paused) */;   transition: : 요소에 트랜지션 효과를 넣는 속성   transition-property: /* 트랜지션의 속성 지정 (none | all | property) */;  transition-timing-function: /* 트랜지션의 진행 속도 지정 */;   /* cubic-bezier(n,n,n,n) 함수 : 애니메이션을 3차원 베지에 곡선에 맞게 표현 */   /* linear : cubic-bezier(0,0,1,1). 애니메이션 효과가 처음부터 끝까지 일정한 속도로 진행 */   /* ease : 기본값. cubic-bezier(0.25,0.1,0.25,1). 애니메이션 효과가 천천히 시작되어 빨라졌다가 다시 느려짐 */   /* ease-in : cubic-bezier(0.42,0,1,1). 애니메이션 효과가 천천히 시작됨 */   /* ease-out : cubic-bezier(0,0,0.58,1). 애니메이션 효과가 천천히 끝남 */   /* ease-in-out : cubic-bezier(0.42,0,0.58,1). 애니메이션 효과가 천천히 시작되어 천천히 끝남 */   /* steps(1,...) 함수 : 애니메이션을 스텝에 맞게 끝어서 표현 */   /* step-start : steps(1,start). 시작하는 지점에 스텝 */   /* step-end : steps(1,end). 끝나는 지점에 스텝 */  transition-duration: /* 트랜지션이 진행될 시간 지정 (단위: s 또는 ms) */;  transition-delay: /* 트랜지션이 시작하기 전에 대기하는 시간 지정 (단위: s 또는 ms) */;  ","categories": [],
        "tags": ["CSS"],
        "url": "/css1/",
        "teaser": null
      },{
        "title": "[Operation System] 1. Operation System",
        "excerpt":"운영체제 (Operation System) : 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어      컴퓨터 시스템 자원의 효율적인 관리 (Performance) : 하드웨어 자원을 각각의 사용자 응용 프로그램에 적절히 분배            하드웨어 자원 (Hardware Resource) : CPU 시간, 기억 장치 및 디스크 영역, I/O 장치           사용자 편의성 제공 (Convenience) : 사용자가 더 편리하게 사용할 수 있는 환경을 구성                 프로세스 관리 (Process Management)         메인 메모리 관리 (Main Memory Management)         파일 관리(File Management)         저장 장치 관리 (Storage Management)         I/O 장치 관리 (I/O Device Management)         시스템 호출 (System call)        부팅 (Booting) : 컴퓨터를 시작할 때 자기 자신을 구동시킬 프로그램을 스스로 불러내는 동작     메인 메모리 (Main Memory) : 즉시 필요한 데이터를 저장하는 주 기억 장치            RAM : 휘발성 주 기억 장치 (전원이 꺼지면 모든 내용이 지워짐)                    코드 영역 (Code Area) : 실행할 프로그램의 코드가 저장되는 영역                            CPU는 이 영역에 저장된 명령어를 하나씩 호출해 수행함                                   데이터 영역 (Data Area) : 실행할 프로그램의 전역 변수와 정적 변수가 저장된 영역                            프로그램 시작 시 할당, 프로그램 종료 시 소멸                                   스택 영역 (Stack Area) : 프로그램의 함수 호출과 관련된 지역 변수와 매개 변수가 정적으로 저장된 영역                            후입선출 (Last-In, First-Out) 방식에 따른 동작 : PUSH로 데이터 저장, POP로 데이터 인출               메모리의 높은 주소에서 메모리의 낮은 주소의 방향으로 할당               함수 호출 시 할당, 함수 호출 종료 시 소멸                                   힙 영역 (Heap Area) : 사용자에 의해 동적으로 할당되고 해제되는 전역 변수가 저장되는 영역                            할당되는 변수의 크기 제한이 없음 : 크기 제한이 존재하는 스택에 비해 액세스 속도가 상대적으로 느림               CPU에 의해 효율적으로 관리되는 스택 영역과 달리, 사용자가 힙 영역을 관리해야 함                                    메모리 단편화 (Memory Fragmentation) : 사용 가능한 메모리가 존재하나, 할당 불가능                                               메모리의 낮은 주소에서 메모리의 높은 주소의 방향으로 할당                                               ROM : 비휘발성 주 기억 장치 (전원이 꺼져도 그 안의 내용이 계속 유지)                    POST (Power-On Self-Test) : 부팅 시 가장 처음 실행, 현재 컴퓨터의 상태 검사           부트 로더 (Boot Loader) : POST 다음에 실행, 보조 기억 장치의 운영체제를 탐색 후 RAM에 할당                            보조 기억 장치에서 RAM으로 할당된 운영체제는 컴퓨터 전원이 꺼질 때까지 상주 (Resident)                                                   SSD/HDD : 운영체제가 저장된 보조 기억 장치            커널 (Kernel) : 운영체제가 수행하는 모든 작업이 저장       명령어 해석기 (Shell) : 사용자가 요청하는 명령어를 해석해 커널에 요청하고 결과를 출력                    응용 프로그램 (Application) : 운영체제 위에서 수행되며, 운영체제가 지원하는 자원만을 사용 가능                           일괄 처리 시스템 (Batch Processing System) : 프로그램 수행 과정의 자동화     Resident Monitor : 프로세서에 할당하기 위해 (컴파일 -&gt; 링크 -&gt; 로딩)의 과정을 하나의 프로그램으로 작성   시분할 시스템 (Time-sharing System) : CPU가 프로그램을 수행하는 시간을 제한     스위칭 (Switching) : 프로그램이 일정 시간 실행되면 Time Out을 발생시켜 다음 프로그램으로 넘어가게 함   다중 작업 (Multitasking) : CPU가 짧은 시간 내에 여러 프로그램을 스위칭해 동시에 작업하는 것처럼 보이게 함            CPU 스케줄링 (CPU Scheduling) : CPU가 어느 프로그램을 실행할지 선택하는 작업           다중 프로그래밍 (Multiprogramming) : 메모리에 여러 응용 프로그램을 적재해 idle 상태 최소화     프로그램 실행 시에 계산을 담당하는 CPU와 입출력을 담당하는 I/O 장치가 교대로 실행            idle상태 : I/O 장치가 실행되는 동안 CPU가 아무런 작업도 하지 않는 상태           인터럽트 기반 시스템 (Interrupt-based System) : 인터럽트 발생 시 ISR에 맞는 처리 수행     인터럽트 (Interrupt) : 프로그램 실행 중에 예기치 않은 상황이 발생할 경우 이를 CPU에 알리는 전기 신호            외부 인터럽트 (Eternal Interrupt) = 하드웨어 인터럽트 (Hardware Interrupt)       내부 인터럽트 (Internal Interrupt) = 소프트웨어 언터럽트 (Software Interrupt)                    예외 (Exception)           시스템 호출 (System call)                           인터럽트 서비스 루틴 (Interrupt Service Routine) : 인터럽트 신호를 처리할 방법을 내포한 운영체제 내의 코드   이중 모드 (Dual Mode Execution) : 유저 (User) 모드와 커널 (Kernel) 모드를 나눔      ! 문제 : 어떤 작업이 자원을 계속해서 점유하는 일과 같이 컴퓨터의 작업 효율을 저해하는 행위로부터 보호할 수단 필요       CPU 내 레지스터 (Register)의 Mode-Bit를 플래그 (flag)로 활용해 나타냄 (커낼 모드 : 0, 유저 모드 : 1)   각 명령어에 Mode-Bit를 넣어 시스템 내의 Mode-Bit와 같을 시에만 명령어 수행   특권 명령어 (Privileged Instruction) : 커널 모드에서만 내릴 수 있는 명령어            STOP, HALT, RESET, SET_TIMER 등       유저 모드에서는 특권 명령어를 내릴 수 없음 (내부 인터럽트를 발생해 해당 명령어를 요청한 프로그램을 강제 종료)           시스템 호출 (System Call) : Mode-Bit를 바꾸는 행위 (INT 80)            사용자가 하드웨어 자원에 접근할 때, 프로그램에서 시스템 호출을 발생시켜 운영체제에 위임해 커널 모드로 처리                   컴퓨터가 부팅되는 과정 : 커널 모드     응용 프로그램이 실행되는 과정 : 커널 모드     응용 프로그램이 실행되는 중일 때 : 유저 모드     인터럽트가 발생한 후 처리하는 과정 : 커널 모드     인터럽트를 처리한 후 : 유저 모드      하드웨어 보호 (H/W Protection) : 잘못된 명령이나 접근에 보호하기 위해 운영체제에서 내부 인터럽트 발생      ! 문제 : 정보들이 여러 I/O 장치를 통해 컴퓨터로 입출력되는 과정에서 장치 간 혹은 데이터 간의 혼선이 발생할 수 있음    입출력 장치 보호 (I/O Protection) : in, out과 같은 입출력 명령을 특권 명령으로 지정해 운영체제를 통해 수행     입출력 수행 시에는 관리자 모드로 전환해 특권 명령을 내림            Privileged Instruction Violation : 사용자가 입출력 명령을 직접 내린 경우 프로그램을 강제 종료              ! 문제 : 다른 사용자나 운영체제에 할당된 메모리 영역에 접근해 정보나 프로그램을 해킹할 수 있음    메모리 보호 (Memory Protection) : CPU와 메인 메모리 간 주소 버스에 Memory Management Unit 설치     두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장   사용자에 할당된 메모리 영역을 벗어난 주소값을 가져오지 못하게 함   Memory Management Unit 설정은 운영체제만 변경 가능            Segment Violation : 사용자에 할당된 메모리 영역을 벗어난 주소값이 MMU에 오면 내부 인터럽트를 발생시킴              ! 문제 : 프로그램에서의 무한 루프로 인해 CPU가 독점되어 다른 프로그램이 수행되지 못할 수 있음    CPU 보호 (CPU Protection) : 타이머 (Timer)를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킴     타이머 (Timer) : 무한 루프나 자원 독점을 막기 위해 특정 시간이 지나면 타이머 인터럽트를 발생시킴            타이머 인터럽트 (Timer Interrupt) : 인터럽트의 ISR에서 CPU가 프로그램의 CPU 점유 시간을 측정해 분배       운영체제는 타이머가 끝난 작업을 종료시키고 스케줄링 (Scheduling) 이전에 타이머 실행          ","categories": [],
        "tags": ["Operation System"],
        "url": "/os1/",
        "teaser": null
      },{
        "title": "[Operation System] 2. Process",
        "excerpt":"프로세스 (Process) : 실제 메인 메모리에 할당되어 실행 중인 프로그램      프로그램은 보조 기억 장치에서 아무런 동작을 하지 않은 상태   어떤 요청에 의해 메인 메모리에 할당되어 CPU를 사용하면서 실행   각각의 프로세스는 CPU에 의해 샐행된 후 …를 생성 (메인 메모리를 효율적으로 사용해야 함)            프로세스 테이블 엔트리 = 프로세스 컨트롤 블록 (Process Control Block)       주소 공간 (Address Space)                    코드 세그먼트 (Code Segment) : 프로그램 소스 코드가 저장           데이터 세그먼트 (Data Segment) : 전역 변수가 저장           스택 세그먼트 (Stack Segment) : 지역변수와 매개변수가 저장                              지역변수와 매개변수가 후입선출을 따른 스택에 저장되므로, 전역 변수를 먼저 선언해 메인 메모리의 공간 절약 가능    프로세스의 생성과 종료 (Creation and Destruction of Process)     최초의 프로세스인 Init의 생성은 부팅된 운영체제가 처음 수행하는 작업 중 하나   생성된 프로세스가 다른 프로세스를 생성하는 과정을 반복            프로세스의 생성을 위한 시스템 호출 : fork()       프로세스의 종료를 위한 시스템 호출 : exit()           생성된 모든 프로세스는 자신을 식별할 수 있는 고유의 정수값인 PID을 가짐            생성된 모든 프로세스는 자신을 생성한 사용자 고유의 UID 값 또한 가짐 (부모와 자식이 동일한 값)                 프로세스 트리 (Process Tree) : 부모 프로세스인 A에서 자식 프로세스인 B, C, D가 파생되어 생성            부모 프로세스 : 프로세스를 생성한 프로세스       자식 프로세스 : 프로세스로부터 생성된 프로세스       형제 프로세스 : 같은 부모 프로세스에서 파생된 자식 프로세스           프로세스 컨트롤 블록 (Process Control Block) : 프로세스에 대한 모든 정보를 저장하는 곳     CPU는 여러 프로세스를 빈번히 전환하면서 수행하기에 각 프로세스의 데이터를 저장해야 작업을 이어서 수행할 수 있음   운영체제 내에서 프로세스를 관리하는 코드 부분에 저장            프로세스 컨트롤 블록에 데이터를 저장 및 복원하는 시간 역시 다중 작업을 위해 프로세스에 할당되는 시간에 포함           프로세스 상태, 프로그램 카운터, 스택 포인터, 파일 디스크립터 등의 정보 포함      프로세스 상태 (Process Status) : 각 단계들에서 상태 전이가 일어나 다음 단계로 넘어감     New : 프로그램이 메인 메모리에 할당된 상태   Ready : 프로세스가 언제든 실행 가능한 상태; 할당된 프로그램이 실행되기 위한 모든 준비를 마친 상태로 대기된 상태            n개의 작업이 있을 때, CPU의 프로세서는 스케줄러의 0~(n-1)번, 즉 n개의 작업을 번갈아 처리           Running : CPU가 해당 프로세스를 실제로 실행중인 상태   Waiting=Blocked : Running이 불가능한 상태            프로세스가 끝나지 않은 시점에 해당되는 I/O 정보가 없어 작업할 수 없음       Waiting가 끝나면 다시 CPU에 실행되기 위해 Ready로 돌아가야 함           Terminated : 프로세스가 완전히 종료된 상태              I/O 작업으로 인한 상태 변화 : Running -&gt; Waiting -&gt; Ready -&gt; Running     시간 초과로 인터럽트에 의한 상태 변화 : Running -&gt; Ready -&gt; Running      프로세스 큐 (Process Queue) : 커널이 프로세스 스케줄링을 위해 데이터 영역에서 관리하는 큐     Ready Queue : 프로세스 상태가 Ready인 프로세스들이 CPU 제어를 기다리는 큐            어떤 CPU 스케줄링 알고리즘을 선택하는지에 따라 CPU 제어 순서가 달라짐           Job Queue : 보조 기억 장치의 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐            시스템 내의 모든 프로세스 관리 : Ready Queue, Device Queue에 속한 모든 프로세스 포함           Device Queue : 프로세스 상태가 Waiting인 프로세스들이 CPU 외의 자원을 기다리는 큐            기다리는 자원들마다 큐가 할당되며, 해당 자원이 사용되면 인터럽트를 발생시키고 Ready Queue로 이동                 각 큐는 프로세스의 프로세스 컨트롤 블록을 가리키는 포인터 방식으로 연결 리스트를 구현   스케줄러 (CPU Scheduler) : 프로세스 순서를 정해 프로세스 큐에 올릴 것을 결정하는 커널의 코드     장기 스케줄러 (Long-term Scheduler) : 생성된 프로세스 중 Job Queue에서 Ready Queue에 이동시킬 것 선택            장기 스케줄러는 현재 메모리에 할당된 프로세스의 개수 (Degree of multiprogramming)를 제어       장기 스케줄러는 I/O bound Process,CPU bound Process를 메인 메모리에 적절히 할당해야 함                    I/O bound Process : I/O 작업 (입출력) 비중이 높은 프로세스           CPU bound Process : CPU 작업 (계산) 비중이 높은 프로세스                           중기 스케줄러 (Medium-term Scheduler) : 실행 중인 프로세스 중 보조 저장 장치로 옮길 것을 주기적으로 검사            Swapping (Swap-out↔Swap-in) : Swap-in할 때 이전 공간으로 재할당되는 것은 보장되지 않음                    Swap-out : 메인 메모리에서 우선 순위가 은 프로세스를 통째로 보조 기억 장치로 저장           Swap-in : 나중에 해당 프로세스가 다시 사용되려 할 때 보조 기억 장치에서 메인 메모리에 다시 할당                       중기 스케줄러 또한 현재 메모리에 할당된 프로세스의 개수 (Degree of multiprogramming)를 제어           단기 스케줄러 (Short-term Scheduler) : Ready Queue 내에서 프로세스들 중 어떤 것을 다음에 실행시킬지 선택            CPU 스케줄러 (CPU Scheduler) 라고도 부르며, 시분할 시스템에서 Time Out이 발생하면 호출           문맥 전환 (Context Switching) : CPU가 실행중인 프로세스를 멈추고 다른 프로세스를 실행하는 작업     문맥 (Context) : 각 프로세스 컨트롤 블록 내에서 표현            하드웨어 문맥 : 프로그램 카운터 정보와 레지스터 정보를 저장       프로세스 주소 공간 : 각 프로세스가 갖고 있는 독자적인 주소 공간에 위치           CPU 스케줄러 : CPU가 어느 프로세스를 다음에 실행할지 지정   디스패쳐 (Dispatcher) : 문맥 전환이 발생하면 Ready에서 Running으로 상태 전이            문맥 전환 오버헤드 (Context Switching Overhead) : 문맥 전환이 발생할 때마다 디스패쳐를 매번 실행시킴                CPU에서 실행중인 프로세스의 데이터는 해당 프로세스의 프로세스 컨트롤 블록에 갱신   새로 시작될 프로세스의 프로세스 컨트롤 블록를 CPU로 복원   캐시와 Translation Lookup Buffer를 재설정           시스템 호출로 인한 인터럽트 발생 시 :                실행 중인 프로세스의 문맥을 프로세스 컨트롤 블록에 갱신하나, 문맥 전환은 이루어지지 않음                 ","categories": [],
        "tags": ["Operation System"],
        "url": "/os2/",
        "teaser": null
      },{
        "title": "[Operation System] 3. CPU Scheduling",
        "excerpt":"CPU 스케줄링 (CPU Scheduling) : CPU 스케줄러에서 어느 프로세스를 다음에 실행할지 지정      선점 (Preemptive) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 강제로 점유할 수 있음   비선점 (Non-Preemptive) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 점유할 수 없음            예외 : I/O 발생           CPU 스케줄링 척도 (CPU Scheduling Criteria) : CPU 스케줄링의 효율을 분석하는 기준     CPU 점유율 (CPU Utilization) : 현재 CPU가 작업을 수행하는 비율 -&gt; 높을수록 좋음   처리율 (Throughput) : 단위 시간 당 완료되는 프로세스의 개수 -&gt; 많을수록 좋음   소요 시간 (Turnaround Time) : 프로세스가 생성된 시간부터 종료되는 데까지 걸린 시간 -&gt; 짧을수록 좋음   대기 시간 (Waiting Time) : CPU 제어를 위해 Ready Queue에서”만” 대기한 시간 -&gt; 짧을수록 좋음            평균 대기 시간 (Average Waiting Time) : (각 프로세스들의 대기 시간의 합) / (프로세스들의 개수)           응답 시간 (Response Time) : Interactive System에서 입력에 대한 반응 시간 -&gt; 짧을수록 좋음   선입선출 (First-Come, First-Served) 스케줄링 : 가장 먼저 작업을 요청한 프로세스를 먼저 수행     비선점 (Non-Preemptive)   들어온 순서대로 작업을 수행한다고 해도 그것이 반드시 효율적이지 않음            Convoy Effect : CPU를 많이 점유하는 프로세스가 먼저 수행되어 나머지 프로세스들이 그만큼 오래 대기                \t \t\t \t\t\tProcess \t\t\tBurst Time (msec) \t\t \t    \t                P1         3                       P2         3                       P3         24                     FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.                Average Waiting Time : (0 + 3 + 6) / 3 = 3msec                       \t \t\t \t\t\tProcess \t\t\tBurst Time (msec) \t\t \t    \t                P1         24                       P2         3                       P3         3                     FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.                Average Waiting Time : (0 + 24 + 27) / 3 = 17msec                 CPU를 오래 점유하는 P3로 상대적으로 빠른 처리가 가능한 P1과 2가 오래 대기하는 Convoy Effect 발생!      최단작업 (Shortest-Job-First) 스케줄링 : 시간이 가장 짧게 수행되는 프로세스를 먼저 수행     비선점 (Non-Preemptive), 선점 (Preemptive)   일반적으로 가장 빠른 평균 대기 시간을 가지나, 현실에선 각 프로세스의 CPU 점유 시간이 주어지지 않아 비현실적        \t \t\t \t\t\tProcess \t\t\tBurst Time (msec) \t\t \t    \t                P1         6                       P2         8                       P3         7                       P4         3                     FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, P4 순으로 처리한다.                Average Waiting Time : (0 + 6 + 14 + 21) / 4 = 10.25msec                 SJF Scheduling : (작업 시간이 짧은 순서대로) P4, P1, P3, P2 순으로 처리한다.                Average Waiting Time : (0 + 3 + 9 + 16) / 4 = 7msec                  우선순위 (Priority) 스케줄링 : 우선순위가 가장 높은 프로세스를 먼저 수행     비선점 (Non-Preemptive), 선점 (Preemptive)   우선순위는 정수값으로 표현되며, 값이 작을수록 우선순위가 높음        \t \t\t \t\t\tProcess \t\t\tBurst Time (msec)       Priority \t\t \t    \t                P1         10         3                       P2         1         1                       P3         2         4                       P4         1         5                       P5         5         2                     Priority Scheduling : (우선순위가 높은 순서대로) P2, P5, P1, P3, P4 순으로 처리한다.                Average Waiting Time : (0 + 1 + 6 + 16 + 18) / 5 = 8.2 msec                  라운드 로빈 (Round-Robin) 스케줄링 : 원 모양으로 모든 프로세스를 돌아가면서 수행     선점 (Preemptive)   시분할 시스템에서 CPU가 한 프로세스를 일정 시간 수행한 뒤 대기 상태로 보내고, 다음 프로세스를 수행하는 것 반복            Time Quantum : CPU가 한 프로세스를 수행하는 시간 -&gt; 스케줄리의 효율성이 Time Quantum의 크기에 의존                \t \t\t \t\t\tProcess \t\t\tBurst Time (msec)       Time Quantum \t\t \t    \t                P1         7         4msec                       P2         4                       P3         4                     RP Scheduling : (CPU에 요청받은 순서) P1, P2, P3, 그리고 (완료하지 못한) P1 순으로 처리                Average Waiting Time : (4 + 8 + 12) / 3 = 8 msec                       \t \t\t \t\t\tProcess \t\t\tBurst Time (msec)       Time Quantum \t\t \t    \t                P1         7         3msec                       P2         4                       P3         4                     RP Scheduling : (CPU에 요청받은 순서) P1, P2, P3, (완료하지 못한) P1, P2, P3, 그리고 P1 순으로 처리                Average Waiting Time : (12 + 13 + 14) / 3 = 13 msec                  멀티레벨 큐 (Multi-level Queue) 스케줄링 : 각 프로세스 그룹에 따른 큐를 두어 수행     프로세스 그룹 : 프로세스를 기준에 따라 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치            Interactive Process : 유저 수준 &gt; 데이터를 바로바로 처리 (I/O bound Process)       Batch Process : 유저 수준 &gt; 일정 시간에 데이터를 한번에 처리 (CPU bound Process)           우선순위에 따라 대기할 큐를 지정할 수 있고, 각 큐마다 서로 다른 스케줄링 방식을 사용 가능   멀티레벨 피드백 큐 (Multi-level Feedback Queue) 스케줄링 : 멀테레벨 큐에 피드백 추가     멀티레벨 큐처럼 프로세스를 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치            모든 프로세스들은 처음에는 무조건 우선순위가 가장 높은 큐에서 대기                    vs 멀티레벨 큐 : 우선순위에 따른 큐 지정 가능                           피드백 (Feedback) : time out이 발생한 프로세스를 보다 낮은 우선순위의 큐로 격하            I/O bound Process는 높은 우선순위, CPU bound Process는 낮은 우선순위          ","categories": [],
        "tags": ["Operation System"],
        "url": "/os3/",
        "teaser": null
      },{
        "title": "[Operation System] 4. IPC",
        "excerpt":"프로세스 간 통신 (Inter Process Communication) : 프로세스 간에 데이터를 주고받는 행위      독립 프로세스 (Independent Process) : (단일 처리 시스템에서) 다른 프로세스에 독립적인 동기적 프로세스   협력 프로세스 (Cooperating Process) : 실행중인 다른 프로세스와의 상호 작용을 통해 수행되는 비동기적 프로세스   공유 메모리 (Shared Memory) : 협력 프로세스 간 하나의 공유 메모리 영역을 만들어 상호 통신     공유 메모리 세그먼트 : 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치       커널 의존성이 낮아 속도가 빠르고, 유저 레벨에서의 IPC가 가능해 자유로운 통신이 가능   대량의 정보를 다수의 프로세스에게 배포 가능함   자원과 데이터를 공유하므로, 동기화 문제가 발생할 수 있음   메시지 패싱 (Message Passing) : 협력 프로세스 간 각자의 메시지를 운영 체제에 전달해 통신     별도의 구축 없이 커널만을 이용하기에 비교적 구현이 쉬움   커널을 이용할 때마다, 시스템 호출에 따른 문맥 전환이 매번 발생 (문맥 복사 2번 수행, 문맥 전환 오버헤드 발생)   파이프 (PIPE) : 통신을 위한 버퍼를 생성해 프로세스가 데이터를 상호 통신          익명 파이프 (Anonymous PIPE) : 통신할 프로세스를 명확히 아는 경우             부모-자식 혹은 형제 간 통신에 사용 (외부 프로세스에서 사용할 수 없음)       하나의 프로세스는 데이터를 쓰기만, 다른 하나는 데이터를 읽기만 수행 → 반 이중 (Half-Duplex) 통신       송수신을 모두 하기 원한다면 파이프를 2개 구현해야 함                네임드 파이프 (Named PIPE) : 전혀 모르는 상태의 프로세스 간의 통신에 사용             익명 파이프의 확장된 상태 : FIFO를 통해 이름이 있는 파일을 사용하여 프로세스 간 통신       송수신을 모두 하기 원한다면 파이프를 2개 구현해야 함           소켓 (Socket) : 동일한 운영체제에서 실행되는 프로세스 간 데이터를 교환하는 Endpoint     클라이어트와 서버가 네트워크 소켓 통신을 통해 데이터를 공유 (원격에서 프로세스 간 데이터를 공유할 때 사용)            양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고받음       각각의 PC의 포트를 담당하는 소켓은 데이터를 송수신하는 역할을 맡은 하나의 프로세스           전이중 (Full Duplex) 통신이 가능 : 서버-클라이언트 환경을 구축하는 데에 용이   중대형 어플리케이션에서 주로 사용   메시지 큐 (Message Queue) : 메모리 공간을 활용한 PIPE     입출력 방식은 Named PIPE와 유사   PIPE나 FIFO와 달리 다수의 프로세스 간 메시지를 전달할 수 있음   사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 다룰 수 있음 → 메시지 접근을 위한 키 (Key) 필요   메모리 맵 (Memory Map) : 열린 파일을 메모리에 맵핑시켜서 공유     공유 메모리처럼 메모리를 공유함 (공유 매개체가 파일 + 메모리)   주로 파일로 대용량 데이터를 공유해야 할 때 사용, 파일 입출력이 느릴 때 사용하면 편리   대부분의 운영체제에서 프로세스를 실행할 때 실행 파일의 각 세그먼트를 메모리에 사상하기 위해 메모리 맵 파일 사용   메모리 맵 파일은 파일 크기를 변경할 수 없으며, 메모리 맵 파일을 사용하기 이전 혹은 이후에만 파일 크기를 변경 가능  ","categories": [],
        "tags": ["Operation System"],
        "url": "/os4/",
        "teaser": null
      },{
        "title": "[Operation System] 5. Thread",
        "excerpt":"쓰레드 (Thread) : 프로세스 내부의 흐름      CPU를 구성하는 기본 단위로, 일반적으로 하나의 프로세스는 하나의 쓰레드가 존재   하나의 쓰레드는 고유한 Thread ID, Program Counter, Register Set 및 Stack을 가짐   다중 쓰레드 (Multi-Threads) :  하나의 프로세스에 쓰레드가 2개 이상 존재     Concurrent : 한 프로세스에서 여러 쓰레드가 빠른 시간 간격으로 스위칭되어 동시에 실행되는 것처럼 보임            여러 쓰레드들이 하나의 프로세스 안에 속하면서 code, data 메모리 공간과 프로세스 자원 file과 I/O 공유       메시지 패싱 X (운영 체제를 거치지 않고도 통신 가능), 공유 메모리 X (공유 메모리를 만들지 않아도 됨)                    멀티 프로세스에 비해 문맥 전환 시간이 짧고, 메모리와 자원의 할당이 더 효율적                           운영체제가 다중 쓰레드를 지원 : 현대 운영체제에서의 문맥 전환은 프로세스가 아닌 쓰레드 단위로 이루어짐            하나의 프로세스 안에서 여러 쓰레드가 수행되다가 다른 프로세스로 넘어가 그 프로세스의 쓰레드를 수행함                    웹 브라우저 : 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 따로 수행                              프로세스와 쓰레드의 비교 : 다중 프로세스와 다중 쓰레드는 둘다 여러 흐름이 동시에 진행된다는 공통점을 가지나,          다중 프로세스에서 각 프로세스는 독립적으로 실행되며 각각 별개의 메모리를 차지한다.     다중 쓰레드는 프로세스 내 메모리를 공유해 사용할 수 있다. 고로, 프로세스보다 스레드 간의 전환 속도가 빠르다.     다중 쓰레드는 CPU가 여러 개일 경우에 각 CPU가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다.     다중 쓰레드는 각각의 쓰레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없어 ‘경쟁 조건’의 문제가 발생한다.      다중 쓰레드 모델 (Multi-Threads Models) :  2개 이상의 쓰레드로 구성된 모델     유저 쓰레드 (User Thread) : 유저 레벨의 쓰레드 라이브러리를 통해 관리되는 쓰레드   커널 쓰레드 (Kernel Thread) :  운영체제가 제공하고 직접 관리하는 쓰레드   Many-to-One 모델 : 한 커널 쓰레드가 여러 유저 쓰레드 처리     병목 현상 : 시스템 호출이 발생하면, 모든 유저 쓰레드가 대기해야 함   One-to-One 모델 : 유저 쓰레드 한 개당 커널 쓰레드를 대응시켜 처리     커널 쓰레드가 과도하게 생성되어 비효율적임   Many-to-Many 모델 : 여러 유저 쓰레드가 여러 커널 쓰레드 처리     커널 쓰레드의 수는 유저 쓰레드의 수보다 작거나 같게 해야 함   Two-Level 모델 : 중요한 작업은 One-to-One으로, 나머지는 Many-to-One으로 처리  ","categories": [],
        "tags": ["Operation System"],
        "url": "/os5/",
        "teaser": null
      },{
        "title": "[Operation System] 6. Main Memory Management",
        "excerpt":"메인 메모리 관리 (Main Memory Management)      메모리 공간은 기본적으로 주소 (address)와 데이터 (data)로 구성되어 있음            CPU는 주소를 가지고 메인 메모리에 요청을 하거나 해당 주소에 계산 결과를 저장       메인 메모리는 CPU가 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달                 프로그램의 빌드는 소스 파일, 목적 파일, 실행 파일 순서로 생성            소스 파일 (Source file) : 고수준 언어 또는 어셈블리어                    컴파일 단계 : 소스 파일은 컴파일러 또는 어셈블러에 의해 컴파일 또는 어셈블하여 목적 파일 생성                       목적 파일 (Object file) : 컴파일된 결과 또는 어셈블된 결과                    링크 단계 : 목적 파일은 링커 (Linker)에 의해 라이브러리를 찾아 정보를 추가해 실행 파일 생성                       실행 파일 (Executable file) : 링크된 결과                    로드 단계 : 실행 파일은 로더 (Loader)에 의해 메인 메모리에 할당                                 빌드된 프로그램은 code, data, stack 영역으로 구분됨            단순히 생성된 프로그램은 code, data 영역만 존재       로드 단계에서 프로그램이 실행을 위해 메모리에 적재되었을 때, 운영체제에 의해 stack 영역이 추가됨           메모리 계층 (Memory hierarchy) : 각각의 특징이 있는 저장 장치를 혼용해 효율성 극대화     메모리 매니저 (Memory Manager) : 메모리 하이라키를 관리하는 관리 시스템의 일부분         캐시 (Cash) : 빠르고, 비싸고, 휘발성   메인 메모리 (Main Memory) : 캐시보다 느리고, 캐시보다 싸고, 휘발성   디스크 스토리지 (Disk Storage) : 메인 메모리보다 느리고, 메인 메모리보다 싸고, 비휘발성      메모리 계층 구조를 통해 프로그래머가 사용하기 좋은 모델로 추상화하고, 운영체제를 통해 추상회된 객체를 관리한다.    Q. CPU가 한 번에 한 프로세스를 수행하면? : Mono-Programming      메인 프레임 (mainframe) : RAM 위의 OS에 유저 프로그램이 주소로 연결되어 존재   임베디드 시스템 (Embedded System) : OS가 위치한 ROM 아래에 유저 프로그램이 주소로 연결되어 존재   퍼스널 컴퓨터 (personal computer) : 메인 프레임 + ROM 위 장치 관리자가 유저 프로그램 위에서 OS의 관리를 받음      하단 내용은, CPU가 여러 프로세스를 돌아가면서 수행하는 Multi-Programming 환경이라 가정한다.    Q. 만약 메모리 추상화를 사용하지 않는다면? : 모든 프로그램이 물리 메모리를 직접 사용     프로그래머에게 제공되는 메모리 영역 : 실제 물리 메모리 (0 ~ (실제 물리 메모리의 크기))            각 주소는 n비트로 구성된 셀 (Cell)로 정의           하드웨어의 도움 없이 두 프로그램이 동시에 메모리에서 실행된다는 것은 불가능            메모리의 프로세스를 이미지 형태로 디스크에 저장하고, 프로그램을 메모리로 스와핑 (Swapping)할 순 있음              ! 메모리 추상화를 사용하지 않는다고 했으니, 메모리 계층 구조 또한 존재하지 않는거네?         아니다. 메모리를 추상화하는 방법 중 하나로, 메모리 추상화를 사용하지 않는 것이다.                { a, b, c, d, … } 를 추상화하는 방법 (1) := alphabetic         { a, b, c, d, … } 를 추상화하는 방법 (2) := { a, b, c, d, … }                   … 운영체제는 메모리 계층 구조를 이루는 캐시, 메인 메모리, 디스크 스토리지를 물리 주소를 통해 직접 접근한다.         그런데, 물리 주소를 직접 접근하는 방법에는 Protection &amp; Relocation 이슈가 존재한다.      P1. 프로텍션 (Protection) : 한 프로세스가 운영체제나 다른 프로세스의 파티션을 침범하지 못하게 해야 함     IBM360모델 : 프로텍션 코드 (Protection code)            프로세스의 PSW에는 4bit 키가 포함 / 메모리를 2KB 블럭 단위로 나누고, 각 블록에 4bit 프로텍션 코드 할당       수행되는 프로세스는 자신의 PSW 키와 액세스하는 블럭의 프로텍션 코드를 비교해, 일치하지 않으면 트랩 발생           P2. 리로케이트 (Relocation) : 변수 주소나 프로시저 주소에 대한 접근에 차이가 발생     컴파일된 .exe 파일을 파티션에 로드해 실행할 때, 바이너리 파일이 아닌, 파티션을 기준으로 접근해야 함            컴파일된 .exe 파일을 파티션 A와 B에 각각 로드해 실행할 때, 각 파티션을 기준으로 접근해야 함              컴파일된 .exe 파일의 첫번째 명령어가 100번지에 있는 프로시저 콜이라고 가정하면…         해당 파일을 파티션에 로드해 실행했을 때 : 0 + 100번지로 접근 (파티션의 시작 주소) + 100번지로 접근         IBM360모델 : 정적 재배치 (Static Relocation)            프로그램이 메모리에 로드될 때, 파티션을 기준으로 접근하도록 명령어 수정                    링커가 프로그램의 어떤 부분이 리로케이트되어야 하는지 알아야 함                           주소 바인딩 (Address Binding) : 프로세스의 논리적 주소를 물리적 메모리 주소로 연결     주소 공간 (address space) : 프로세스가 메모리에 접근할 때 사용하는 주소들의 집합            각 프로세스들은 자신들만의 주소 공간을 가짐 -&gt; logical address           프로그램이 어떤 주소를 사용해도, 메인 메모리에 할당된 주소를 찾아가도록 해야 함            논리 주소 (logical address) : CPU에서 사용하는 주소. 메모리 내 프로세스의 독립적인 공간       물리 주소 (physical address) : 메인 메모리에서 사용하는 주소. 하드웨어에 의해 정해진 주소 공간              … 그러므로 프로그램이 할당된 실제 메모리 주소 공간의 위치는 프로그램을 실행하는 CPU에 전혀 영향을 미치지 않음         그럼 어떻게 각각의 프로세스들에게 서로 다른 주소 공간을 제공할 수 있을까?      MMU의 재배치 레지스터 (Relocation Register) : 프로세스의 논리 공간을 메모리의 물리 공간으로 연속해 매핑     동적 재배치 (Dynamic relocation) : 프로세스의 논리 주소를 메모리의 물리 주소으로 변경            베이스 레지스터 (Base Register) : (파티션의 시작 주소)       리미트 레지스터 (Limit Register) : (파티션의 크기)                 현재 프로그램이 파티션에 로드되었을 때, 프로그램이 로드된 파티션의 크기를 리미트 레지스터의 값에 저장   CPU는 메인 메모리에서 주소가 사용 가능한지 여부를 생각하지 않고, 명시된 그대로 물리 주소를 사용하려고 함   CPU가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더해 수행 (Relocation)   CPU가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소가 리미트 레지스터의 값과 동일하거나 큰지 확인 (Protection)            O : 프로텍션 바이오레이션 (Protection Violation) 발생시켜 메모리 참조를 중단       X : 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더한 값을 메모리 버스에 보냄              Q. 그럼 베이스 레지스터 &amp; 리미트 레지스터를 사용하면 이젠 더 이상 문제가 없는걸까?         모든 메모리 참조마다 덧셈과 비교 연산이 요구되기에, 비교적 시간이 오래 걸림 : 특히 덧셈 연산이!                블로트웨어 (Bloatware) : 메모리의 크기를 증가하는 속도를 소프트웨어의 크기가 증가하는 속도가 역전                             정적 메모리 파티션 (Fixed memory partitions) : 메모리를 파티션 여러 개로 미리 나누고 프로세스 할당                Multiple input Queues : 도착한 작업을 크기에 맞는 가장 작은 파티션에 넣음         Single input Queue : 도착한 작업을 수용할 큐를 하나만 배정, 먼저 도착한 작업을 먼저 실행시킴                             정적 메모리 파티션은 메모리가 시스템이 구동할 모든 프로세스를 적재 가능한 용량을 가져야 성립하나,             시스템이 구동할 모든 프로세스들이 필요한 메모리의 전체 크기는 실제 RAM 용량보다 크다.       프로그램이 시작하기 전에 이미 실행 중인 프로세스들이 적재되어 있다.            … 모든 프로세스들을 계속 적재하기엔, 물리 메모리 크기에 한계가 있다는 문제에 대해, 2가지 해결책이 제시되었다.         Swapping : 한 프로세스의 전체 이미지가 메모리로 적재되어 실행되다가 실행되지 않으면 디스크로 이동     Virtual Memory : 한 프로세스의 전체 이미지가 아닌 일부만 메모리에 있어도 프로세스의 실행이 가능      스와핑 (Swapping) : 메모리에 로드된 프로세스 중에 장기간 미사용된 것을 하드 디스크에 이미지 형태로 저장     프로세스 이미지 (Process Image) : 프로그램이 메모리에 로드되고 실행되어 데이터가 변경된 프로세스            하드 디스크에 존재하는 .exe, .app에 데이터가 변경되었기에 이를 하드 디스크의 backing store에 저장                    swap-out : 메인 메모리 -&gt; Backing store           swap-in : Backing store -&gt; 메인 메모리                                 … backing store는 메인 메모리의 모든 프로세스가 swap-out될 때 데어터의 소실 없이 저장할 수 있어야 한다.         그러므로, 하드 디스크에서 backing store이 할당받는 크기는 최소 메인 메모리의 크기라 예상할 수 있다.            (a) 각 프로그램의 데이터 세그먼트가 늘어날 공간을 미리 확보   (b) 각 프로그램의 세그먼트를 프로그램 텍스트 / 데이터 세그먼트 / 스택 세그먼트로 나눔            프로그램 텍스 위의 데이터 세그먼트와 스택 세그먼트가 서로를 향해 자라게끔 함                    힙 (Heap) 영역 (Room for growth) : 사용자가 동적으로 할당할 영역                            malloc, calloc 등의 명령어로 관리                                                   동적 메모리 파티션 (Dynamic memory partitions) : 프로그램이 메모리에 로드될 때마다 파티션을 나누고 할당     운영체제가 동적으로 할당된 프로세스를 관리 : 힙 영역이 커지므로, 프로세스의 확장을 위한 공간이 할당되어야 함         (b) Bit Maps 사용 : 맵에 X비트를 관장할 Y개의 할당 단위 (allocation unit)            단위 유닛이 메모리에 할당되어 있으면 유닛의 값을 1, 할당되어 있지 않으면 0 (flag bit)                   할당 단위가 작아지면? : 유닛의 개수 Y가 커진다.                Y를 표현할 flag bit가 많이 필요하므로, 맵의 크기가 커져 맵을 탐색할 때의 성능이 저하된다.                 할당 단위가 커지면? : 유닛의 개수 Y가 작아진다.                Y를 표현할 flag bit가 적게 필요하므로, 비트맵의 공간이 작아진다.         마지막 프로세스에 빈 공간 역시 커져 더 많은 메모리 공간이 낭비될 가능성이 있다.                   … Bit Maps의 문제점 : 프로세스가 k개의 할당 단위를 요구할 때, 맵에서 k개의 0비트를 연속해서 찾아야 한다.       (c) Linked Lists 사용 : 메모리의 낮은 주소부터 링크드 리스트의 노드가 있음            각 엔트리는 P (프로세스) or H (홀)을 표현하는 flag, 시작 주소, 길이, 다음 엔트리를 가리키는 포인터로 구성                   프로세스 종료 시 Linked Lists를 업데이트하는 방법                종료되는 프로세스는 일반적으로 2개의 이웃을 가짐 → 이웃은 다른 프로세스가 차지한 공간이거나 빈 공간                             (a) X에 해당되는 엔트리를 X에서 H로 바꿔 갱신     (b), (c) 2개의 엔트리를 통합해 하나로 표현     (d) 3개의 엔트리를 통합해 하나로 표현      Contiguous Memory Allocation : 메모리에 새로 생성된 프로세스들을 위한 메모리 공간 할당     메모리 단편화 (Memory fragmentation) : 메인 메모리에 흩어진 홀들이 불연속적으로 할당된 상태            프로세스 생성 &amp; 종료 반복 → scattered holes       홀 (Hole) : 메인 메모리에서 프로세스가 할당되지 않은 영역           외부 단편화 (External fragmentation) : 프로세스를 할당할 크기가 충분하나, 메모리 단편화로 할당이 불가능한 상태         First-fit : 프로세스 크기보다 크거나 같은 홀을 탐색하는 순서 중에서 가장 먼저 찾은 홀에 프로세스 할당         Best-fit : 할당할 프로세스 크기와 홀의 크기 차이가 가장 작은 홀에 프로세스 할당         Worst-fit : 할당할 프로세스 크기와 홀의 크기 차이가 가장 큰 홀에 프로세스 할당            Best-fit을 사용하였다가 다른 프로세스가 쓰지 못할 정도의 홀이 생겼을 때를 위한 대안                 Compaction : 메모리 여러 곳에 흩어져있는 홀들을 강제로 하나로 병합            홀을 옮기는 오버헤드가 매우 크고, 어느 홀을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않음              일반적으로 할당 속도는 First-fit가 가장 빠르며, 메모리 이용률은 First-fit와 Best-fit이 비슷하다.         하지만 Best-fit을 사용하더라도, 외부 단편화로 인해 여전히 전체 메모리의 1/3 정도를 낭비한다.     ","categories": [],
        "tags": ["Operation System"],
        "url": "/os6/",
        "teaser": null
      },{
        "title": "[Operation System] 7. Paging",
        "excerpt":"페이징 (Paging) : 프로그램과 메모리를 일정한 크기로 나눔      가상 주소 (Virtual address) : 프로그램이 가상 메모리에서 참조하는 주소            가상 메모리 (Virtual Memory)가 있다면, 각 프로그램은 자신의 고유한 가상 주소 공간을 가짐                    가상 메모리 사용 O : 가상 주소가 그대로 메모리 버스에 실려 물리 주소가 됨           가상 메모리 사용 X : 가상 주소가 MMU에 의해 물리 주소로 매핑                                 가상 주소 공간과 물리 주소 공간은 고정된 크기 단위의 유닛들로 동일하게 나뉜다.            가상 페이지 (Virtual Page) : 가상 주소 공간을 나눈 조각. 각 페이지는 연속된 주소를 가짐       페이지 프레임 (Page Frame) : 물리 메모리를 나눈 조각.                   다음 그림에서는 가상 주소 공간을 64KB, 물리 메모리 공간을 32KB, 유닛 크기는 4KB로 가정하고 있다.                논리 주소 (logical address) : 세그먼트 (segment) + 오프셋 (offset)                세그먼트 (segment) : 64KB의 고정된 길이와 시작 위치으로만 구성         오프셋 (offset) : 세그먼트의 시작 지점에서 실제 주소까지 떨어진 거리                 가상 주소 (virtual address) : single 32-bit unsigned integer                가상 페이지는 16진수로 표현 (16bit) : 0x00000000 ~ 0xffffffff의 범위 (4096bit=4KB)                 물리 주소 (physical address) : 물리 메모리에서 각각의 셀 (cell)의 주소                페이지 프레임은 가상 페이지가 매핑되는 물리 메모리의 일부분(4096bit=4KB)                        명령어 MOV REG, 0을 수행한다고 가정해보자.             이 명령어에서 접근하는 가상 주소 0는 MMU로 전달된다.       MMU는 해당 가상 주소가 가상 페이지 0에 속한 것임을 확인한다.       MMU는 가상 페이지 0에 매핑된 물리 주소의 페이지 프레임이 2임을 계산한다.       가상 주소 0은 물리 주소 8192로 변환되고, 이 물리 주소가 메모리 버스에 실린다.            … 가상 페이지를 페이지 프레임에 매핑하는 것만으론, 가상 주소 공간이 물리 주소 공간보다 큰 문제를 해결하지 못한다.    페이지 폴트 (Page Fault) : 페이지가 메모리에 매핑되어 있지 않음을 파악하면 CPU에서 트랩 발생     present 비트 : 어떤 페이지가 실제 메모리에 존재하는지 표현하는 비트 (가상 페이지에 X로 표현)            페이지가 메모리에 매핑되어 있지 않으면, CPU에서 트랩을 발생시켜 운영체제에 이를 알림           Page Fault가 발생하면, 운영체제는 적게 사용되고 있는 페이지 프레임을 하나 선택            선택한 페이지가 수정되었다면 (dirty 상태) 이를 디스크에 기록       선택한 페이지가 수정되지 않았다면 (clean 상태) 디스크에 존재하는 것과 동일하니 기록하지 않음       선택한 기존 페이지의 내용을 지우고, 참조하려는 페이지의 내용을 페이지 프레임에 적재       선택한 기존 페이지 프레임을 X로, 참조한 페이지 프레임을 숫자로 매핑시켜 가상 페이지 맵 수정       트랩이 발생한 명령어를 다시 실행              명령어 MOV REG, 24576을 수행할 때 Page Fault가 발생해 OS에서 페이지 프레임 1을 교체한다고 가정해보자.         가상 페이지 1이 더 이상 매핑되지 않음 (X)을 표시한다.     가상 페이지 7이 페이지 프레임 1에 매핑되었음을 표시한다.      페이징 테이블 (Page Table) : 가상 페이지 번호 (VPN)를 페이지 프레임 번호 (PFN)로 매핑      위의 매핑 정보를 바탕으로 가상 주소 8196를 물리 주소 24580로 변환하는 과정을 가정해 살펴보자.               16비트 크기를 갖는 가상 주소는 VPN와 오프셋으로 구분된다.                페이지 번호는 페이지 테이블의 인덱스로 사용된다.                 페이지 테이블에는 VPN에 대응되는 PFN이 기록되어 있다.                present가 1이면, 페이지 테이블의 PFN 3과 가상 주소의 오프셋 12가 결합해 물리 주소가 된다.                 물리 주소를 주소 출력 레지스터를 통해 메모리 버스로 전달해 참조한다.              페이지 테이블엔 디스크에 존재하는 페이지의 디스크 주소에 대한 정보가 없음 (Page Fault : 운영체제 내부에서 처리)            메모리에 존재하는 페이지 주소에 대한 정보만 존재 : 하드웨어가 가상 주소를 물리 주소로 변경할 때 사용                 페이지 테이블의 각 페이지에 존재하는 정보            페이지 프레임 번호 (PFN) : 가상 주소를 물리 주소로 매핑                    해당 페이지가 매핑된 물리 주소 결정                       Present 비트 : PFN이 유효한지 아닌지 결정 (가상 주소가 사용될 때마다 확인)                    0 (X)이면 해당 엔트리에 대응되는 페이지가 물리 메모리에 존재하지 않는 상태 (트랩 발생)                       Protection 비트 : 어떤 접근이 허용되는지 표시                    write, read, execute                       Modify 비트 : 페이지가 수정되었는지 아닌지 확인                    페이지의 내용이 write되면, 하드웨어가 자동으로 비트를 1로 세팅                            Modify 비트가 1 (dirty)이면, 페이지 프레임이 교체될 때 디스크에 기록되어야 함               Modify 비트가 0 (clean)이면, 페이지 프레임이 교체될 때 새로운 내용으로 덮어씌워도 됨                                               Reference 비트 : 해당 페이지가 write 또는 read로 접근되었을 때 설정                    운영체제가 Page Fault의 처리를 위해 교체할 페이지 프레임을 선택할 때 사용                       Cashing Disabled 비트 : 해당 페이지가 캐싱될 수 있는지 여부                    페이지가 메모리가 아닌 장치 레지스터에 매핑되어 있을 때 실행                                          64bit 주소를 사용하는 컴퓨터는 가상 주소 공간이 2^64byte       가상 주소 공간의 한 페이지가 4KB = 2^12byte이면,                    페이지 테이블의 엔트리 개수는 전체 공간을 한 페이지로 나눈 2^52개           엔트리 하나당 4byte의 크기를 가진다면, 페이지 테이블의 크기는 2^52 * 4byte                            … 페이징은 다음 두 가지 문제를 해결해야 한다.         가상 주소 공간이 커지면, 페이지 테이블의 크기 (= 페이지 테이블 엔트리의 개수) 또한 증가한다.                페이지 테이블을 유지하기 위해 필요한 메모리의 크기가 클 수 있음                 가상 주소에서 물리 주소로의 변환이 빠르게 이루어져야 한다.                메모리를 참조하는 오버헤드가 작아야 함                  TLBs (Translation Lookaside Buffers) : 페이징의 속도를 높이고, 큰 가상 주소 공간을 지원하는 기법      대부분의 프로그램들은 적은 개수의 페이지를 집중적으로 참조하는 경향이 있다.         페이지 테이블의 일부 엔트리만이 높은 빈도로 참조되고, 나머지 엔트리는 낮은 빈도로 참조된다.         TLB : 페이지 테이블의 참조 없이 가상 주소를 물리 주소로 매핑할 수 있는 작은 크기의 메모리            MMU 내부에 존재하며, 적은 개수의 엔트리를 가짐                    각각의 TLB 엔트리는 한 페이지에 대한 정보를 포함                                        MMU는 주소 변환을 할 때 요청된 가상 페이지가 TLB에 있는지 검색     가상 페이지가 존재하고 보호코드를 위반하지 않으면, 대응되는 페이지 프레임을 사용하여 주소 변환을 실행     TLB가 존재하지 않으면, TLB miss 발생. MMU는 페이지 테이블에서 해당 페이지 테이블 엔트리를 검색     그리고 TLB 엔트리 중 하나를 선택해 그 내용을 교체. 페이지 테이블에 없는 수정 비트는 페이지 테이블에 기록     찾은 페이지 테이블 엔트리를 TLB 엔트리에 기록 (이때 다시 참조한다면 TLB hit로 처리)     새로운 정보가 적재될 때는 페이지 테이블 엔트리에 있는 내용이 적재         메모리 계층 구조에서 발생할 수 있는 miss의 경우의 수 : 2^3가지 -&gt; 실제 발생 가능한 경우의 수 : 5가지      \t   \t\t   \t\t\t  Cache         TLB         Virtual Memory         발생 가능 여부 \t\t\t  설명 \t\t   \t   \t   \t\t   \t\t\t  hit         hit         hit         가능 (최선) \t\t\t  (1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X) (2) Cache가 hit이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 있음 \t\t   \t\t   \t\t\t  miss         hit         hit         가능 \t\t\t  (1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X) (2) Cache가 miss이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 없음 (3) Virtual Memory가 hit이므로, 캐시에 데이터를 불러오기 위해 메모리에 접근하면 데이터를 가져올 수 있음 (4) 메모리에서 캐시로 가져온 데이터를 CPU에 전달 \t\t          \t\t\t  hit         miss         hit         가능 \t\t\t  (1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O) (2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환 (3) Cache가 hit이므로, 변환한 물리 주소로 캐시에 접근해 캐시에 있는 데이터를 CPU에 전달 \t\t          \t\t\t  miss         miss         hit         가능 \t\t\t  (1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O) (2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환 (3) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음 (4) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달 \t\t          \t\t\t  miss         miss         miss         가능 (최악) \t\t\t  (1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O) (2) Virtual Memory가 miss이므로 (Page fault), 하드 디스크에서 데이터를 직접 가져와 페이지 테이블을 업데이트 (3) 이제 TLB가 miss &gt; hit이므로, 가상 주소를 물리 주소로 변환 가능. (4) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음 (5) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달 \t\t          \t\t\t  miss         hit         miss         불가능 \t\t\t  메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음 \t\t          \t\t\t  hit         hit         miss         불가능 \t\t\t  메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음 \t\t          \t\t\t  hit         miss         miss         불가능 \t\t\t  메모리 계층 구조 위반 : Page fault인데 Cache가 hit일 수 없음 (캐시에 데이터가 있을 수 없음) \t\t   \t                TLB miss인 경우 : 페이지 테이블에는 정보가 있지만, TLB에 그 정보가 들어있지 않을 때                해결책 : 페이지 테이블의 페이지 엔트리 내 데이터를 가져와 TLB에 넣음                 Page fault인 경우 : TLB에도 정보가 없고, 페이지 테이블에도 그 정보가 없을 때                운영체제는 권한을 받아 하드 디스크의 데이터를 페이지 테이블에 가져오고, TLB에 가져온 데이터를 넣음                  다단계 페이지 테이블 (Multi-level Page Table)     페이지 테이블을 페이지 프레임 크기로 나눔            해당 페이지 테이블의 페이지가 invalid하면 메모리에 할당하지 않음       기존의 단일한 페이지 테이블을 트리 구조로 연결           페이지 디렉토리 (Page Dictionary) : 페이지 프레임의 유무를 확인하는 자료구조            적어도 하나의 PFN이 valid하다면, 페이지 디렉토리의 해당 엔트리는 존재함                        기존의 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있음     다단계 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있지 않음       다단계 페이지 테이블에서의 모든 페이지 테이블은 항상 메모리에 유지될 필요가 없다.          필요한 페이지 테이블만 메모리에 할당해 절약할 수 있음   페이지 디렉토리로 물리 메모리의 빈 공간에 페이지 테이블 엔트리를 생성 가능   기존의 TLB Miss가 2번 늘어나 주소 변환이 2번 필요하고, TLB Miss를 처리해 메모리를 최적화하는 로직이 복잡해짐   역 페이지 테이블 (Inverted Page Table)     빠른 하드웨어 레지스터로 구성된 단일한 페이지 테이블 사용            페이지 테이블의 각 엔트리는 하나의 메모리 프레임에 대응           크기가 고정된 페이지 테이블에 프로세스를 맵핑            프로세스 실행 시 운영체제는 메모리에 존재하는 프로세스의 페이지 테이블 전체를 하드웨어 레지스터 배열에 적재           논리 주소는 PID, PFN, offset으로 구성   물리 주소는 MFN와 offset으로 구성         논리 주소의 PID와 PFN 정보를 바탕으로 페이지 테이블에서 동일한 엔트리 탐색   페이지 테이블에서 PID와 PFN가 일치하는 (MFN)번째 항목을 발견   MFN과 Offset 정보를 바탕으로 확인된 메모리 주소에 접근           64bit를 사용하는 컴퓨터에서 256MB의 물리 메모리가 4KB 페이지 프레임 2^18개로 구성되었다면,                페이지 테이블을 사용할 때의 페이지 테이블의 엔트리는,                        가상 주소 공간 2^64byte을 한 페이지 프레임의 크기 4KB = 2^12byte로 나눈 2^52개                             역 페이지 테이블을 사용하는 페이지 테이블의 엔트리는 물리 메모리의 페이지 프레임의 개수와 같으므로,                        물리 메모리 256MB = 2^28byte를 한 페이지 프레임의 크기 4KB = 2^12byte로 나눈 2^16개                                         프로세스 실행 중엔 페이지 테이블을 위한 추가적인 메모리 참조가 필요 없음 (프로세스 확장이 페이지 테이블과 무관)   페이지 테이블이 커질수록 구현을 위한 비용이 증가하고, 최악의 경우 페이지 테이블 전체를 적재해야 함 ex) 문맥 교환  ","categories": [],
        "tags": ["Operation System"],
        "url": "/os7/",
        "teaser": null
      },{
        "title": "[Operation System] 8. Page Replacement Algorithm",
        "excerpt":"페이지 교체 알고리즘 (Page Replacement Algorithm) : 페이지 폴트 시 교체할 페이지 선택      교체한 페이지가 다시 필요해져 페이지 폴트가 발생하는 비율을 줄여야 함 : 자주 사용되지 않을 페이지를 선택해야 함            제거할 페이지 중 최고의 페이지는 가장 긴 시간동안 접근하지 않을 페이지           최적 페이지 교체 알고리즘 (Optimal Page Replacement Algorithm) : 가장 사용하지 않을 페이지 교체     운영체제가 모든 페이지 참조를 수집했다고 가정하면, 각 페이지들이 몇개의 명령어 뒤에 처음으로 참조되는지 알 수 있음   그 중 가장 많은 명령어 뒤에 참조되는 페이지를 교체      페이지 폴트가 발생했을 때, 운영체제가 각 페이지들이 어느 시점에 참조되는지 알 수 없음         프로세스를 처음 돌린 뒤에 수집된 정보를 바탕으로 사용 가능      NRU (Not Recently Used) 페이지 교체 알고리즘 : 최근에 사용되지 않은 페이지 교체     가상 메모리를 지원할 때, 각 페이지마다 운영체제가 페이지 사용 정보를 수집하기 위한 2개의 상태 비트를 유지            R (Reference 비트) : 페이지가 참조될 때마다 설정 (read/write)       M (Modify 비트) : 페이지가 수정될 때 마다 설정 (clean/dirty)           최근에 참조되지 않은 페이지를 참조된 페이지와 구별하기 위해 주기적으로 (clock tick마다) R비트를 0으로 초기화   페이지를 4개의 클래스로 분류            클래스 0 : R = 0, M = 0       클래스 1 : R = 0, M = 1       클래스 2 : R = 1, M = 0       클래스 3 : R = 1, M = 1           페이지 폴트가 발생했을 때, 낮은 클래스에 있는 페이지 중 하나를 랜덤으로 교체            참조도, 수정도 안된 클래스 3에 속한 페이지가 있으면 내쫓고,       없으면 최소 한 사이클에서 참조되지 않은 클래스 2에 속한 페이지가 있으면 내쫓고,       없으면 자주 참조되지만 수정되지 않은 클래스 1에 속한 페이지가 있으면 내쫓고,       없으면 참조도, 수정도 이루어진 클래스 0에 속한 페이지가 있으면 내쫓는다.              가장 최근에 참조되지 않은, 변경된 페이지의 교체가 집중적으로 참조된, 변경되지 않은 페이지의 교체보다 좋음    FIFO 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지 교체     메모리에 페이지들이 들어온 순서대로 링크드 리스트를 sorting   페이지 폴트가 발생하면, 맨 앞에 들어온 것을 교체           메모리에 오래 있던 페이지가 자주 사용되는 페이지일 수 있음                 벨레이디의 모순 (Belady's anomaly) : 페이지 프레임이 늘어나면, 페이지 폴트의 개수가 오히려 느는 경우           Second-Chance 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지의 R을 검사한 후 교체     메모리에 페이지들이 들어온 순서대로 링크드 리스트를 sorting   페이지 폴트가 발생하면, 가장 오래된 페이지의 R을 검사            R = 0이면, 이 페이지는 최근에 사용되지 않은 페이지이므로 교체해도 됨       R = 1이면, 이 페이지를 맨 뒤로 옮기고, R를 0으로 초기화 (적재 시간도 현재시간으로 갱신)하고 다시 검사              자주 참조되는 페이지를 교체할 가능성이 있는 FIFO를 개선         하지만, 페이지를 리스트 맨 뒤로 이동시켜아 하기 때문에 동작의 효율성이 떨어질 수 있음      Clock 페이지 교체 알고리즘 : 시계 모양 원형 리스트를 구성하고, 화살표가 가리킨 페이지의 R을 검사     메모리에 페이지들이 들어온 순서대로 원형 리스트를 sorting   페이지 폴트가 발생하면, 화살표가 가리키는 페이지의 R을 검사            R = 0이면, 최근에 사용되지 않은 페이지이므로, 새로운 페이지 삽입 후 화살표를 다음 페이지로 이동       R = 1이면, 이 페이지의 R를 0으로 초기화하고 그 다음 페이지를 검사              LRU 페이지 교체 알고리즘 : 가장 오랫동안 사용되지 않은 페이지를 교체     메모리에 페이지들이 들어온 순서대로 링크드 리스트를 sorting            가장 최근에 사용된 것을 리스트의 맨 앞에, 가장 오래된 것을 리스트의 맨 뒤에 오게끔 배치           페이지 폴트가 발생하면, 가장 맨뒤에 있는 페이지를 추출      모든 메모리의 참조마다 리스트를 갱신해야 함 : 리스트에서 페이지를 탐색, 삭제, 이동하는 작업은 오래 걸림    LRU의 하드웨어 구현 1 : 64bit 카운터     카운터가 명령을 실행할 때마다 C값을 1씩 증가   각 페이지 테이블 엔트리는 카운터 값을 저장할 수 있는 공간을 가짐   메모리가 참조될 때마다 참조된 메모리를 담고 있는 페이지를 가리키는 페이지 테이블 엔트리에 C값 저장   페이지 폴트가 발생하면, 모든 페이지 테이블 엔트리의 C값을 조사해 가장 적은 값을 갖는 페이지를 교체      LRU의 하드웨어 구현 2 : N*N bit로 구성된 행렬을 갖는 LRU 하드웨어     N개의 페이지 프레임 -&gt; N*N bit로 구성된 행렬 : 행렬의 모든 값의 초기값은 0   페이지 프레임 k가 참조되면, LRU 하드웨어는            행렬에서 k번째 행의 모든 비트를 1로 설정       k번째 열의 모든 비트를 0으로 설정           행의 이진 값이 가장 작은 행에 대응되는 페이지 프레임이 가장 과거에 참조된 것           페이지가 0,1,2,3,2,1,0,3,2,3 순으로 참조되었다고 가정하자.         일단 1행을 모두 1로 0열을 0으로 초기화     1행을 모두 1로, 1열을 모두 0으로 초기화     페이지 폴트가 발생하면, 행 값이 제일 낮은 프레임을 교체                만약 그림 j에서 페이지 폴트가 발생하였으면, 2행이 가장 낮으므로 프레임 2를 교체                  LRU의 소프트웨어 구현 1 : NFU (Not Frequently Used)     각 페이지마다 각 페이지들이 얼마나 자주 참조되었는지 알려줄 소프트웨어 카운터를 유지 (카운터의 초기값은 0)   클록 인터럽트가 발생할 때마다 운영체제는 메모리의 모든 페이지를 검사하여 R의 값을 소프트웨어 카운터에 더함   페이지 폴트가 발생하면, 가장 적은 카운터 값을 갖는 페이지가 교체      NFU에는 잊어버리는 기능이 부재되어 있다.         다중 패스 컴파일러의 경우 : 패스 1에서 자주 참조된 페이지들은 높은 카운터 값을 가짐, 이는 패스 2에서도 유지     만일 패스 1이 그 이후 다른 패스들보다 더 긴 실행 시간을 가진다면 혹은 패스 1에서 더 많은 참조가 일어난다면, 패스 1에서 실행된 페이지들은 그 이후 패스에서 사용되는 페이지들에 비해 더 큰 카운터 값을 가짐                그러므로 패스 1에 사용되던 페이지 대신 현재 패스에 사용하는 유용한 페이지들을 교체                  LRU의 소프트웨어 구현 2 : 에이징 (Aging)     NFU를 기반으로, 다음의 사항을 변경한다.            R를 더하기 전에 오른쪽으로 1비트 시프트한다.       R는 오른쪽 비트가 아닌 왼쪽 최상위 비트에 추가된다.                       시간 순서를 구별할 정보를 기록                LRU : 오직 하나의 비트로 참조 여부만 기록해, 페이지 3, 5 중 어떤 페이지가 더 먼저 참조되었는지 모름         에이징 : 시간 순서를 구별할 정보를 기록해, 2번의 클록 틱 전에 1번 더 참조된 페이지 5 대신 3 교체                 과거에 대한 정보를 제한                NFU : 과거에 대한 정보를 모두 기억해 10번째 전에 참조되었는지, 100번 전에 참조되었는지 알 수 없다.         에이징 : 최대 N번 전에 정보를 기록할 N비트만이 존재해, 과거에 대한 정보를 제한된다.                  워킹 세트 알고리즘 (The Working Set Page Replacement Algorithm) : 페이지 집합 관리           스레싱 (Thrashing) : 멀티 프로그래밍의 정도가 높아 페이지 폴트가 계속 발생해 페이지 교체 시간이 길어짐                멀티 프로그래밍의 정도가 높은 경우 : 여러 프로세스로 인해 프로세스가 충분한 페이지를 가지지 못함                        어느 순간부터 CPU 점유율이 하락 (프로세스는 스와핑하느라 바쁜데, CPU는 아무것도 안한다.)                                                 Demand Paging : 실제로 필요할 때 (요청이 있으면) 그 page를 메모리에 올린다.                프로세스가 시작될 때 메모리에는 어떤 페이지도 존재하지 않음         CPU가 첫 명령어를 fetch하면 페이지 폴트를 통해 운영체제가 로드                 참조의 지역성 (Locality of reference) : 프로세스는 작은 페이지만을 집중적으로 참조하는 경향이 있음                locality set : 집중적으로 참조되는 해당 페이지의 집합                     워킹 세트 (Working Set) W(K, T) : 프로세스가 현재 사용하고 있는 페이지의 집합            워킹 세트의 locality set : 프로세스가 일정 시간 원활히 수행되기 위해 한번에 올라와야 하는 페이지들의 집합              워킹 세트를 (시간 T)에 대해, 가장 최근에 (횟수 K번) 발생한 메모리 참조에 의해 사용된 페이지의 집합이면,         뒤의 페이지가 앞의 페이지를 포함하니 K를 늘리수록 커지다가, (가상 페이지의 개수가 한정되어) 한 곳에 수렴              워킹 세트 모델 (Working Set)            PrePaging : 각 프로세스의 워킹 세트를 추적하다, 프로세스가 실행되기 전 그 프로세스의 워킹 세트 미리 로드       주기적인 인터럽트가 R을 일정 시간마다 초기화       페이지 폴트가 발생하면, 페이지 테이블을 스캔해서 쫓아낼 페이지를 탐색       해당 프로세스의 워킹 세트 전체를 한꺼번에 메모리에 올라갈 수 있는 경우에만 메모리에 할당                    그렇지 않을 경우, 모든 페이지 프레임들을 모두 반납시키고 디스크로 swap-out (스레싱 방지)                              워킹 세트 윈도우 (Working Set Window) : 올라올 워킹 세트를 결정 (워킹 세트 윈도우의 크기 : T)            페이지가 참조된 시점부터 T 시간 동안 메모리에 유지하고, 그 시점이 지나면 메모리에서 지움           메모리에 있는 프로세스들의 워킹 세트 크기의 합이 페이지 프레임의 수보다 클 경우 : 일부 프로세스를 swap-out            남은 프로세스의 워킹 세트가 메모리에 모두 올라가게 해 이를 우선적으로 충족 (멀티프로그래밍의 정도를 줄임)           워킹 세트를 모두 할당한 후에도 페이지 프레임이 남으면, swap-out된 프로세스를 메모리에 올려 워킹 세트 재할당           현재 가상 시간 (Current virtual time) : 프로세스가 시작된 후에 CPU를 실제 사용한 시간                마지막으로 사용한 시간 (Time of last use)                 페이지의 현재 가상 시간이 2204일 때 페이지 폴트가 발생하면,                페이지 테이블을 모두 스캔하면서 R을 체크한다.         R = 1 : 마지막으로 페이지를 사용한 시간을 현재 가상 시간으로 바꾼다.         R = 0 : age = (현재 가상 시간 - 마지막으로 페이지를 사용한 시간)와 T 비교                        age &gt; T : 워킹 세트에 그 페이지가 포함되어 있지 않으므로, 그 페이지를 지우고 게속 스캔한다.             age &lt;= T : 가장 큰 age를 만드는 페이지를 기억하고 계속 스캔한다.                             마지막까지 스캔했을 때 (모든 엔트리가 age &lt;= T이면), 가장 큰 age를 만드는 페이지를 지운다.         모든 엔트리가 R = 1이면 (가장 큰 age를 만드는 페이지를 모른다면), 한 페이지를 랜덤으로 지운다.                  세그멘테이션 (Segmentation) : 하나의 가상 주소를 제공하는 페이징과 달리, 여러 개의 가상 주소 제공     프로세스를 논리적 내용을 기반으로 나누어서 메모리에 배치            세그멘테이션 기법에서의 프로세스는 세그멘트 (segment)의 집합                    각 세그먼트는 자기만의 선형적인 주소 공간을 가짐                       페이징 기법에서는 주소 공간이 서로 충돌될 수 있지만, 세그멘테이션에서는 동적으로 테이블이 커지거나 줄어듬              세그먼트 테이블 : 각 엔트리의 논리 주소는 &lt;segment-number, offset&gt;            페이징과 달리 세그먼트의 크기는 일정하지 않기에 테이블에 limit 정보가 추가로 담겨 있음       만약 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 프로세스가 강제 종료                        논리 주소 (2, 100) : 물리 주소 4400번지     논리 주소 (1, 500) : 인터럽트로 인해 프로세스가 강제로 종료 (범위 벗어남)         세그멘테이션의 장점            보호 : 세그먼테이션도 페이징처럼 r, w, x를 테이블에 추가하는데, 프로세스를 논리적으로 나눠 비트 설정 간단       공유 : 세그먼테이션은 정확히 code 영역만 나누기에 다른 영역을 포함할 확률이 높은 페이징보다 더 효율적              …하지만 세그멘테이션은 외부 단편화 문제를 해결하지 못해, 현재는 페이징 기법을 대부분 사용한다.          외부 단편화 : 메모리 할당을 처음 시작할 때 크기가 서로 다른 프로세스로 인해 다양한 크기의 홀이 발생 (checkerboarding)                세그먼트를 논리적인 단위로 나눈 세그멘테이션 역시 외부 단편화로 인해 메모리 낭비가 큼                 세그멘테이션을 페이징 (Paged segmentation) : 펜티엄 (Pentium)                cs, ds, ss를 각각의 세그먼트가 아닌 하나의 주소 공간으로 통일해서 사용                        그러므로 cs, ds, ss는 다 같은 셀렉터 값을 가짐                             세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 2번                        CPU의 세그먼트 테이블에서 주소 변환, 그리고 다음 페이지 테이블에서 주소 변환                                     ","categories": [],
        "tags": ["Operation System"],
        "url": "/os8/",
        "teaser": null
      },{
        "title": "[Docker] 1. Virtualization",
        "excerpt":"가상화 (Virtualization) : 컴퓨터 자원 (Computer Resource)의 추상화      하드웨어 종속성 배제 : 물리적인 하드웨어 자원을 논리적인 단위로 나누고 이를 통합해 가상의 자원을 활용   리소스 가상화 (Resource Virtualization) : 컴퓨터 내 특정 자원만을 추상화     (가상의) 메인 메모리 : 가상 메모리 (Virtual Memory)   (가상의) 저장 장치 : 클라우드 (Cloud)   (가상의) 그래픽 카드 : vGPU   (가상의) 네트워크 : 가상 사설 네트워크 (Virtual Personal Network)   플랫폼 가상화 (Platform Virtualization) : 여러 개의 프로세스을 구동할 수 있는 플랫폼을 추상화     에뮬레이션 (Emulation) : 다른 컴퓨터 프로세서를 위해 쓰인 운영체제와 응용 프로그램을 실행   하드웨어 수준 가상화 (H/W-level Virtualization) : 하드웨어 플랫폼 위의 하이퍼바이저를 통해 가상 머신을 관리함        운영체제 수준 가상화 (O/S-level Virtualization) : 운영체제의 커널이 각각의 격리된 프로세스를 동작시킴            에뮬레이터 (Emulator) : 모든 하드웨어 자원의 동작을 소프트웨어로 대체             애뮬레이터 안의 응용 프로그램은 물리 하드웨어가 아닌 인터프리터 프로그램을 통해 실행 (JVM)                    인터프리터 프로그램은 가상 머신에서 명령을 수행할 때마다 물리 CPU가 처리할 바이너리 코드 갱신           물리 CPU는 에뮬레이터를 실행하기 위한 바이너리 코드를 해석해 이를 대신 실행                       장점 : 아키텍쳐가 전혀 다른 하드웨어 역시 가상화할 수 있음 (vs 하이퍼바이저 : 가상화할 수 없음)       단점 : 물리 CPU 내에서 직접 실행할 때보다 비효율적임                하이퍼바이저 (Hypervisor) : 다수의 가상 머신을 생성, 실행, 제어하는 논리적 플랫폼으로써의 프로세스             하이퍼바이저 안의 응용 프로그램은 물리 하드웨어를 하이퍼바이저에 의해 제한적으로 사용                하드웨어 가상 머신 (H/W Virtual Machine) : 하이퍼바이저에 의해 생성된 가상 환경                        Type 1. 호스팅 (Hosting) : 하이퍼바이저가 일반 프로그램과 같이 운영체제의 소프트웨어 계층에서 실행                     장점 : 가상의 하드웨어를 구동하기에 호스트 운영 체제에 큰 제약이 없음           단점 : 호스트 위에 게스트를 구동하는 방식이기에 비교적 큰 오버헤드 가짐 / GPU Passthrough 미지원                                Type 2. 네이티브 (Native) : 하이퍼바이저를 하드웨어에 직접 임베디드되어 실행                     장점 : 별도의 호스트가 없어 오버헤드가 적음 / 하드웨어를 직접 제어하기에 효율적인 자원 사용 가능           단점 : 자체적인 가상 머신에 대한 관리 기능이 없기에, 이를 위한 별도의 컴퓨터나 콘솔이 필요                        전가상화 (Full-Virtualization) : 하이퍼바이저에서 명령을 번역                             게스트가 요청한 명령은 하이퍼바이저가 실행한 관리용 가상 머신 DOM을 통해 하드웨어에 접근               하이퍼바이저가 각 가상 머신들의 모든 명령을 번역하여 실행하고, 이에 맞게 자원을 할당해야 함                                                반가상화 (Para-Virtualization) : 게스트 가상 머신에서 명령을 번역                             게스트 가상 머신이 하이퍼 콜 (Hyper Call)을 통해 하이퍼바이저에 명령을 직접 요청               게스트 가상 머신의 운영 체제가 하이퍼 콜을 요청할 수 있게 커널을 수정해야 함                                                   컨테이너 (Container) : 소프트웨어 패키지 (Software Package)의 추상화     컨테이너는 프로세스가 동작하는 격리된 사용자 공간 인스턴스            하나의 응용 프로그램과 그 응용 프로그램의 동작을 위한 라이브러리로 구성           운영체제의 커널은 여러 개의 격리된 컨테이너를 갖추어 각각의 개별적인 서버처럼 동작시킴           컨테이너를 사용하는 이유?                가상머신보다 공간을 적게 차지하며, 재가동성 또한 가상머신보다 좋다.         어플리케이선과 동일한 환경 세트로 개발되기에, 테스트에서 프로덕션까지의 이식성 및 일관성에 용이하다.         동적으로 리소스를 사용할 수 있어, 별도의 리소스를 할당할 필요가 없다.         서버의 밀도를 늪일 수 있다. 즉, 서버 내의 리소스를 과다하게 사용하지 않는 선에서 최적화가 가능하다.         하나의 커널에서 동작하기에, 업데이트 및 패치 작업 등을 한번만 수행하면 모든 컨테이너에 적용된다.                          리눅스 컨테이너 (Linux Container) : 리눅스에서 제공하는 운영체제 레벨의 컨테이너 기술             커널 레벨의 격리된 (isolated) 공간만 제공할 뿐, 개발 및 서버 운영에 필요한 부가 기능 부족              운영체제 A에만 가능한 a, 운영체제 B에만 가능한 b, 운영체제 C에만 가능한 c을 동시에 실행한다고 가정한다면,         에뮬레이션 : 응용 프로그램 ×3 ⊂ 에뮬레이트 운영체제 ×3 ⊂ 에뮬레이터 ×3 ⊂ 호스트 운영체제 ⊂ 하드웨어     Type 1. 호스팅 : 응용 프로그램 ×3 ⊂ 게스트 운영체제 ×3 ⊂ 하이퍼바이저 ⊂ 호스트 운영체제 ⊂ 하드웨어     Type 2. 네이티브 &gt; 전가상화 : 응용 프로그램 ×3 ⊂ 게스트 운영체제 ×3 ⊂ DOM ⊂ 하이퍼바이저 ⊂ 하드웨어     Type 2. 네이티브 &gt; 반가상화 : 응용 프로그램 ×3 ⊂ 수정된 게스트 운영체제 ×3 ⊂ 하이퍼바이저 ⊂ 하드웨어     운영체제 수준 가상화 : 컨테이너 프로세스 ×3 ⊂ 컨테이너 관리 소프트웨어 ⊂ 운영체제 ⊂ 하드웨어         Q. MacOS에서 도커로 윈도우 컨테이너를 실행하는 경우엔? : 응용 프로그램을 실행할 때 (O) 운영 체제를 실행할 때 (X)            윈도우 컨테이너 ⊂ 가상 머신 (호스팅) ⊂ 컨테이너 관리 소프트웨어 ⊂ 운영체제 ⊂ 하드웨어          ","categories": [],
        "tags": ["Docker"],
        "url": "/docker1/",
        "teaser": null
      },{
        "title": "[Github Pages] 1. 개발자에게 개발 블로그는 왜 필요한가요?",
        "excerpt":"   내가 아직 취업 시장에 발도 담구지 않은 대학생인데 내가 개발 블로그의 필요성에 대해 논하는 것이 의미가 있는 걸까? 라는 의문이 들어 작년에 작성한 글에서는 이 부분을 짚어보지 않았다. 하지만 이 부분을 뺀 채로 블로그를 운영하다보니, 처음에 내가 가졌었던 생각이나 느낌이 희석되면서, 여러 가지를 이유로 들며 블로그 운영을 게을리한 것 같다. 그래서 지난 1년간 내가 작성한 내용을 다시 정리하기 앞서, 이 부분에 대해 이야기하고자 한다.    1. 블로그에 글을 쓰는 과정 또한 하나의 공부가 될 수 있다.  사실 글을 쓰는 과정은 엄청나게 귀찮다. 글을 쓰기 위한 소재도 미리 준비해야 하고, 그 소재에 대해 모르는 부분을 공부해야 하고, 내가 잘못된 내용을 적는 게 아닌지 검토하는 과정 또한 거쳐야 하고… 하지만 내가 이전에 공부하거나 경함한 내용을 자세하고 정확히 설명하기 위해 노력하면서, 그 내용에 대한 나의 이해도가 올라가는 것 같다. 이전에 블로그에 글을 쓰기 전의 나는 수업 끝나면 다시 책을 펴보지 않았지만, 지금은 블로그에 글을 쓰기 위해서라도 최대한 기록을 남기려고 노력한다. 이러면서 내가 단순히 개념으로 머릿속에 집어넣은 내용을 블로그의 문장이나 예시로 설명하면서, 내용을 이해하는 것을 넘어서 개념을 응용하는 능력 또한 증진되는 것 같다.       글을 쓰는 것과 같이 누군가에게 무언가를 설명하려고 노력하는 행위를 나만 성장하는 데에 있어 도움이 된다고 느낀 건 아닌지, 실용주의 프로그래머라는 책에서는 프로그래머가 고무 오리 인형에게 코드 한 줄씩 설명하는 고무 오리 디버깅 (rubber duck debugging)으로 무언가를 설명해본 경험의 중요성을 강조한다. 이처럼 무언가를 설명해보는 경험이 계속 축적되다보면, 나중엔 무엇을 배우든간에 그것을 어떻게 설명해볼지에 대해 미리 생각해보게 될 것이다.    그리고 당연하지만, 글은 하나의 기록이고 그 자체로 나의 history가 된다. 자신이 공부하고 경험한 것을 기록하는 것은, 당연하지만 내가 기억하는 것보다 더 오래 보존된다. 나는 공부를 하거나 이런저런 자료를 참고한 것을 모으는 방법에 대해 늘 고민하곤 했는데 (예를 들면 즐겨찾기에 등록하는 것이나 PDF를 저장하는 것. 2가지 모두 단점이 명확해 중간에 그만두었다), 역시 코드의 주석처럼 글을 쓸 때 바로바로 참고한 내용을 링크를 걸어주는 방법이 제일 즉각적이고 직관적인 것 같다. 또한 만약 생각이나 회고을 적어둔 경우에는 내가 이런 생각을 했구나, 하면서 나중에 참고하기도 좋다.   2. 블로그를 운영하는 것이 성장의 동기가 될 수 있다.  나는 어렸을 때부터 무언가를 수집하는 것을 좋아했다. 초등학교 때는 TCG 게임의 카드들을 수집해 컬렉터 앨범을 만드는 것을 좋아했고, 중학교 때에는 코인 홀더에 담을 프루프를 사기 위해 용돈을 모아본 적도 있다. 블로그에 글을 쓰는 것 또한 내가 인터넷이나 서적 곳곳에 퍼져 있는 지식들을 수집해 하나의 모음집을 만든다고 느꼈기에 처음 개설하였을 때부터 블로그를 운영하는 데에 애착이 갔다.       그래서 나는 Blog-driven, 즉 블로그를 운영하기 위해 공부하고 경험하면서 나 또한 성장한다는 개념에 대해 긍정적으로 생각한다. 대다수의 사람들이 보통 블로그에 글을 쓰면서 Blog-driven이 이루어진다고 생각하는데, 나는 Blog-driven이 더 포괄적인 개념이라고 생각한다. 블로그를 계속해서 살아있는 상태로 유지하려면 단순히 블로그에 글을 쓰는 것만이 아닌, 블로그를 개선하고 유지보수하는 과정 또한 필요하다. 지난 1년간 블로그를 운영하면서 알게 모르게 시행착오를 거친 부분이 꽤 되는데 웹 개발을 공부하면서 이를 블로그에 대입해 생각해보기도 하고, 블로그에 적용시켜볼 계획도 세우기도 하는 식으로 앞으로 나아가는 데에 큰 도움이 되었던 것 같다.    3. 운영하는 블로그가 개발자에게 새로운 기회를 줄 수 있다.  내가 이번에 대학교 4학년이 되면서 느낀 점이 있다면, 나를 포장하고 홍보하는 것 또한 정말 중요하다는 것이다. 수능은 모든 학생을 일렬로 세우고 점수로 평가하지만, 사회에는 어떤 절대적인 기준이 존재하지 않으므로 사람들이 나를 평가할 수 있는 input data를 내가 스스로 가공해 제공할 필요성이 있다. 특히 개발자는 다른 직업보다 정보를 활용하는 능력이 뛰어나다보니, Github 프로필을 만들거나 포트폴리오 사이트를 만드는 것과 같이 나에 대한 정보를 공유하는 것 또한 매우 활발하다.       요즘 IT 기업들이 지원자의 개발 블로그나 Github의 주소를 요구하는 것 또한 그런 맥락일 것이다. 기업 입장에서는 모든 점에서 뛰어난 인재를 채용하고자 하겠지만, 그것은 매우 소수이다. 그래서 기업은 지원자의 잠재력 또한 확인해 평가하고자 노력한다. 그리고 이런 부분은 개발과 직접적으로 관련되어 있지만 단순한 결과물의 집합체인 이력서나 포트폴리오보다는, 성장하는 데에 있어 중요한 가치를 엿볼 수 있는 개발 블로그나 Github에 잘 들어나는 것 같다.      Reference         코드쓰는사림 님이 작성하신, 개발자가 블로그를 운영해야 할 이유     productuidev 님이 작성하신, 개발자 취업준비 (포트폴리오/블로그)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog1/",
        "teaser": null
      },{
        "title": "[Github Pages] 2. 개발 블로그는 어디에 만들어야 하나요?",
        "excerpt":"   글을 시작하기 앞서 말할 부분이 있다. 이번 포스트의 내용은 나의 주관적인 판단이 들어간 서술이 많다. 나야 보시다시피 Github Pages를 사용하지만 다른 사람들은 여러 이유로 다양한 플랫폼을 사용할 것이고, 그 부분을 지적하거나 문제시하는 게 아님을 분명히 밝히고 싶다. 이 글은 어디까지나 개발 블로그로 사용되는 여러 플랫폼에 대해 이야기해보는 과정을 통해 개발 블로그를 처음 만드는 개발자들이 이런 부분을 고려했으면 좋겠다, 는 취지로 작성된 것이다.    1. 네이버 블로그     한때는 블로그, 하면 네이버? 라고 할 만큼 국내에서 가장 많이 쓰였던 블로그 플랫폼이다. 나도 개발 관련은 아니지만 작년까지 네이버 블로그를 운영했었다. 그런 점에서 가지는 네이버 블로그의 장점은 (국내 한정) 보편성이다. 보편적으로 쓰이는 만큼 사용자 수가 많고, 대다수가 한번씩은 네이버 블로그에 글 정도는 올려보게 되는 것이다. 그리고 이전의 올드한 디자인도 개선된 편이고 카테고리 사용도 간편하다. (이번에 새로 도입된 웹 에디터는 좀 불편했다.)    하지만, 네이버 블로그의 가장 큰 문제는 역시 구글에서 검색했을 때 노출이 잘 되지 않는다는 것이다. 사실상 이 문제가 다른 모든 장점을 덮고도 남는다고 무방하다. 네이버라는 하나의 생태계에서 자체적으로 생산되는 컨텐츠를 검색할 수 있다는 것이 네이버 검색이 우리나라에서 널리 쓰이는 이유이겠지만, 개발자들 대다수가 구글을 통해 검색하는 만큼 다른 개발자들에게 내 글을 노출시키기 어렵다. (물론 블로그에 글을 올리는 목적이 조회수는 아니지만 내 글을 읽어주는 독자가 있다는 것, 그것이 적어도 내 의욕을 좌지우지하는 것 같다.)    2. 티스토리        Example         이동욱 님이 운영하시는, 기억보단 기록을      2006년에 창립되어 네이버처럼 국내에서 보편적으로 많이 쓰이는 블로그 플랫폼이다. 옛날엔 초대장 시스템이 있어서 사용자들의 접근성이 다소 떨어졌는데, 이게 사라지고 나서는 많이들 사용하는 것 같다. 예전에는 다음이 운영했는데, 다음이랑 카카오가 합병된 이후로는 카카오가 운영중인 것 같다.    개발자의 시선에서는 코드 삽입도 지원하고, 플러그인도 다양해 커스터마이징도 가능하고, 구글 노출도 되고, 거기다가 구글 애드센스도 달 수 있고… 정말 안 쓸 이유가 없다. 그렇기에 정말 많은 개발 블로그들이 개설되어 있고, 나 역시도 구글링할 때에 제일 많이 들어가는 플랫폼 중 하나이다. 그래서 초심자가 가장 무난하게 개발 블로그를 시작한다면, 티스토리에서 할 것을 권하고 싶다.    아, 생각해보니 티스토리가 이런 팔방미인이 될 수 있었는지를, (TMI지만) 간략하게나마 적어두어야 할 것 같다. 티스토리가 등장하는 2000년대 중반은 막 우리나라에서 블로그라는 개념이 퍼져나가는 태동기였다. 그때는 상술한 네이버 블로그나 지금은 사라진 다음 블로그처럼 IT 기업들이 운영하는 서비스형 블로그들이 주를 이루었는데, 블로그를 정말 자유롭게 이용하기엔 회사의 약관이나 운영방침과 같은 제약이 있어 차질이 생기곤 했다. (카카오가 운영하는 티스토리 또한 이 문제에 자유롭지는 않다.)    그래서 정재훈 씨가 처음 개발하고, 이후에는 태터앤컴퍼니 (TNC)에서 외국에 존재하던 설치형 블로그를 현지화해 출시한 프로그램이 태터툴즈이었다. 태터툴즈는 기존의 설치형 블로그의 장점을 유지하면서, 한국어에 최적화된 점에서 굉장히 주목을 받았고, 그 TNC가 다음과 합작해 만든 블로그 서비스가 바로 티스토리이다. 이런 알련의 과정 속에서 탄생한 티스토리는 설치형 블로그와 서비스형 블로그의 장점이 적절히 혼합되어 있다.    참고로 TNC는 2008년 국내 최초로 구글에 인수되었고 (!), 태터툴즈는 태터툴즈 사용자 커뮤니티였던 태터네트워크재단 (TNF)에서 개발을 전담해 텍스트큐브 (TextCube)로 리브랜딩되어 현재도 운영중…이면 좋겠지만, 정식 버전은 2014년 2월에 나온 1.10.10에서 멈춘 것 같고 베타 버전도 2.0 베타 3이 마지막인 것 같다. (텍스트큐브 Github)    3. 브런치        Example         옛날개발자 님이 운영하시는, 에디의 기술블로그      브런치는 2015년에 카카오가 글쓰기에 최적화된 플랫폼을 만든다는 야심찬 목표를 갖고 오픈한 블로그 플랫폼이다. 이곳에 글을 올리려면 작가 신청을 하고 에디터팀의 승인 심사에 합격해야 한다고 한다. 그래서 브런치에서 개발 블로그를 몇개 보긴 했는데도, 솔직히 난 소설 글쓰기 플랫폼으로 알고 있었다…    하술할 미디엄을 어느 정도 벤치마킹한 것으로 보이는데, 미디엄과 달리 코드 삽입이 안되서 이미지로 캡쳐해야 한다는 점이 너무 아쉽다. 디자인이랑 폰트가 워낙 깔끔해서 글쓰기엔 특화된 느낌은 확실히 강한데, 개발 블로그로 사용하기에는 한계점이 명확해 보인다.   4. 미디엄        Example         Moon 님이 운영하시는, medium     박상권 님이 운영하시는, medium      미디엄은 2012년 에반 윌리엄스가 만든 소셜 네트워크 서비스이다. 플랫폼을 처음 보았을 때에는 트위터나 링크드인과 같은 소셜 네트워크 서비스의 느낌이 강해 보였는데, 글을 작성하려 할 때 나오는 메모장 화면이 직관적이라 굉장히 좋았다. (미디엄이 글 쓸 때 나오는 한글 폰트가 구리다는 얘기가 많은데, 확장 프로그램 깔면 해결되는 부분이라 생각해 일단 나는 고려하지 않았다.)    그런데 내가 안쓰는 이유는… 사실 처음 블로그를 만들 때 미디엄에 대해 몰랐다! 원래부터 국내 사용자 수가 적다보니 미디엄을 개발 블로그로 쓰는 분들은 더 적은 거 같다. 그리고 카테고리랑 검색 기능이 없으니, 앞서도 얘기했지만 SNS 같은 느낌이 계속 드는 것 같아서 좀 손이 잘 가지 않는다.   5. Notion        Example         younho9 님이 운영하시는, notion      나는 옛날부터 노트에 무언가를 적는 것을 선호해서 스마트폰을 산 뒤로 애플 메모, 네이버 메모, 마이크로스프트 원노트, 에버노트 순으로 메모 앱을 사용했는데 뭔가 아쉬운 점이 한두 개씩은 있엇다. 그런데 노션을 2019년즘에 처음 사용하고 나서는 너무 만족해서 쭈욱 사용하고 있다.    단점을 말하기 앞서… 확실히 짚고 가야할 것이 있다. 노션은 블로그가 아닌 메모장이다. 그런데 메모장을 블로그로 사용하려면 그게 잘 될까? 이것저것 템플릿을 잘 가져와 쓴다고 해도, 메모장이라는 근본적인 한계가 명확하다고 생각한다. 다음은 내가 직접 써보면서 느낀 단점들이다.      페이지 주소가 직관적이지 않고, 페이지 제목이 바뀌면 새로운 주소를 가지게 되어 글을 다시 공유해야 한다.   하나의 페이지이기 때문에 카테고리, 글 검색, 댓글 기능이 부재되어 있다.   페이지가 무거우면 페이지를 불러오는 그 로딩 과정이 매우 길다.   그러면 노션 블로그를 호스팅하면 되지 않을까? 할텐데, 도메인과 호스팅 비용이 상당히 든다. 당장 무료로 쓸 수 있는 옵션이 이렇게 많은데, 노션이 좋다고 계속해서 돈을 지출하는 것은 좀 과하지 않을까?   6. 벨로그     벨로그는 2018년 velopert 님이 개설한 개발자에 특화된 블로그 서비스이다. 유저 수가 소수였던 초창기와 달리, 지금은 국내 많은 개발자들이 유입되면서 개발자 생태계가 잘 구축되어 있고, 올라오는 정보의 양과 질 모두 좋은 편이다. 또한 코드 삽입, 마크다운 에디터 등 개발자에 특화된 요소들이 눈에 띄는 요소이다. 모두 같은 디자인이고 커스터마이징할 수 있는 요소가 없다는 부분이 단점이긴 하지만, 앞서 말한 티스트리처럼 초심자가 개발 블로그를 처음으로 만든다고 한다면 벨로그가 가장 이상적이라 생각한다.    7. 워드프레스 블로그     상술한 티스토리의 TMI 파트에도 잠깐 등장한 워드프레스는 2003년 출시된 오픈소스 기반 CMS이다. 전세계에 있는 정말 많은 사이트나 블로그들이 워드프레스를 기반으로 되어 있고, 다양한 플러그인과 테마 또한 존재한다. 그래서 2018년에 네이버 블로그에서 워드프레스 블로그로 이전을 시도한 적이 있었는데… 결과는 실패였다.    그때 실패한 가장 큰 이유는 그때 군생활이여서 무언가를 공부할 여건이 도저히 되지 않았다는 것이었다. 워드프레스를 처음 접했을 때 생각보다 시간이 걸리고 이에 대해 공부할 부분도 꽤 된다. 그리고 처음에 플러그인을 게임 애드온처럼 이것저것 설치했는데 버전 충돌이 생겨서, 다시 제거하고 하나씩 학습해보고… 거기다가 PHP나 자바스크립트에 대한 공부 또한 필수적이다. 이런 것을 개발자들은 학습곡선 (Learning Curve)이 계속 길어진다고 표현하던데… 정말 맞는 말이라고 생각한다.   8. Github Pages        Example         한재엽 님이 운영하시는, JBEE.io     이종립 님이 운영하시는, 기억 보조용 위키      Github Blog라는 하나의 서비스가 존재하는 건 아니고, Github가 제공하는 Github Pages를 이용해 Github 저장소에 블로그나 웹 사이트 같은 웹 서비스를 호스팅하는 방식이다. 아무래도 지금 내가 사용하고 있는 거기도 하고 지난 1년간 공부하고 경험한 것도 있기에 이 부분을 조금 상세히 언급해보고자 한다.      긍정적인 점            커스터마이징의 자유도가 엄청나게 높다. 나처럼 Github Pages용 오픈 소스 테마를 이용해도 되고 아예 처음부터 설계해 만드는 것 또한 가능하다. 구글 검색에 내 블로그를 노출시킬 수도 있고, 구글 애드센스를 통해 광고를 달아줄 수도 있다. 요약하면, 개발자가 가지고 놀기에 정말 좋다!       Github에 저장소로 올라가는 방식으므로 Github와 연동이 된다. 로컬에서 블로그를 쉽게 편집하고 관리할 수 있으며, commit과 push로 글을 등록하면 된다. Github 저장소에 백업이 되어 있기 때문에 (당연하게도) 이를 원격지에서 다운받아 사용할 수도 있고, 필요한 경우 롤백하는 것도 가능하다.       마크다운 형식으로 작성하는 것을 지원하고, 코드 블룩이나 인용 블록 또한 지원한다. 게시글 하나하나가 .md 파일이라 나중에 플랫폼을 이전한다 하더라도 이를 다시 활용하는 것 또한 가능하다.              복합적인 점            워드프레스 블로그만큼은 아니지만, 다른 것들에 비해 진입장벽이 존재한다. 처음에 웹 사이트의 소스 코드를 올리거나 수정하는 작업이 필요하므로 최소한 git이랑 markdown을 어떻게 사용하는지는 알아야 한다. 블로그를 이것저것 건드려보려고 한다면 백엔드 관련 지식이 요구되고, 커스터마이징을 해보려면 간단한 프론트엔드 관련 지식 또한 필요해진다. 물론 웹 개발자를 지망한다면 이런 일련의 과정을 한번 하는 것도 도움이 된다.       Github 저장소에 올라가는 방식이므로 저장소 내의 소스 코드가 모두 공개된다. 블로그를 노출시키고 싶지만 블로그 내부까지 노출시키고 싶지 않는다면, 유료 걔정으로 전환해서 비공개로 전환해야 한다.       하나의 Github 저장소는 용량과 트래픽에 제한이 존재한다. (1GB의 최대 용량, 월 100GB의 트래픽 제한) 제한을 넘어서 사용하려면 Cloudflare과 같은 CDN을 추가로 사용해야 한다. 일단은 한도 내에서만 쓰면 무료인 것은 장점이지만, 한도를 넘어버린다면 돈을 써야하니 용량이 있는 파일을 올리는 것과 같은 경우에 주의할 필요가 있다.              부정적인 점            정적 페이지로 빌드한는 것만 지원한다. 그래서 댓글 기능을 추가할 때 외부 데이터베이스와 연동이 되지 않아 이를 위한 플러그인을 별도로 설치해야 한다. (Github가 소스 관리를 위한 서비스이니… 동적 호스팅 서비스는 AWS와 같은 클라우드 벤더 등을 사용하자.)       벨로그처럼 작성하는 문서 서식을 바로 렌더링해서 볼 수 없다. 프리뷰 플러그인을 사용한다 치더라도, 플러그인으로 형성된 화면과 렌더링된 화면이 일치하지 않아 결국엔 플러그인을 잘 안쓰게 된다.       글을 쓸 때 표나 이미지를 넣는 게 불편하다. 나 같은 경우에는 html과 css를 사용해 넣는데, 해당 문법을 알아도 표를 일일이 만드는 것은 굉장히 귀찮다. 이미지 같은 경우에는 외부 사이트에 업로드해 이를 호스팅하는데 그것 또한 좀 번거로운 작업이다.              나는 Github Pages 블로그를 운영하는 것은 장단점이 매우 명확하고, 개개인마다의 호불호가 엄청 갈릴 수 밖에 없다고 생각한다. 실제로 Github Pages 블로그를 운영하시다가 다른 블로그 플랫폼으로 이주하시는 분들도 많이 보았고 나 또한 블로그를 개설하면서, 그리고 개설된 블로그를 운영하면서도 이주할지말지에 대해 많이 고민했었다.     그래도 내가 Github Pages 블로그를 운영하는 데에는 git을 이용해 블로그를 관리할 수 있다는 것과 블로그 운영을 통해 웹 개발의 전반적인 과정을 학습해볼 수 있다는 점이 가장 큰 이유인 것 같다. Github Pages 블로그를 개설할 때에는, 정말 아무것도 모르는 감자 (…)라서 많이 헤맸다. 그래서 처음에는 블로그와 연동되는 git에 대해 공부하고자 Do it! 지옥에서 온 문서 관리자 깃 &amp; 깃허브 입문이라는 도서를 구매해서 공부해보고, 그 다음에는 블로그를 커스터마이징해보려고 Do it! HTML+CSS+자바스크립트 웹 표준의 정석이라는 도서를 구매해서 공부해보고 이를 최대한 적용해보는 식으로 실습하였다. 이렇게 블로그를 성장시키려고 노력하는 과정 속에서 나 또한 많이 성장할 수 있었고, 앞으로도 이런 blog-driven이 잘 이루어졌으면 하는 것이 내 바램이다.      Reference         productuidev 님이 작성하신, 개발자 취업준비 (포트폴리오/블로그)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog2/",
        "teaser": null
      },{
        "title": "[Github Pages] 3. Github Pages 블로그 소개",
        "excerpt":"   사실 이전 포스트에서 Github Pages에 대한 내용이 있어 좀 중복되는 느낌이 들 수도 있다. 하지만, 이 포스트에서는 Github Pages의 원리를 짚어보고자 작성한 것이니 혹시 모르는 사람들은 한번 읽어보자.    Github Pages 블로그란?      정적 웹사이트 생성기 (SSG; Static Site Generator)   많은 사람들이 Github Pages로 블로그를 사용하고 있어 이를 블로그 서비스로 인식하기 쉽지만, 사실 Github Pages의 실체는! 바로 Github에서 제공하는 정적 웹 사이트 호스팅 서비스이다. 그리고 정적 웹 사이트 호스팅 서비스를 가능하게 하는 것이 바로 SSG란 것이다.    SSG로 생성된 사이트는 모든 웹 페이지를 미리 생성하고, 방문자로부터 요청이 들어오면 미리 만든 웹 페이지를 그대로 응답해준다. 그러므로 서버와 클라이언트 모두 렌더링을 위한 작업이 거의 없기 때문에, SSG로 생성된 웹 사이트는 속도가 매우 빠른 장점을 가진다. 그리고 SSG로 생성된 사이트는 미리 만들어놓은 수많은 웹 페이지로 이루어져 있는 구조라 검색엔진 최적화 (SEO; Search Engine Optimization)가 뛰어나 검색엔진이 사이트를 크롤링하는 데에 적합하다.    그러나 빌드할 때마다 모든 웹 페이지를 생성하는 작업을 매번 하다보니, 컨텐츠를 자주 업데이트하는 웹 사이트나 규모가 커 빌드 시간이 오래 걸리는 웹 사이트에서는 큰 비효율성이 발생해 SSG보다는 다른 렌더링 기술을 사용한다. 그래서 SSG는 개인 블로그와 같이 컨텐츠의 변경이 자주 일어나지 않은, 소규모 웹 사이트를 제작할 때 많이 쓰이는 기술이다. (SSG 외에도 SPA, SSR과 같은 렌더링 기술이 있는데, 달레 님께서 SPA와 SSG, 그리고 SSR이라는 글에서 잘 정리해주셨으니 참고하길 바란다.)    지금 현재 내가 사용하고 있는 Github Pages 테마인 Minimal Mistakes는 Jekyll을 정적 웹사이트 생성기로 사용해 웹 사이트를 정적으로 생성한다. Jekyll 외에도 Hexo, Hugo와 같은 여러 정적 웹사이트 생성기들이 존재하는데, 이들을 간단하게 비교해보자.      Jekyll            Ruby 기반       가장 많이 쓰이고, 한글 래퍼런스 많음       Github Pages에서 공식으로 지원 : push한 글들이 별도의 빌드 과정 없이 알아서 Publish       글이 많아질수록 전체 빌드 속도가 느려짐              Hexo            Node.js (javascript) 기반       (javascript를 써서 그런지) 한글 래퍼런스 많음       Hexo로 블로그를 만들 때 참고할 만한 글              Hugo            Golang 기반       런타임에 다른 의존성이 필요하지 않아, 빌드 과정을 포함해도 빌드 속도가 빠른 편       한글 래퍼런스는 상대적으로 적음       Hugo로 블로그를 만들 때 참고할 만한 글              지킬 (Jekyll)      사실 SSG 중에 Jekyll이 좋은 거 같아 골랐다기보단, Minimal Mistakes 테마가 내 마음에 들어서 설치했는데 구글링해보니 다들 Jekyll을 쓰더라…의 흐름으로 쓰게 된 거고, Jekyll 말고도 다른 SSG가 있는 것을 알게 된 이후에도 어차피 다 같은 SSG인데 Jekyll 말고 굳이 다른 거를 배워서 쓸 필요성을 못 느껴서 (물론 Jekyll이 문제가 많다고 느끼면 다른 SSG를 사용할지에 대해 고민해봐야 할 것이다.) Jekyll을 계속 사용하고 있긴 하다. 일단 Jekyll이 어떤 방식으로 동작하는지 정리해보겠다. (사실 SSG와 동일한 원리인데, 이를 구체화한 것으로 생각하면 된다.)    Jekyll은 동적 웹 사이트 (Dynamic Web Site)과 동일하게, 레이아웃에 해당하는 templates과 컨텐츠에 해당하는 contents를 분리해 저장한다. (이때 Jekyll에서 templates을 작성할 때 사용하는 언어가 Liquid이고, contents를 작성할 때 사용하는 언어가 markdown이다.) 하지만 동적 사이트와 달리, Jekyll은 templates와 contents을 합친 HTML 문서를 미리 빌드해 저장하고, 방문자가 요청을 보내면 정적 컨텐츠에 해당하는 HTML 문서를 전송한다.    그래서 Jekyll은 웹 사이트를 운영하기 위한 HTML 관련 지식을 몰라도, .md 파일로 문서를 작성하면 HTML 파일로 이를 변환해주는 작업을 해주며 변환된 결과물을 토대로 웹 사이트를 구축해서 서비스해준다.   깃허브 페이지 (Github Pages)   상술하였듯 Github Pages는 Github에서 제공하는 정적 사이트 호스팅 서비스로, 무료 계정에 한해 하나의 Github Pages를 무료로 제공한다. Github Pages는 연동된 Github 저장소에서 HTML, CSS, JavaScript와 같은 정적 컨텐츠를 가져와 그대로 배포하는 방식으로 작동한다. 만약 Github 저장소가 Jekyll 디렉토리의 형태로 존재한다면, Github Pages는 해당 저장소가 Jekyll로 작성된 것임을 알고 이를 Jekyll로 빌드해 배포한다.       Reference         SW developer 님이 작성하신, GitHub Pages 블로그 따라하기     Wheel 님이 작성하신, 지킬 (Jekyll)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog3/",
        "teaser": null
      },{
        "title": "[Github Pages] 4. Github Pages 블로그 개설",
        "excerpt":"   이 내용은 작년 9월 말부터 작성한 Minimal Mistakes으로 Github Blog 만들기’의 내용 일부분을 재구성한 것이다. 해당 포스트도 완성도 있는 글이고, 처음 블로그를 설정하시는 분들 또한 도움을 얻을 것이라 생각되나… 그때쯤 작성한 글들 대부분이 너무 나열식으로 쓰였고, 출처에 대한 언급이 많이 부실해 (모르는 부분이 있어 찾으려 하면 출처가 없어서 나도 찾지 못한다…), 부족한 점들을 보완하기 위해 다시 작성되었다.  그리고 현재 작성자의 실행 환경의 OS가 MacOS임을 미리 밝혀둔다. 아마 근시일 내에는 기기를 바꿀 계획이 없으니, 동일한 OS를 사용하시는 분들은 그대로 진행해주시면 된다.    1. Ruby 설치  macOS는 Ruby가 기본적으로 설치되어 있으니, 터미널을 실행하고 다음 명령어를 입력해 Ruby의 설치 여부를 확인한다.   ruby -v // ruby X.X.X 출력 : 정상 설치 // \"zsh: command not found: ruby\" 출력 : 설치 오류   2. Jekyll 설치  터미널 창에 gem install 명령어를 입력해 Jekyll을 설치한다. 참고로 gem은 분산 패키지로, 라이브러리의 작성, 공개, 설치를 도와주는 시스템이다.   gem install jekyll   그리고 터미널 창에 다음 명령어를 입력해 Jekyll가 정상적으로 설치되었는지 확인한다.   jekyll -v // jekyll X.X.X 출력 : 정상 설치 // \"zsh: command not found: jekyll\" 출력 : 설치 오류   3. Jekyll theme 선택  이전 포스트에서 Jekyll은 레이아웃에 해당하는 templates과 컨텐츠에 해당하는 contents를 합쳐 HTML 문서로 미리 빌드해 저장하고, 이를 방문자에게 보여준다고 설명한 바 있다. 그런데 대부분의 블로거들은 레이아웃의 중요성은 알지만 이를 어떻게 구성해야할지 몰라 막막할 것이다. 그런 블로거들을 위해 존재하는 것이 Jekyll theme이다.    Jekyll theme은 다른 사람들이 미리 작업해놓은 templates으로, 많은 Jekyll theme들이 무료로 공개되어 있다. 무료 Jekyll 중에 사람들이 많이 사용하는 것이 minimal-mistakes이다. 간결하고 깔끔한 디자인과 꾸준한 업데이트, 그리고 무엇보다 엄청난 양의 한글 래퍼런스 (…)로 인해 나 역시도 minimal-mistakes을 기반으로 블로그를 개설하였기에, 앞으로 진행할 블로그 개설 역시 minimal-mistakes를 기반으로 진행한다.    먼저 minimal-mistakes Github 페이지에서 .zip 파일을 다운로드한 후 압축을 해제한다. 그리고 아래 사진을 참고하여 필요한 파일 및 디렉토리만 남기고 나머지는 삭제한다. (아, 기존에 존재하지 않는 _post와 _page 디렉토리는 추후에 사용할 예정이니 미리 생성해두자.)      4. 로컬에서 웹 호스팅  터미널 창에 다음 명령어를 입력해 Gemfile을 설치하기 위한 bundler를 사용해보자. 그러면 .jekyll-cache 폴더와 Gemfile.lock 파일이 생성된다.   gem install bundler   bundler 설치가 완료되면, 터미널 창에 다음 명령어를 입력해 Gemfile을 검사해 필요한 목록을 설치할 수 있다.   bundle install   이제 터미널 창에 다음 명령어를 입력하여 블로그를 로컬에서 호스팅해보자.   bundle exec jekyll serve   http://127.0.0.1:4000으로 접속하면 minimal-mistakes이 적용된 블로그 화면을 확인할 수 있다.   5. GitHub Pages에서 웹 호스팅   이제 Github에 (Github ID).github.io의 형식으로 원격 저장소를 생성하자. 다음은 내 블로그가 저장된 원격 저장소 이미지이다.      그리고 지금까지 정리한 내용들을 포함한 디렉터리를 github에 push하면, https://(Github ID).github.io를 주소로 하는 블로그가 생성된 것을 확인해볼 수 있다. 그리고 https://github.com/(Github ID)/(Github ID).github.io/actions에서 블로그가 빌드된 기록을 확인할 수 있다. 만약 원격 저장소에서 푸시된 내용에 대한 빌드 작업이 실패한다면, 그 내용의 배포가 진행되지 않은 것을 확인해볼 수 있다.      Reference         SW developer 님이 작성하신, GitHub Pages 블로그 따라하기     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog4/",
        "teaser": null
      },{
        "title": "[Github Pages] 5. Github Pages 블로그 설정 & 포스트",
        "excerpt":"   솔직히 블로그 설정을 건드는 부분은 내가 아는 정보들을 그대로 나열할 수 밖에 없다고 생각한다… 그래도 내가 시행착오를 겪었던 경험을 떠올리면서 하나하나 풀어서 작성하려 하였으니, 미숙한 글이지만 남들에게 도움이 되었으면 정말 좋겠다… 그리고 Github Pages이나 Minimal Mistakes으로 처음 블로그를 운영하시는 분들의 시선에 맞춰 html, css에 대한 자세한 내용은 다른 포스트로 옮겼으니 참고해주셨으면 한다.    1. 블로그 기본 설정     위의 디렉터리에서 _config.yml이라는 파일을 열어보면 다음과 같이 구성되어 있는데, 오른쪽의 주석을 참조해서 나만의 블로그를 커스텀마이징해보자. 이걸 어떻게 적용하는지 잘 모르겠다, 싶은 사람은 내 블로그에 적용된 것을 예시로 보면서 작업해보자.   minimal_mistakes_skin    :         # 블로그의 전체적인 스킨 지정                                     # (Minimal Mistakes에서 기본적으로 제공)                                    # \"default\" \"air\", \"aqua\", \"contrast\", \"dark\"                                    # \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"  # Site Settings locale                   : \"ko-KR\" # 블로그에 쓰일 로컬 언어 지정 title                    :         # 메타 태그에 들어갈 블로그의 제목 지정 subtitle                 :         # 블로그의 제목 하단에 위치할 부제목 지정 name                     :         # 블로그 저자 이름 지정 description              :         # SEO 향상을 위한 meta description 태그 지정 url                      :         # 블로그 url                                     # \"https://(github ID).github.io\" repository               :         # github repository url                                    # \"https://github.com/(github ID)/(github ID).github.io\" teaser                   :         # 관련 포스트나 검색 등에 들어갈 미리보기 이미지 지정                                    # (\"assets/images/\"로 연결) logo                     :         # 블로그의 제목 옆에 들어갈 로고 이미지 지정                                    # (\"assets/images\"로 연결) masthead_title           :         # 블로그 프로필 상단에 위치할 사이트 제목 지정 breadcrumbs              : true    # 브래드크럼 사용 여부 지정 words_per_minute         : 200     # 포스트를 읽는 데 걸리는 시간을 계산히기 위한 분당 읽는 글자의 지정   2. 블로그 레이아웃 설정  이제 조금은 삭막한(?) 블로그의 레이아웃을 뜯어고칠 차례이다. 우선은 이전처럼 _config.yml 파일을 아래와 같이 자신이 원하는 대로 수정하면 된다.   ## 블로그 좌측 사이드바에 위치할 프로필 설정 author:   name             :       # 저자 이름 지정   avatar           :       # 저자 이미지 지정   bio              :       # 저자 바이오그래피 지정   location         :       # 저자 위치 지정   email            :       # 저자 이메일 지정   links:                   # 저자 관련 사이트 링크 지정     - label:               # 사이트 분류 지정       icon:                # 사이트 아이콘 지정       url:                 # 사이트 url 지정  ## 블로그 하단에 위치할 꼬리말 설정 footer:   links:                   # 블로그 관련 사이트 링크 지정     - label:               # 사이트 분류 지정       icon:                # 사이트 아이콘 지정       url:                 # 사이트 url 지정   (1) 네비게이션 바   다음은 기본 테마를 보면서 혹은 자기가 기능을 적용하면서 불편한 점들을 확인하고, 직접 테마의 요소들을 뜯어고치는 건데… 이건 사람마다 달라서 뭐라고 말을 못하겠다. 그래서 나 같은 경우에 어떤 부분이 불편했고, 그래서 수정했는지 얘기해보고자 한다. 우선은 블로그 상단의 네비게이션 바에 내가 보기에 불필요한 카테고리들이 있었다. 그래서 카테고리, 태그만 남기기 위해  _data/navigation.yml 파일을 수정하였다.  _pages 디렉토리를 보면 여기에 적용할 수 있는 여러 요소들이 있는데, 직접 입맛에 맛게 적용해보면 된다.   main:   - title: (카테고리)        # 화면에 보여질 세부 항목의 이름 지정     url: /(카테고리)/        # _pages 내에 정해진 양식 파일이나 특정 링크로 연결   (2) 블로그 너비 및 폰트 크기   그리고 블로그에 포스트를 쓸 때에 한쪽에는 VS Code를, 다른 쪽에는 로컬에서 호스팅한 블로그를 보기 위한 사파리 브라우저를 띄워 놓곤 했는데, 그때마다 기본으로 설정된 블로그 너비랑 폰트 크기가 글을 읽기에 굉장히 불편했다. 그래서 _sass/minimal_mistakes/_variables.scss 파일과 _sass/minimal_mistakes/_reset.scss 파일을 다음과 같이 수정해보았다.   // 블로그 너비 설정 /*    Grid    ========================================================================== */  $right-sidebar-width-narrow: 200px !default;    // default 200px $right-sidebar-width: 300px !default;           // default 300px $right-sidebar-width-wide: 400px !default;      // default 400px   ## 블로그 폰트 크기 설정 html {   /* apply a natural box layout model to all elements */   box-sizing: border-box;   background-color: $background-color;   font-size: 16px;                    // Default 16px;    @include breakpoint($medium) {     font-size: 16px;                  // Default 18px;   }    @include breakpoint($large) {     font-size: 16px;                  // Default 20px;   }    @include breakpoint($x-large) {     font-size: 16px;                  // Default 22px;   }    -webkit-text-size-adjust: 100%;   -ms-text-size-adjust: 100%; }   (3) 블로그 아이콘   또 블로그 주소 창에 같이 뜰 아이콘이 아무것도 안 뜨니 뭔가 내 블로그 같다는 느낌이 안들었다. 그래서 이것 또한 _includes/_head/custom.html 파일에 내가 원하는 아이콘을 넣었다.   &lt;!-- start custom head snippets --&gt;  &lt;!-- insert favicons. use https://realfavicongenerator.net/ --&gt; &lt;link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/assets/logo.ico/apple-touch-icon.png\"&gt; &lt;link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/assets/logo.ico/favicon-32x32.png\"&gt; &lt;link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/assets/logo.ico/favicon-16x16.png\"&gt; &lt;link rel=\"mask-icon\" href=\"/assets/logo.ico/safari-pinned-tab.svg\" color=\"#ffffff\"&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#ffffff\"&gt; &lt;meta name=\"theme-color\" content=\"#ffffff\"&gt;   내가 수정한 것은 이정도? 인데 자잘하게 더 파고들면 커스텀마이징할 레이아웃 요소가 정말 많다. html, css, yml 파일을 건드는 것이라 그리 어렵지도 않고, 한번 배워두면 생각보다 쓸 때도 많다. 아래는 Minimal Mistakes Themes의 디렉토리 구조에 주석을 단 것인데, 커스텀마이징이 필요할 때 이를 참고하기 좋은 것 같다.   minimal-mistakes ├── _data                                 # 테마를 커스터마이징하기 위한 파일을 저장하는 디렉터리  | |                                       # (yml, yaml, json, csv, tsv 파일을 자동으로 읽어들어 site.data로 사용) | ├── navigation.yml                      # 상단 메뉴바를 커스터마이징하기 위한 파일 | └── ui-text.yml                         # 언어별로 어떤 텍스트로 표시되는지 나열하는 파일 | ├── _site                                 # 재사용되는 html 파일을 저장하는 디렉터리 (공통된 컴포넌트들 보관) | ├── search                              # 검색 엔진을 커스터마이징한 내용을 저장하는 디렉터리 | ├── analytics-providers | └── custom.html                         # 분석 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일 | ├── comments-providers | └── custom.html                         # 댓글 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일 | ├── head | └── custom.html                         # head를 커스터마이징한 내용을 저장하는 파일 | ├── footer | └── custom.html                         # footer를 커스마이징한 내용을 저장하는 파일 | ├── nav_list                            # 메뉴 상단바의 리스트에 대한 helper 파일 | ├── archive-single.html                 # 아카이브 문서에서 단일 문서를 표현하는 방법을 저장하는 파일 | ├── author-profiles.html                # author profile link애 대한 내용을 저장하는 파일 | ├── author-profile-custom-links.html    # author profile link를 커스마이징한 내용을 저장하는 파일 | ├── breadcrumbs.html                    # breadcrumbs에 대한 내용을 저장하는 파일 | ├── single-page | ├── page__taxonomy.html                 # 단일 문서에서 태그와 카테고리를 표현하는 방법을 저장하는 파일 | ├── tag-list.html                       # 단일 문서에서 태그 리스트를 표현하는 방법을 저장하는 파일 | └── category-list.html                  # 단일 문서에서 카테고리 리스트를 표현하는 방법을 저장하는 파일 ├── _posts                                # 블로그에 포스트한 md 파일을 저장하는 디렉터리 ├── _includes ├── _layouts                              # 각 문서의 디자인과 직접적으로 연결된 전체적인 레이아웃 디렉토리 ├── _sass                                 # minimal-mistakes.scss에 임포트할 수 있는 scss 파일을 저장하는 스타일시트 디렉터리 ├── assets                                # css, js, 이미지 파일을 저장하는 디렉터리 | ├── _css | ├── _images | └── _js  ├── _config.yml                           # 블로그를 구성하기 위한 기본적인 설정값을 설정하는 yml 파일 ├── Gemfile                               # 사용할 gem 플러그인 목록 ├── index.html                            # 블로그 처음 홈 페이지 └── package.json   3. 블로그 포스트 작성 및 머릿말 작성  _posts 폴더에 XXXX(YEAR)-XX(MONTH)-XX(DAY)-(NAME).md을 생성해보자. 이때 YEAR, MONTH, DAY는 포스트가 작성된 연도, 월, 일이 되고 NAME은 포스트의 경로가 된다. 그리고 파일 상단에 위치할 머릿말을 작성하기 위해 아래와 같이 ---에 둘러싸인 내용을 작성해보자.   --- title: \"[Blog] macOS에서 Minimal Mistakes로 깃허브 블로그 만들기\"  categories:     - Github.io  tag:     [HTML, JavaScript, SCSS, Ruby]  toc: true toc_sticky: true  date: 2022-09-26 lastmod: 2022-09-26 ---                              양식 이름             양식 설명                                         title             포스트 제목                               categories             포스트 카테고리                               tags             포스트 태그                               toc             우측 상단의 목차                               toc_label             목차 이름                               toc_icon             목차 아이콘                               toc_sticky             목차 고정 여부                               date             포스트 작성일                               lastmod             포스트 수정일                               author_profile             프로필 창 표시 여부                 우리가 글을 작성하는 데에 사용할 Markdown은 텍스트 기반의 마크업 (MarkUp) 언어로, 특수기호와 문자를 활용한 매우 간단한 구조의 문법을 사용해 보다 빠르게 컨텐츠를 작성할 수 있다! Github의 README.md가 대표적인 예시인데, Github Pages 역시 이를 활용해 문서를 작성하는 데에 사용한다. 마크다운 문법은 여기서 상세히 설명하고 있으니 참고하자.   4. 블로그 포스트 내에 문자 박스 양식 넣어보기  추가로 minimal-mistakes theme의 css로 설정된 스타일 요소를 class로 불러와 적용할 수 있는데, 그중 하나인 상자 양식을 활용해보자. Markdown (.md) 파일이니까 html 태그들을 쓰면 그대로 화면에 표현할 수 있다.   &lt;p class=\"notice--primary\"&gt;   &lt;strong&gt;     이 항목은 현재 작성중입니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다. &lt;/p&gt;  &lt;p class=\"notice--info\"&gt;   &lt;strong&gt;     이 항목은 macOS 기반으로 작성되었습니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다. &lt;/p&gt;  &lt;p class=\"notice--danger\"&gt;   &lt;strong&gt;     이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다. &lt;/p&gt;  &lt;p class=\"notice--warning\"&gt;   &lt;strong&gt;     이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.   &lt;/strong&gt;&lt;br&gt;     &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다. &lt;/p&gt;                  이 항목은 현재 작성중입니다.             &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.                    이 항목은 macOS 기반으로 작성되었습니다.             &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.                    이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.             &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.                    이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.             &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.          Reference         Jekyll 디렉토리 구조 (번역)     ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog5/",
        "teaser": null
      },{
        "title": "[Github Pages] 6. Github Pages 블로그 기능 추가",
        "excerpt":"   이 게시물은 Github Pages 블로그, 혹은 Minimal Mistakes 테마에 없는 기능들을 추가해나간 기록들이다. html이나 css를 다룰 줄 알면 금방 할 수 있는, 혹은 다 구글링하면 나오는 내용들이긴 하지만 내가 어떻게 문제를 인식하여 어떤 과정을 거쳐 이를 해결하였는지, 에 대해 자세히 쓰고 싶었다. 그래서 이 게시물은 다른 게시물들과 달리, 내가 블로그에서 부족하다고 느낀 점들을 계속 조금씩이라도 보충해나갈 계획이다.    1. 블로그 댓글 (feat. disqus, giscus)  앞서 서술한 게시물을 보면 Github Pages는 정적 웹 사이트 호스팅 서비스라는 말이 있다. 모든 웹 페이지를 미리 생성하고, 방문자로부터 요청이 들어오면 미리 만든 웹 페이지를 그대로 응답한다는 건데, 사용자와 동적으로 정보를 주고받아야 하는 댓글 등의 기능은 불가능하다는 것이다.    그래서 처음에는 댓글 플랫폼인 disqus를 통해 이를 해결하고자 하였다. 방법은 간단한데, 사이트에 가입하고 무료 플랜을 구독한 다음에 _config.yml를 다음과 같이 수정해주기만 하면 된다.   comments:   provider               : \"disqus\" # 댓글 제공자 지정   disqus:     shortname            :          # disqus ID 지정   그런데 disqus에서 제공하는 기능인 ‘SNS로 댓글 달기’은 개발자 친화적인 기능은 아니였고, 또 나중에는 광고가 노출되기 시작했다. 그래서 대안으로 찾은 게 giscus인데, GitHub Discussions로 작동하고, 마크다운도 지원하면서 대댓글이나 반응과 같은 자잘한 기능들이 마음에 들었다.      적용하는 방법도 Github 앱을 저장소에 설치한 뒤에 html 파일에 아래의 스크립트를 넣어주기만 하면 되는데, 나 같은 경우에는 Minimal Mistakes 테마에서 _includes/social_share.html 파일에 해당 구문을 넣어 적용시켰다.   &lt;section class=\"page__share\"&gt;   &lt;script src=\"https://giscus.app/client.js\"     data-repo=\"pocj8ur4in/pocj8ur4in.github.io\"     data-repo-id=\"R_kgDOICGarA\"     data-category=\"Q&amp;A\"     data-category-id=\"DIC_kwDOICGarM4CZ65L\"     data-mapping=\"pathname\"     data-strict=\"1\"     data-reactions-enabled=\"0\"     data-emit-metadata=\"1\"     data-input-position=\"top\"     data-theme=\"dark_dimmed\"     data-lang=\"ko\"     data-loading=\"lazy\"     crossorigin=\"anonymous\"     async&gt;   &lt;/script&gt; &lt;/section&gt;   2. 블로그 Google 검색 노출 및 검색 설정  아무래도 블로그를 운영하다 보면 다른 사람들의 반응이 궁금할 때가 많은데, 아무것도 설정하지 않은 블로그는 검색되지 않는다는 사실을 깨닫고 해결책을 찾아보았다. Google Search Console에서 내 도메인을 입력한 다음에 소유권 확인을 위해 다운받은 .HTML파일을 root에 위치시키만 하면 며칠 안으로 아래와 같이 적용된다.      추가로 블로그 포스트들이 검색 엔진에 검색되는 것을 가능하도록 진행할 작업들이 있는데, 먼저 _config.yml 파일에서 아래 설정들을 true로 설정한다.   search                   : # 블로그 검색 여부 지정 search_full_content      : # 블로그의 내용 검색 여부 지정   그리고 웹 크롤링을 위해 sitemap.yml과 robots.txt 파일을 생성해 root에 위치시키면 된다.   # 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용 User-agent: * Allow: /  # 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 차단 User-agent: * Disallow: /  # 구글 검색 로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용 User-agent: Googlebot Disallow: /  # 네이버 검색로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용 User-agent: Yeti Disallow: /  Sitemap: https://pocj8ur4in.github.io/sitemap.xml   만약에 블로그의 방문자 수 통계를 보고 싶다면, Google Analytics를 가입한 후 애널리틱스 데이터 스트림을 설정하면 된다. 이때, 측정 ID를 복사한 후 _config.yml 파일을 다음과 같이 수정하면 된다.   # Analytics analytics:   provider               : \"google-gtag\"   google:     tracking_id          : \"(측정 ID)\"   ","categories": [],
        "tags": ["Github Pages"],
        "url": "/blog6/",
        "teaser": null
      },{
        "title": "[Docker] 2. Docker",
        "excerpt":"도커 (Docker) : 컨테이너 기반 가상화 (Container-based Virtualization)      Q. 도커를 쓰는 이유? : 비교적 효율적인 가상화 방식 + 통일된 개발 환경 + 배포의 동시성     Virtualization : 응용 프로그램 실행 시 운영체제 수준 가상화 방식이 성능 손실이 더 적고 빠르게 동작한다.   Development : 운영체제에 상관없이 같은 환경에서 개발할 수 있게 해준다.   Deployment : 서비스 환경과 응용 프로그램을 같이 배포할 수 있게 한다.           분산 어플리케이션을 클라우드 환경으로 이주한다고 가정하면,                IaaS : 서비스로서의 인프라                        어플리케이션을 구성하는 각 컴포넌트가 모두 가상 머신에서 독립적으로 동작             이주 과정은 쉽지만, 가상 머신의 성능을 모두 활용하지 못하며 운영비가 비쌈                             PaaS : 서비스로서의 플랫폼                        어플리케이션을 구성하는 각 컴포넌트가 클라우드 서비스 제공자의 매니지드 서비스에 종속             운영비가 저렴하고 관리가 쉬우나, 이주 과정이 복잡함                                       … 도커를 활용한다면? : 각 컴포넌트를 컨테이너로 이주하고, 쿠버네티스 등으로 전체 어플리케이션 관리 가능       공식 홈페이지에서 .dmg 파일을 다운로드 후 설치   터미널 창에 다음 명령어를 입력해 도커가 정상적으로 설치되었는지 확인   docker version // 현재 도커의 버전 확인  Client:  Cloud integration: ~  Version:           ~  API version:       ~  Go version:        ~  Server: ~  Engine:   Version:          ~   API version:      ~   Go version:       ~     Q. 클라이언트와 서버의 버전 정보가 따로 구성되어 있는 이유?         도커가 클라이언트와 서버의 역할을 각각 수행할 수 있음                리눅스 터미널에 도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 출력                  도커 컴포넌트 (Docker Component) : 도커 엔진을 중심으로 여러 컴포넌트를 조합해 구성           도커 엔진 (Docker Engine) : 도커 이미지를 생성하고 컨테이너를 관리             로컬 이미지 캐시 담당 : 새로운 이미지가 필요할 때 이미지를 다운로드하거나, 기존 이미지를 사용       Docker API을 통해 맡은 기능 수행 → 도커 명령행 인터페이스 (Docker CLI)에서 도커 API 호출                도커 레지스트리 (Docker REgistry) : 도커 이미지를 공개하고 공유             Docker 공식 레지스트리 서비스로 Docker Hub가 있음       클라우드 사업자 또한 AWS ECR, GCP Artifact Registry 등의 컨테이너 레지스트리 제공                도커 컴포즈 (Docker Compose) : 여러 컨테이너를 하나의 서비스로 정의해 컨테이너의 묶음으로 관리             여러 개의 컨테이너 구성 정보를 코드로 정의한 파일을 읽어 컨테이너를 순차적으로 생성                도커 머신 (Docker Machine) : 가상 호스트에 도커 엔진을 설치하여 호스트를 관리             여러 운영체제나 클라우드 환경에서 도커를 동일하게 실행하기 위해 도커의 실행 환경을 자동으로 생성                도커 스왐 (Docker Swarm) : 여러 도커 호스트를 클러스터화해 관리             Manger가 클러스트를 관리하거나 API를 제공하고, Node가 컨테이너를 실행           도커 명령어 (Docker Command) : docker &lt;command&gt; 형식으로 구성     리눅스 터미널에 도커 명령어를 입력하면 도커 서버에서 이에 해당되는 작업 수행   항상 root 권한으로 실행되기에 $ sudo를 앞에 붙어야 함   sudo usermod -aG docker $USER # 현재 사용자를 docker 그룹에 추가                                               docker 명령어                 명령어 형식                 명령어 설명                                                             docker search                 $ docker search [이미지]                 도커 허브에서 이미지 검색                                           docker pull                 $ docker pull [사용자명/] 이미지 [:태그]                 도커 허브에서 이미지 다운로드 사용자명을 지정해 도커 허브에서 해당 사용자가 올린 이미지을 다운로드 태그로 버전을 지정해 다운로드 (latest : 최신 버전)                                           docker images                 $ docker images                 사용 가능한 모든 이미지 목록 확인                                           docker rmi                 $ docker rmi 이미지 [:태그]                 다운로드한 이미지 삭제 태그로 버전을 지정해 다운로드 (latest : 최신 버전)                                           docker run                 $ docker run [옵션] [실행할 이미지]                 이미지를 컨테이너로 생성한 뒤 컨테이너 실행 입력받은 이미지가 현재 없다면, 해당 이미지를 도커 허브에서 다운로드 실행할 파일을 지정해 직접 실행 가능 (여기서 빠져나오면 컨테이너가 정지)                                             docker run 옵션                 옵션 설명                                                             -d                 백그라운드 모드 (detached mode)                                           -p [호스트 포트:컨테이너 포트]                 호스트와 컨테이너의 포트를 연결 (port forwarding) http://호스트 IP:호스트 포트로 컨테이너의 포트 접속                                           -v [호스트의 디렉터리]                 호스트의 디렉터리를 컨테이너의 디렉터리에 연결 (mount)                                           -e [환경변수]                 컨테이너 내에서 사용할 환경변수 설정 (environment variable)                                           --name [컨테이너 이름]                 컨테이너 이름 설정 (container name)                                           -rm                 프로세스 종료 시 컨테이너 자동으로 제거 (remove container)                                           -link [컨테이너 이름:주소]                 컨테이너와 컨테이너 연결 (link container) [주소:포트번호]로 컨테이너에 접속                                           -it                 리눅스 터미널 입력을 위한 옵션 (interactive / Pseudo-tty)                                                                      docker ps               $ docker ps [옵션]               실행중인 모든 컨테이너 목록 확인 -a 옵션으로 정지된 컨테이너까지 모두 검색                                         docker start               $ docker start [컨테이너 이름 | 컨테이너 ID]               정지된 컨테이너 재시작                                         docker stop               $ docker exec [컨테이너 이름 | 컨테이너 ID]               실행 중인 컨테이너 정지                                         docker attach               $ docker attach [컨테이너 이름 | 컨테이너 ID]               실행 중인 컨테이너에 접속                                         docker exec               $ docker exec [컨테이너 이름 | 컨테이너 ID] [명령] [매개 변수]               컨테이너 외부에서 컨테이너 내의 명령 실행                                         docker diff               $ docker diff [컨테이너 이름 | 컨테이너 ID]               컨테이너가 실행되면서 변경된 파일 목록 확인 A : 추가된 파일 C : 변경된 파일 D : 삭제된 파일                                         docker cp               $ docker cp [컨테이너 이름 | 컨테이너 ID] [:컨테이너 경로] [호스트 경로]               컨테이너의 파일을 호스트의 디렉토리로 복사                                         docker attach               $ docker attach [컨테이너 이름 | 컨테이너 ID]               실행 중인 컨테이너에 접속                                         docker rm               $ docker exec [컨테이너 이름 | 컨테이너 ID]               생성된 컨테이너 삭제                                         docker commit               $ docker commit [옵션] [컨테이너 이름 | 컨테이너 ID] [이미지 이름] [:태그]               컨테이너를 이미지 파일로 생성                                         docker build               $ docker build [옵션] [도커 파일 경로] [--tag 이미지 이름 : 이미지 태그]                도커 파일에 설정된 내용대로 도커 이미지 생성 --tag 뒤에 이미지 이름와 이미지 태그를 설정할 수 있음                                         docker history               $ docker history [이미지 이름 | 이미지 ID] [:태그]               도커 파일에 설정된 내용대로 이미지 히스토리 생성                                         docker inspect               $ docker inspect [이미지나 컨테이너 이름 | 이미지나 컨테이너 ID]               이미지나 컨테이너의 세부 정보 출력                              ","categories": [],
        "tags": ["Docker"],
        "url": "/docker2/",
        "teaser": null
      },{
        "title": "[Docker] 3. Docker Container",
        "excerpt":"도커 컨테이너 (Docker Container) : 도커에서 제공하는 컨테이너 기술      해당 부분에서 이어지는 내용입니다. 이전 내용에서는 가상화의 한 종류인 컨테이너 기술에 대해 서술하였다면, 이번에는 도커를 중심으로 하여 컨테이너에 대해 다뤄보겠습니다.    도커 컨테이너는 도커가 관리하는 독립적인 가상 리소스를 가진다.     컨테이너 안에는 어플리케이션과 그 어플리케이션의 실행 환경 (호스트명, IP 주소, 디스크 드라이브 등)이 들어있음            각 컨테이너는 독립적인 환경을 가지되, 실행되는 컴퓨터의 CPU, 메모리, 운영체제를 공유함                    격리 (isolation)와 밀집 (density)의 조건을 동시에 충족           빌드 - 공유 - 실행의 workflow으로 소프트웨어 배포를 단순화하기에 적합                                 컨테이너 내부 어플리케이션이 실행중이여야 컨테이너의 상태도 실행 중이 된다.            컨테이너가 Existed인 상태에서는 CPU 자원이나 메모리를 사용하지 않는다.           컨테이너가 종료되어도, 컨테이너는 사라지지 않고 그대로 남아있다.            나중에 다시 컨테이너를 실행하거나, 내부 파일이나 로그를 확인해볼 수 있다.       컨테이너를 백그라운드에서 계속 동작하도록 하려면, -d (--detach)           컨테이너는 기본적으로 외부 환경에 노출되지 않는다.            도커는 호스트 컴퓨터의 네트워크 계층에 끼어들어 네트워크 트래픽 중 필요한 것을 컨테이너에 전달       컨테이너의 포트를 호스트 컴퓨터에 공개하려면, --publish                    도커가 호스트 컴퓨터를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너에 전달                           도커 컨테이너 또한 별도의 환경 변수 (Environment variable)를 가질 수 있다.     호스트 운영체제의 것을 가져오는 것이 아닌, IP 주소나 호스트 이름처럼 도커로부터 부여받음   도커 이미지 (Docker Image) : 컨테이너의 실행에 필요한 모든 파일과 설정값 정보를 포함     상태값을 가지지 않음 (변하지 않는 값들을 저장) ↔ 컨테이너 : 이미지가 실행된 살태 (변하는 값들을 저장)   이미지 레이어 : 도커 이미지는 여러 Read-Only 레이어로 구성되고, 파일 추가 및 생성 시 새로운 레이어 생성            이미지 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일로, 여러 이미지와 컨테이너에서 공유함       유니온 파일 시스템 (Union File Systems)읕 통해 여러 개의 레이어를 하나의 파일 시스템으로 활용                   docker image ls에서 도커 이미지의 SIZE는 논리적 용량이지 실제로 차지하는 디스크 용량이 아니다!                 docker system df를 통해 이미지 전체 용량의 총합을 볼 수 있다.              컨테이너 레이어 : 컨테이너가 실행되면 이미지 레이어 위에 읽기-쓰기 (Read-Write) 레이어를 추가            컨테이너를 실행하면서 생성되거나 변경된 내용을 저장           이미지 경로 : URL 방식으로 관리 -&gt; 뒤에 태그 (/tag)를 붙임   Q. 도커 이미지를 쓰는 이유? : 도커 이미지와 도커 컨테이너들을 클래스나 인스턴스처럼 활용한다.     도커는 해시 값 (= 컨테이너 ID)과 임의의 이름 (= 컨테이너 이름)를 통해 컨테이너를 구분하고 이들을 환경변수로 관리    운영자가 지금까지 운영한 서버를 도커 이미지로 배포하고 도커 컨테이너에 설치한다면,    도커 파일 : 지금까지 서버를 운영한 기록   도커 이미지 (도커 파일 + 실행 시점) : 지금부터 설치된 서버가 가질 초기값   도커 컨테이너 (도커 파일 + 환경 변수) : 지금부터 설치된 서버가 운영될 장소      도커 안에서는 서버 역시 하나의 소프트웨어처럼 사용할 수 있고, 생성할 수 있는 컨테이너의 개수에도 제한이 없다.   도커 레지스트리 (Docker Registry) : 도커 이미지를 저장하고 관리하는 중앙 저장소      도커 플랫폼은 소프트웨어 배포 기능을 자체적으로 내장하고 있음            로컬에 이미지가 없더라도 도커가 서버에서 자동으로 이미지를 내려받음           도커 허브 (Docker Hub) : 도커 엔진에 기본으로 설정된 도커 레지스트리      도커 허브 계정을 생성한 후, 터미널을 통해 도커 허브에 접속   docker login --username pocj8ur4in Password: ***** Login Succeeded      도커 이미지의 다운로드를 위한 이미지 참조 (Image Reference)는 네 개의 요소로 구성            이미지가 저장된 레지스트리 도메인 (기본값은 도커 허브)       이미지 작성자 계정 ID       이미지 레포지토리 ID       이미지 태그 (기본값은 latest)           docker.io/diamol/golang:latest      이미지에 새로운 이미지 참조를 부여하여, 한 이미지에 여러 개의 참조를 갖게 할 수도 있음   docker image tag new-tag pocj8ur4in/vw-api:latest   사설 도커 레지스트리 (Private Docker Registry) : 로컬 혹은 원격 환경에 레지스트리를 구축      도커 코어 레지스트리 서버는 docker/distribution에서 개발이 진행되고 있음            도커 허브와 동일한 레이어 캐시 시스템을 통해 이미지를 내려받고 푸시하는 기능 제공       웹 기반 UI 관련 기능은 빠져 있음           ","categories": [],
        "tags": ["Docker"],
        "url": "/docker3/",
        "teaser": null
      },{
        "title": "[Docker] 4. Docker File",
        "excerpt":"도커 파일 (Dockerfile) : 서버 운영 기록을 코드로 저장한 파일을 특정 시점의 도커 이미지로 빌드           눈송이 서버 (Snowflakes Server) : 각 서버마다 운영 기록이 달라 서로 모양이 다른 서버들이 공존하는 상황       … 서버 간의 운영체제, 컴파일러, 설치된 패키지 등의 차이로 발생하는 문제 개선을 위해 서버 운영 기록을 저장하자!    도커 파일을 생성하는 과정은 테스트 주도 개발의 순환에 부합하다고 볼 수 있다.     테스트 주도 개발 (Test Driven Development) : 선 테스트 후 개발 사이클을 반복하는 개발 방법론       테스트를 작성한다. → 도커 파일을 만든다.   테스트에 실패하고 코드를 수정한다. → 도커 이미지의 빌드에 실패하고 도커 파일을 수정한다.   테스트에 성공한다면, 코드를 리펙터링한다. → 도커 이미지의 빌드에 성공한다면, 도커 파일의 내용을 리펙터링한다.   처음으로 되돌아간다.    DSL (Domain-Specific Language) : 도커 파일을 작성할 때 쓰는 언어 (도커 이미지의 생성 과정 표현)     생성 과정을 표현? : 도커 파일은 일련의 인스트럭션을 실행된 결과로 도커 이미지를 생성한다.         도커 파일의 인스트럭션과 이미지 레이어는 1:1의 관계를 가진다.                FROM : 다른 컨테이너 이미지를 빌드의 시작점으로 지정             AS: 컨테이너에 이름을 붙일 수 있음                ENV : 컨테이너 내에서 사용될 환경 변수를 지정            WORKDIR : 컨테이너 이미지의 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정            COPY : 로컬의 파일 시스템 내 파일, 디렉터리를 컨테이너 이미지로 복사             --from= : 해당 파일이 호스트 컴퓨터가 아닌 다른 컨테이너의 파일임을 알려줌                CMD : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정            RUN : 빌드 과정에서 컨테이너 안에서 명령을 실행한 다음에 그 결과를 이미지 레이어에 저장       Q. 도커 파일을 쓰는 이유?   A1. 동일한 환경에서 어플리케이션을 실행 가능하게 한다.     모든 빌드 과정은 도커 컨테이너 내부에서 이루어지며, 각 컨테이너는 모든 도구를 정확한 버전으로 갖추고 있다.            신규 개발자의 적응 기간, 빌드 서버의 관리 부담, 개발자 간의 도구 버전의 차이로 인한 빌드 실패를 줄일 수 있다.           A2. 멀티 스테이지 환경에서 각 단계는 자신만의 캐시를 가져 성능을 향상시킬 수 있다.     도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.            만약 해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당하는 단계 안으로 국한된다.       이어지는 다음 단계는 캐시를 재사용하면서 시작되므로, 캐시 재사용을 통해 빌드 단계에서 시간 절약이 가능하다.           A3. 멀티 스테이지 스크립트를 통해 최종 산출물의 크기를 가능한 한 작게 유지할 수 있다.     최종 산출물인 도커 이미지에 불필요한 도구를 제외하여 어플리케이션의 의존 모듈 자체를 줄일 수 있다.  ","categories": [],
        "tags": ["Docker"],
        "url": "/docker4/",
        "teaser": null
      },{
        "title": "[JPA] 1. JPA",
        "excerpt":"개발자가 SQL을 직접 다룰 때의 문제           DB는 객체 구조와는 다른 데이터 중심의 구조를 가져 객체를 DB에서 직접 저장하거나 조회할 수 없음             개발자가 객체지향 어플리케이션과 DB 중간에서 SQL과 JDBC API를 이용해 변환해야 함       객체를 DB에 CRUD하기 위해서 너무 많은 SQL과 JDBC API를 코드로 작성해야 함                DAO를 이용해 SQL를 은닉해도 결국엔 SQL에 의존적인 개발이 될 수 밖에 없음             개발자가 엔티티를 신뢰하고 사용할 수 없음… 이게 진정한 계층 분할?              그럼, JPA는 어떻게 문제를 해결하였는가?          객체를 DB에 저장하고 관리할 때 JPA가 제공하는 API 사용                저장 → persist() : 객체를 DB에 저장하면, INSERT SQL를 생성해서 DB에 전달         조회 → find() : 객체 하나를 DB에서 조회하면, SELECT SQL를 생성해서 DB에 전달         수정 → 객체를 조회해 값을 변경하면, 트랜잭션을 커밋할 때 UPDATE SQL를 생성해 DB에 전달         연관 객체 조회 → 연관된 객체를 사용하는 시점에 SELECT SQL를 실행                  객체와 관계형 데이터베이스의 패러다임 불일치     객체지향 프로그래밍 : 추상화, 캡슙화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치 제공   비즈니스 요구사항을 정의한 도메인 모델 또한 객체로 모델링 → 객체와 관계형 데이터베이스는 지향하는 바가 다르다!           상속 : 객체는 상속이라는 기능을 가지지만, 테이블은 상속이라는 기능이 없음             데이터베이스 모델링의 슈퍼타입-서브타입 관계를 이용한다고 해도, 매번 2가지 SQL를 만들어야 함                연관관계 : 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조에 접근해서 조회             그러나 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 이용해서 연관된 테이블을 조회       그럼 객체를 테이블에 맞추어 모델링하면? : 외래 키와 참조의 예 → 객체지향의 장점을 잃어버릴 수 있다!                객체 그래프 탐색 : 객체에서 회원이 소속된 팀을 조회할 때에는 참조를 사용해 연관된 팀을 탐색             그런데 참조를 통해 팀을 탐색할 수 있을지 없을지 알 수 없음 → 너무나 큰 제약사항                    결국 DAO를 통해 SQL을 직접 확인하기 위해 상황에 따른 여러 메소드를 만들어야 함                                비교 : 데이터베이스는 기본 키의 값으로 각 row를 구분하지만, 객체는 동일성 비교, 동등성 비교를 활용             동일성 비교 (==) : 객체 인스턴스의 주소 값을 비교, 동등성 비교 (equals()) : 객체 내부의 값을 비교                    기본 키 값이 같은 객체를 2번 조회했을 때, 이 객체들이 다른 인스턴스면 동등하되 동일하지 않다.                              그럼, JPA는 어떻게 문제를 해결하였는가?          상속 → 자바 컬렉션에 객체를 저장하듯이 JPA에 객채를 저장하면 이를 두 테이블에 나눠 저장     연관관계 → 개발자가 관계를 설정해 객체를 저장하면, 참조를 외래 키로 변환해 INSERT SQL 전달     객체 그래프 탐색 : 실제 객체를 사용하는 시점까지 DB 조회를 미루는 지연 로딩 이용     비교 : 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장      JPA (Java Persistence API) : 자바 진영의 ORM 기술 표준     ORM (Object-Relational Mapping) : 객체와 관계형 DB를 매핑   왜 JPA를 사용해야 하는가?     생산성 : 반복되는 CRUD용 SQL 코드를 작성하는 대신, 자바 컬렉션에 객체를 저장하듯 JPA에 객체를 전달하면 됨   유지보수 : 매번 SQL과 JDBC API 코드를 변경할 필요 없음   패러다임의 불일치 해결 : ORM 프레임워크가 상속, 연관관계, 객체 그래프 탐색, 비교 등의 문제를 대신 해결   성능 : 어플리케이션과 DB 사이에서 동작하면서 다양한 성능 최적화 기회를 제공   데이터 접근 추상화 및 벤더 독립성 : DB 접근 계층을 제공해서 특정 DB 기술에 종속되지 않음      References          자바 ORM 표준 JPA 프로그래밍     ","categories": [],
        "tags": ["JPA"],
        "url": "/jpa1/",
        "teaser": null
      },{
        "title": "[MicroService] 1. MicroService",
        "excerpt":"비즈니스 민첩성 : 자신의 특화된 서비스를 빠르게 제공하고, 피드백을 반영해 서비스를 빠르게 개선      빠른 배포 주기 : 비즈니스 민첩성을 간접적으로 보여주는 지표 → 어떻게 빠른 비즈니스 속도를 가질 수 있을까?   클라우드 인프라 (Cloud Infra)의 등장 : 아마존의 AWS, 구글의 구글 클라우드 플랫폼     비용 측면 : 클라우드의 사용량에 따라 비용을 유연하게 조정할 수 있음 → 사용한 만큼만 비용을 지불   어플리케이션 측면 : 어플리케이션을 여러 개의 블록처럼 관리해 효율성을 극대화            사용량 증가에 따른 성능 및 가용성을 Scale-up, Scale-out → 특정 부분만 탄력성 있게 확장 가능           어떤 서비스가 클라우드 인프라에 적합할까 : 클라우드 프랜들리? 클라우드 네이티브?     클라우드 프렌들리 (Cloud Friendly) : 시스템을 하나의 큰 덩어리로 만들어 클라우드 인프라에 올리는 것   클라우드 네이티브 (Cloud Native) : 시스템을 여러 개의 블록 단위로 나누어 클라우드 인프라에 올리는 것   마이크로서비스 (MicroService) : 여러 서비스 인스턴스가 하나의 비즈니스 어플리케이션 구성     서비스가 갖는 저장소가 각각 다르므로 업무 단위로 모듈 경계가 명확하게 구분            확장하거나 변경할 때에는 특정 기능별로 독립적으로 작업한 뒤에 빌드해서 배포하면 됨       각 서비스가 독립적이기에 서로 다른 언어, 데이터, 기술로도 개발 가능 → 폴리글랏 (Polyglot)              마이크로서비스 이전에는? : 모노리스 (Monolith)         전체 시스템이 하나의 단위로 개발되는 일체식 어플리케이션     일반적으로 클라이언트, 어플리케이션, 데이터베이스의 3-tier 시스템으로 구성     아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 함     단일 프로세스에서 실행되므로, 확장이 필요할 경우에 전체 어플리케이션을 동시에 확장해야 함                로드밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 스케일 아웃                  마이크로서비스를 위한 조건은 무엇인가?           업무 기능 중심 팀             콘웨이 법칙 (Conway’s law) : 시스템을 개발할 때 항상 시스템의 모양이 팀 의사소통 구조를 반영                    마이크로서비스를 만드는 팀은 역할이나 기술이 아닌, 업무 기능을 중심으로 한 팀이 되어야 함                       기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자, 테스터 등 다양한 역할의 인원으로 구성                    서비스를 처음부터 끝까지 만들기 위한 모든 단계의 역할을 갖추고 있음           같은 공간, 같은 시간을 공유하기에 의사소통이 원활하고 빠르게 진행할 수 있음           여러 기능들이 모여 있다는 의미에서 다기능 팀 (Cross-Functional Team)이라고도 부름                                자율적인 분권 거버넌스             각 마이크로서비스 팀은 빠르게 서비스를 만드는 것을 최우선 목적으로 함                    중앙의 강력한 표준이나 절차 준수를 강요받지 않음           스스로 효율적인 방법론과 도구, 기술을 찾아 적용 → 폴리글랏 프로그래밍, 폴리글랏 저장소                                제품 중심의 생명 주기             개발 모델이 프로젝트 단위가 아니라 제품 단위로 구성됨 → 개발 조직과 운영 조직이 결합       소프트웨어를 완성해야 할 기능들의 집합이 아닌, 비즈니스를 제공하는 제품 (Product)로 봄                    우선 빠르게 개발한 뒤에 반응을 보고 개선하는 방식으로 개발           프로젝트 형태의 워터풀 (WaterFall) 개발 방식이 아닌, 제품 중심의 에자일 (Agile) 개발 방식 채용           2~3주 단위의 스프린트 (Sprint)를 통해 소프트웨어에 피드백을 즉각적으로 반영                                CI/CD 파이프라인의 자동화             개발과 운영을 동시에 수행하는 데비옵스 (DevOps)를 궁극적으로 가능하게 함       각각의 CI/CD 파이프라인 프로세스는 CI/CD 파이프라인 도구를 통해 자동화가 이루어짐                    ‘Infrastructure as Code’ : 코드를 이용해 인프라 구성부터 어플리케이션 빌드 및 배포를 정의                                분권 데이터 관리             폴리글랏 저장소 (Polyglot Persistence) 접근법 : 서비스별로 데이터베이스를 갖도록 설계                    각각의 저장소가 서비스별로 분산되어 있으며, 다른 서비스에 API를 통해 접근함                       결과적 일관성 (Eventual Consistency) : 일시적으로 다른 두 서비스의 데이터가 결국엔 동일해짐                    여러 트랜잭션을 하나로 묶지 않고, 별도의 로컬 트랙잭션을 수행           각 저장소 내 데이터의 비즈니스 정합성을 위해 데이터 일관성이 다른 부분을 보상 트랙잭션으로 맞춤                                내결함성을 고려한 설계             내결함성 (Fault Tolerance) : 시스템은 언제든 실패할 수 있는 가능성이 존재한다.                    시스템이 실패해서 더는 진행할 수 없을 때에도, 자연스럽게 대응할 수 있도록 설계하여야 함                       다양한 실패에 대비해 완벽히 테스트할 수 있는 환경을 마련해야 함       시스템의 실패를 감지하고 대응하기 위한 실시간 모니터링 체계 또한 갖춰야 함       장애를 일부러 발생시키는 카오스 몽키 (Chaos Monkey)를 만들어 아키텍처 동작을 점검하기도 함              Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice1/",
        "teaser": null
      },{
        "title": "[MicroService] 2. MSA",
        "excerpt":"마이크로서비스 아키텍처 (MSA) : 마이크로서비스를 접목한 아키텍처 구조      클라우드 인프라와 접목해 아마존, 넷플릭스에 의해 구체화 → 비즈니스 성공 사례   각 서비스는 개별 프로세스에서 실행되며, HTTP API를 통해 통신   각 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용해 독립적으로 배포      마이크로서비스 아키텍처 (MSA)와 서비스 지향 아키텍처 (SOA)의 비교         SOA : 컴포넌트를 모아 비즈니스적으로 의미있고 완결적인 서비스 단위로 모듈화                SOA와 MSA의 공통점 : 비즈니스 서비스의 집합으로 시스템을 개발         SOA와 MSA의 차이점 : 이론적인 SOA와 달리, MSA는 클라우드 인프라와 접목해 구체화                     MSA 내부 아키텍처 : API, 비즈니스 로직, 이벤트 발행, 데이터 처리의 구조화 등 MSA 내부 구조를 정의한 것   MSA 외부 아키텍처 : 인프라, 플랫폼, 어플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것   리액티브 선언 (The Reactive Manifesto) : 어플리케이션이 요청에 즉각 응답하고 가동되길 기대     응답성 (Responsive) : 사용자에게 신뢰성 있는 응답을 빠르고 적절히 제공하는 능력   탄력성 (Resilient) : 장애가 발생하더라도 시스템 전체에 영향을 주지 않고 복구하는 능력   유연성 (Elastic) : 사용량에 변화가 있더라도 그에 비례해 자원을 조절해 균일한 응답성을 제공하는 능력   메시지 기반 (Message Driven) : 비동기 메시지로 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향   → 4가지 요건을 만족하는 시스템을, 급변하는 상황을 적응할 수 있는 리엑티브 시스템 (Reactive System)이라 정의   강결합에서 약결합의 아키텍처로의 변화     소프트웨어 아키텍처 : 소프트웨어를 구성하는 요소와 그 구성 요소 간의 관계를 정의한 것            아키텍처를 정의하는 과정 : 시스템 구축을 위한 여러 비기능 요건들을 만족하는 해결 방법을 찾는 과정                    비기능 요건 : 시스템 성능, 시스템 가용성, 보안, 유지보수성, 확장성 등                       마이크로서비스 아키텍처는 ‘클라우드’라는 가상화된 인프라를 활용한 것이므로, 이를 고려해 설계해야 함           아키텍처 유연성 (Architecture Flexibility) : 시스템 자체가 변화 및 확장에 언제든지 대응할 수 있는 능력            시스템을 구성하는 구성 요소 간의 관계들이 느슨하게 결합되어 언제든지 대체되거나 확장될 수 있음       리액티브 시스템이 리액티브하기 위해서 반드시 갖춰야 할 특성 중 하나       클라우드 인프라 자체가 유연성과 확장성을 갖추므로, 어플리케이션 아키텍처 또한 아키텍처 유연성이 필요                과거 : 아키텍처 구성 요소들이 특정 벤더의 제품에 전적으로 의존            유명한 제품군을 사용함으로 품질이 보장될 수 있음       특정 기술에 락인 (lock-in)되어 시스템을 쉽게 변경하거나 확장하기 어려움           현재 : 클라우드 환경 아래에서 사용하는 오픈 소스 기반 제품들이 충분한 기능, 품질, 호환성을 제공            아키텍처 설계가 필요한 레이어에서 적절한 솔루션을 선택하고 이를 조합하는 개방적 방식으로 변화       클라우드 기반 어플리케이션의 구축에 필요한 인프라 및 어플리케이션 영역에 다양한 제품들이 등장           MSA 패턴 : MSA의 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 스타일 혹은 패턴     인프라 구성 요소 : 마이크로서비스를 지탱하는 인프라스트럭처를 구축하는 데에 필요한 구성 요소   플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴   어플리케이션 패턴 : 마이크로서비스 어플리케이션을 구성하는 데에 필요한 패턴   인프라 구성 요소를 서비스 유형별로 나누어 해당되는 제품 중 하나를 의사결정 → 클라우드 인프라     IaaS (Infrastructure as a Service) : 가상 머신, 스트리지, 네트워크 등 인프라 제공            고객이 관리할 수 있는 범위가 가장 넓은 클라우드 컴퓨팅 서비스       AWS 등 퍼플릭 클라우드 공급 업체 (CSP)가 준비한 환경을 고객이 선택할 수 있음       가상화된 물리적 자원을 UI 형태의 대시보드 혹은 API 형태로 제공       고객은 서버와 스트리지에 접근할 수 있지만, 클라우드 내 가상 데이터 센터를 통해 리소스를 전달받는 형태       개발자는 운영체제와 어플리케이션을 직접 관리해야 함 : 개발자와 인프라 관리자의 역할이 분담       예시 : AWS EC2, AWS S3           CaaS (Container as a Service) : 업로드, 구성, 실행, 확장, 중지할 수 있는 컨테이너 제공            가상 머신이 아닌 컨테이너를 기본 리소스로 활용해 어플리케이션을 개발, 실행, 관리       컨테이너화된 어플리케이션을 빌드하고 배포하는 개발 환경은 퍼플릭 클라우드 공급 업체 (CSP)가 제공       예시 : Kubernetes Service, AWS ECS           PaaS (Platform as a Service) : 어플리케이션에 미들웨어, 런타임까지 탑재한 플랫폼을 제공            가상화된 클라우드 위에 원하는 서비스를 개발할 수 있도록 개발 환경을 미리 구축해 서비스 형태로 제공       고객은 개발 환경을 고려할 필요 없이 어플리케이션 자체에 집중할 수 있음       어플리케이션이 플랫폼에 종속되어 개발되므로, 다른 플랫폼으로의 이식이 어려울 수도 있음       예시 : Lambda, AWS Elastic Beanstalk           시스템의 기반이 되는 인프라 레이어의 구축 → 베어메탈 장비 혹은 가상 인프라 환경을 통한 구축     가상 인프라 환경 : 하이퍼바이저 (Hypervisor)의 사용 여부 및 게스트 OS 유무에 따라 나뉨            가상 머신 (Virtual Machine) : 하이퍼바이저를 통해 하나의 시스템에서 여러 운영체제를 사용                    운영체제 패치 및 관련 라이브러리 설치로 인한 오버헤드가 지속적으로 발생                       컨테이너 (Container) : 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성                    도커 (Docker) : 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 제어                            이식성 : 도커만 실행할 수 있으면 호스트 커널에 상관없이 동일하게 사용               신속성 : 크기가 작고 가벼워 빠른 배포가 가능 + 문제 발생 시 다시 가동하면 됨               재사용성 : 동일한 환경을 재사용해 쉽게 설정 가능 → 서버 환경 구축이 쉬워짐                                               컨테이너 오케스트레이션 (Container Orchestration) : 컨테이너 관리 기술                    컨테이너 배치 및 복제, 확장 및 축소, 장애 복구 컨테이너 간 통신, 로드밸런싱 등           쿠버네티스 (Kubernetes) : Pod, Deployment, Replica Sets 정보 확인 가능                            각 컨테이너가 요구하는 자원을 쿠버네티스에 요청하면 노드에 맞춰 자동 배치               컨테이너 이상을 점검해, 실패하면 컨테이너를 자동으로 교체하고 리스케줄링               일정량의 CPU 및 메모리 사용량을 초과하면 자동으로 수평 확장                                                   마이크로서비스의 운영과 관리를 지원할 클라우드 플랫폼 (미들웨어)의 구축 → 플랫폼 패턴     데비옵스 (DevOps) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화            소프트웨어를 빠르게 개발하게끔 지원하는 빌드, 테스트, 배포를 위한 자동화 환경       지속적 제공 (CI) : 빌드된 소스 코드의 실행 파일을 실행 환경에 반영하기 전에 진행       지속적 배포 (CD) : 저장소에 빌드한 소스 코드의 실행 파일을 실행 환경까지 자동으로 배포              자동 빌드 및 배포 절차         매일 자신이 작성한 소스 코드와 이를 테스트할 테스트 코드를 형상관리 시스템에 보낸다. (Push)     매일 빌드 도구에서 형상관리 서버의 코드를 가져와 (Pull) 통합하고, 자동으로 빌드하고 테스트를 수행한다.     테스트 수행 결과를 리포트에 기록하고, 빌드된 소스 코드를 스테이징 환경에 자동으로 배포한다.     테스터가 스테이징 환경에서 테스트를 수행할 때 혹은 리포트 결과에 문제가 있으면, 소스 코드를 수정한다.         빌드·배포 파이프라인의 설계 : 빌드·배포 과정동안 수행해야 할 업무 (task)를 정의한 것            리포지토리에서 소스 코드를 가져와 빌드해 실행 파일을 만드는 작업       이전 작업이 성공하면, 다음 작업이 자동으로 수행히게끔 위의 작업들을 관리하는 작업       실행할 어플리케이션을 실행 환경에 배포하는 작업           → Infrastructure as Code를 통해 빌드·배포 파이프라인의 절차를 완벽하게 자동화할 수 있음       Infrastructure as Code : 인프라 구성을 프로그래밍하는 것처럼 처리해 많은 컨테이너 배포 처리를 함            형상관리 리포지토리에서 소스 코드를 가져와 빌드하여 실행 파일을 만드는 작업       실행 파일을 실행 환경에서 배포하는 작업       작업들을 통제하고 연결해서 모든 작업이 성공하면 다음 작업이 자동으로 수행되도록 연계하는 작업           마이크로서비스가 실제 구동되는 환경에서 동작될 수 있도록 운영 관리 요소 → 운영 관리 패턴     마이크로서비스의 발전 과정에서 아키텍처의 문제 영역들이 지속적으로 논의되었고, 이에 따른 해결책을 모색해옴            1999년 XP 방법론, 2001년 에자일 선언을 통해 빠른 실패와 피드백을 기반하는 실용적인 실천법 적용       2010년 넷플릭스가 AWS EC2로 인프라를 전환하면서 발생한 문제점들을 해결하기 위한 넷플릭스 OSS 개발                    여러 마이크로서비스 간의 라우팅을 위한 줄 (Zuul)           적절한 부하 분산을 하는 로드밸런싱을 위한 리본 (Ribbon)           모니터링을 위한 히스트릭스 (Hystrix)           서비스 등록을 위한 유레카 (Eureka)                       2013년 마이크로서비스를 쉽게 개발할 수 있는 스프링부트 (SpringBoot) 프레임워크가 발표       2013년 도커, 2014년 쿠버네티스와 같은 컨테이너 기반 기술들이 개발           → 클라우드 환경, 넷플릭스 OSS, 프레임워크, 컨테이너 기반 기술이 아울러져 마이크로서비스 생태계를 계속 발전시킴       스프링 클라우드 : 스프링부트 + 넷플릭스 OSS            스프링 진영에서 기존 스프링 프레임워크에 넷플릭스 OSS들이 더 잘 돌아갈 수 있도록 통합하여 발표              마이크로서비스 서비스와 스프링 클라우드 서비스의 연계 흐름         스프링 클라우드를 포함한 모든 마이크로서비스가 인프라에 종속되지 않도록 DB, 파일 등에 저장된 설정 정보를 형상관리 시스템에 연계된 Config 서비스에서 가져와 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩     로딩과 동시에 ‘서비스 레지스트리’에 자신의 서비스 이름과 클라우드 인프라로부터 할당받은 물리 주소를 매핑     클라이언트가 ‘API 게이트웨이’를 통해 마이크로서비스에 접근하면, …                API 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드밸런싱을 수행         API 게이트웨이’는 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 ‘서비스 레지스트리’ 검색을 통해 서비스의 위치를 가져옴         ’API 게이트웨이’는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 확인하기 위해 ‘권한 서비스’와 연계해 인증 및 인가 처리를 수행                 모든 마이크로서비스 간의 호출 흐름은 ‘모니터링 서비스’와 ‘추적 서비스’에 의해 모니터링되고 추적됨      다양한 서비스의 등록 및 탐색 → 서비스 레지스트리, 서비스 디스커버리 패턴      예시 : 넷플릭스 OSS 유레카 (Eureka), 스프링 유레카 (Spring Eureka), 쿠버네티스 DNS 및 서비스           프런트엔드 클라이언트가 여러 백엔드 마이크로서비스를 어떻게 호출해야 할까?            스케일 아웃을 통해 인스턴스가 여러 개로 복제되었을 때 어떻게 부하를 적절히 분산할 수 있을까?         → 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드밸런싱 기능이 제공되어야 한다!           라우터가 최적 경로를 탐색하려면 서비스 이름에 해당하는 IP 주소를 알아야 함                그런데 이러한 라우팅 정보를 클라이언트가 가진다면, 클라우드 환경에서 동적으로 변경되는 백엔드의 유동 IP 정보를 매번 전송받아 변경해야 함 → 제3의 공간이 필요               → 마이크로서비스의 이름과 유동적인 백엔드의 유동 IP 정보를 보관할 저장소를 제공하자!               각 서비스 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 IP 주소를 레지스트리에 등록   클라이언트가 해당 서비스 이름을 호출할 때, 라우터가 레지스트리 서비스를 검색해 매핑된 IP 주소를 호출   즉, 레지스트리는 모든 마이크로서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소   모든 마이크로서비스가 처음 가동될 때 자신의 위치 정보를 레지스트리에 저장하고, 서비스가 종료될 때 삭제   레지스트리는 Config, 모니터링, 추적과 같이 관리와 운영을 위한 기반 서비스의 주소 또한 함께 보관   서비스 단일 진입 → API 게이트웨이 패턴      예시 : 스프링 클라우드 Spring API Gateway, 쿠버네티스 인그레스 리소스 (Ingress Resources) 및 서비스                  여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하면 호출 관계가 매우 복잡해짐         → 이러한 복잡한 호출 관계를 통제할 수 있는 방법이 필요하다!               API 게이트웨이 (Gateway) : 다양한 클라이언트가 다양한 서비스에 접근하기 위한 단일 진입점            L4 하드웨어 장비나 소프트웨어로 구현된 서비스 흐름 제어를 위한 서비스 라우팅 기능을 수행                    다른 유형의 클라이언트에게 서로 다른 API 조합을 제공할 수 있음           각 서비스에 접근할 때 필요한 인증 및 인가 기능을 한번에 처리할 수 있음           서비스에 문제가 발생해 요청에 대한 응답 지연이 발생할 때 다른 서비스로 요청 경로를 변경할 수 있음                       레지스트리 서비스와 연계하여 여러 인스턴스로 부하를 분산하는 동적 라우팅이나 로드밸런싱이 가능       권한 서비스와 연계하여 인증 및 인가 처리를 수행할 수 있음       로그 집계 서비스와 연계하여 요청 및 응답 데이터 등에 대한 로깅이 가능       에러율, 평균/최고 지연 시간, 호출 빈도와 같이 시간에 따른 환경 변화를 추적할 수 있는 메트릭 (Metric) 데이터를 시계열 형태로 저장할 수 있음       트래킹 ID 추적과 같이 트레이싱 서비스와 연계하여 서비스 추적이 가능       모니터링 서비스와 연계해 장애 격리가 가능 → 서킷 브레이커 패턴           다양한 클라이언트에 대한 특화된 처리 → BFF 패턴      진입점을 하나로 두는 API 게이트웨이와 달리, 프런트엔드의 유형에 따라 각각의 진입점을 둠   프런트엔드를 위한 백엔드라는 의미에서 Backend for Frontend   각 프런트엔드에 대한 처리만 수행하는 BFF 이후에 통합 API 게이트웨이를 두어, 공통 처리를 통제할 수도 있음   마이크로서비스 어플리케이션 구성 정보의 관리 → 외부 구성 저장소 패턴      예시 : 스프링 클라우드 Spring Cloud Config, 쿠버네티스 컨피그맵 (ConfigMap)           클라우드 인프라를 사용할 때, 어플리케이션이 마이크로서비스가 사용하는 자원의 설정 정보를 포함하면?                자원의 설정 정보이 변경될 때 어플리케이션이 반드시 재배포해야 하므로 서비스가 중단되어야 함         여러 마이크로서비스가 동일한 구성 정보를 사용한다면 이를 일일이 변경하기가 어려움         여러 마이크로서비스를 변경하는 시점에 일부 마이크로서비스의 구성 정보가 불일치할 수도 있음               → 마이크로서비스가 사용하는 자원의 설정 정보를 쉽고 일관되게 변경 가능하도록 관리해야 한다!               외부 저장소 : DB 연결 정보, 파일 스토리지 정보와 같이 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 관리   Config 원칙 : Staging, Dev, Test처럼 어플리케이션 배포 환경은 매번 달라지니, 코드와 설정 정보는 분리돼야            클라우드에서 운영되는 어플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안됨                    배포 시 변경될 호스트명, 백엔드 서비스의 연결을 위한 리소스 정보, 서버의 IP 주소나 포트 정보 등                           사용자의 신원을 증명하고, 접근 권한을 부여 → 인증 및 인가 패턴                  여러 마이크로서비스에 대한 인증 및 인가에 대한 접근 제어는 어떻게 구현해야 할까?         → 각 서비스가 모두 인증 및 인가를 중복으로 구현하는 것은… 당연히 비효율적!               중앙 집중식 세션 관리            마이크로서비스는 사용량에 따라 수시로 수평 확장되어 로드밸런싱이 되기 때문에 세션 데이터가 손상될 수 있음       각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장해 모든 서비스가 같은 사용자 데이터를 얻게 함       레디스 (Redis) 등을 세션 저장소로 사용           클라이언트 토큰            중앙 서버에 저장되는 세션과 달리, 토큰은 사용자의 브라우저에 저장       사용자의 신원 정보를 가진 토큰은 서버로 요청을 보낼 때 전송되기 때문에 서버에서 인가 처리를 할 수 있음       JWT : 토큰 형식을 정의하고 암호화되는 공개 표준 (RFC 7519)              클라이언트 토큰을 통한 사용자 인증의 흐름          브라우저가 사버에 사용자 이름과 패스워드로 인증을 요청한다.     서버는 인증 후에 사용자 정보의 인증 및 인가 정보를 포함하여 토큰을 생성하고 브라우저에 전송한다.     브라우저는 서버 자원을 요청할 때 토큰을 함께 보내고, 서버는 토큰 정보를 확인한 후 자원 접근을 허가한다.         API 게이트웨이를 사용한 클라이언트 토큰            API 게이트웨이가 외부 요청의 입구로 추가되어 인증 프로세스를 진행       인증 및 인가를 위한 별도의 전담 서비스가 API 게이트웨이와 연동하여 다른 서비스의 인증 및 인가 처리를 위임 → 인증 서비스 (Auth Service)              API 게이트웨이와 인증 서비스를 활용한 클라이언트 토큰을 통한 사용자 인증의 흐름          클라이언트가 리소스 서비스에 접근을 요청하면, API 게이트웨이는 인증 서비스에 전달한다.     인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지 확인하고 (→ 인증),     인증 서비스는 해당 요청이 해당 리소스에 대한 접근 권한이 있는지 확인하고 (→ 인가),     모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토큰 (Access Token)을 발급한다.     클라이언트는 다시 액세스 토큰을 활용해 접근을 요청한다.     각 리소스 서비스는 이러한 요청이 액세스 토큰을 포함하고 있는지 판단하여 리소스에 대한 접근을 허용한다.      장애 및 실패 처리 → 서킷 브레이커 패턴           여러 서비스로 구성된 시스템에서 한 서비스에 장애가 생기면, 다른 서비스가 영향을 받을텐데…?                전체 시스템은 정상적인데, 특정 기능을 누르면 한참 대기하는 경우 → 장애가 다른 서비스로 전이되었다!               → 장애가 발생한 서비스를 격리해서 유연하게 처리하자!               서킷 브레이켜 (Circuit Breaker) : 시스템 과부하나 특정 서비스에 문제가 생겼을 때, 자연스럽게 다른 정상적인 서비스로 요청 흐름을 변경하는 것 → 장애가 다른 서비스로 전이되지 않게 하자!            A → B → A의 서비스 흐름에서 B 서비스가 장애가 생겼을 때, A가 동기 요청을 보내면? : 계속 기다린다…                    B 서비스 호출에 대한 연속 실패 횟수가 임계값을 초과하면, 이후 서비스 호출 시도를 모두 실패로 처리           풀백 (Fallback) 메소드를 지정해 정상 응답을 대신할 대체 응답을 사용자에게 제공                           마이크로서비스의 장애 감지 → 모니터링 및 추적 패턴      예시 : 스프링 클라우드 히스트릭스 (Hystrix) + 집킨 (Zipkin)                  그래서 서킷 브레이커는 언제, 어떻게 작동하는데…?         → 각 마이크로서비스의 장애를 실시간으로 감지할 수 있고, 서비스 간의 호출을 파악하자!               히스트릭스 대시보드 : 각 요청의 트래픽이 원형으로 표현 → 서비스 성능에 문제가 생기면, 서킷 브레이커 발동 (⦁)   집킨 대시보드 : 각 서비스 트랜잭션의 호출을 추적하거나, 지연 구간별 장애 포인트를 확인할 수 있음            서비스 API를 선택하면, 각 API가 다른 API를 어떻게 호출하는지 확인 가능                    전체적인 API 간의 호출 빈도를 확인할 수 있는 정적 다이어그램 또한 제공                           마이크로서비스의 로그 관리 → 중앙화된 로그 집계 패턴           마이크로서비스가 사용량에 따라 탄력적으로 변화하면, 그 인스턴스가 삭제되면 로컬 로그는 초기화..?                로그 (Logs) 원칙 : 로그는 이벤트 스트림 (Event Streams)로 처리되어야 함                        로그는 시작과 끝이 고정된 것이 아니라, 서비스가 실행되는 동안 계속 흐르는 흐름             서비스는 스트림의 전달 및 저장에 절대 관여하면 안됨!                                로그를 전달하거나 저장하는 매커니즘 자체가 특정한 기술 및 인프라에 의존하게 됨                 마이크로서비스가 로그 관련 매커니즘을 직접 구현하면 유연성이 떨어짐                                                               → 서비스에서 발생한 이벤트 스트림 형태의 로그를 수집하고 분석할 방법을 찾자!               ELK 스택 : 엘라스틱서치 &amp; 로그스태시 &amp; 키바나를 기반으로 하는 데이터 분석 환경을 구성            엘라스틱서치 (ElasticSearch) : 분산형 검색 및 분석 엔진                    정형, 비정형, 위치 정보, 메트릭 등 원하는 방법으로 검색을 수행 및 결합 가능                       로그스태시 (Logstash) : 서버 측의 로그 집합기                    여러 소스에서 동시에 데이터를 수집 및 변한하여 특정 보관소로 데이터를 전송하는 데이터 처리 파이프라인                       키바나 (Kibana) : 시각적으로 로그 내역을 보여주는 대시보드                    위치 데이터, 시계열 분석, 그래프 관계 등을 히스토그램, 막대 그래프, 파이차트 등의 형태로 표현                           → 각 서비스의 인스턴스 로그를 집계해서 중앙에서 집중 관리할 수 있고, 특정 로그를 검색 및 분석할 수 있음               마이크로서비스 내의 로그를 중앙 서버의 레디스로 전송한다.     중앙 서버의 레디스에서 중앙 로그 저장소에 해당 로그들을 전송한다.     중앙 로그 저장소에 엘라스틱서치 엔진이 로그를 인덱싱한다.     해당 로그 정보를 키바나 대시보드를 통해 표현한다.            중간 지점에 레디스가 존재하는 이유? : 마이크로서비스의 로그스태시에서 보낸 로그 스트림이 중앙 로그 저장소에 몰리면 성능상의 문제가 생길 수 있으므로 임시 저장소 역할의 레디스를 추가      MSA 운영 관리 패턴의 변화 1 : 쿠버네티스 (Kubernetes)      기존 : 문제마다 상이한 기술들로 접근하여 해결            넷플릭스 OSS나 스프링 클라우드를 이용해 각각의 서비스를 별도로 둠       유연성처럼 수평 확장이 필요한 요소들은 AWS IaaS 서비스를 통해 해결           현재 : 쿠버네티스 하나로 모든 문제들을 해결            인프라 차원의 AWS IaaS → 컨테이너 레플리카 기술로 탐색 및 호출을 통합한 소프트웨어 차원의 쿠버네티스           MSA 운영 관리 패턴의 변화 2 : 서비스 메시 (Service Mash)      기존 : API 게이트웨이, 서비스 레지스트리, Config 서비스와 같이 운영 관리를 위한 여러 기반 서비스를 별도로 둠            업무 처리 마이크로서비스에 스프링 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함께 탑재       스프링 클라우드는 Java 기반이므로, 다른 언어로 폴리글랏하게 구현할 수 없음           현재 : 이스티오과 같은 서비스 메시 패턴을 적용            MSA 문제 영역 해걸을 위한 기능을 비즈니스 로직과 분리해 네트워크 인프라 계층에서 수행       인프라 레이어로서 서비스 간의 통신을 처리하여 문제 해결 패턴을 포괄해 처리           이스티오 (Istio) : 서비스 메시 패턴의 대표적인 구현체            사이드카 (Sidecar) 패턴 : 어플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포                    마이크로서비스마다 함께 배포되는 사이드카 프락시에 운영 관리를 위한 기능이 별도로 존재           운영 관리 기능과 별개로 존재하는 마이크로서비스는 순수한 비즈니스 로직으로 제공될 수 있음           컨트롤 플레인 (Control Plain)으로 중앙에서 통제되며, 사이드카끼리 통신하여 관련 운영 관리 기능 제공                   → 쿠버네티스의 파드 (Pod)에 서비스 컨테이너와 사이드카 구현체인 엔보이 (Envoy) 컨테이너가 함께 배포                      넷플릭스 OSS &amp; 스프링 클라우드와 이스티오의 차이점          이스티오는 사이드카로 격리되어 YAML과 같은 설정 파일르 정의되어 어플리케이션 코드 변경이 거의 없음     Java만이 아닌, 폴리글랏 어플리케이션도 지원 가능     쿠버네티스와 완벽하게 통합된 환경을 지원      마이크로서비스 어플리케이션 구현을 위한 마이크로서비스 구성 및 설계 → 어플리케이션 패턴      어플리케이션 영역에서도 유연성, 확장성, 독립성을 염두에 두어 설계되어야 함 → 백엔드, 프론트엔드 영역 모두!   마이크로 프론트엔드 → UI 컴포넌트 패턴           마이크로서비스의 장점인 서비스의 독립적인 변경 및 배포를, 기존 모노리스 프론트엔드로는 힘들텐데…?                모노리스 프론트엔드 : 백엔드의 여러 API를 호출하고 조합하여 화면을 구성해 표현                   → 프론트엔드도 마이크로서비스처럼 기능별로 분리하고 각 프런트엔드를 조합하여 동작하게 하자!       프레임 (Frame) 형태의 부모 창에 각 마이크로 프론트엔드를 조합해 동작            실제 각 기능의 표현은 마이크로 프런트엔드 조각이 구현 → 여러 백엔드 마이크로서비스 API 호출           프론트엔드 ↔ 백엔드, 백엔드 ↔ 백엔드 간의 통신 → 마이크로서비스 통신 패턴      동기 호출 방식 : 클라이언트에서 서버 측에 존재하는 마이크로서비스 REST API를 호출할 때 사용            사용자가  A 서비스에 B 서비스가 필요한 HTTP GET 방식의 요청을 보내면,                    A 서비스가 B 서비스에 HTTP GET 방식의 동기 호출을 수행하고,           B 서비스가 응답을 발생한다. (성공 시 200 OK)                       다양한 클라이언트 채널 연계나 라우팅, 로드밸런싱을 원활하기 위해 API 게이트웨이를 둘 수 있음       요청을 보내면 바로 응답이 오는 직관적인 방식이므로, 가장 많이 쓰이고 구현하기 쉬움       호출을 받은 마이크로서비스에 장애가 생긴다면, 요청을 보낸 서비스는 응답할 때까지 대기하면서 재호출                    여러 서비스 간의 연계를 통해 업무를 처리하는 마이크로서비스에서는 장애가 연쇄적으로 발생할 수 있음           서비스가 다른 서비스를 호출해서 얻은 정보로 기능을 제공한다는 것은, 서비스 간의 의존도가 높다는 의미                           메시지 기반 비동기 (asynchronous) 통신 방식 : 메시지를 보내면, 응답을 기다리지 않고 다음 업무 처리            메시지 브로커 (Message Broker) : 동기식처럼 완결성을 보장할 수 없으니, 이를 보장하는 메커니즘을 활용                    아파치 카프카 (Apache Kafka), 레빗엠큐 (RabbitMQ) 등           메시지를 보내는 생산자 (Producer)와 메시지를 받아 처리하는 소비자 (Consumer)                            생산자와 소비자가 서로 직접 접속하지 않고 메시지 브로커를 통해 연결               메시지 브로커에 메시지를 전달하고 자신의 일을 처리하면, 메시지 브로커가 전송을 보장                                   메시지 브로커으로 중계되므로, 서로 통신하는 서비스들이 물리적으로 동일한 시스템에 위치하지 않아도 됨           서로 프로세스를 공유할 필요도 없으며, 동일한 시간대에 동시에 동작하지 않아도 됨                       비동기 방식의 이벤트 기반 아키텍처 (Event-driven Architecture) : 비동기 통신 방식으로 느슨한 연계 지향                    분산 시스템 간에 발신자가 이벤트를 생성 및 발행 (Publish)하여,           해당 이벤트를 필요로 하는 수신자에게 전송하면,           이벤트를 구독 (Subscribe)하고 있던 수신자가 이벤트를 받아 처리한다.                   → 순서에 따라 특정 행동이 발생하는 기존의 방식이 아닌, ‘상태의 변화’를 의미하는 이벤트에 대한 반응으로 동작                   마이크로서비스를 독립적으로 수정 및 배포 → 저장소 분리 패턴           기존 모노리스 시스템의 저장소인 통합 저장소의 문제점?                어플리케이션 모듈은 분리하되 저장 처리는 모듈별로 격리하지 않고 다른 모듈에서의 호출을 허용         모든 비즈니스 로직이 데이터베이스의 SQL 처리에 몰려있는 경우가 대부분         데이터 중심 어플리케이션은 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려움         성능 문제가 발생하였을 때, SQL 구문 튜닝이나 Scale-up에 의존할 수 밖에 없음         여러 마이크로서비스로 분리해도 요쳥이 증가하면 데이터베이스만 바쁜 상태가 됨                        자동으로 확장되는 마이크로서비스의 Scale-out이 무의미함                                   → 여러 개의 마이크로서비스에 적합하게 데이터베이스 벤더를 운영하는 방법을 찾자!               각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다!   자신이 가진 데이터는 다른 서비스에 직접 노출하지 않고 각자 공개한 API를 통해서 접근 가능 → 정보 은닉   저장소가 격리되어 있기 때문에 각 저장소를 자율적으로 선택할 수 있음 → 폴리글랏 저장소   해당 제약을 통해 데이터를 통한 변경의 파급 효과를 줄여 서비스를 독립적으로 만듬   여러 분산된 서비스를 하나의 일관된 트랜잭션으로 → 분산 트랜잭션 처리 패턴           저장소 분리 패턴의 문제점?                여러 분산된 서비스에 걸친 비즈니스 처리를 하면, 비즈니스 정합성과 데이터 일관성은 어떻게 보장하지?                     2단계 커밋 : 분산 데이터베이스 환경에서 원자성 (atomicity)을 보장하기 위해,            분산 트랜잭션에 포함된 모든 노드가 커밋 (commit) 혹은 롤백 (rollback)되는 메커니즘       각 서비스에 lock-in이 걸려 발생하는 성능 문제로 비효율적인 방법       각 서비스가 다른 인스턴스로 로딩되므로 이를 통제하기 어려움       서비스의 저장소가 각각 다를 경우에 문제가 발생 (NoSQL 저장소 : 2단계 커밋 미지원)       네트워크 장애 등으로 특정 서비스의 트랜잭션을 처리하지 않는 경우 트랜잭션이 묶인 서비스에 즉시 영향           사가 (Saga) 패턴 : 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴            여러 분산된 서비스 내에서 각각의 로컬 트랜잭션과 보상 트랜잭션을 통해 비즈니스 및 데이터의 정합성을 맞춤                    각 로컬 트랜잭션을 통해 자신의 데이터베이스를 갱신한다.           사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 이벤트를 발행하여 데이터의 일관성을 맞춘다.           서비스에서 트랜잭션 처리에 실패하면, 앞선 다른 서비스에 처리된 트랜잭션을 롤백할 보상 트랜잭션을 준다.                           데이터 일관성에 대한 생각의 전환 → 결과적 일관성            이전엔 비즈니스 처리를 위한 규칙을 만족시킬, 데이터 일관성을 반드시 실시간으로 맞춰야 한다고 생각했다.       그러나 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것이 아니다. 어떤 비즈니스들은 어느 일정 시점이 되었을 때 일관성을 만족해도 된다. → 결과적 일관성 (Eventual Consistency)       이벤트 기반 비동기 통신 및 사가 패턴을 적용한 아키텍처, 메시지 브로커을 활용하여, 결과적 일관성을 반영해 비즈니스 및 시스템의 가용성을 극대화할 수 있다.           읽기와 쓰기의 분리 → CQRS 패턴           마이크로서비스의 서비스별 데이터 저장소에서 전통적인 DB 트랜잭션을 사용하면?                데이터 읽기 및 수정 작업으로 인한 리소스 교착 상태가 발생할 수 있다.               → 동일한 저장소에 데이터를 넣은 뒤에 CRUD를 처리하는, 기존의 패러다임을 전환하는 것은 어떨까!               명령 조회 책임 분리 (Command Query Responsibility Segregation)            사용자의 비즈니스 요청은 시스템의 상태를 변경하는 연산과 시스템의 상태를 조회하는 연산으로 나눠짐       일반적인 비즈니스 모델에서는 입력, 수정, 삭제보다 조회가 더 많이 사용됨                    서비스 내에 모든 기능을 넣으면 조회 요청 빈도가 증가함에 따라 다른 명령 기능 또한 확장되니 비효율적                       하나의 저장소에 쓰기 모델과 읽기 모델을 분리하거나, 쓰기 저장소와 조회 저장소를 따로 두자!                    쓰기 시스템의 부하를 줄이면서, 조회 대기 시간을 줄일 수 있음                              CQRS 패턴을 적용한 예시          명령 측면의 마이크로서비스                입력, 수정, 삭제 처리를 수행         쓰기에 최적화된 관계형 데이터베이스를 저장소로 활용         업무 규칙을 표한하기 좋은 언어 (Java)를 프로그래밍 언어로 사용                 조회 측면의 마이크로서비스                조회 서비스는 사용량이 많으므로, 스케일 아웃을 통해 인스턴스를 증가시킴         조회 성능이 높은 NoSQL 데이터베이스를 저장소로 활용         조회를 간단하게 구현할 수 있는 언어 (Node.js)를 프로그래밍 언어로 사용                 이벤트 주도 아키텍처                명령 서비스를 사용함에 따라 조회 서비스와의 데이터 일관성이 깨지므로 이를 유지하는 목적                       명령 서비스가 저장소에 데이터를 쓸 때, 저장 내역이 담긴 이벤트를 발생시켜 메시지 브로커에 전달         메시지 브로커의 이벤트를 구독하는 조회 서비스는 이벤트 데이터를 가져와 데이터를 최신으로 동기화                        시간 간격이 있으나 어느 시점에 일치하는 결과적 일관성이 이루어짐                                      저장소가 격리된 여러 마이크로서비스의 기능들을 연계한 서비스 제공 → API 조합과 CORS      API 조합 (API Composition) : 기능을 제공하는 마이크로서비스를 조합할 상위 마이크로서비스로 조합된 기능 제공            하위 서비스는 각자 독립적인 API를 제공하면서 연계 API를 위해 상위 서비스에 정보 제공           → 상위 서비스가 하위 서비스에 의존되는 결과를 가져옴 : 하위 서비스의 실패가 상위 서비스에 영향을 준다.       CQRS 패턴을 활용한 기능 연계 : 상위 마이크로서비스에 통합 이벤트 핸들러와 통합 저장소를 두자            독자 저장소를 갖는 하위 서비스에서 자신의 서비스 내 정보가 변경될 때 변경 내역을 각 변경 이벤트로 발행       상위 서비스는 구독한 이벤트를 가져와서 자신의 서비스 저장소에 기록해 데이터 일관성을 맞춤           쓰기 연산의 최적화 → 이벤트 소싱 패턴           사가 패턴과 CQRS 패턴에서 비즈니스 불일치를 피하려면,                저장소에 저장하는 것과 메시지를 보내는 것은 언제나 완전하게 진행되어야 하지만,                        객체의 상태를 관계형 데이터베이스에 저장하기 위해 SQL 질의어로 변환하는 것은 번거로움             메시지 발행과 저장 처리의 두 가지 기능을 수행하는 것 또한 빠르지 않음                                   → 메시지 발행과 저장 처리를 언제나 완전하게 처리하면서 성능도 최적화시킬 방법을 찾자!           비즈니스를 처리할 때 데이터의 처리는 항상 처리 상태의 결괏값을 계산하고 데이터의 최종 상태를 확정해 저장                일반적인 관계형 데이터베이스와 Java를 사용할 때,         품목에 대한 데이터 모델이 정의되어 있다면,         품목의 상태가 변경될 때 매번 트랜잭션 결과를 반영해서,         품목 데이터 모델의 결과를 계산해야 한다.               → 객체의 상태 변경에 따라 데이터 모델로 처리하여 최종값을 반영하는 과정은 복잡하고 속도가 느림               객체의 상태를 데이터 모델에 맞춰 계산하지 않고, 상태 트랜잭션 자체를 이벤트 저장소에 그대로 저장            메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있음 → 쓰기 속도가 매우 빠름       상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산       매일 자정 상태를 계산하고 스냅샵으로 저장한 후에, 현재 상태 정보가 필요할 때 스냅샵 이후의 트랜잭션만 처리       명령 측면, 조희 측면의 서비스가 이벤트 저장소의 모든 CRUD 처리하는 대신, 입력 및 조회만 처리하면 됨                    저장소에서 변경 및 삭제가 발생하지 않으므로, 명령 측면의 서비스를 여러 개로 확장해도 동시 업데이트 및 교착 상태가 발생하지 않음                              이벤트 저장소의 데이터 형태 예시          이벤트 아이디     이벤트 타입 : 어떠한 상태인지?     엔티티 타입 : 어떠한 객체의 이벤트인지?     엔티티 데이터 : 변경 내용을 JSON 형태로 저장 → 상태 객체가 그대로 들어감       → 이벤트 소싱은 모든 트랜잭션의 상태를 즉시 계산하지 않고, 별도의 이벤트 스트림으로 이벤트 스트림 저장소에 저장       이벤트 스트림 저장소 : 오로지 추가만 가능하게끔 하여, 계속 이벤트들이 쌓이게끔 함            실제 내가 필요한 데이터를 구체화하는 시점에 그때까지 축적된 트랜잭션을 바탕으로 상태를 계산해 구성       이벤트 데이터베이스의 역할뿐만이 아니라 메시지 브로커 처럼 작동       데이터 저장 처리 메커니즘이나 메시지 큐와 같은 이벤트를 전달하기 위한 메커니즘을 통합       저장된 상태를 통해 정확한 검사 로깅을 제공하고, 객체의 예전 상태를 재구성하는 것이 가능       외부 어플리케이션에 이벤트를 전달하는 것 또한 저장한 이벤트를 그대로 전송하면 됨              Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice2/",
        "teaser": null
      },{
        "title": "[vocawik] 1. vocawik 프로젝트 소개",
        "excerpt":"1. 들어가며   음성 합성 (Speech Synthesis)은 인간의 육성 혹은 그와 비슷한 주파수를 합성하여 인공적인 음성을 자동으로 만들 수 있는 기술을 말한다. 인간의 말소리 혹은 이와 유사한 소리를 일정한 단위로 분할해 각 조각에 부호를 붙이는 방식으로 데이터화해 음성 라이브러리 (Vocal Library)에 저장하면, 음성 합성 엔진 (Speech Synthesis Engine)이 사용자의 지시에 따라 음성 라이브러리에 필요한 음성 단위를 불러오고 이를 기반으로 하여 인공적인 음성을 합성한다. 음성 합성 기술 문자를 대신 읽어주는 스크린 리더 (Screen Reader)로서, 1984년 애플 매킨토시 (Apple Macintosh)에 매킨토크 (MacInTalk) 기능으로 탑재된 이후 오랜 기간에 걸쳐 다양한 분야에서 활용되고 있다.    2003년 2월 야마하 (Yamaha)에서 개발된 보컬로이드 (VOCALOID) 엔진 역시 음성 합성을 기반으로 한 소프트웨어로, 사용자가 프로그램만으로 사람의 노랫소리를 활용한 음원을 작곡하는 것을 목표로 한다. 그러나 기존 음성 합성 기술이 산업적인 용도에 초점을 맞춰져 있던 것과 달리, 보컬로이드를 비롯한 음성 합성 엔진은 음성 데이터에 다이폰 (Diphone), 음성의 강약, 비브라토, 숨소리 등의 부가적인 정보들을 더한 가수 라이브러리 (Singer Library)를 제공해 인간의 음성에 흡사한 소리를 생성할 수 있다. 또한 스코어 에디터 (Score Editor)는 노래의 가사나 음표만이 아닌, 음원의 억양와 높낮이 등을 가변하여 사용자가 자유롭게 음원을 조절할 수 있게끔 한다.         야마하가 보컬로이드를 발표한 이후, 여러 기업들이 음성 제공자 (Voice Provider)의 목소리를 활용한 가수 라이브러리를 발표하였다. 2007년 8월 31일 크립톤 퓨처 미디어 (Crypton Future Media)에서 발매한 하츠네 미쿠 (初音ミク)는 대표적인 음성 합성 이미지 캐릭터로, 현대 일본 캐릭터 문화의 상징 중 하나로 여겨질 만큼 어마어마한 성공을 거두었다. 최근까지도 Project SEKAI COLORFUL STAGE! feat. 初音ミク, ポケモン feat. 初音ミク Project VOLTAGE 18 Types/Songs와 같은 관련 컨텐츠나 피규어, 넨도로이드 등 굿즈들이 끊임없이 나오고 있으며, SONY, TOYOTA 등 유명 회사들과의 콜라보 역시 지속적으로 이루어지고 있다.   음성 합성 소프트웨어를 활용한 음악 산업의 성공에는 관련 창작물들을 하나의 ‘창작 문화’로 여기면서 자발적으로 생산·유통·소비 활동에 참여하는 팬덤의 영향력이 뒷받침되었다고 본다. 아마추어 작곡가들이 가수나 밴드를 통해 자신이 작곡한 곡을 재상산하는 것은 현실적인 어려움이 존재한다. 그러나 음성 합성 소프트웨어를 통해 손쉽게 자신의 곡에 가수의 음성을 넣는 것이 가능해지면서, 음성 합성 소프트웨어를 활용한 자신의 곡을 투고하는 프로듀서 (Producer)들이 등장하였다. 그리고 유튜브 (Youtube), 니코니코 동화 (ニコニコ動画)와 같이 사용자가 동영상을 자유롭게 올리거나 시청할 수 있는 비디오 플랫폼을 통해 생산자와 소비자가 시공간의 제약을 넘어 자유롭게 교류할 수 있는 환경 또한 조성되었다. 거기에 더해 소비자가 단순히 컨텐츠를 즐기는 것을 넘어, 직접 프로듀서로 활동하거나 일러스트, MMD와 같은 2차 창작물을 생산하는 활동을 하면서 문화적 파급력을 갖게 되었다고 볼 수 있다.         국내에서도 이런 음성 합성 소프트웨어를 활용한 음악 산업의 성공과 파급력에 주목하여, 한국어를 지원하는 보컬로이드 가수 라이브러리인 시유 (SeeU)나 유니 (UNI)가 출시되었고, 크리크루 (CreCrew)나 보카로 가사 위키 등 음성 합성 소프트웨어 관련 웹 사이트 또한 개설된 바가 있다. 그러나 음성 합성 소프트웨어가 일본이나 전세계에 미친 영향력에 비하면 국내에서의 파급력은 매우 제한적이었으며, 특히 관련 웹 사이트의 경우에는 운영되었던 사이트들이 폐쇄되면서 이용자들에게 불편함을 겪거나 수년간 축적된 데이터가 소실되는 경우가 발생하곤 하였다. 그래서 이번에는 음성 합성 소프트웨어를 주제로 한 지속 가능한 웹 사이트의 구현을 목표로 하여 웹 사이트를 기획하고 이를 바탕으로 설계하고자 한다.   2. vocawik 프로젝트 기획 &amp; 설계   프로젝트 목표 : 프로젝트 진행 과정에서 이루고자 하는 내용      도메인 정의 및 어플리케이션 아키텍처 구조 설계            사이트에서 제공하고자 하는 기능 및 책임들이 도메인별로 명확히 분리되어야 함                  언어, 프레임워크,   기능 명세서 (ver-0.0.1)                           분류         ID         이름         설명         상태                                 화면 (To)         TO-001         ~ 화면 이동 (~Page)         ~ 화면으로 이동한다.         -                       회원 (User)         US-001         ID 로그인 (IdLogin)         '비회원'이 '아이디' 또는 '이메일'과 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 때, '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되면 '회원'에 대한 '인가'를 수행한다.         -                       US-002         OAuth 로그인 (OAuthLogin)         '비회원'이 '특정 외부 사이트 (Google, Kakao, Naver, Apple, X)로 로그인 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 '인가'를 수행한다.         -                       US-003         OTP 로그인 (OTPLogin)         '회원'이 '2단계 로그인 (OTP) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행할 경우에 '일회용 비밀번호'를 확인할 수 있는 'OTP 키'를 발급하고, '2단계 로그인 화면'으로 이동한다. 만약 2단계 로그인 화면에서 입력받은 값이 일회용 비밀번호과 일치하면, '회원'에 대한 '인가'를 수행한다.         비회원 (인증)                       US-004         로그인 이메일 인증 (EmailAuthLogin)         '회원'이 '2단계 로그인 (이메일 인증) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되는 경우에 '일회용 비밀번호'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고, '2단계 로그인 화면'으로 이동한다. 만약 2단계 로그인 화면에서 입력받은 값이 일회용 비밀번호과 일치하면, '회원'에 대한 '인가'를 수행한다.         비회원 (인증)                       US-005         로그인 유지 (RememberMe)         '비회원'이 '로그인 유지 옵션'을 활성화한 상태로 로그인을 성공하였을 때, '회원'이 브라우저를 끄고 다시 접속하더라도 로그인 상태를 일정 기간 유지한다. (로그아웃 시에는 해당되지 않는다.)         비회원→회원                       US-006         비밀번호 재설정 (ResetPassword)         '비회원'이 '비밀번호 재설정' 버튼을 누르면, '비밀번호 재설정 아이디/이메일 입력 화면'으로 이동한다. 입력받은 값와 일치하는 회원 정보가 존재한다면, '임시 비밀번호'가 존재하는 '비밀번호 재설정 이메일'을 생성 및 전송한다.         -                       US-007         회원가입 ()                  -                       US-008          ()                  -                       US-009          ()                  -                       US-010          ()                  -                       관리자 (Admin)         AD-001          ()                  -                       위키 (Wiki)         WI-001          ()                  -                       문서 (Document)         DO-001          ()                  -                       검색 (Search)         SE-001          ()                  -                       게시판 (Board)         BO-001          ()                  -                     참고문헌          논문                김도희. (2018). 보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼.         임현정. (2012). 보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문.                 기사                안태춘, ‘한국 보컬로이드는 어떻게 나아가야할까?’                 도서                조이, 서비스를 성공시키는 기획자의 비법 노트         남경호, 사례로 배우는 언어 전환 프로젝트 관리         한정현 외 3인, 도메인 주도 설계로 시작하는 마이크로서비스 개발                 ","categories": [],
        "tags": ["vocawik"],
        "url": "/vocawik1/",
        "teaser": null
      },{
        "title": "[TIL] 2024년 01월 TIL",
        "excerpt":"January, 2024 : TIL를 작성하자!   2023년은 내게 있어 다사다난한 해였다. 교수님 밑에서 친구들과 함께 프로젝트도 해보고, 기업에 취업하고자 여러 군데에 서류도 넣어 면접까지 진행하였다. 그리고 내가 부족하다고 느낀 부분을 메꾸기 위해 여러 도서들을 사서 정리하기도 하였으며, 주니어 개발자를 위한 여러 행사들 또한 참여하였다. 그런데 지금 올해를 회고하는 내게 있어서 아쉬운 점은 내가 경험한 것들, 내가 공부한 것들, 내가 작업한 것들을 성실히 기록하지 않았다는 점이다. 그래서 이제 하루 앞으로 다가온 2024년에는, 내가 매일매일 성장한 기록을 글의 형태로 남기고자 한다.    TIL은 Today I Learned의 약자로, 오늘 하루동안 배운 것 혹은 경험하고 느낀 것들을 기록하면서 회고하는 것이다. 이미 여러 개발 블로그들을 보면, 김남윤님의 TIL이나 초보몽키님의 TIL처럼 많이들 TIL을 쓰시는 것을 볼 수 있다. TIL이 정해진 양식이나 규칙 없이 자유롭게 자신의 스타일로 작성하다 보니 보고서처럼 쓰시는 분들도, 일기처럼 쓰시는 분들도 있어 정말 다양하게 쓰신다는 것을 알 수 있었다. 원래는 양식이나 규칙을 확실히 정해놓고 매일매일 쓰려고 하였는데 일단은TIL을 한번도 작성해본 적이 없다보니, 일단은 한 달 정도는 여러 형태로 글을 써보면서 나한테 적합한 글쓰기 방식을 찾아봐야할 것 같다. 대신에 내가 왜 TIL을 작성해야 하는지에 대해 생각해보았다.           TIL을 쓰는 이유 1. 내가 매일 경험한 것을 회고하기 위해    하루를 보내면서 내가 모르는 내용이나 개념을 만나는 경우가 정말 많다. 그리고 나의 솔루션이 옳은지에 대한 기술적인 고민을 하는 과정 또한 경험하게 된다. 그러나 그동안 내가 경험한 것들을 기록할 때에는, 이런 과정을 생략하고 개조식으로 글을 써서 내가 중요하다고 생각한 부분 위주로 잘 정리하고자 노력하였다. 지금 와서 내가 정리한 글들을 보면 ‘내가 어떤 문제 상황에서 어떻게 해결하였는지?’에 대한 과정이 결여되었다는 느낌을 받았다. 하지만 TIL처럼 매일 내가 경험한 것들을 작성한다면, 나의 문제 해결 과정이 잘 들어난 글쓰기가 되지 않을까 생각하였다.            TIL을 쓰는 이유 2. 나 자신의 노력을 증명하기 위해    기업에서 원하는 주니어 개발자는 어떤 인재일까? 에 대해 고민을 많이 해보았다. 사실 시니어들의 눈에 주니어 개발자 모두가 고만고만한 실력이나 기술 스택을 가진 것처럼 보일 것 같았다. 그렇다면 내가 남들보다 더 낫다고 할 수 있는 부분은 무엇일까? 나는 그것이 성장 가능성이지 않을까 생각하였다. TIL은 내가 성장에 대한 갈망이 높고, 성실함과 꾸준함을 겸비하였음을 어필할 수 있어, 내가 남들보다 더 성장할 수 있는 사람이라는 것을 보여줄 수 있을 것이라고 기대한다.       2024년 01월 01일 (월)      신년을 맞아 앞으로 내가 해야할 일들을 아래와 같이 정리해보는 시간을 가졌다.            Python으로 알고리즘 문제를 풀면서 코딩 테스트 준비하기       Java, Spring과 같이 백엔드 개발자에 있어 필요한 내용을 공부해 포스트로 정리하기       기획부터 배포까지의 일련의 과정을 경험할 수 있는 협업 프로젝트 진행하기       정보처리기사, SQLD와 같이 취업에 도움이 될 수 있는 자격증 취득하기       내가 목표로 하는 회사들에 지원하여 서류, 코딩 테스트, 면접과 같은 채용 프로세스 경험하기       하루동안 내가 경험한 일들을 기록하는 TIL 작성하기       자신의 기술과 역량을 보여줄 수 있는 개발자 포트폴리오 만들기           vocawik 기획서 작성에 참고하기 위해 사례로 배우는 언어 전환 프로젝트 관리 1장의 내용을 정리하였다.   Goodnotes 앱으로 필기하기 위해 알라딘으로 구매한 전자책을 스캔하는 Automator 워크플로우 파일을 작성하였다.   2024년 01월 02일 (화)      어제 작성한 Automator 워크플로우 파일을 오전에 실행해보니 같은 파일명으로 파일을 덮어쓰는 오류가 있었다. 그래서 스크린샷을 찍어 이를 각각 다른 이름으로 저장하고, 필요한 경우에 색상 반전을 실행하는 파이썬 코드를 작성하였다.            사실 저장된 스크린샷 이미지들을 하나의 PDF로 만드는 것까지 코드로 작성하였는데, 막상 실행해보니 출력된 결과물의 화질이 그렇게 좋지 않아 이 부분은 수작업으로 진행하였다.       알라딘으로 구매한 전자책 37권과 재학 기간에 스캔한 전공 서적 6권을 대상으로 진행하였다. 전자책을 스캔하는 작업과 색상 반전을 실행하는 작업 모두 내 예상보다 많은 시간이 소요되서 하루 내내 여기에만 매달린 거 같다.           from PIL import ImageGrab import time import pyautogui   def take_screenshot(filename):     # 로딩 시간 지연     time.sleep(2)      # 현재 화면 전체를 캡처     screenshot = ImageGrab.grab()      # 파일로 저장     screenshot.save(filename)      # 오른쪽 방향키 누르기     pyautogui.press('right')   if __name__ == \"__main__\":     # 초기 시간 지연     time.sleep(5)      for i in range(1, 256):         file_path = \"page\" + str(i) + \".png\"          # 스크린샷 찍기         take_screenshot(file_path)    from PIL import Image   def invert_colors(image_path, output_path):     # 이미지 열기     image = Image.open(image_path)      # 이미지 모드 확인 및 변경 (모드가 'RGBA' 또는 'LA'인 경우에 대비)     if image.mode in ('RGBA', 'LA'):         r, g, b, a = image.split()         rgb_image = Image.merge('RGB', (r, g, b))     else:         rgb_image = image.convert('RGB')      # 이미지 크기 및 모드 확인     width, height = rgb_image.size      # 각 픽셀의 RGB 값을 반전     inverted_image = Image.new('RGB', (width, height))     for x in range(width):         for y in range(height):             pixel = rgb_image.getpixel((x, y))             inverted_pixel = tuple(255 - value for value in pixel)             inverted_image.putpixel((x, y), inverted_pixel)      # 반전된 이미지 저장     inverted_image.save(output_path)   if __name__ == \"__main__\":     for i in range(1, 256):         input_image_path = \"page\" + str(i) + \".png\"         output_image_path = \"pages\" + str(i) + \".png\"         invert_colors(input_image_path, output_image_path)       vocawik 기획서 작성에 참고하기 위해 사례로 배우는 언어 전환 프로젝트 관리 2장의 내용을 정리하였다.   2024년 01월 03일 (수)      오늘 아침, 지난달에 면접을 진행한 디지털하나路 2기 금융서비스개발 분야에 합격하였다는 전화를 받았다.            솔직히 말하면 면접을 진행하면서 아쉬운 점들이 많았고, 경쟁률도 내 예상보다 높은 편이였기에 이렇게 합격을 하게 될 줄은 전혀 몰랐다. 6개월이라는 짧지 않은 기간에 매일 9시간씩 심도 깊게 진행되는 프로그램인 만큼, 본 과정에 열심히 참여하여 이전보다 성장할 수 있도록 노력해야겠다.       공고문에 따르면 디지털하나路 금융서비스개발의 커리큘럼은 금융의 이해, 서비스 개발의 요소, FrontEnd 개발, BackEnd 개발, 데이터베이스와 보안, 3차례의 팀 프로젝트로 구성되어 있다. 과정 하나하나가 BackEnd 개발자를 지망하는 내게 큰 도움이 될 것 같고, 특히 부족한 협업 경험이 아킬레스건이라 생각한 내게 있어 팀 프로젝트를 3차례 진행해보는 것은 굉장한 메리트가 될 수 있을 것이라고 생각한다.       하나은행 HR 담당자 분들이 진행하시는 채용설명회 및 채용상담 또한, 자소서나 포트폴리오를 어떻게 작성하고 관리할지 고민이 많고 실제 면접 경험이 부족한 나에게 큰 도움이 될 것 같다.                 vocawik 기획서 작성에 참고하기 위해 사례로 배우는 언어 전환 프로젝트 관리 3장의 내용을 정리하였다.            디지털하나路 일정을 감안힌다면, 보다 빠른 기획서의 작성이 필요하다. 오는 1월 13일에 인프라 매니저와의 만남을 약속하였고 1월 15일에 디지털하나路 과정이 시작될 예정이니, 1월 11일에 기획서 초안을 완성하도록 한다.           2024년 01월 04일 (목)      vocawik 기획서 작성에 참고하기 위해 사례로 배우는 언어 전환 프로젝트 관리 4장의 내용을 정리하였다.      내일배움카드 발급이 이렇게 오래 걸릴 줄은 몰랐다. 디지털하나路 일정이 촉박하다보니, 카드를 직접 수령하려고 은행만 세 군데 다녀왔다. 그건 그렇고 그동안 작성한 내용을 읽어보니 점점 일기장이 되는 것 같다? 그래도 일단은 괜찮겠지..?    2024년 01월 05일 (금)      vocawik 기획서 작성에 참고하기 위해 사례로 배우는 언어 전환 프로젝트 관리 5장의 내용을 정리하였다.            책의 내용이 7장으로 구성되어 있는데, 7장은 후일담이라 내일 6~7장의 내용을 정리해 마무리하면 될 것 같다.       정리를 마무리한 다음에는 정리된 내용을 토대로 기획서의 뼈대를 잡을 계획이다. 내가 기획하고 있는 프로젝트는 기존 프로젝트의 언어 전환이 아닌 신규 서비스의 구현이긴 하지만, 실제로 어떻게 프로젝트를 관리할지에 대해 다시 한 번 생각해볼 수 있었으며 기획서에도 분명 채용할 만한 부분이 많음을 느끼고 있다.                    기획서는 현재 1. 기획 배경, 2. 타 사이트 분석, 3. 서비스 설계의 흐름으로 작성하고 있으며, 현재 1번의 내용은 완성하고 2번의 내용을 작성하고 있는 상태이다.                           2024년 01월 06일 (토)      vocawik 기획서 작성에 참고하기 위해 사례로 배우는 언어 전환 프로젝트 관리 6~7장의 내용을 정리하였다.   이전에 작성하였던 홈브류 (Homebrew)와 관련된 게시글을 수정하여 포스팅하였다.   2024년 01월 07일 (일)      이전에 작성하였던 HTML와 관련된 게시글과 CSS와 관련된 게시글을 수정하여 포스팅하였다.   2024년 01월 08일 (월)      이전에 작성하였던 구현 알고리즘과 관련된 게시글을 수정하여 포스팅하였다. 사실 예제 느낌으로 문제들도 풀었던 것 같은데, 아무리 찾아봐도 안보여서 백준에서 구현 문제를 몇 개 풀고 이에 대한 해설까지 더해서 다시 올려야 할 것 같다.   2024년 01월 09일 (화)      리눅스를 공부하는 과정에 tmux에 대해 알게 되어 맥북 로컬 환경에 설치하여 직접 실습해보고, tmux에 관련된 게시글을 작성해 포스팅하였다. 간단한 구조나 직접 사용하면서 필요하다고 생각된 명령어들 위주로 게시글을 작성하긴 하였는데, 아무래도 직접 사용해보면서 이 툴에 익숙해지는 것이 무엇보다 중요해보인다.   2024년 01월 10일 (수)      이전에 작성하였던 python과 관련된 게시글을 수정하여 포스팅하였다. 조만간 이 게시글의 내용을 참고하여 SpringBoot가 기반으로 하는 Java에 대해서도 심층 깊게 작성할 계획이다.   도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 MSA에 대한 게시글을 작성중이다.            2장의 내용이 길기도 하고, 인프라 영역에 대해 내가 모르는 부분이 많아 완성하는 데에 시간이 더 길릴 것 같다.           2024년 01월 11일 (목)      도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 MSA에 대한 게시글을 작성중이다.            마이크로서비스의 흐름을 주도하고 있는 넷플릭스와 쿠버네티스가 대단하다는 생각이 많이 드는 시간이었다.           클린 코드 1장을 읽으면서 정리한 내용을 바탕으로 한 게시글을 작성하였다.            깨끗한 코드가 무엇인가에 대한 여러 의견들을 보면서 그동안 작성해본 코드에 대해 반추하면서 과연 과연 내가 저자로서의 책임을 갖고 코드를 작성하였는지에 대해 생각해볼 수 있었다.           2024년 01월 12일 (금)      을지로입구역에 위치한 하나은행 사옥에서 디지털하나路 2기 입학식 행사에 참여하였다. 행사는 교육 커리큘럼이나 출결 관리와 같은 전달 사항들을 안내하는 오리엔테이션 위주로 진행되었고, 디지털하나路에 같이 참여하게 될 직원 분들과 수강생들 또한 처음 만나뵙게 되었다. 이제 다음주부터 본격적인 일정이 시작되는 만큼, 열심히 참여하여 내가 원하는 바를 이뤘으면 한다.   도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 MSA에 대한 게시글을 작성중이다.            이제 인프라 영역에 해당되는 부분을 마치고, 내가 다루는 어플리케이션 영역에 대한 내용을 다루고 있다. 이전에 운영 관리 패턴에 대해 공부하면서 인프라 영역이 다루는 범위가 넓어지면서 어플리케이션 영역이 하는 업무가 줄어든건가? 라는 생각이 들었는데, 그렇지 않다는 것을 깨닫게 되었다.           가상 면접으로 배우는 대규모 시스템 설계 1장을 공부하면서 시스템 설계에 대한 게시글을 작성중이다.   정보처리기사 필기 합격을 위해 소프트웨어 공학 및 개발 방법론에 대해 공부한 게시글을 작성하려고 하는데, 너무 개념이나 외울 내용이 많아서 이거를 어떻게 공부할지 좀 고민하는 중이다.   2024년 01월 13일 (토)      월요일에 찾았던 구현 문제를 푼 기록을 오늘 Notion에서 발견해서, 이전에 작성하였던 구현 알고리즘과 관련된 게시글을 수정하여 포스팅하였다. 추가로 그리디와 브루트포스 알고리즘에 대한 내용까지 완성되어 있어서, 이를 마크다운 파일로 수정해서 포스트로 작성할 계획이다.   도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 MSA에 대한 게시글을 작성하였다.            MSA이 발전하는 과정에서의 문제들과 이에 대한 해결책으로서의 패턴들을 접하면서, 내가 이전에 고민한 아키텍처 설계에 대해 회고하는 시간을 가질 수 있었고, 앞으로 새롭게 진행될 나의 작업이 이를 반영해보고 싶다는 생각이 들었다. 특히 인프라 영역의 쿠버네티스와, 어플리케이션 영역의 메시지 브로커 및 이벤트 아키텍처, 데이터베이스 영역의 NoSQL 저장소는 빨리 공부하여 프로젝트에 적용할 필요성을 느꼈다.           디지털하나路 커리큘럼을 살펴보니 git을 다루는 시간이 초반에 하루 정도 있었는데, 솔직히 Github Desktop이 편한 나로서는 리눅스로 직접 명령어를 입력해본 경험이 적다는 것을 깨닫고 이에 대한 내용을 정리하는 중이다. 근데 이거를 하루만에 끝내버리면 직접 실습도 잘 안할 것 같아서, 조금씩 시간을 내서 틈틈이 작성하려고 한다.   2024년 01월 14일 (일)      도메인 주도 개발로 시작하는 마이크로서비스 개발 3장을 공부하면서 마이크로서비스 MSA에 대한 게시글을 작성중이다.            마이크로서비스 내부의 아키텍처에 대해 본격적으로 고민하기 전에 전통적인 어플리케이션의 아키텍처들에 대해 정리하였다. 내가 배웠거나 경험한 내용들이 대부분 나와 있어서, 이해가 빠르기도 하면서도 한편으론 아키텍처의 문제점을 훑어보면서 기존 지식에 함몰되면 안되겠다는 느낌을 받았다.           이전에 알고리즘에 대해 공부한 내용을 바탕으로, 그리디 알고리즘과 관련된 게시글을 포스팅하였다.   이것이 자바다 1장에서 공부한 내용으로 자바와 자바가 어떻게 동작하는지 다루는 게시글을 포스팅하였다.            자바가 이전부터 자주 써온 언어인 만큼, 내게 필요하다고 판단된 영역부터 다뤄보고 싶어서 1장의 내용에 내가 따로 공부한 내용을 더해 좀더 심도 깊게 자바에 대해 이해하는 글을 작성하고자 하였다.           2024년 01월 15일 (월)      도메인 주도 개발로 시작하는 마이크로서비스 개발 3장을 공부하면서 마이크로서비스 MSA 아키텍처에 대한 게시글을 작성하였다.            실제 기획하고 있는 프로젝트가 있는 만큼, 내 기획을 설계로 바꾸려면 어떻게 해야 할지 고민을 많이 해본 것 같다. 또 이벤트 및 이벤트 브로커의 개념이 명확하지 않았는데, 예시 및 적용된 사례들을 보면서 이 개념을 정말 잘 이해할 수 있었다. 빨리 아파치 카프카를 배워서 써봐야 할 것 같다. 그리고 조금 의문이 드는 부분이 하나 있다면 마이크로서비스 각각의 로컬 저장소를 두고 외부에 토탈 저장소로 관리하는 방식인데 사실 이거는 작은 규모의 프로젝트에서는 투머치? 아닌가 생각이 들긴 했다.           2024년 01월 16일 (화)      도메인 주도 개발로 시작하는 마이크로서비스 개발 4장을 공부하면서 마이크로서비스 에자일 개발 프로세스에 대한 게시글을 작성하였다.            에자일 개발 프로세스에 대해 알고 었었기 때문에 글이 쉽게 다가왔고, 또 스크럼에서 이야기하는 스프린트를 직접 적용할 때 사용하는 협업 툴인 Slack이나 Jira를 기회가 되면 꼭! 활용해보고 싶었다.           이 블로그를 도커 허브에 올리는 Github Actions 동작을 위한 yml 파일를 추가하였다! 흐름은 그동안 내가 작성한 프로젝트이랑 거의 동일하게 동작하는데, 도커 허브 이미지를 본 친구가 포트포워딩을 통해 외부 주소로 어플리케이션을 잠깐동안 접속할 수 있게끔 해줘서 다른 서버에서도 동작하는 내 블로그를 볼 수 있었다! (그냥 8080 포트만 열어주면 바로 구성해서 사용자에게 보여주는 점은 솔직히 신기하였다.)   2024년 01월 17일 (수)      vocawik 프로젝트는 스프링부트 및 이와 연동할 소프트웨어가 필수적으로 구성되어야 한다. 하지만 도메인 주도 설계에 입각하여 마이크로서비스를 만든다면, 프로젝트의 버전 및 의존성 관리와 아키텍처 내에 있는 각 요소 간의 연계가 반드시 이루어져야 한다고 생각하였다. 그래서 이 작업을 직접 설계한 뒤에  자동으로 구성할 수 있도록 우선 spring initializr을 참고해 bash 스크립트를 작성하였다. 아래는 다음의 내용인데, 의존성 관리는 내가 스프링 어플리케이션을 직접 실행해보면서 필요한 설정들을 확인해야 할 것 같아 주말에 진행할까 한다.   #!/bin/zsh  # 전역 변수를 정의합니다.  declare -r springBoot=\"Java SpringBoot\" declare var_framework declare var_spring_initializr=\"curl -G https://start.spring.io/starter.tgz\" declare var_spring_initializ_end=\" | tar -xzvf -\"  # 함수를 정의합니다.   func_start() {     echo -e \"# vocawik 웹 어플리케이션 개발에 필요한 요소들의 설치 및 초기 설정을 자동으로 구성합니다.\\n\" }  func_error() {     echo -e \"# 잘못된 접근입니다.\\n\" }  func_framework() {     echo -e -n \"## 웹 프레임워크 구성\\n[1] $springBoot\\n&gt; \"     read var_framework      case $var_framework in         \"1\")             func_springboot             ;;         *)             func_error             func_framework             ;;     esac }  func_springboot_print_curl() {     echo -e \"$var_spring_initializr$var_spring_initializ_end\\n\" }  func_springboot_curl_plugin() {     echo -e -n \"### 빌드 플러그인\\n[1] Maven\\n[2] Gradle (Grovy)\\n[3] Gradle (Kotlin)\\n&gt; \"     read build_plugin     case $build_plugin in         \"1\")             var_spring_initializr+=\" -d type=maven-project\"             ;;         \"2\")             var_spring_initializr+=\" -d type=gradle-project\"             ;;         \"3\")             var_spring_initializr+=\" -d type=gradle-project-kotlin\"             ;;         *)             func_error             func_springboot_curl_plugin         ;;     esac }  func_springboot() {     echo -e \"\\n## $springBoot 초기 설정\"     func_springboot_print_curl      echo -e -n \"### 도메인 이름 ex) user : \"     read domainName     var_spring_initializr+=\" -d applicationName=Vocawik\"     result=$(echo \"$domainName\" | sed 's/./\\U&amp;/')     var_spring_initializr+=$result     var_spring_initializr+=\"Application\"      var_spring_initializr+=\" -d artifactId=\"     var_spring_initializr+=$domainName          var_spring_initializr+=\" -d groupId=vowawik\"      var_spring_initializr+=\" -d packageName=vocawik.\"     var_spring_initializr+=$domainName      var_spring_initializr+=\" -d name=\"     var_spring_initializr+=$domainName      echo -e -n \"### 프로젝트 설명 ex) Demo project for Spring Boot : \"     read description     var_spring_initializr+=\" -d description=\"     var_spring_initializr+=\"$description\"     func_springboot_print_curl      func_springboot_curl_plugin      var_spring_initializr+=\" -d bootVersion=3.2.1\"     var_spring_initializr+=\" -d packaging=jar\"     func_springboot_print_curl      # 의존성 추가      eval \"$var_spring_initializr$var_spring_initializ_end\" }  func_main() {     func_start     func_framework }   # 프로그램을 시작합니다. func_main      실전 스프링부트 1장을 공부하고 여기서 배운 내용을 게시글로 작성하는 중이다.            디지털하나路의 커리륨럼은 크게 백엔드, 프론트엔드의 투 트랙으로 구성되어 있다. 그런데 초반에는 프론트엔드 분야를 다루므로 이 부분은 수업을 들으면서 공부하면 될 것 같은데, 그 다음에 진행될 백엔드나 프로젝트를 위해서라도 스프링부트에 대한 독학은 필수라고 생각해서 실전 스프링부트를 통해 지속적으로 공부할 계획이다. (근데 이 책 진짜 좋은 것 같다… 아무래도 초심자에겐 어렵겠지만, 한번 스프링부트로 프로젝트를 간단하게 만들었거나 좀 심층적으로 공부하고 싶다면 꼭 추천해주고 싶다.)           2024년 01월 18일 (목)      블로그의 태그 모아보기 레이아웃을 수정했다. (태그 링크 및 글 숫자 표시)            작업한 내용은 진짜 별건 아닌데, 처음 보는 jekyll 문법에 살짝 당황하긴 했다. 그렇지만 이게 작동하는 모양이 타임리프랑 비슷하다는 것을 깨닫게 되어서 (뒤에 보니 역시 jekyll 또한 타임리프랑 같은 템플릿 엔진의 한 종류였다) 구조는 금방 이해했던 것 같다. 나중에 블로그 관련 시리즈를 추가로 작성하면, 이 문법에 대한 것을 다루면 좋을 것 같다.           디지털하나路 과정 중에 만난 분과 같이 스터디를 진행하기로 약속하였다.            이 링크는 스터디를 진행할 때 활용할 리프지토리로, 매일매일 그날 배운 내용과 관련된 주제를 하나 정해서 공부하고 이를 그 다음 날에 서로에게 발표하는 흐름으로 진행해보기로 하였다. 리포지토리는 발표하기 앞서, 다른 사람들에게 발표 주제에 대해 정리된 글을 공유하여 흔히 말하는 ‘선한 영향력’을 주는 동시에, 자신 역시도 더 좋은 질문을 받을 수 있는 기회를 얻고자 하는 취지에서 생성하였다. 그날의 발표 주제는 깃허브 이슈를 통해 모두에게 공유될 수 있도록 하고 오늘 역시 이렇게 이슈가 열려 있는 상태이다.           디지털하나路 스터디 1일차 주제인 ‘Javascript와 Typescript의 compiler 분석’에 대해 공부하였다.   2024년 01월 19일 (금)      디지털하나路 스터디 1일차 주제에 대해 스터디 팀원과 이야기를 나누고, 서로 자유롭게 의견을 교류하는 시간을 가졌다.            지금 커리큘럼이 초반인 만큼, 발표보다는 의견 교류가 주로 이루어졌던 것 같다. 우리가 진행하고 있는 스터디의 방향성이나, 향후 진로에 대한 고민과 같은 얘기가 이루어졌고 발표 자료는 따로 게시글을 만들었다.           2024년 01월 20일 (토)      실전 스프링부트 1장을 공부하고 여기서 배운 내용을 게시글로 작성하는 중이다.   tmux에 대해 작성한 게시글에서 명령어 부분에 대해 다룬 내용을 수정하였다.            실제로 명령어를 입력해보니 안되는 부분이 있었는데, 내가 참고한 자료는 운영체제가 달랐던 것 같다.       실습하는 과정에서 블로그 세션을 따로 열어서 로컬 Jekyll 서버를 계속 띄워두고 있는데, IDE가 꺼질 때마다 다시 실행하는 게 매우 귀찮았는데 이렇게 하니 괜찮은 것 같다. (문제가 생기면 터미널로 접속해야 하긴 하는데, 그럴 일이 잘 없을 것 같다.)              사실 이번 주가 디지털하나路 1주차였는데, 9 to 6 생활이 생각보다 힘들다…ㅎㅎ 토요일에 일어나는데 아침부터 두통이 너무 심해서, 카페에서 3시간 정도만 공부하다가 친구랑 저녁을 같이 먹었다. 아무래도 장기간 진행되는 일정인 만큼, 체력 관리를 잘 해야할 것 같다.    2024년 01월 21일 (일)      실전 스프링부트 1장을 공부하고 여기서 배운 내용을 바탕으로 하여 게시글을 작성하였다.            게시판 만들기니, 간단한 서비스 제작하는 정도로 스프링부트를 다뤄 심층적인 이해가 필요하다는 생각을 했었다. 그런 내 의도에 가장 적합한 책을 골랐다는 생각이 들었고, 또 소위 말하는 ‘~를 마스터했다’고 자처하려면 이렇게 깊게 공부해야겠다는 것을 느꼈다.           2024년 01월 22일 (월)      실전 스프링부트 2장을 공부하고 여기서 배운 내용을 게시글로 작성하는 중이다.            이 부분도 익숙한 친구들이 많이 보인다. 내 생각보다 스프링에 대해 많이 아는건가? 하다가도, 하나씩 뜯어보는 순간, 얇디얇은 지식이 폭로당하고 있다; 이전에 언급하였듯 지금 디지털하나路 프론트엔드 커리큘럼을 진행하고 있는데, 강사님이 진행하시는 내용을 보면서 저정도까지 깊게 알아야 된다는 것을 느끼는 중이다.           디지털하나路 스터디 2일차 주제에 대해 스터디 팀원과 이야기를 나누고, 서로 자유롭게 의견을 교류하는 시간을 가졌다.            디지털하나路에서 다뤄본 TailwindCSS을 주제로 이에 대해 정리하는 시간을 가졌는데, 솔직히 말하자면 이전에 부트스트랩으로 사이트 화면을 만들어본 나로서는 어떤 점이 좋은지 알기가 좀 어려웠다. 물론 점유율이 높은 부분에 이유가 있겠지, 싶어서 이를 주제로 잡은 것이었는데… 프로젝트에서 사이트 화면 구현을 할 일이 생겨서 직접 만지다 보면 체감하는 부분이 있지 않을까 싶긴 하다. 2일차 주제에 대해 정리한 게시글 또한 작성하였다.           2024년 01월 23일 (화)      깃허브 블로그의 navigation bar 및 footer 부분을 수정하였다.            지인이 개설한 포트폴리오 페이지를 보면서 나 또한 블로그에 자기소개 및 포트폴리오를 목적으로 한 페이지가 있으면 좋겠다고 생각하였다. 그래서 이에 대한 사전 작업으로, 블로그 레이아웃에서 프로필 부분을 뜨지 않도록 비활성화한 것을 다시 롤백하였고, 푸터 부분에서 나를 팔로우할 수 있는 여러 경로들이 나올 수 있게끔 수정하였다. 그 부분을 먼저 손댄 이유는 (1) 향후 블로그 커스텀마이징을 위해선 지킬 문법과 블로그에 적용된 minimal-mistake 테마의 레이아웃 구조에 대해 파악할 필요성이 있었고, (2) 사이트를 이용할 사용자들이 사이트 내에서 이동하는 것을 이전보다 편리하게 할 수 있을 것이라고 생각했기 때문이다. minimal-mistake 테마로 블로그를 구현한 사례들을 보면 프로필에 사이트 목차를 구현한 것이 여럿 보였는데 이 부분을 추가로 구현해야 할 것 같다.           2024년 01월 24일 (수)      디지털하나路 및 모던 자바스크립트 Deep Dive에서 배운 내용을 정리한 게시글을 작성하고 있다.            지금 진도를 팍팍 나가다 보니 내가 계속 놓치는 부분이 생기는 것 같아, 이전에 구매한 책을 통해 빠르게 예습하고 거기에 수업에서 배운 것들을 더해나가는 식으로 진행할 생각이다. (모던 자바스크립트 Deep Dive 또한 1000페이지에 가까운 엄청난 분량이라 거의 병행할 것 같긴 하지만 (…)) 그래서 지금 작성하는 내내 게시글로서는 정리가 안된 느낌이 없잖아 있는데, 지난번에 운영체제 수업을 정리했던 것처럼 빠르게 한 게시글에 정리하고 뒤에 여러 게시글로 나누어야 할 것 같다.           2024년 01월 25일 (목)      디지털하나路 및 모던 자바스크립트 Deep Dive에서 배운 내용을 정리한 게시글을 작성하고 있다.   디지털하나路 스터디 3일차 주제에 대해 스터디 팀원과 이야기를 나누고, 서로 자유롭게 의견을 교류하는 시간을 가졌다.            오늘 주제는 프로토타입 패턴에 대해 준비하였는데… 문제는 내가 프로토타입 패턴에 대해 잘 이해가 되지 않은 상태로 스터디에 임해 질문에 대해 답변을 잘하지 못했다는 것이다. 같이 스터디를 해주신 분이 잘 이해를 해주셨지만, 나 스스로 많이 부끄러웠고 아쉬웠던 것 같다. 그래서 내일 해당 주제에 대해 다시 정리해서 스터디를 진행하겠다고 말씀드리고 집에서 자바 코드로 두들겨 보면서 나 스스로 다시 정리하는 시간을 가졌다.       결국 새벽 3시 반에 잤는데, 그 다음 날 오전에 피곤해서 많이 힘들었다. 열받는다고 무리하면 안되는 빡빡한 스케줄인데 욕심을 부렸던 것 같다, 반성한다…           2024년 01월 26일 (금)      디지털하나路 및 모던 자바스크립트 Deep Dive에서 배운 내용을 정리한 게시글을 작성하고 있다.   어제, 그리고 오늘 프로토타입 패턴에 대해 공부하고 3일차 주제에 대해 정리한 게시글와 프로토타입에 대해 이해하기 위한 샘플 코드를 작성하였다.   2024년 01월 27일 (토)      vocawik 기획서의 기능 명세서를 작성하고 있다.            지난번에 인프라 매니저 분을 뵈면서 기획서 초안을 보여드렸을 때 받은 피드백 중 하나가 아키텍처 구조도 및 기능 명세서 작성인데, 전자는 이후에 전달드렸고 후자는 아직 진행하지 못한 상태이다. 그런데 인프라 매니저 분께서 진행하시는 작업들에 비해 내가 맡기로 한 부분들이 더딘 감이 있다는 것을 느껴, 디지털하나路 수업이 없는 주말에 사이트에서 제공하고자 하는 기능들을 최대한 정리해둘 계획이다. 아마 다음주 주말과 다다음주 주말에 다시 뵐 예정인데, 그때까지 최대한 기획서 완성을 목표로 해야할 듯 하다.           2024년 01월 28일 (일)      어제에 이어, vocawik 기획서의 기능 명세서를 작성하고 있다.            일단 각 서버가 포함할 도메인 영역을 크게 나누고 하나씩 기능을 적어보곤 있는데, 도메인 사이의 중복된 기능이 있는 경우를 어떻게 처리해야할지 고민되는 부분이 있다. 예를 들자면, ‘회원’, ‘관리자’ 도메인에 ‘이메일 알림’ 기능이 있으면 중복된 내용을 구현하기 보다는, 이를 새로운 ‘이메일 알림’ 도메인으로 처리하는 것이 맞는 듯 한데, 이러면 너무 서비스를 많이 구현해야 하는 게 아닌가? 싶긴 하다. 사실 마이크로서비스 자체가 micro하니, 틀린 것 아닌 것 같긴 한데, 중복된 부분을 무한정 띄어내 새로운 영역을 만드는 것 또한 아닌 것 같고…          ","categories": [],
        "tags": ["TIL"],
        "url": "/til1/",
        "teaser": null
      },{
        "title": "[Linux] tmux",
        "excerpt":"tmux : 터미널 멀티플렉서 (Terminal Multiplexer)      단일 단말기 창 혹은 원격 터미널에서 여러 터미널 세션에 액세스할 수 있도록 가상 콘솔을 다중화            하나의 터미널에서 화면을 분할하여 사용할 수 있음       영구적인 세션을 제공하기에 작업 중에 원격 서버와의 연결이 끊겨도 작업 내용이 사라지지 않음           tmux 구조 : tmux 서버와 tmux 클라이언트로 구성      tmux를 실행하면 하나의 윈도우를 가진 새로운 세션이 생성되어 화면에 출력            화면 아래의 상태 표시줄에 현재 세션에 대한 정보가 표시, interactive commands를 입력할 때 사용                      세션 (Session) : 하나 이상의 윈도우가 있는 독립된 작업 공간             세션은 tmux 서버에서 실행되는 프로세스로, tmux가 관리하는 가상 터미널       세션은 1개 이상의 tmux 클라이언트로 접속할 수 있음                윈도우 (Window) : 동일한 세션에서 시각적으로 분리된 부분             세션은 무조건 1개 이상의 윈도우를 가짐       윈도우는 인덱스로 구분되며, 0번부터 시작                패널 (Panel) : 동일한 윈도우에서 분리된 부분             패널은 윈도우 내에 1개 이상 존재하면서, 입력을 받는 부분                상태 바 (Status bar) : 세션, 윈도우, 패널에 대한 정보를 볼 수 있는 초록색 바       tmux 명령어 : 세션, 윈도우, 패널의 범위에 영향을 미치는 명령어들이 존재                              tmux 명령어 이름             tmux 명령어 설명                                         세션 관련                               tmux             새로운 세션 시작                               tmux new -s {이름}             특정 이름을 가진 새로운 세션 시작                               tmux ls             현재 열린 세션 목록 나열                               tmux rename-session -t {기존 이름} {새로운 이름}             기존 이름을 가진 세션을 새로운 이름으로 변경                               tmux attach             마지막 세션으로 접속                               tmux attach -t {이름}             특정 이름을 가진 세션으로 접속                               ctrl+b → d             현재 세션 나가기                               tmux kill-session -t {이름}             특정 이름을 가진 세션을 종료                               (tmux에서) exit             (세션 내부에서) 현재 세션 종료                               (tmux에서) ctrl+b → :             (세션 내부에서) tmux 명령 모드 진입                               윈도우 관련                               ctrl+b → c             새로운 윈도우 생성                               ctrl+d             현재 윈도우 종료 (만약 윈도우가 1개면, 현재 세션 종료)                               ctrl+b → &amp;             모든 윈도우 종료                               ctrl+b → p             이전 윈도우로 이동                               ctrl+b → n             다음 윈도우로 이동                               ctrl+b → l             마지막 윈도우로 이동                               ctrl+b → {0 ~ 9}             특정 번호를 가진 윈도우로 이동                               ctrl+b → ,             현재 윈도우 이름 바꾸기                               ctrl+b → w             현재 열린 윈도우 목록 나열                                ctrl+b → [             copy 모드로 전환 (스크롤 가능)                               패널 관련                               ctrl+b → \"             현재 패널을 가로로 나누기                               ctrl+b → %             현재 페널을 세로로 나누기                               ctrl+b → {방향키}             현재 패널에서 방향키 방향의 패널으로 이동                               ctrl+b → z             현재 패널 확대/축소 전환                               ctrl+b → ␣             현재 패널에서 다른 패널으로 순환                               ctrl+b → x             현재 패널 삭제                ","categories": [],
        "tags": ["Linux"],
        "url": "/tmux1/",
        "teaser": null
      },{
        "title": "[Clean Code] 1. 깨끗한 코드",
        "excerpt":"코드 (Code) : 프로그래밍의 결과로서 요구사항을 상세히 표현하는 수단      프로그래밍 (Programming) : 요구사항을 상세히 명시하는 작업            나쁜 코드는 프로젝트의 개발 속도를 떨어뜨리며, 팀 생산성을 떨어뜨림       나쁜 코드는 나쁜 코드를 ‘유혹’한다 : 나쁜 코드를 고치면서 오히려 더 나쁜 코드를 만들어냄           그렇다면, 깨끗한 코드란 무엇인가?     by 비야네 스트롭스트룹            보는 사람에게 즐거움을 선사하는 ‘우아한’ 코드       시간과 자원을 낭비하지 않는 ‘효율적인’ 코드       세세한 사항까지 철저히 오류 처리를 하는 코드       ‘깨끗한 코드란 한 가지를 잘한다.’ : 나쁜 코드는 많은 일을 하려 애쓰다가 의도와 목적이 흐려진다.           by 그래디 부치            ‘잘 쓴 문장처럼 읽혀야 한다.’ → 가독성 높은 코드       ‘명쾌한 추상화와 단순한 제어문’ → 추측이 아니라 사실에 기반한 코드           by 데이브 토마스            다른 사람이 고치기 쉬운 코드       테스트 케이스가 존재하는 코드       작을수록 좋은, ‘최소한의’ 코드           by 마이클 페더스            작성자가 모든 사항을 고려하여, 주의 깊게 작성한 코드       시간을 들여 깔끔하고 단정하게 정리된 코드           by 론 제프리스            중복을 피하고, 한 기능만을 수행하면서, 표현력이 높으며, 초반부터 간단한 추상화를 고려한 코드           by 워드 커닝햄            읽으면서 ‘짐작했던 기능을 그대로 수행’하는 코드       언어를 단순하게 보이도록 만드는 책임이 우리에게 달려 있음           우리가 저자다 : 저자에게는 독자와 잘 소통할 책임이 있다.     코드를 짤 때에는 자신이 저자라는 사실을, 그리고 저자의 노력을 보고 판단할 독자가 잊지 말자!   저자 역시 독자다 : 새 코드를 짜면서 끊임없이 기존 코드를 읽기에, 읽기 쉽게 만들면 짜기 또한 쉽다.   보이스카우트 규칙 : “캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.”     Check-out할 때보다 좀 더 깨끗한 코드를 Check-in한다면, 코드는 절대 나빠지지 않는다.      Reference          클린 코드 Clean Code     ","categories": [],
        "tags": ["Clean Code"],
        "url": "/clean_code1/",
        "teaser": null
      },{
        "title": "[Engineer Information Processing] 1. 소프트웨어 공학 & 개발 방법론",
        "excerpt":"소프트웨어 (Software) : 프로그램과 프로그램 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭      프로그램 (Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합   자료구조 (Date Structure) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭            데이터 간의 논리적 관계나 데이터를 처리하는 알고리즘을 의미           문서 (Document) : 소프트웨어를 개발하면서 작성하는 문서들을 총칭            사용자 설명서, 소프트웨어 요구 분석서, 평가서, 명세서, 프로젝트 계획서, 감사 계획서 등을 의미           소프트웨어의 특징      상품성 : 소프트에어를 개발하면 상품이 되어 판매할 수 있다.   복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.   변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.   복제성 : 복제가 쉬워 쉅게 복사 및 유통이 가능하다.   순응성 : 기술의 발전, 사용자 요구, 사회적 흐름의 변화에 맞춰 적절히 변형된다.   비가시성 : 소프트웨어 구조는 외관으로 나타나 있지 않고 코드로 내재되어 있다.   소프트웨어의 분류      시스템 소프트웨어 (System Software) : 하드웨어를 관리하고 컴퓨터 자원을 활용하는 소프트웨어            운영체제, 컴파일러, 로더, 디버거 등           응용 소프트웨어 (Application Software) : 사용자가 원하는 목적에 맞게 만들어진 소프트웨어            엑셀, 파워포인트, 워드프로세서, 포토샵 등           미들웨어 소프트웨어 (Middleware) : 시스템 소프트웨어와 응용 소프트웨어를 연결해주는 중간 단계의 소프트웨어            데이터베이스 관리 시스템, 웹 서버, 어플리케이션 서버, 트랜잭션 처리 모니터 등           시스템 (System) : 컴퓨터로 처리할 자료를 입력해 저장, 처리, 가공해 출력하도록 설계 및 구현된 정보 체계      하나의 목적을 위해 시스템의 여러 요소들이 유기적으로 결합된 것            입력 (Input) : 처리 방법, 제어 조건, 처리할 데이터를 시스템이 투입하는 요소       출력 (Output) : 처리된 결과를 시스템에서 출력하는 요소       처리 (Process) : 입력된 자료를 처리 조건에 따라 변환 및 가공하는 요소       제어 (Control) : 시스템의 기본 요소들이 각 과정을 올바르게 행하는지 감독하는 요소       피드백 (Feedback) : 처리된 결과를 측정 및 파악하여 목표에 도달되었는지 검사하고, 만약 불충분한 경우에 목표 달성을 위해 다시 입력하는 요소           소프트웨어의 위기 (Software Crisis) : 소프트웨어 개발 속도가 하드웨어 개발 속도을 따라가지 못함      하드웨어 비용을 초과하는 개발 비용의 증가   개발 기간의 지연   개발 인력의 부족 및 인건비 상승 → 개발 인력을 최대한 많이 투입하는 것은 해결책이 아님   성능 및 신뢰성 부족   유지보수의 어려움에 따른 엄청난 비용   소프트웨어 공학 (Software Engineering) : 경제적으로 신뢰도 높은 소프트웨어를 만드는 체계      전기전자공학자협회 (IEEE) → 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법으로 정의   소프트웨어의 등장 배경      소프트웨어 개발에 필요한 시간과 비용 예측력이 부족   개발된 소프트웨어의 품질 수준이 부족   하드웨어에 대한 소프트웨어의 상대적인 비용이 증대   유지보수 역할의 증대   하드웨어 및 소프트웨어 기술의 급속한 발전   크고 복잡한 소프트웨어에 대한 수요의 증가   특정 개인에 의존하는 시스템의 개발   소프트웨어 공학의 분류      소프트웨어 개발 생명주기 모형 : 소프트웨어를 개발하는 과정을 단계별로 분류한 모형            폭포수 모형, 프로토타입 모형, 나선형 모형, 에자일 개발 방법론 등           소프트웨어 프로세스 모형 : 소프트웨어 개발을 위한 절차와 방법을 제공하는 모형            ISO/IEE 12207, CMM1 등           소프트웨어 품질 관리 : 소프트웨어 개발 과정에서 품질을 유지하고 향상시키기 위한 관리 기법을 연구하는 것            테스트, 코드 리뷰, 정적 분석 등           소프트웨어 유지보수 : 개발된 소프트웨어를 사용하고 보수하는 과정을 연구하는 것            버그 수정, 기능 추가, 기술 업그레이드 등           소프트웨어 공학의 기본 원칙      현대적인 프로그래밍 기술이 적용되어야 한다.   신뢰성이 높아야 한다.   사용의 편리성과 유지보수성이 높아야 한다.   지속적인 검증 시행을 해야 한다.   사용자가 원하는 대로 동작해야 한다.   시스템의 안전성와 보안에 최선을 다해야 한다.   최신 프로그램 언어, 최신 알고리즘 사용 현황을 확인해야 한다.   소프트웨어 개발 비용을 최소화하도록 노력해야 한다.   개발 단계와 소스 코드 등의 문서화를 통해 명확성을 유지해야 한다.   공학적으로 좋은 소프트웨어의 조건      신뢰성이 높고 효율적이여야 하며, 사용자의 의도대로 동작해야 한다.   편리성 제공 및 잠재적 에러를 최소화해야 한다.   유지보수성이 쉬워야 한다.   소프트웨어 공학 계층 구조      도구 : 프로세스와 방법을 처리하는 기능을 제공   방법론 : 소프트웨어를 설계하는 데 기술적인 방법을 제공하는 것   프로세스 : 소프트웨어의 가장 기초가 되며, 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미   소프트웨어 공학의 목표      최소의 비용으로 단기간에 적합한 소프트웨어를 개발하는 것   소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를  ","categories": [],
        "tags": ["Engineer Information Processing"],
        "url": "/engineer_information_processing1/",
        "teaser": null
      },{
        "title": "[System Design Interview] 1. 사용자 수에 따른 규모 확장성",
        "excerpt":"시스템 디자인 면접 (System Design Interview) : 시스템 아키텍처를 설계하는 면접      질문 범위도 매우 크고 모호하며, 답변 절차 또한 정형화되어 있지 않음            시스템에 따른 변이 (variation)이 많음                    의사소통 및 문제 해결 능력이 소프트웨어 엔지니어의 필요 능력과 비슷함           지원자들은 그 모호한 문제를 어떻게 분석하고 단계적으로 해결하는지를 확인                            문제 해결 아이디어를 어떻게 설명하고 토론하는지?               문제 해결 아이디어를 어떻게 평가하고 개선하는지?                                                   사용자 수에 따른 규모 확장성 : 사용자가 얼마나 되는지에 따라 변화하는 시스템 설계   단일 서버 : 모든 컴포넌트가 단 한 대의 서버에서 실행되는 시스템을 설계      웹, 어플리케이션, 데이터베이스, 캐시 모두가 하나의 서버에서 실행      단일 서버에서 사용자의 요청이 처리되는 과정          사용자는 도메인 네임을 이용해 웹 사이트에 접속한다.                도메인 네임을 DNS (Domain Name Service)에 질의한다.         DNS 조회 결과로 IP 주소 (웹 서버의 주소)가 반환된다.                 해당 IP 주소로 HTTP 요청이 전달된다.     요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.         그렇다면 실제 요청은 어디에서 오는가?            웹 어플리케이션인 경우?                    비즈니스 로직의 구현과 데이터 저장의 처리를 위한 서버 구현           사용자에게 표현하기 위한 클라이언트 구현                       모바일 앱인 경우?                    모바일 앱과 웹 서버 간의 통신에는 HTTP 프로토콜을 이용           HTTP 프로토콜을 통해 반환될 응답 데이터의 포맷으로 JSON을 사용                           데이터베이스 서버 : 트래픽을 처리할 서버 (웹 계층)에 DB 서버 (데이터 계층)을 증설      어떤 데이터베이스를 사용할 것인가?            관계형 데이터베이스를 선택할 경우?                    관계형 데이터베이스 관리 시스템 (RDBMS) : MySQL, …           자료를 테이블, 열, 칼럼으로 표현           여러 테이블에 있는 데이터를 그 관계에 따라 조인 (join)                       비관계형 데이터베이스 (NoSQL)를 선택할 경우?                    저장소 : 키-값 (key-value), 그래프 (graph), 칼럼 (column), 문서 (document)                       비관계형 데이터베이스가 최선인 경우는 언제?                    아주 낮은 지연 시간 (latency)이 요구됨           다루는 데이터가 비정형 (unstructured) 데이터임           JSON 등 데이터를 직렬화 (serialize)하거나 역직렬화할 수 있기만 하면 됨           아주 많은 양의 데이터를 저장해야 함                           수직적 규모 확장 vs 수평적 규모 확장?      수직적 확장 (scale-up) : 서버에 고사양 자원을 추가            서버로 유입되는 트래픽의 양이 적을 때 최선       단순하지만, 한계가 명확함 : 하나의 서버에 CPU나 메모리를 무한대로 증설할 수 없음       장애에 대한 자동 복구 (failover)이나 다중화 (re-dundancy) 방안을 제시하지 않음                    서버에 장애가 발생하면, 어플리케이션이 그대로 중단된다.                           수평적 확장 (scale-out) : 더 많은 서버를 추가하여 성능을 개선            로드밸런서 (Load balancer) : 부하 분산 집합 내의 웹 서버들에게 트래픽 부하를 분산                    로드밸런서의 공개 IP로 접속 : 웹 서버가 클라이언트의 접속을 직접 처리하지 않음           같은 네트워크 내의 서버 간 통신에는 사설 IP 주소 사용           장애를 자동으로 복구하지 못하는 문제 (no failover) 해소                            서버 a가 오프라인으로 상태가 변경되어도 모든 트래픽이 서버 b로 전송                                   웹 계층의 가용성 (availability) 향상                            로드밸런서를 통해 트래픽을 자동적으로 분산 가능                                               데이터베이스 다중화 : 원본은 master 서버에, 사본은 slave 서버에 저장                    쓰기 연산 (write)과 DB를 변경하는 명령어의 입력은 master 서버에서만 가능           slave 서버는 master 서버에서 사본을 전달받아, 읽기 연산 (read)만을 지원                            성능 향상 : 다중화 모델을 통해 병렬로 처리될 수 있는 질의 (query)의 수 증가               안정성 (reliability) : 다중화된 DB를 여러 곳에 분산 가능               가용성 (availability) : 어떤 DB 서버에 장애가 발생해도 서비스 지속 가능                                   DB 서버 하나가 오프라인 상태가 된다면?                            1대뿐인 slave 서버가 오프라인 상태인 경우?                                    읽기 연산이 한시적으로 모두 master 서버로 전달                                               여러 대의 slave 서버 중 하나가 오프라인 상태인 경우?                                    읽기 연산이 나머지 slave 서버로 분산                                               1대뿐인 slave 서버를 가진 master 서버가 오프라인 상태인 경우?                                    해당 slave 서버가 master 서버가 돠어 모든 DB 연산 수행                   프로덕션 (production) 환경 : slave 서버의 데이터가 최신이 아닐 수도 있음                                            복구 스크립트 (recovery script)를 통한 추가                                                                                                                           로드밸런서와 데이터베이스 다중화를 고려한 설계            사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.       사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.       HTTP 요청은 서버 1이나 서버 2로 전달된다.       웹 서버는 사용자의 데이터를 slave 데이터베이스에서 읽는다.       웹 서버는 데이터 변경 연산을 master 데이터베이스로 전달한다.           캐시 (Cache) : 응답 시간 (latency) 개선을 위해 데이터를 잠시 보관      캐시 계층 : 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 보관            주도형 캐시 전략 (read-through caching strategy)                    만약 데이터가 캐시에 있다면, 캐시에서 데이터를 읽음                            데이터가 캐시에 없다면, DB에서 해당 데이터를 읽어 캐시에 씀                                   캐시에서 웹 서버로 데이터를 반환함                           캐시를 사용할 때 고려해야 할 점?            캐시는 어떤 상황에 바람직한가? : 갱신이 드물지만, 참조가 빈번한 데이터       어떤 데이터를 캐시에 저장? : 영속적이지 않은 데이터       캐시 내의 데이터는 어떻게 만료 (expire)할까? : 캐시에서 정책에 따라 삭제       일관성 (consistency)는 어떻게 유지할까? : 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션으로 처리되어야       장애에는 어떻게 대처할까? : 단일 장애 지점의 발생을 피해 캐시 서버를 분산       캐시 메모리의 크기는? : 캐시 메모리를 과할당 (over-provision)       데이터 방출 (eviction) 정책은? : LRU, LFU 등을 경우에 맞게 적용           컨텐츠 전송 네트워크 (CDN) : 정적 컨텐츠의 전송에 쓰이는 분산 서버 네트워크      정적 컨텐츠 (이미지, 비디오, CSS, JavaScript 파일 등)을 캐시   사용자가 웹 사이트에 방문하면, 가장 가까운 CDN 서버가 정적 컨텐츠를 전달           사용자가 이미지 URL를 통해 image.png에 접근한다.                URL의 도메인은 CDN 서비스 사업자가 제공                 CDN 서버의 캐시에 해당 이미지가 없으면 원본 서버에서 파일을 요청                원본 서버가 파일을 반환할 때, 응답 HTTP 헤더는 TTL 값을 포함                 CDN 서버는 파일을 캐시하고 사용자에 반환 (TTL 값만큼 캐시)                사용자가 만료가 안된 이미지의 요청을 CDN 서버에 전송하면, 캐시로 처리                     CDN 사용 시 고려할 사항?            비용 : 자주 사용되지 않는 컨텐츠를 캐싱하는 것은 비효율적       만료 기한 : time-sensitive한 컨텐츠의 만료 기한은 신중히 설정해야 함       CDN 장애 대처 방안 : CDN이 오프라인 상태일 때의 동작에 대한 고려       컨텐츠 무효화 (Invalidation) 방법 : CDN 서비스 사업자가 제공하는 API를 이용한 컨텐츠 무효화                    컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 (object versioning) 이용                           CDN과 캐시를 추가한 설계            정적 컨텐츠는 웹 서버가 아닌 CDN을 통해 서비스됨       캐시를 통해 데이터베이스의 부하가 줄어들 수 있음           무상태 (stateless) 웹 계층 : 웹 계층을 수평적으로 확장하는 방법      사용자 세션 데이터와 같은 상태 정보를 웹 계층에서 제거해야 함   상태 정보를 관계형 DB나 NoSQL과 같은 지속성 저장소에 보관하고 필요할 때 가져옴   상태 정보 의존적인 아키텍쳐 : 클라이언트 정보에 대한 상태를 유지하며 요청들 사이에 공유      사용자 A의 상태 정보가 서버 1에 저장되면,            해당 사용자 인증에 대한 HTTP 요청은 해당 서버로만 가야 한다.       다른 서버로 가면 사용자 인증은 무조건 실패한다.           같은 클라이언트로부터의 요청은 항상 같은 서버로만 전송된다.            고정 세션 (sticky session) 기능을 지원하는 로드밸런서에 부담을 준다.       로드밸런서 뒷단에 서버를 추가 및 제거가 어렵고, 서버의 장애 처리 또한 복잡해진다.           무상태 아키텍처 : 사용자로부터의 HTTP 요청은 어떤 웹 서버로도 전달 가능함      웹 서버는 상태 정보가 필요할 때에 공유 저장소 (Shared Storage) 에서 데이터를 가져옴            상태 정보는 웹 서버로부터 물리적으로 분리              Reference          가상 면접으로 배우는 대규모 시스템 설계     ","categories": [],
        "tags": ["System Design Interview"],
        "url": "/system_design_interview1/",
        "teaser": null
      },{
        "title": "[Git] Git 개념 및 명령어 정리",
        "excerpt":"버전 관리 (Version Control) : 특정한 시간 기준으로 파일 변화를 저장하고 관리      버전 (Version) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용   1. 로컬 버전 관리 (Local Version Control)     로컬 사용자가 서버 없이 로컬 컴퓨터 내의 데이터베이스를 이용해 파일의 변경 정보 관리            협업에서 사용하기 어려움, 내부 정보가 손상되면 복구할 방법이 없음           2. 중앙집중식 버전 관리 (Central Version Control) : 서브 머신 (SVN)     클라이언트가 최종본를 관리하는 데이터베이스 서버로부터 개별 파일을 로컬에 다운로드, 수정본을 서버에 올림            데이터베이스 서버에 의존적, 협업 규모가 커지면 수정 충돌 문제 발생 (유사 사례 : 나무위키의 편집 충돌)           3. 분산형 버전 관리 (Distributed Version Control) : 깃 (Git)     클라이언트가 원격 저장소에서 전체 기록과 각 기록을 추적할 수 있는 정보를 포함한 데이터를 로컬 저장소에 저장            클라이언트가 자신의 작업을 원격 저장소에 독립적인 로컬 저장소에 버전별로 저장하고 관리       여러 클라이언트들의 작업을 여러 로컬 저장소로 다원화해 각 클라이언트는 충돌의 염려 없이 작업 가능       필요한 경우에 클라이언트가 서버의 원격 저장소에 원하는 버전을 통합 (서버 단위의 편집 버전을 +1)                    클라이언트는 원격 저장소에 자신의 작업을 통합시킬 때만 서버와 통신하면 됨                           깃 (Git) : 분산형 버전 관리 시스템 (Distributed Version Control System)     터미널 창에 다음 명령어를 입력해 homebrew를 통해 git 설치   brew install git   .gitignore 디렉터리 : 버전 관리를 하지 않을 파일이나 디렉터리, 혹은 파일 확장자를 설정      특정한 이름을 가진 파일 제외   filename.txt      특정한 확장자를 가진 파일 제외   *.txt      특정한 경로 아래의 파일 제외   folder/      특정한 경로 아래의 특정한 확장자를 가진 파일 제외   folder/filename.txt      예외 만들기   !filename.txt   README.md 파일 : 프로젝트에 대한 설명과 사용 방법, LICENSE 등의 내용을 작성     기존의 Markdown에 깃허브에서만 사용 가능한 기능을 추가한 Github Flavored Markdown을 이용   Github 프로젝트 레포지토리 페이지에서 README.md가 표현된 것을 확인 가능            자신의 아이디와 같은 이름의 레포지토리의 README.md는 해당 사용자의 깃허브 프로필에 표시됨                 뱃지 : 해당 사이트에서 뱃지의 구성 요소들을 직접 지정해 생성한 후 img 태그로 삽입   &lt;img src=\"https://img.shields.io/badge/(아이콘 내용)-(아이콘 색상)?style=flat-square&amp;logo=(로고 이름)&amp;logoColor=(로고 색상)\"/&gt;         방문자 수 : 해당 사이트에서 Target URL과 로고를 선택한 후 a 태그로 삽입   &lt;a href=\"https://github.com/pocj8ur4in\"&gt; ... &lt;/a&gt;         Solved.ac 티어 : 해당 사이트에서 마크다운 언어로 삽입   [![Solved.ac 프로필] (http://mazassumnida.wtf/api/v2/generate_badge?boj={백준ID})] (https://solved.ac/{백준ID})         Solved.ac 잔디 : 해당 사이트에서 img 태그로 삽입   &lt;img src=\"http://mazandi.herokuapp.com/api?handle={백준ID}&amp;theme=warm\"/&gt;         자주 사용한 언어 : 해당 사이트에서 마크다운 언어로 삽입   [![Top Langs] (https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브ID)] (https://github.com/깃허브ID/github-readme-stats)      .git 디렉터리 : 깃의 버전을 저장할 로컬 저장소     버전 (Version) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용            작업 트리 (Working Tree) : 파일 수정, 저장 등의 작업을 하는 작업 디렉터리                    스테이징 (Staging) : 작업 트리에서 작업한 파일을 버전으로 만들기 위해 스테이지로 이동                       스테이지 (Stage) : 버전으로 만들 파일이 대기하는 스테이징 영역                    커밋 (Commit) : 스테이지에서 대기중인 파일을 버전으로 만들어 레포지토리에 저장                       레포지토리 (repository) : 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 저장소                    푸시 (Push) : 로컬 (local) 레포지토리에서 원격 (remote) 레포지토리로 커밋을 커밋 내역을 보냄                           깃 명령어 (Git Command) : git &lt;command&gt; 형식으로 구성      git : 깃 명령 다음에 입력할 수 있는 명령어 옵션 확인   $ git ...      git init : 깃 저장소를 만들 디렉터리 초기화 (깃 저장소인 .git 디렉터리가 생성)   $ git init Initialized empty Git repository in ...      git status :  깃의 현재 상태 확인            untracked 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하지 않습니다. (파일이 스테이지에서 대기 : false)       tracked 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하고 있습니다. (파일이 스테이지에서 대기 : true)                    unmodified 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되지 않았습니다.                            Working tree clean                                   modified 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었으나 스테이징되지 않았습니다.                            Changes not stage for commit:                                   staged 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었고 스테이징되었습니다.                            Changes to be committed:                                                   $ git status On branch master  // 현재 master 브랜치에 위치해 있음 No commits yet    // 아직 커밋한 파일이 존재하지 않음 nothing to commit // 현재 커밋한 파일이 존재하지 않음  $ git status On branch master No commits yet untracked files   // untracked 상태 : 아직 버전 관리하지 않은 파일들이 존재함      git add : 작업 트리에서 스테이지로 스테이징            -a 옵션을 통해 모든 파일을 스테이징           $ git add helloWorld.txt      git commit : 스테이지에 있는 파일을 버전으로 커밋            -m 옵션을 통해 커밋과 함께 메시지 저장       -am 옵션을 통해 스테이징과 커밋을 동시에 처리           $ git commit -m \"message1\"      git ls-files : tracked 상태인 파일들을 확인   $ git ls-files      git log : 레포지토리에 저장된 버전 정보 확인            커밋 해시 (commit hash) : 커밋을 구별하는 ID (HEAD-&gt;master : 해당 버전이 가장 최신임을 표시)       작성자 (Author) : git config --global user를 통해 입력한 사용자 정보 (이름과 이메일)       작성일 (Date) : 버전이 작성된 시각       커밋 메시지 (commit message) : git commit -m을 통해 저장된 메시지              다양한 옵션을 통해 필요한 요소를 확인할 수 있음 (--oneline, --graph 등등)    $ git log      git remote : 로컬 레포지토리에 설정된 원격 레포지토리의 목록 확인            -v 옵션을 통해 원격 레포지토리의 주소 확인       add {이름} {주소} 옵션을 통해 로컬 레포지토리에 원격 레포지토리를 연결       rm {이름} 옵션을 통해 저장소 삭제           $ git remote      git clone : 원격 레포지토리를 복사해 로컬 레포지토리로 저장   $ git clone      git push : 로컬 레포지토리의 커밋 내역을 원격 레포지토리에 반영   $ git push      git pull : 원격 레포지토리의 커밋 내역을 로컬 레포지토리에 반영   $ git pull   브랜치 (Branch) : 원본에서 가지치기해 복사한 소스를 가지고 별도의 버전을 새로 생성      git branch {이름} : 브랜치 생성   git branch : 브랜치 목록 확인   git checkout {이름}/git switch {이름} : 특정 브랜치로 이동  ","categories": [],
        "tags": ["Git"],
        "url": "/git1/",
        "teaser": null
      },{
        "title": "[Algorithm] 3. 그리디",
        "excerpt":"그리디 (Greedy) : 매 순간 가장 좋은 것을 선택 (현재의 선택이 나중에 미칠 영향은 고려 X)      사전에 외우고 있지 않아도, 풀 수 있을 가능성이 높음   특정 문제를 만났을 때, 그리디 알고리즘을 적용해 문제를 풀 수 있을지 파악할 수 있어야 함   ‘가장 큰 순서대로’, ‘가장 작은 크기부터’와 같은 기준이 제시됨   (1) 문제 풀이를 위한 최소한의 아이디어를 떠올리고, (2) 그것이 정당한지 검토해야 답을 도출할 수 있음   BOJ 11047번. 동전 0 (S4)   import sys read = sys.stdin.readline  N, K = map(int, read().split()) O = 0 C = list([read() for i in range(N)])  for i in range(N):     if (K &lt; int(C[N - 1 - i])):         continue     else:         while (K &gt;= int(C[N - 1 - i])):             K -= int(C[N - 1 - i])             O += 1      print(O)   BOJ 1931번. 회의실 배정 (S1)   import sys read = sys.stdin.readline  N = int(read()) li = [list(map(int, read().split())) for i in range(N)]  li.sort(key=lambda x: [x[1], x[0]])  R = 1 C = li[0][1]  for i in range(N - 1):     if C &lt;= li[i + 1][0]:         C = li[i + 1][1]         R += 1  print(R)   BOJ 11399번. ATM (S4)   import sys read = sys.stdin.readline  N = int(read()) li = list(map(int, read().split())) li.sort()  s = 0  for i in range(N):     s += li[i] * (N - i)  print(s)   BOJ 1541번. 잃어버린 괄호 (S2)   import sys read = sys.stdin.readline  li = read().split('-') r = 0  for i in range(len(li)):     s = li[i]     s = s.split('+')     s = list(map(int, s))     s = sum(s)     if i == 0:         r = s     else:         r -= s  print(r)   BOJ 13305번. 주유소 (S3)   import sys read = sys.stdin.readline  N = int(read()) L = list(map(int, read().split())) P = list(map(int, read().split()))  C = 0 S = L[C] * P[C]  for i in range(1, N - 1):     if L[i] * P [C] &gt; L[i] * P[i]:         C = i     S += L[i] * P [C]  print(S)  ","categories": [],
        "tags": ["Algorithm"],
        "url": "/algorithm3/",
        "teaser": null
      },{
        "title": "[Java] 1. Java",
        "excerpt":"자바 (Java) : 객체지향 프로그래밍 언어 (Object-Oriented Programming Language)      객체지향 프로그래밍 (OOP) : 초기부터 객체지향 방법론에 의거해 객체 지향 프로그램 언어로 설계            먼저 객체를 만들고, 이들 객체들을 서로 연결하여 하나의 큰 프로그램을 완성           플랫폼에 독립적 : 동일한 프로그램을 여러 운영체제에서 실행 가능            어떤 운영체제인지 상괸없이 동일한 .java 파일을 컴파일하면, 동일한 .class 파일이 생성       WORA : Write Once, Run Anywhere           메모리를 자동으로 정리 : 가비지 콜렉터 등을 활용해 RAM을 자동으로 관리   풍부한 래퍼런스 : 오픈 소스 라이브러리를 기반으로 한 자바 생태계가 장기간 구축되어왔음   Java SE : Java의 표준 문법 (Standard Edition)      Java가 어떤 문법적인 구성을 가졌는지, 와 같은 것들을 정의      Oracle에서 Java 공식 로드맵을 통해 자바의 미래 버전 적용 상황을 볼 수 있음    JDK (Java Development Kit) : Java SE의 구현체      Java 프로그램을 개발하고 실행하기 위해 JRE 및 여러 개발 도구들을 제공   자바 런타임 환경 (Java Runtime Environment) : Java를 위한 서비스를 제공하는 소프트웨어 계층      JRE는 컴퓨터 운영체제 위에서 존재하며, JVM 및 라이브러리로 구성   자바 코드를 필요한 라이브러리와 결합한 뒤에 JVM을 시작하는 온디스크 시스템   자바 가상 머신 (Java Virtual Machine) : 서로 다른 플랫폼에 동일한 Java 실행 환경 제공      플랫폼에 종속적 : 자바에서 소스 파일을 통해 생성된 바이트 코드를 CPU에 맞게 바이너리 코드로 해석한 후 실행            소스 코드 (source code) : Java 언어로 작성된 소스 파일 (*.java)       바이트 코드 (byte code) : 소스 코드를 JVM이 이해할 수 있는 언어로 변환한 파일 (*.class)       바이너리 코드 (binary code) : 컴퓨터가 이해할 수 있는 1bit 크기의 0과 1로 이루어진 이진 코드           클래스 로더 (Class Loader) : JVM 내로 .class 파일을 로드하고 이를 실행 엔진에 배치      메소드 영역에 저장되는 데이터 : FQCN / 클래스, 인터페이스, enum / 메소드와 변수           로딩 (Loading) : JVM이 시작할 때, 3개의 클래스 로더가 순서대로 동작             BootStrap ClassLoader : JDK 클래스 파일 (코어 자바 API) 로딩       Platform ClassLoader : JAVA_HOME/lib/ext 또는 java.ext.dirs에 위치한 클래스 파일 로딩       System ClassLoader : classPath나 modulePath에 위치한 클래스 파일 로딩                 마지막까지 클래스를 찾지 못하면 ClassFoundException                링크 (Linking) : 로드된 .class 파일을 검사하고 이를 메소드 영역에 넣음             검증 (Verify) : .class 파일 형식이 유효한지 검사       준비 (Preparation) : 클래스 변수 (static)와 기본값에 필요한 메모리를 준비       교체 (Resolve) : 심볼릭 메모리 래퍼런스를 메소드 영역에 있는 실제 래퍼런스로 교체                초기화 (Initialization) : static 변수 또는 static 블록 내부의 값을 기본값으로 할당       자바 실행 엔진 (Execution Engine) : 클래스 로더에 의해 배치된 클래스의 바이트 코드를 실행      자바 인터프리터 (Java Interpreter) : JVM에서 바이트 코드를 한줄씩 명령어 단위로 읽어 번역   JIT 컴파일러 : 인터프리터 방식으로 실행하다가, 적절한 시점에 바이트 코드 전체를 바이너리 코드로 번역해 실행   가비지 콜렉터 (Garbage Collector) : 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제해 메모리를 관리   런타임 데이터 에리어 (Runtime Data Area) : 운영체제에서 프로그램 수행을 위해 할당한 메모리 공간      PC 레지스터 (PC Register) : 쓰레드 (Thread)가 시작될 때 생성되는 공간            쓰레드가 현재 실행할 스택 프레임을 가리키는 포인터 생성           JVM stack : 프로그램 실행 과정에서 임시로 할당할 데이터를 저장 (메소드 호출 시 마다 각각의 스택 프레임 생성)   Native method stack : 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행   힙 (Heap) : 모든 쓰레드가 공유하는 객체 저장            new로 생성된 객체와 배열 혹은 String 관련 자원이 저장 / GC에 의해 관리       Permanent Generation : 생성된 객체들의 정보의 주소값 저장                    리플렉션 (Reflection) 으로 동적으로 클래스가 로드될 때 사용           클래스 로더에 의해 로드된 클래스, 메소드 등에 대한 메타 정보가 저장 : JVM에 의해 사용                       New/Young : 생명 주기가 짧은 객체를 GC의 대상으로 하는 영역 (Minor GC 발생)                    Eden : 객체들이 처음 생성되는 공간 (첫번째 GC가 발생)           Survivor 0, 1 : Eden에서 참조되는 객체들이 저장 (Major GC 발생 : Minor GC에 비해 느림)                       Old : 생명 주기가 긴 객체를 GC의 대상으로 하는 영역                    New/Young에서 일정 시간 참조되고 있는 객체들이 저장                           메소드 영역 (Method Area) : 클래스를 메모리에 처음 올릴 때 초기화하는 클래스 이름, static 메소드나 변수 저장            Runtime Constant Pool : 상수 자료형을 저장해 참조 (중복 방지)           자바 네이티브 인터페이스 (Java Native Interface) : 자바 네이티브 코드로 작성된 함수 사용 방법 제공      자바 네이티브 코드 (Java Native Code) : 다른 언어로 작성된 라이브러리를 JVM 내에서 호출하는 코드   네이티브 메소드 라이브러리 (Native Method Library) : 네이티브 실행 프로그램을 만들 때 사용되는 라이브러리  ","categories": [],
        "tags": ["Java"],
        "url": "/java1/",
        "teaser": null
      },{
        "title": "[Java] 2. 변수 (variable)",
        "excerpt":"변수 (variable) : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름      변수의 선언 : 어떤 차입의 데이터를 저장할지, 그리고 변수의 이름이 무엇인지 결정   변수의 이름 : 첫번째 글자는 소문자로 시작하되, 캐멀 스타일 (Camel Style)로 작성하는 것이 관례   값의 대입 (=) : 선언된 변수에 값을 저장 → 변수의 초기화      원시 자료형 (Primitive type) : 선언 시 메모리 주소 위치 (JVM stack)에 실제 값이 저장   논리 리터럴 (Boolean) : 참과 거짓을 의미      논리 타입 (boolean) : true / false   정수 리터럴 (Integers) : 정수를      문자 (char) : ''를 이용해 표시 (초기값 : '\\0'=0)   바이트 (byte) : 데이터를 나타내는 바이트 값 (초기값 : 0)   정수 (short, int, long) : 2, 4, 8바이트 크기 내의 정수 (초기값 : 0)   실수 (float, double) : 4, 8바이트 크기 내의 실수 (초기값 : 0.0)   참조 자료형 (Reference type) : 선언 시 메모리 주소 위치에 실제 값이 가리키는 다른 주소를 저장     원시 자료형을 기초로 하여 만들어짐 → Non-Primitive type   실제 값은 Heap에 저장      자바는 주소값의 추상화를 금지함, Call by value만 가능 (C/C++ : 주소값 저장 (*) 및 추출 (&amp;) 가능)    var : 데이터 타입을 명시하지 않아도 지역 변수의 타입을 자동으로 추론하는 키워드     지역 변수만 사용 가능 (static 적용 불가)   선언과 함께 명시적인 초기화를 반드시 해야 함   NULL로 초기화할 수 없음   람다 표현식과 같이 사용할 수 없음   var s = 'String'; var n = 100;   변수의 스코프 (Scope) : 변수가 유효한 범위      접근 지정자 (access modifier) : 접근 가능한 수준 지정            public : 어느 클래스에서든 해당 클래스에 대해 접근 가능       protected : 해당 패키지와 같은 패키지 내에 있는 클래스와 상속받은 클래스가 해당 클래스에 접근 가능       default : 해당 클래스와 같은 패키지 내에 있는 클래스만이 해당 클래스에 대해 접근 가능       private : 해당 클래스 및 그 클래스를 포함한 클래스만이 해당 클래스에 대해 접근 가능           변수의 라이프타임 (LifeTime) : 변수가 메모리 영역에 저장되어 있는 시간      인스턴스 변수 (static block과 static method를 제외한 클래스 전체) : 객체가 생성되어 메모리에 존재하는 동안   클래스 변수 (클래스 전체) : 클래스가 초기화되고 프로그램이 끝날 때까지   로컬 변수 (변수가 선언된 블록의 내부) : 변수 선언 이후부터 블록을 벗어날 때까지   변수의 형변환 (Type Conversion) : 현재의 타입을 다른 타입올 바꾸는 것      boolean을 제외한 나머지 기본 자료형 간의 타입 변환이 가능       타입 프로모션 (Type Promotion) : 범위가 작은 데이터 타입의 값을 더 큰 범위의 데이터 타입에 할당 (묵시적 형변환)            byte &lt; short &lt; int &lt; long &lt; float &lt; double           int intN = 23; long longN = intN;      캐스팅 (Casting) : 범위가 큰 데이터 타입의 값을 더 작은 범위의 데이터 타입으로 할당 (명시적 형변환)   int n = 100; c = (char) n;      업캐스팅 (Up-Casting) : 부모-자식 관계의 객체에서 자식 객체를 부모 객체로 형변환 (묵시적 형변환)   다운캐스팅 (Down-Casting) : 부모-자식 관계의 객체에서 부모 객체를 자식 객체로 형변환 (명시적 형변환)   class MyClass {   String name;   String ID;    public MyClass(String name){     this.name = name;   } }  class StudentClass extends MyClass {   String grade;    public StudentClass(String name){     super(name);   } }  public class UpClass {   public Static void main(String[] args){     MyClass P;     StudentClass S = new StudentClass(\"I\");          P = S; // 업캐스팅 발생      System.out.println(P.name); // 컴파일 오류 없음      S = (StudentClass) P;   // 다운캐스팅 발생      System.out.println(S.name); // 컴파일 오류 없음   } }   배열 (Array) : 인덱스 (Index)와 그 인덱스에 대응하는 데이터들로 이루어진 선형 자료구조      배열의 생성 : 배열 공간을 할당받는 과정 (배열에 대한 래퍼런스 변수 선언 + 배열 생성)            래퍼런스 변수 : 메모리 상에 생성된 인스턴스를 가리키는 데에 사용되는 변수 (배열의 주소 값을 가짐)       new : 클래스의 새로운 객체를 생성할 때, 객체를 저장할 메모리를 할당하고 생성자를 호출해 객체를 초기화       = : 스택의 래퍼런스 변수가 힙의 배열 데이터를 가리킴           int[] intArray; intArray = new int [10]; int[] intArray = new int [10]; int[] intArray = {1,2,3,4,5,6,7,8,9};  int[][] intArray2; int intArray2 = new int[2][3]; int intArray2 = { {1, 2, 3}, {4, 5, 6} };      .length 필드 : 배열이 가진 길이 (원소의 개수)를 반환   len = intArray.length  len1 = intArray2.length     // 2차원 배열이 가진 행의 개수 len2 = intArray2[n].length  // 2차원 배열 중 n번째 행이 가진 열의 개수      비정방형 배열 : 행마다 열의 개수가 서로 다른 배열   int[][] intArray3 = new int[3][]; intArray3[0] = new int[1]; intArray3[1] = new int[2]; intArray3[2] = new int[3]; int intArray3 = { {0}, {1,2}, {3,4,5} };  int intArray3[][] = { {0}, {1,2}, {3,4,5} };      메소드의 배열 반환 : 실제 배열에 대한 래퍼런스가 반환   int makeArray() {     int t = new int[4];     return t; }  int[] intArr = makeArray();      객체 배열 : 객체에 대한 래퍼런스를 원소로 갖는 배열   Person[] people = new Person[20];  for(int i = 0; i &lt; people.length; i++){     people[i] = new Person();     people[i].age = 20 + i; }   객체 (Object) : 프로그램에서 사용되는 데이터 혹은 식별자에 의해 참조되는 공간      new : 객체를 생성하는 연산자   P = new Person(\"A\"); P.age = 30;      생성자 : 객체가 생성될 때 자동으로 호출되는 메소드 (객체에 필요한 초기화 수행)            this : 객체 자신을 참조           class MyClass {     int id;      public MyClass (int x) { // 생성자는 클래스 이름과 동일한 이름을 가짐         this.id = x;     }      public void MyFunc (int id) {         this.id = id;     }  }      this() : 동일한 클래스 내의 다른 생성자를 호출할 때 사용 (반드시 생성자의 첫 문장에서 사용되어야 함)   public MyClass {     String title;     int price;     int id = 0;      public MyClass(String title, int price, int id) {         this.title = title;         this.price = price;         this.id = id;         id += 1;     }      public MyClass(String title, int price, int id) {         this.title = title;         this.price = price;         this.id = id;         id += 1;     }      public MyClass(String title, int price) {         this(title, price, id);         id += 1;     }      public static void main(String[] args) {         MyClass mart1 = new MyClass(\"apple\", 100, 1);         MyClass mart2 = new MyClass(\"banana\", 200);     } }      가비지 컬렉션 (garbage Collection) : new로 할당받고 사용하지 않는 객체의 메모리 공간을 자동으로 JVM에 반환            소멸자 (delete)로 객체의 소멸을 명시해야 하는 C++과 달리, 자바는 소멸자가 필요 없음           클래스 (Class) : 객체를 생성하기 위해 변수와 메소드를 정의하는 틀      필드 (Field) : 객체의 상태 혹은 속성 (인스턴스 변수, static 변수)   public class MyClass {     String name;     static long id; }      메소드 (method) : 객체의 행동 (인스턴스 메소드, static 메소드)   public class MyClass {     string name;     long id;      string getName() {         return name;     }          long getID() {         return id;     }      void setName(String name) {         this.name = name;     }      void setID(long id) {         this.id = id;     } }      생성자 (Constructor) : 객체를 생성한 후에 필요한 초기화 작업을 수행하는 메소드   public class MyClass {     string name;     long id;      MyClass(String name, long id) {         this.name = name;         this.id = id;     } }      초기화 블럭 (Initializer) : 객체를 생성한 후에 필요한 초기화 작업을 세분화            클래스 초기화 블럭 : 클래스가 최초로 로딩될 때       인스턴스 초기화 블럭 : 인스턴스가 생성되었을 때           public class MyClass {     string name;     static long id;         // 클래스 초기화 블럭     static {         id = 1;     }         // 인스턴스 초기화 블럭     {         name = \"이름\";         id += 1;     } }      캡슐화 (Encapsulation) : 변수나 메소드는 반드시 클래스 내에서만 구현 가능 / 클래스 안의 내부 클래스 구현 가능     public class (클래스 이름) {     public static void main(String[] args {         ...     }      class (내부 클래스 1 이름) {         ...     }      static class (내부 클래스 2 이름) {         ...     }      void (내부 함수 이름)() {         ...     }     ... }       상속 (Inheritance) : 부모 클래스에 정의된 필드와 메소드를 자식 클래스가 물려받는 것     public class Person {    Person() { ... } ... } public class Student extends Person {   super(); // 부모 클래스의 생성자를 호출   ... }       instanceof : 객체의 타입을 검사하는 연산자 (상속 관계 &amp; 구현 관계 모두 포함)     ``` class Lee extends Student implements Person { … }     Lee lee = new Lee(); assertThat(lee instanceof Lee).isTrue(); assertThat(lee instanceof Student).isTrue(); assertThat(lee instanceof Animal).isTrue(); assertThat(lee instanceof Person).isTrue();       ```    main() : 해당 클래스를 자바 어플리케이션에서 실행하는 메소드      접근 제어자 public  : 다른 모든 클래스에서 호출 가능 (클래스 외부의 JVM에 의해 호출되어야 하므로)   static : 프로그램 시작부터 메모리에 저장됨 (프로그램이 시작할 때부터 JVM에 의해 호출되어야 하므로)   void : 종료 코드를 등록하기 위해 int를 반환해야 하는 ```C``와 달리, 종료 코드를 등록할 필요 없음   String[] args : 명령줄에 주어진 모든 인자를 문자열로 처리해 main()에 전달   public class (클래스 이름) {     public static void main(String[] args {         ...     } }      static : 모든 객체에 공통으로 사용하기 위해 정적으로 선언 (프로그램 시작부터 메모리에 저장)          static 메소드는 static 멤버만 사용할 수 있고, this 키워드를 사용할 수 없음      final : 오직 한 번만 할당할 수 있어 항상 같은 값을 가지는 entity를 정의할 때 사용하는 키워드      final 클래스 : 클래스가 상속받을 수 없음   public final class MyClass { ... }      final 메소드 : 오버라이딩으로 수정할 수 없음   public final class MySuperClass {      protected final void MyFunc() { ... } } public final class MyClass extends MySuperClass {      protected final void MyFunc() { ... } // 컴파일 오류 }      final 변수 : 한번 값을 할당하면 수정할 수 없는 상수 정의   static float Pl = 3.141592;   어노테이션 (Annotation) : 컴파일 &amp; 실행 과정에서 코드를 어떻게 처리할지 알리는 메타데이터      클래스나 메소드 위에 붙으며, @로 시작 : 어노테이션의 유무나 어노테이션에 설정한 값을 통해 클래스를 다르게 실행   @Override // 메소드를 오버라이딩 (상속받은 부모 클래스나 인터페이스에서 해당 메소드가 없으면 컴파일 오류)   자바 모듈 (Java Module) : 클래스, JAR, 패키지 수준의 코드 그룹화 제공      하나의 자바 어플리케이션은 하나 이상의 .class 파일로 구성   다수의 클래스 파일을 .jar 파일로 압축해 배포 및 실행 가능   서로 관련 있는 클래스들은 하나의 패키지로 묶어서 관리   JDK의 Scanner 클래스 : 자바의 키 입력 (Key input)      String next() : 문자열 타입으로 반환   Byte nextByte() : 바이트 타입으로 반환   short nextShort(), int nextInt(), long nextLong() : 정수 타입 (short, int, long)으로 반환   float nextFloat(), double nextDouble() : 실수 타입 (float, double)으로 반환   String nextLine() : 한 줄 전체 (\\n)를 일고 문자열 타입으로 반환   import java.util.Scanner; Scanner scan = new Scanner(System.in); String name = scan.nextLine();      자바 표준 입력 스트림 system.in : 입력되는 키 값을 바이트 정보로 반환 (문자 정보로 변환)     InputSteamReader rd = new InputSteamReader(System.in); // 키보드 입력 스트림 생성 int s = rd.read(); // 키보드로부터 문자 하나를 읽고 이를 s에 저장      예외 처리 (Exception handling) : 발생한 예외에 대해 작성한 프로그램 내에서 대응하는 것      예외 (Exception) : 프로그램 실행 중에 발생하는 런타임 오류 (Runtime error)            Checked Exception : 컴파일러에 의해 예외 발생을 인지 (컴파일 오류)       Unchecked Exception : JVM에서 예외 발생을 인지 (예외 객체 생성 후 처리)              자바에서 자주 발생하는 예외          NullPointerException : Null 래퍼런스를 참조할 때 발생     ClassCastException : 변환할 수 없는 타입응로 객체를 변환할 때 발생     IOException : 입출력 동작 중에 인터럽트가 발생할 때 발생     NumberFormatException : 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환할 때 발생     IllegalArgumentException : 잘못된 인자를 전달할 때 발생     ArrayIndexOutOfBoundsException : 배열의 범위를 벗어나 접근할 때 발생     NoSuchMethodException : 런타임 시점에 존재하지 않는 메소드를 호출할 때 발생         try-catch-finally : 발생한 예외에 대한 예외처리를 하는 구문            try : 오류가 발생할 것으로 예상되는 부분       catch : 발생할 오류에 관련된 예외에 대해 대응할 부분       finally : 예외 발생 여부에 상관없이 반드시 실행되어야 하는 부분       throws: 예외 처리의 의무를 현재 예외가 발생한 메소드에서 그 메소드를 호출한 메소드로 전달           public void funcA() {     try {         ...     } catch (Exception e) { // 예외가 발생할 때 생성된 예외 객체와 타입이 일치하면, 래퍼런스 변수가 생성된 예외 객체를 가리킴         ...     } finally {         ...     } }  public void funcB() throws Exception { // throws로 예외 처리를 Exception로 전달     ... }  ","categories": [],
        "tags": ["Java"],
        "url": "/java2/",
        "teaser": null
      },{
        "title": "[MicroService] 3. MicroService Architecture",
        "excerpt":"비즈니스 로직 (Business Logic) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념           소프트웨어의 가치는? by Clean Architecture                행위 기치 : 소프트웨어의 기능         구조 가치 : 소프트웨어의 아키텍처 → 소프트웨어를 Soft하게 만드는 것               → 코드나 설계의 구조를 깔끔히 하는 대신 기능 구현만 목표하면, 엉망이 된 소프트웨어 대처에 더 많은 비용 발생           문제 영역에서 비즈니스 로직을 분석 및 이해하고, 프로그래밍 언어로 잘 표현하는 것이 개발자의 역할                기능이 정확하게 동작하는 것과 더불어, 이해하기 쉽고 변경하기 쉬운 시스템을 만드는 것                  관심사의 분리 (Separation of Concerns) : 시스템의 각 영역이 처리하는 관심사가 분리해 관리되어야 함      각 영역은 고유의 관심사에 의해 분리되어 집중되어야 함 → 모듈화, 계층화            비즈니스 로직은 어플리케이션의 핵심 영역이므로, 기술에 영향을 적게 받게 설계해야       기술과 비즈니스 로직을 분리했을 때, 어플리케이션의 복잡성이 낮아지고 유지보수성이 높아짐       비즈니스 로직을 모두가 이해할 수 있게 구조화된 객체 모델로 표현되어야 함           → 유연하고 확장성 있는 MSA 시스템을 개발하려면, 마이크로서비스의 내부 구조를 어떻게 유연하게 만들지 고민해야!       데이터베이스 중심 아키텍처 (Database Centric Architecture) : 데이터 중심 서비스 구현      특정한 관계형 데이터베이스에 의존한 데이터 모델링을 수행한다.   물리 테이블 모델을 중심에 두고 어플리케이션을 구현한다. (예시 : SpringBoot Application)            Controller, Service, DTO, Repository &amp; Entity로 어플리케이션을 구성       SQL 매핑 프레임워크인 MyBatis나 Java Persistence API인 JPA로 데이터를 처리              데이터베이스 중심 아키텍처에서 비즈니스 로직은 서비스에 존재해야 한다. 그러나,          흐름 제어 로직만 서비스에 존재하고, 비즈니스 개념이나 규칙은 테이블이나 SQL 질의로 존재한다.     DTO는 SQL 질의를 통해 정보를 가져오는 정보 묶음 (Information Holder)의 역할밖에 할 수 없다.          간단한 처리 로직의 경우에는 적합하나, 업무가 다양해지면 점점 복잡성을 제어할 수 없음   업무 개념이 특정 관계형 테이블 데이터베이스의 테이블로 표현되어, 데이터 질의어인 SQL가 필요한 경우가 있음   서비스의 비즈니스 개념과 규칙이 대부분 데이터베이스에 표현 → 성능이 데이터베이스에 의존            데이터가 늘어남에 따라 데이터베이스의 성능은 지속적으로 떨이짐                    데이터베이스 서버의 Scale-out과 SQL 질의문 튜닝에 의존하게 됨                           MSA 시스템의 확장성과 유연성을 위한 내부 어플리케이션의 아키텍처 구조      클라우드의 풍부한 자원 환경에서는, 어플리케이션 자체의 성능보단 어플리케이션의 확장성과 유연성이 더 중요하다!   계층형 아키텍처 (Layered Architecture)      티어 (Tear) : 물리적인 장비나 서버 컴퓨터 등의 물리 계층   레이어 (Layer) : 물리적인 티어 내부에서 어플리케이션이 처리할 관심사를 구분하는 논리 계층            프레젠테이션 (Presentation) : 화면 표현 및 전환 처리       비즈니스 로직 (Business Logic) : 비즈니스 개념, 규칙, 흐름 제어       데이터 액세스 (Data Access) : 데이터 처리              계층형 아키텍처를 개발하기 위하여 지켜야 할 규칙!          상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.     상위 계층은 하위의 여러 계층을 모두 알 필요 없이 바로 밑의 근접 계층만을 활용한다.     상위 계층이 하위 계층에 영향받지 않게 구성해야 한다.     하위 계층은 자신을 사용하는 상위 계층을 알지 못하게끔 구성해야 한다.     계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.                구현 클래스에 직접 의존하지 않게끔 하여 약결합을 유지해야 한다.                     의존성 역전의 원칙 (DIP) : ‘유연성이 극대화된 시스템은 코드 의존성이 구체가 아닌 추상에 의존한다.’ → O   개방 폐쇄의 원칙 (OCP) : ‘소프트웨어 객체는 확장에 열리되, 변경에 닫혀 있어야 한다.’ → X            개체의 행위는 확장될 수 있지만, 이때 객체를 변경해서는 안된다. 그러나 상위 계층에서 하위 계층으로 제어의 흐름 (Flow of Control)이 흐르는 계층형 아키텍처에서 소스 코드의 의존성 또한 그 방향을 따를 수 밖에 없다.       상위 계층이 하위 계층의 구체 클래스가 아닌 추상 인터페이스에 의존시키고 그 인터페이스의 구현체를 달리해 의존성을 줄이면서 다형성을 유지할 수 있지만, 인터페이스는 그 계층이 정의하는 추상 특성의 한계를 벗어날 수 없다.           → 즉, 하위 계층의 유형이 추가되어 확장될 때, 닫혀 있어야 할 상위 계층이 하위 계층이 정의한 특성이 영향받는다!          DIP를 철저히 적용하여 OCP가 가능하게 하는, 의존 관계 역전의 방법 또한 존재한다.          프레젠테이션, 비즈니스 로직, 데이터 액세스을 갖는 3계층 시스템이라 가정할 때,                고수준 영역인 비즈니스 로직이 저수준 영역인 데이터 액세스에 의존한다. (싱위 != 고수준 → 중요도)         그러나 데이터 액세스 계층에서 정의한 인터페이스가 경계를 넘어 비즈니스 로직 계층에 존재하도록 하면,                        데이터 액세스의 구현체는 비즈니스 로직 계층의 인터페이스만을 보게 된다.                       → 아례 계층이 위 계층에 의존하게 하는 것이이 의존 관계 역전!                            헥사고날 아키텍처 (Hexagonal Architecture)      DIP를 적용한 계층형 아키텍처의 한계?          프레젠테이션, 데이터 액세스 계층만이 아닌 다양한 인터페이스를 필요로 하는 현대 어플리케이션                어플리케이션을 호출하는 다양한 시스템 유형과 어플리케이션과 상호작용하는 다양한 저장소가 존재                   → 단방향 계층 구조가 가지는 근본적인 한계를 넘어서자!       포트 엔드 어댑터 아키텍처 (Port and Adapter Architecture)            저수준의 외부 영역 : 인터페이스 처리를 담당                    인바운드 어댑터 (Inbound Adaptor) : 서비스 외부에서 들어오는 요청을 처리                            REST API를 발행하는 컨트롤러               웹 페이지를 구성하는 스프링 MVC 컨트롤러               이벤트 메시지를 구독하는 이벤트 핸들러 등                                   아웃바운드 어댑터 (Outbound Adaptor) : 서비스 내부의 비즈니스 로직에 의해 호출되어 외부와 연계                            데이터 액세스 처리를 담당하는 DAO               이벤트 메시지를 발행하는 이벤트 클래스               외부 서비스를 호출하는 프락시 (Proxy)                                               고수준의 내부 영역 : 순수한 비즈니스 로직 표현                    외부 영역과 연계되는 포트 (Port)를 가짐 → 어댑터가 포트를 호출                            인바운드 포트 (Inbound Port) : 내부 영역의 사용을 위해 표출된 API               아웃바운드 포트 (Outbound Port) : 내부 영역이 외부를 호출하는 방법 정의                                                   → 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게끔 한다.   클린 아키텍처 (Clean Architecture)           Robert C. Martin : ‘소프트웨어는 행위 가치와 구조 가치를 가지며, 구조 가치는 더 중요하다.’                왜? : 소프트웨어를 더 유연하게 하는 것이 구조 가치이므로         소프트웨어를 유연하게 유지하는 방법? : 구조 중에서 선택할 수 있는 사항들을 오랫동안 여는 것                        특히 열어두어야 할 선택 사항은, 중요하지 않는 세부사항                                         엔티티 (Entity) : 비즈니스 업무 규칙 (사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙)            모든 시스템에는 해당 도메인의 업무를 규정하는 업무 규칙이 존재 → 시스템 내에서 자동화       업무 규칙과 데이터를 결합하여 엔티티 객체로 만들 수 있음           유스케이스 (UseCase) : 어플리케이션 업무 규칙            자동화된 시스템을 사용하는 처리 절차를 기술       어플리케이션에 특화된 업무 규칙을 표현하며, 엔티티 내의 업무 규칙을 호출해 시스템을 사용하는 흐름을 닫음       엔티티는 프레임워크, 데이터베이스에 의존하지 않고 유스케이스 객체를 통해 조작되는 간단한 객체로 존재해야 함           컨트롤러 (Controller) : 인터페이스 어댑터 (게이트웨어를 통해 연결)   인터페이스 (Interface) : 프레임워크 &amp; 디바이스 (프레젠터를 통해 연결)           엔티티와 유스케이스를 감싸고 있는 나머지 모든 영역이 세부 사항                입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토클 등                   → 세부 사항과 유스케이스의 관계를 DIP를 통해 플러그인처럼 유연하게 처리해야 한다.    바람직한 마이크로서비스의 내부 아키텍처 → 클린 마이크로서비스 (Clean Microservice)      마이크로서비스 시스템에서 정의해야 할 마이크로서비스의 내부 구조가 다양할 수 있음            자율적인 마이크로서비스 팀에 의한 폴리글랏한 내부 구조를 가질 수 있기 때문       간단한 기능이면 모노리스를, 복잡한 기능이면 헥사고날/클린 아키텍처의 구조를 기반으로 정의하는 게 바람직           클린 마이크로서비스 아키텍처가 지향해야 할 원칙      지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.   업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.   세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분된다.   고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 한다.   저수준 영역은 언제든지 교체 및 확장이 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안 된다.   인터페이스나 추상 클래스를 지원하는 Java의 경우, 구체 클래스가 추상 인터페이스에 의존하는 DIP를 적용한다.   인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수주느이 어댑터가 이를 구현한다.   클린 마이크로서비스 아키텍처의 구조           내부 영역 (Inbound Area) : 비즈니스 로직을 표현하는 영역                      도메인 (Domain) : 내부 영역의 중심부에 존재하는 영역                     핵심 비즈니스 개념과 규칙을 구현           엔티티 (Entity)와 값 객체 (VO)를 갖는 에그리거트 (Aggregate)로 존재                                서비스 (Service) :  내부 영역에서 도메인을 감싸는 영역                     도메인을 호출하여 업무를 처리하는 절차를 기술                                서비스 인터페이스 (Service I/F) : 서비스 처리를 위한 인터페이스                     외부에서 내부 영역에 존재하는 서비스를 사용할 수 있도록 API를 제공                                API 프록시 인터페이스 (API Proxy I/F) : 다른 서비스의 API 프록시 호출을 위한 인터페이스                     프록시 (Proxy) 패턴 : 프록시에게 어떤 일을 대신하게 함                            어떤 객체를 사용할 때, 객체를 직접 참조하지 않고 이에 대응되는 프록시 객체로 대상 객체에 접근                                                        레포지토리 인터페이스 (Repository I/F) : 저장소 처리를 위한 인터페이스                     비즈니스를 처리하는 데에 필요한 기본적인 저장소 처리 사항을 추상화해 정의           외부 영역의 저장소 어댑터가 각 저장소에 맞는 저장소 처리 세부 기술로 구현                                도메인 이벤트 발행 인터페이스 (Domain Event Publish I/F) : 이벤트 메시지 발행을 위한 인터페이스                     도메인 이벤트 (Domain Event) : 어떤 사건에 따른 상태의 변경 사항           하나의 도메인 이벤트를 각 명칭을 갖는 클래스로 구현 → 컨슈머 (Consumer)에 전달되어 발행 (Publish)                                외부 영역 (Outbound Area) : 기술 중심의 세부 사항을 의미하는 영역                      API 퍼플리싱 어댑터 : 클라이언트 ↔ 서비스 인터페이스                     내부 영역의 서비스 인터페이스를 호출해 REST API를 발행하는 인바운드 어댑터           명시적인 REST 리소스 명칭을 정의하고, 각 REST 메소드가 의도에 맞게 서비스 인터페이스를 호출           엔티티를 직접 제공하지 않고 API에 맞는 DTO를 생성해 엔티티를 변환 및 매핑해 전달해야 함                                API 호출 프록시 어댑터 : 프록시 인터페이스 ↔ 다른 서비스                     내부 영역에 정의된 프록시 인터페이스를 구현하여 다른 서비스의 API를 호출하는 아웃바운드 어댑터           REST API, 소켓이나 SOAP 프로토콜 등 각 기술에 맞는 적절한 통신 방법을 구현해야 함                                저장소 처리 어댑터 : 레포지토리 인터페이스 ↔ 데이터베이스                     데이터 처리 메커니즘의 선택 → SQL vs OR?                            SQL 매핑 방식 (MyBatis) : SQL 질의문을 수동으로 작성할 수 있어 세밀한 SQL 제어가 가능               OR 매핑 방식 (JPA, Spring Data) : 런타임 시 OR 매퍼가 저장소에 따라 자동으로 질의문 생성                                    질의문을 수동으로 작성할 필요가 줄어들어 균일한 질의문 품질과 생산성 향상 가능                                                                                        도메인 이벤트 발행 어댑터 : 이벤트 인터페이스 ↔ 메시지 브로커                     도메인 이벤트를 발행하여 송신하는 아웃바운드 어댑터           실제 도메인 이벤트가 생성되는 위치는 내부 영역                            에그리거트 패턴을 적용했을 때의 도메인 이벤트는 에그리거트에서 발생한 사건이 됨                                   도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스의 구현체                            특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행                                                        도메인 이벤트 핸들러 어댑터 : 메시지 브로커 ↔ 서비스 인터페이스                     발행된 도메인 이벤트를 수신할 수 있는 인바운드 어댑터           외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달           이벤트의 상태에 따라 적절한 서비스 인터페이스를 호출해서 내부 영역에 이벤트를 전달해야 함                           클린 마이크로서비스의 내부 영역에 참고할 만한 패턴      서비스 인터페이스는 외부 영역이 내부 영역에 대해 많이 알지 못하게 함            서비스 인터페이스가 없다면? : 추이 종속성이 발생할 수 있고, 정보 은닉성이 보장될 수 없음           리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프록시 인터페이스는 DIP를 지원            고수준 영역에 인터페이스가 존재하면, 저수준 영역의 외부 어댑터가 이러한 인터페이스를 구현하도록 해야 함           도메인은 비즈니스 개념을 표현하는 엔티티의 역할울 수행   서비스는 도메인을 활용하여 시스템의 흐름 처리를 수행하는 유스케이스의 역할을 수행   간단한 비즈니스 로직의 처리 → 트랜잭션 스크립트 (Transaction Script) 패턴      비즈니스 개념을 표현하는 도메인 객체가 행위를 가지고 있지 않음   모든 비즈내스 행위, 즉 무언가를 수행하는 책임은 서비스에 있음   서비스가 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행            절차식 프로그래밍 방식과 같기 때문에 객체지향 지식이 없어도 일반적으로 쉽게 이해할 수 있는 구조       기존의 데이터베이스 중심 아키텍처에 익숙하다면 더 빠르게 적응할 수 있음           비즈니스가 복잡해질수록 서비스 코드의 양이 늘어남            서비스가 비대해지면서, 도메인 객체는 정보 묶음의 역할만을 수행       비즈니스 로직 처리가 서비스에서 이루어지므로, 비슷한 유스케이스로 중복된 코드가 생겨나 유지보수에 어려움           복잡한 비즈니스 로직의 처리 → 도메인 모델 (Domain Model) 패턴      도메인 객체가 데이터뿐만이 아니라 비즈니스 행위를 가짐            도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉       도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행           서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임하여 처리            서비스의 책임이 도메인으로 적절히 분산되므로 서비스 메소드가 단순해짐           도메인 모델 패턴의 도메인 모델은 객체지향 설계의 객체 모델            각기 적절한 책임을 가진 여러 클래스들로 구성되므로 이해하기 쉽고 관리 및 테스트가 용이       잘 만들어진 도메인 모델은 복잡한 비즈니스 로직의 처리에 유용       잘 정의된 도메인 모델은 코드의 양을 줄이고 재사용성을 높일 수 있음           복잡한 도메인 모델의 단순화 → 에그리거트 (Aggregate) 패턴           도메인 모델링 : 객체간의 관계를 참조로 표현                일대다 (One-to-Many) 관계의 객체를 쉽게 사용할 수 있음         업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고, 그로 인해 참조 관계가 복잡해짐                   → 즉, 복잡한 도메인 모델은 모델 내부의 경계가 불명확하다. 이 문제를 어떻게 해결할까?       에그리거트 : 데이터 변경의 단위로 다루는 연관 객체의 묶음            Root Entity에서 개념적으로 묶인 엔티티의 집합       1개 이상의 연관된 엔티티와 값 객체 (VO)로 구성된 하나의 묶음 전체       개별 객체 수준의 모델 → 에그리거트 단위의 모델을 통해 도메인 모델을 단순화              에그리거트를 한 단위로 일관되게 처리하기 위한 규칙          에그리거트 루트만 참조한다.     에그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해서만 참조해야 한다. 수정할 때도 동일하다.     에그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.     기본 키를 사용하면 느슨하게 연관되고 수정이 필요없는 에그리거트를 함께 수정하는 실수를 방지한다.     하나의 트랜잭션으로 하나의 에그리거트만을 생성 및 수정한다.      클린 마이크로서비스의 내부 영역에 참고할 만한 패턴      어댑터는 각각의 인터페이스에 대한 동기/비동기 통신 및 저장소 처리를 작업한다.            외부 영역은 내부 영역에 존재하는 서비스 인터페이스를 사용하는 인바운드 어댑터와, 내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 아웃바운드 어댑터로 구성된다.           어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야 한다.            내부 영역이 먼저 정의된 후에 외부 영역의 세부 사항은 늦게 정의돼도 상관없도록 해야 한다.              Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice3/",
        "teaser": null
      },{
        "title": "[MicroService] 4. Agile Development Process",
        "excerpt":"에자일 개발 프로세스 (Agile Development Process) : 피드백을 통한 지속적인 개선 추구      에자일 방법론 (Agile Methodology) : 신속한 반복 작업으로 소프트웨어를 지속적으로 제공하고자 함            CI/CD, DevOps 등의 에자일 방법론 중심의 프랙티스       효율적인 의사소통 구조와 협업 체계를 가진 다기능 팀으로 만듣 수 있는 결과물 → ‘마이크로서비스’       XP의 ‘지속적 통합’ 프랙티스 : 품질이 보장된 소프트웨어를 반복적으로 개발할 수 있게 함       스크럼 프로세스 : ‘스크럼 팀’이라는 조직과 ‘스프린트’라는 짧은 반복 주기를 통해 피드백과 개선 작업을 촉진함              XP나 스크럼을 살펴보면 개발 문화 및 관리 프로세스를 자세히 다루나, 설계 및 개발 공정에 대해 자세히 언급하지 않음          에자일 자체가 성숙한 개발 문화에서 좋은 프랙티스을 가속화하고 기존 공정에서 낭비를 제거하는 방식으로 진행                개발 문화가 미성숙한 팀을 위해 기민한 반복 주기게 적합하며 핵심 활동에 집중할 수 있는 방법이 필요                   → DDD를 중심으로 에자일 프로세스와 연계하여 마이크로서비스를 설계 및 개발하는 공정이 필요하다!    기민한 설계 및 개발을 위한 절차 → 스크럼 기반 마이크로서비스 개발 프로세스      스크럼 (Scrum) : 프로젝트 개발 및 관리를 위한 에자일 개발 방법론 중 하나            제품 백로그 (Product Backlog) : 개발할 제품에 대한 요구 사항 목록       스프린트 계획 회의 (Sprint Planning Meeting) : 스프린트 목표 및 스프린트 백로그를 계획하는 회의       스프린트 백로그 (Sprint Backlog) : 각 스프린트 목표에 도달하기 위해 필요한 작업 목록       스프린트 (Sprint) : 반복적인 개발 주기 (계획 회의부터 제품 리뷰가 진행되는 날짜까지의 기간 : 1~4주)       일일 스크럼 회의 (Daily Scrum Meeting) : 어제 한 일, 오늘 할 일, 장애 등을 공유하는 회의       시연 (Testing) : 초기에 정의한 백로그가 모두 구현되고 그 요건을 만족하는지 확인       회고 (Review) : 팀원들이 자기 스스로를 돌아보면서 개선점을 논의하여 다음 스프린트에 적용           구현 스프린트를 진행하기 위한 준비 및 계획 → 아키텍처 정의 및 마이크로서비스 도출      아키텍처 정의 : 마이크로서비스 내부/외부 아키텍처를 정의하는 공정 → 아키텍처 구성도            기존 워터풀 개발 방식과 달리, 기술 세부사항은 늦게 결정할 수 있어야 한다. (Robert C. Martin)       그러나 최소한의 개발 및 테스팅 환경을 준비하는 게 바람직 : 스프린트에 실제 동작하는 어플리케이션 시연 가능                    도커나 쿠버네티스, 스프링부트 등을 미리 결정한다면, 빠르게 개발 환경을 구축해 개발 과정에 진입 가능                           마이크로서비스 도출 : 스크럼 팀이 개발할 전체 마이크로서비스를 파악하는 작업 → 컨텍스트 맵            모든 마이크로서비스를 하나의 스크럼 팀이 개발할 수 없음       DDD의 전략적 설계로 마이크로서비스를 도출하고, 그것들 간의 대략적인 매핑 관계를 정의해, 우선순위 산정           백엔드와 프런트엔드 개발 공정의 접목 → API 명세 &amp; 도메인 모델링      백엔드와 프런트엔드 영역 간 계악으로 해당 작업이 선행되고, 각각의 공정이 영역을 나누어서 진행       API 명세 (API Details) : 각 백엔드 마이크로서비스가 프론트엔드에 제공할 서비스 명제들을 정리   도메인 모델링 (Domain Modeling) : 화이트보드, 포스트잇 등으로 도메인 설계 모델을 작성            OOAD 방식과 다른 점? : UML 등으로 정형화된 설계 모델을 작성해 소스 코드로 변환하지 않음                    단순한 도구들로 작성해 이를 공유하고 피드백을 받아 곧바로 소스 코드로 도메인을 개발                       MDD와 다른 점? : 추상적인 모델을 완벽히 만들고, 특정 기술이나 프레임워크를 통해 구체화하지 않음                    코드 자체가 모델의 기본 표현 형식을 그대로 반영하므로, 모델과 코드가 단절되지 않음                       핵심 도메인 모델을 이해시키기 위해 역공학 도구를 통해 UML 모델을 표현할 수 있음           UI 레이아웃 정의 및 백엔드 API 호출 → 프론트엔드 영역 설계 및 개발      UI 흐름 정의 : 비즈니스 흐름에 따른 UI 흐름 정의 → UI 스토리보드   UI 레이아수 정의 : 사용자 접점인 사용자 인터페이스 정의 → 발사믹 오븐, 카카오 오븐 등으로 산출   UI 이벤트 및 액션 정의 : UI 레이아웃 내에서 특정 행위를 했을 때 발생하는 이벤트 및 액션 정의   UI 개발 : UI 레아아웃 및 이벤트에 맞게 프론트엔드 어플리케이션 개발 → UI 프레임워크 등으로 산출   어플리케이션을 지속적으로 빌드하고 자동으로 배포 → 빌드 및 배포 환경 자동화      소스 코드 리포지토리 구성 : 프론트엔드, 백엔드 코드를 위한 소스 코드 저장소 구성 (Git)   통합 빌드 잡 (Build Job) 구성 : 리포지토리에 존재하는 소스 코드를 통합해 컴파일 및 테스트 (Jenkins)   컨테이너 생성 파일 생성 : 컨테이너 배포 환경에서 운영 체제, WAS, 어플리케이션을 묶어 이미지 생성 (Dockerfile)   배포 스크립트 : 자동으로 배포되는 스크립트 작성 (Jenkins, Github Actions)      Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice4/",
        "teaser": null
      },{
        "title": "[MicroService] 5. MicroService Design",
        "excerpt":"마이크로서비스 설계 : 응집성 높게 (High Cohesion), 의존도 낮게 (Low Coupling)      마이크로서비스의 내부 구조를 구성하는 각 요소들은 역할별로 모듈화 (Modulation)되어야 함            자체적인 응집도가 높고, 서로 간의 의존성이 낮은 모듈들이 모여 하나의 마이크로서비스를 이룸       하나의 마이크로서비스는 다른 마이크로서비스와 의존성이 낮아야 함           → 마이크로서비스를 구성하는 각각의 요소들을 모두 유연해야 한다.   마이크로서비스를 도출하는 방법            Reference          도메인 주도 설계로 시작하는 마이크로서비스 개발     ","categories": [],
        "tags": ["MicroService"],
        "url": "/microservice5/",
        "teaser": null
      },{
        "title": "[SpringBoot] 1. SpringBoot",
        "excerpt":"객체지향 프로그래밍 (OOP) :  프로그램을 일련의 독립된 객체들로 이해하는 프로그래밍 방법론      캡슐화 (Encapsulation) : 변수와 함수를 하나의 단위로 묶는 것   정보 은닉 (Information Hiding) : 프로그램의 구현을 외부로 드러나지 않게 내부로 감추는 것   상속 (Inheritance) : 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것   다형성 (Polymorphism) : 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석되는 것   객체지향 5원칙 (SOLID) : 객체자향을 올바르게 설계할 수 있도록 도와주는 원칙      SRP (Single Responsibility Principle) : 객체는 오직 하나의 책임을 가져야 한다.            클래스를 설계할 때 어플리케이션의 경계를 정하고, 추상화로 어플리케이션 내의 속성과 메소드를 설계해야 한다.           OCP (Open Closed Principle) : 객체는 확장에 대해 개방적이고 수정에 대해 폐쇄적이어야 한다.            클래스, 모듈, 함수와 연동할 때는 상위 클래스나 인터페이스를 중간에 두어 직접적인 연동을 피해야 한다.           LSP (Liskov Substitution Principle) : 자식 클래스는 항상 자신의 부모 클래스를 대체할 수 있다.            자식 클래스의 인스턴스는 부모 클래스의 인스턴스 역할을 대신할 때에도 논리적으로 문제가 없어야 한다.           ISP (Interface Segregation Principle) : 클라이언트에서 사용하지 않는 메서드는 사용해선 안 된다.            각 상황에 맞는 메소드만 클래스에게 제공하도록 인터페이스를 작게 나누어 설계해야 한다.           DIP (Dependency Inversion Principle) : 자신보다 변하기 쉬운 것에 의존해선 안된다.            추상성이 높고 고수준의 클래스는 구체적이고 저수준의 클래스에 의존하지 않도록 설계해야 한다.           자바 빈 (Java Bean) : 자바 객체를 재사용 가능하도록 컴포넌트화한 클래스      클래스는 반드시 패키지화되어야 한다.   멤버변수는 프로퍼티 (Property) 라고 부른다.   프로퍼티의 접근 제어자는 private이다.   데이터를 저장하는 필드와 그 데이터를 조작하기 위한 외부에서의 접근은 getter와 setter 메소드로 한다.   프로퍼티가 boolean이면, get가 아닌 is를 사용해도 된다.   public class MemberInfo {   private int id;   private String Name;   private String pw;      public int getId() { return id; }   public void setId(int id) { this.id = id; }   public String getName() { return Name; }   public void setName(String name) { this.Name = name; }   public String getPw() { return pw; }   public void setPw(String pw) { this.pw = pw; } }      … 서버 사이드에서 어플리케이선을 개발할 때 자바 빈만으로 해결하지 못하는 문제가 발생한다.          기존 어플리케이션에 필요한 비즈니스 로직만이 아닌, DB와 트랜젝션 처리를 위한 프로그램이 추가로 필요하다.     각각의 어플리케이션 서버에는 독자적인 API이 제공되기에 어플리케이션의 컴포넌트화가 어렵다.      EJB, J2EE : 비즈니스 로직과 시스템 서비스 로직을 분산하고, 로직 간의 규약을 규정      비즈니스 로직을 탑재한 부품을 Enterprise Bean이라 부른다.   DB와 트랙젝션 처리 등의 시스템 서비스를 이용하는 부품을 컨테이너 (Container)라 부른다.   비즈니스 객체들을 관리하는 EJB 컨테이너에서 필요할 때마다 객체를 꺼내는 방식으로 객체들 간의 의존성을 해결한다.   @Stateless public class Service {    @PersistenceContext   private Manager Manager;    public void addCustomer(Customer customer) {     Manager.persist(customer);   } }      … EJB는 비즈니스 로직이 특정 EJB 컨테이너에 종속되는 문제가 발생한다. (→ 기술 침투)          EJB 컨테이너를 사용하기 위한 코드 (상속 &amp; 구현)들이 많고, EJB 컨테이너가 없으면 불필요한 코드가 된다.     회사마다 EJB 컨테이너를 구현한 내용이 달라 다른 회사의 EJB 컨테이너로의 변경이 어렵다.       → 회사마다 다르고 복잡한 자바 엔터프라이즈 어플리케이션의 개발을 하나로 단순화하자!    스프링 (Spring) : 자바 (JAVA) 기반의 웹 프레임워크 (Web Framework)      순수 자바 객체 (Plain Old Java Object) 방식 : POLO            인터페이스를 직접 구현하거나 상속받지 않아 기존 라이브러리 지원에 용이하고, 코드가 간결하며 객체가 가벼움           관점지향 프로그래밍 (Aspect Oriented Programming) : AOP            로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리할 수 있음           의존성 주입 (Dependency Injection) : DI            프로그래밍 구성 요소 간 의존 관계를 코드 밖에서 설정을 통해 정의해, 재사용률을 높이고 모듈 간 결합도를 낮춤           제어의 역전 (Inversion of Control) : IoC            객체의 생성부터 소멸까지의 제어권이 프레임워크에게 있어, 외부 라이브러리 코드가 개발자의 코드를 호출           모델-뷰-컨트롤러 (Model-View-Controller) : MVC 패턴            사용자 인터페이스, 데이터 및 논리 제어의 구현에 사용되는 소프트웨어 디자인 패턴           모듈화 디자인 (Modulation) : 한 프레임워크을 여러 기능적 구성요소 (Module)로 조합해 완성            Core : 제어의 역전 (IOC)과 의존성 주입 (DI) 기능 제공       DAO : 자바 데이터베이스 커넥터 (JDBC) 추상 계층 제공 (VO 클래스로 접근)       ORM : ORM이나 데이터베이스 API와의 통합 기능 제공       Web : 웹 어플리케이션 구현과 관련된 기능 제공       JEE : 엔터프라이즈 J2EE 스펙과 관한 기능 제공              … 스프링 프레임워크가 나왔지만 여전히 개발자가 신경써야 할 일이 많다.          서블릿 (Servlet)에 대한 이해와 서블릿의 배포를 위해 필요한 web.xml에 대한 이해     어플리케이션 컴포넌트를 패키징한 WAR, EAR 디렉터리 구조에 대한 지식     도메인, 포트, 스레드, 데이터 소스 등 어플리케이션을 배포할 때에 필요한 서버 지식     복잡한 클래스 로딩 전략, 어플리케이션 모니터링, 유지 관리, 로깅 처리       → 어플리케이션에 비즈니스 로직을 작성하고, 실행 가능한 파일로 만들어 커맨드라인으로 바로 실행하자!    스프링부트 (SpringBoot) : 스프링 프레임워크 기술을 편리하게 사용할 수 있도록 지원      빠른 구동 (Quick Run) : 어플리케이션에 필요한 의존 관계만 명시하면, 어플리케이션을 빠르게 실행할 수 있음            스프링 MVC 의존 관계를 추가하고 메이븐 혹은 그레이들 프로젝트 설정       스프링 MVC의 DispatcherServlet의 설정       어플리케이션 컴포넌트를 WAR 파일로 패키징       WAR 파일을 아파치 톰캣 (Apache Tomcat) 같은 서블릿 컨테이너에 배포           자동 구성 (Auto Configuration) : 어플리케이션에 필요한 최소한의 컴포넌트를 대신해서 설정            클래스패스에 있는 JAR 파일이나 여러 설정 파일에 지정된 프로퍼티 정보를 바탕으로 구성       XML 파일을 자체적으로 빌드하여 스프링 프로젝트 내 객체 의존성 관리를 자동화       스프링 외부에 존재하는 라이브러리 또한 가져와 자동으로 구성           미리 정의된 방식 (Opinionated) : 어플리케이션 실행에 필요한 컴포넌트들을 starter 의존 관계를 기준으로 구성            spring-boot-starter-web만 추가하면, 웹 어플리케이션 개발에 필요한 의존 관계를 클래스패스에 모두 넣어줌           독립 실행형 (Standalone) : 어플리케이션에 웹 서버를 내장하여 독립적으로 실행 가능            실행 가능한 JAR 파일로 패키징 → java -jar 명령어로 실행 가능       어플리케이션이 쉽게 컨테이너화될 수 있어 클라우드 네이티브 (Cloud Native)에도 적합           실제 서비스 환경에 사용 가능 (Production-Ready)            헬스 체크 (Health Check)나 스레드 덤프 (Thread) 분석을 통한 어플리케이션 모니터링 기능 제공       매트릭 (Metric), 상태 확인, 외부 구성과 같은 프로덕션 준비 기능 제공           스프링부트 컴포넌트 (SpringBoot Components) : 어플리케이션 개발의 특정 영역에 특화된 요소      spring-boot : 스프링부트의 기본 컴포넌트로서, 다른 컴포넌트를 사용할 수 있도록 지원            톰캣 (Tomcat)과 같은 내장 웝 서버 기능       데이터베이스 연결 정보와 같은 어플리케이션 설정 정보를 외부화하는 기능           spring-boot-autoconfigure : 어플리케이션에 필요한 의존 관계의 자동 구성을 담당            클래스패스와 설정 파일의 포로퍼티에 저장된 의존 관계를 바탕으로 스프링 빈 (Spring Boot)을 추론해 생성           spring-boot-starters : 개발의 편의를 위해 제공하는 미리 패키징된 의존 관셰 기술서의 모음   spring-boot-CLI : 그루브 코드를 컴파일하고 실행할 수 있는, 관리자 친화적 명령행 도구            어플리케이션에 수정 사항이 발생할 때마다 파일 내용의 변경 감지       의존 관계 관리나 빌드 관련 문제에 대한 걱정 없이 프로트타입 어플리케이션을 빠르게 만들 수 있게 해줌           spring-boot-actuator : 어플리케이션을 모니터링하고 검사 가능한 엑추에이터 엔드포인트 제공            JMX나 HTTP 엔드포인트로 관리할 수 있음       어플리케이션의 여러 측면의 상태를 감지할 수 있도록 미리 정의된 형태의 다양한 엑추에이터 엔드포인드들을 제공       커스텀 엑추에이터 엔드포인트를 추가하거나, 엑추에이터 엔드포인트의 활성화 여부를 설정할 수 있음       인가되지 않은 접근으로부터 엔드포인트를 보호할 수도 있음           spring-boot-actuator-autoconfigure : 클래스패스에 있는 클래스를 기반으로 엑추에이터 엔드포인트를 자동 구성            의존 관계가 클래스패스에 있으면, 이에 해당되는 것을 엑추에이터 엔드포인트로 추가           spring-boot-test : 테스트 케이스의 작성에 필요한 에너테이션 (annotation) 및 메소드 포함   spring-boot-test-autoconfigure : 어플리케이션의 테스트 케이스에 필요한 의존 관계를 자동 구성   spring-boot-loader : 어플리케이션을 JAR 파일로 패키징하기 위해 필요한 모든 의존 관계와 내장 웹 서버를 포함            독립적으로 사용되지 않고 메이븐이나 그레이들 플러그인과 함께 사용           spring-boot-devtools : 어플리케이션 개발을 돕는 여러 개발자 도구들   스프링부트 프로젝트 구조 : 스프링 이니셜라이저 (Spring Initializr)로 자동 생성      pom.xml / build.gradle : 스프링 이니셜라이저에서 스프링부트 프로젝트를 생성할 때 지정한 의존 관계가 들어 있음            메이븐 (Maven) 혹은 그레이들 (Gradle)과 같은 빌드 도구를 통해 빌드 가능           &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;  &lt;!-- spring-boot-starter-parent : 스타터 의존 관계나 플러그인에 대한 기본 설정 제공 및 관리 --&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;3.2.1&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- 메이븐 리포지토리에서 parent를 가져옴 --&gt;     &lt;/parent&gt;     &lt;groupId&gt;pocj8ur4in&lt;/groupId&gt;  &lt;!-- 프로젝트 아티펙트 정보 --&gt;     &lt;artifactId&gt;test&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;pocj8ur4inTest&lt;/name&gt;     &lt;description&gt;pocj8ur4inTest&lt;/description&gt;     &lt;properties&gt;         &lt;java.version&gt;21&lt;/java.version&gt;     &lt;/properties&gt;     &lt;dependencies&gt;  &lt;!-- dependencies : 스타터 의존 관계들을 선언 --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;  &lt;!-- JUnit, Mockito 등으올 스프링부트 어플리케이션 테스트를 지원 --&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;     &lt;build&gt;         &lt;plugins&gt;  &lt;!-- plugins : 플러그인들을 선언 --&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; &lt;/project&gt;      빌드 플러그인을 통한 스프링부트 어플리케이션의 실행 흐름          resource-plugin의 호출 : src/main/java의 소스 파일들을 빌드 결과가 저장될 디렉터리에 복사     compiler-plugin의 호출 : 어플리케이션을 시작하기 전에 소스 코드를 컴파일       → 빌드 플러그인은 저수준의 세부 작업을 모두 추상화하여 개발자가 쉽게 사용할 수 있게끔 해줌       래퍼 (wrapper) 파일 : 빌드 도구를 로컬에 설치하지 않고 프로젝트를 빌드할 수 있게 해줌   패키지 (Packages) 구조 : 자바 클래스를 포함하는 소스 패키지와 테스트 클래스를 포함하는 테스트 패키지로 분리   application.properties 파일이 존재하는 리소스 (resource) 폴더 : 프로젝트를 진행하면서 사용할 파일들   스프링부트 메인 클래스 (Main Class) : 패키지 내에서 어플리케이션 실행을 담당   package pocj8ur4in.vocawik;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class VocawikApplication {     public static void main(String[] args) {         SpringApplication.run(VocawikApplication.class, args);     } }      main() 메소드 : 웹 어플리케이션을 실행하는 메소드            어플리케이션 컴포넌트를 빌드 및 패키징한 WAR / EAR 파일을 만들어 웹 서버에 배포할 필요가 없음       전통적인 자바 어플리케이션을 실행하는 것처럼 웹 어플리케이션을 실행할 수 있음                 별도의 서블릿 컨테이너를 실행하지 않고, 스프링부트 어플리케이션이 내장된 서블릿 컨테이너 안에서 실행됨                    spring-boot-starter-web이 spring-boot-starter-tomcat 모듈에 대한 의존 관계를 포함                           @SpringBootApplication 어노테이션 : 루트 패키지부터 스프링 어노테이션이 붙은 컴포넌트를 탐색해 관리            @EnableAutoConfiguration : 어플리케이션 클래스패스의 JAR 파일을 바탕으로 어플리케이션을 자동 구성       @ComponentScan : 어플리케이션에 존재하는 스프링 컴포넌트를 탐색                    @Component, @Bean 등이 붙은 자바 빈을 스프링에서 관리하기 위해 루트에서부터 탐색           @ComponentScan(basePackage = {})로 탐색 범위를 직접 지정할 수 있음      - @SpringBootConfiguration : 스프링부트 어플리케이션 설정을 담당                       @Configuration를 내부적으로 포함하여, 컴포넌트 탐색을 통해 어플리케이션 설정 과정에 참여           SpringApplication() 클래스 : run() 정적 메소드를 통해 스프링부트 어플리케이션을 편리하게 실행      run() 메소드가 실행될 때 수행하는 적업의 흐름          클래스패스에 있는 라이브러리를 기준으로 SpringApplication 클래스의 인스턴스 생성     CommandLinePropertySource를 등록해서 명령행 인자를 스프링 프로퍼티로 읽음     1단계에서 생성한 ApplicationContext를 통해 싱글톤 빈 로딩     어플리케이션에 설정된 ApplicationRunner와 CommandRunner 실행         SpringApplication 클래스는 클래스패스에 있는 JAR의 의존 관계를 바탕으로 ApplicationContext 인스턴스 생성            ApplicationContext는 빈을 생성할 때 필요한 의존 관계 주입을 실행할 스프링 IoC 컨테이너의 역할을 담당       클래스패스에 있는 클래스로 어플리케이션 타입이 서블릿 (Servlet) 혹은 리액티브 (Reactive)인지 유추              스프링부트가 ApplicationContext를 로딩할 때의 전략          서블릿 기반 : AnnotationConfigServletWebSErverApplicationContext 클래스 인스턴스 생성     리액티브 기반 : AnnotationConfigReactiveWebServletApplicationContext 클래스 인스턴스 생성     둘다 아닐 경우 : AnnotationConfigApplicationContext 클래스 인스턴스 생성         필요한 경우에 SpringApplication 클래스의 인스턴스를 직접 생성해 어플리케이션 시동 모드를 변경 가능   스프링 프로파일 지정, 어플리케이션 리소스 리소스 로더 지정과 같은 기능을 Setter 메소드로 제공   application.properties 또는 application.yml : 어플리케이션의 설정 정보 관리      src/main/resources/ 디렉토리에 자동으로 생성 (기본값은 .properties)   서버 접속 정보, 데이터베이스 접속 정보와 같은 어플리케이션 설정 정보를 소스 코드에서 분리해서 외부화   멀티 모듈을 구성하거나 배포 환경가 다중화된 경우에, 파일을 여러 개로 나누어 설정을 다르게 관리할 수 있음   JAR 파일 : 스프링부트 프로젝트로부터 생성된 실행 가능한 파일      설정한 패키징 방식에 따라 프로젝트의 target 디렉터리에 .JAR 파일 생성            메이븐은 spring-boot-maven-plugin 플러그인의 repackage 골 (goal)이 메이븐 package 라이프사이클과 연동되어, 컴파일된 클래스 파일 (.class)를 리패키징       그레이들은 스프링부트 프로젝트를 빌드할 때 org.springframework.boot 플러그인이 생성한 bootJar 테스크가 그레이들 build 라이프사이클에 편입되어 패키징           java -jar 명령의 인자로 지정하면 어플리케이션을 실행할 수 있음   ctrl+c 등을 통해 자바 프로세스를 종료하면, 스프링부트 어플리케이션 또한 종료         META-INF : 실행할 JAR 파일의 핵심 정보를 담고 있는 MANIFEST.MF 파일            Start-Class 패러미터 : 어플리케이션을 시작할 클래스를 지정       Main-Class 패러미터 :  Start-Class를 사용해서 어플리케이션을 시작하는 Launcher 클래스를 지정           스프링부트 로더 컴포넌트 : JAR/WAR 파일을 로딩하는 JarLauncher/WarLauncher 클래스            loader.* 프로퍼티에 값을 지정하면, PropertiesLauncher 클래스로 클래스 로딩 과정 커스텀마이징 가능           BOOT-INF/classes : 컴파일된 모든 어플리케이션 클래스가 위치한 디렉터리   BOOT-INF/lib  : 의존 관계로 지정한 라이브러리가 들어있는 디렉터리   classpath.idx : 클래스로더가 로딩해야 하는 순서대로 정렬된 의존 관계 목록이 들어있음   layer.idx : 도커 이미지를 생성할 때 논리적 계층으로 JAR를 분할할 때 사용      안전 종료 (Graceful shutdown) : 처리 중인 요청이 완료될 때까지 기다릴 타임아웃 설정          어플리케이션을 종료할 때, 처리 중인 요청의 처리가 보장되지 않음     종료 명령어 실행되면 더 이상의 요청을 받지 않되, 이미 처리 중인 요청은 완료를 보장해야 함     스프링부트 2.3.0부터 도입되어, 그 이전 버전에서는 동작하지 않음       server.shutdown=graceful # 기본값: immediate spring.lifecycle.timeout-per-shutdown-phase=1m # 기본값: 30s      스프링부트 스타트업 이벤트 : 스프링 어플리케이션 시작 및 초기화 과정에서 사용 가능한 빌트인 이벤트      ApplicationStartingEvent : 어플리케이션이 시작되어 리스너 (Listener가 등록될 때 발행            스프링부트의 LoggingSystem이 해당 이벤트를 통해 어플리케이션 초기화 단계 이전에 필요한 작업 수행           ApplicationEnvironmentPreparedEvent : 어플리케이션이 시작되고 Environment가 준비될 때 발행            MessageConverter, ConversionService, Jackson의 초기화 등 서비스 사전 초기화 (PreInitialize) 작업 수행           ApplicationContextInitializedEvent : ApplicationContext가 준비되고 ApplicationContextInitializer가 실행되면 발행            빈이 스프링 컨테이너에 로디오디어 초기화되기 전에 이루어질 작업이 필요할 때 이 이벤트를 사용           ApplicationPreparedEvent : ApplicationContext가 준비되고 빈이 로딩되었으나 ApplicationContext가 초기화되기 전에 발행            이 이벤트가 발행된 이후에 Environment를 사용할 수 있음           ContextRefreshedEvent : ApplicationContext가 초기화된 이후에 발행            스프링부트가 아닌 스프링이 발행한 이벤트로, SpringApplicationEvent를 상속하지 않음       스프링부트의 ConditionEvaluationLoggingListener가 이 이벤트가 발행되면 자동 구성 보고서를 출력           WebServerInitializedEvent : 웹 서버가 준비되면 발행            스프링부트가 아닌 스프링이 발행한 이벤트로, SpringApplicationEvent를 상속하지 않음       어플리케이션 타입에 따른 하위 이벤트가 존재 (ServletServerInitializedEvent, ReactiveServerInitializedEvent)           ApplicationStartedEvent : ApplicationContext가 초기화되고 ApplicationRunner, CommandLineRunner가 호출되기 전에 발행   ApplicationReadyEvent : 어플리케이션 요청 처리가 준비되었을 때 SpringApplication에 의해 발행            모든 어플리케이션 초기화가 완료된 이후에 발행 : 이후에 어플리케이션 내부 상태를 변경하는 것은 권장되지 않음           ApplicationFailedEvent : 어플리케이션 시작 과정에서 예외가 발생하면 발행            예외 발생 시 스크립트를 실행하거나, 스타트업 실패를 알릴 때 사용           스프링부트 어플리케이션 이벤트 감지 : 스프링부트 스타트업 이벤트가 제공하는 정보들을 활용하기 위해 이벤트를 구독      @EventListener 어노테이션 : 스프링 프레임워크에서 제공하는 이벤트를 구독하는 어노테이션            어플리케이션 스타트업 극초기에 발행되는 이벤트는 감지하지 못함           # @EventListener를 사용해서 ApplicationReadyEvent를 구독 @EventListener(ApplicationReadyEvent.class) public void funcForApplicationReadyEvent(ApplicationReadyEvent applicationReadyEvent) {   System.out.println(\"ApplicationReadyEvent generated at \"   + new Date(funcForApplicationReadyEvent.getTimestamp())); }      SpringApplication 클래스 : 어플리케이션 스타트업을 커스텀마이징할 수 있는 setter 메소드를 통해 리스너 등록            ApplicationListener 인터페이스의 onApplicationEvent 메소드를 구현해 SpringApplication에 추가       SpringApplication에 리스너를 등록하거나 수정하는 것은 클래스 코드의 변경을 유발           # 커스텀 ApplicationListener 구현체 작성 public class ApplicationStartEventListener  implements ApplicationListener&lt;ApplicationStartingEvent&gt; {   @Override   public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {     System.out.println(\"Application Starting Event logged at \"     + new Date(applicationStartingEvent.getTimestamp()));   } }   # SpringApplication에 어플리케이션 이벤트 리스너 추가 @SpringBootApplication public class SpringBootEventApplication {   public static void main(String[] args) {     SpringApplication springApplication      = new SpringApplication(SpringBootEventApplication.class);   } }      spring.factories 파일 : 어플리케이션 기능 설정 및 커스터마이징을 가능하도록 스프링부트가 제공            스프링부트 이전부터 스프링 프레임워크에서 제공 (spring-beans.jar에서 확인 가능) → 스프링부트 2.7.0부터 deprecated              Reference          실전 스프링부트     ","categories": [],
        "tags": ["SpringBoot"],
        "url": "/springboot1/",
        "teaser": null
      },{
        "title": "프로그래밍 언어로서의 JavaScript와 TypeScript (2024.01.19)",
        "excerpt":"   디지털하나路 스터디 1일차 내용을 정리한 글입니다.    공부하고자 한 이유   JavaScript와 TypeScript는 그동안 내가 주로 사용해온 C, C++, Java와 같은 컴파일 언어와는 많은 차이점이 있는 스크립트 언어이다. 오늘은 본격적으로 자바스크립트를 배우기 앞서 자바스크립트와 타입스크립트가 프로그래밍 언어로서 어떤 특성을 가지는지 알아보고자 한다.   공부한 내용   프로그래밍 언어 (Programming Language)는 기계가 읽을 수 있고, 사람이 읽을 수 있는 형식으로, 계산을 서술하기 위한 표기 체계이다. 여기에서 주목할 점은 ‘사람이 읽을 수 있는 형식으로’이다. 사실 기계의 성능을 가장 높이는 방법은 기계의 방식을 그대로 따르는 것이지만, 프로그래밍 언어는 사람의 편의성을 위해 지속적으로 여러 개념들을 도입하였다. 대표적인 예시로 추상화 (Abstraction)이 있다. 추상화는 속성들의 일부분만으로, 주어진 작업이나 객체를 필요한 정도로만 묘사하는 것이다. 예를 들어 int x;라는 구문이 있을 때, int, x, ;는 해당 단어나 기호를 아는 사람들에게 있어 어떤 의미를 가진다는 것을 유추할 수 있게끔 한다. 그리고 컴퓨터 역시 예약어인 int나 ;가 어떤 의미를 가질 때, 그리고 x라는 단어가 쓰였을 때 어떤 일련의 작업, 즉 명령의 순차적 실행, 위치를 표현할 변수의 사용, 그리고 변수의 값을 변경하는 배정문의 사용 등을 진행하면 되는지 알고 있다.   이 ‘사람이 읽을 수 있는 형식으로’라는 조건은 계산을 서술하는 방식에도 영향을 미쳤다. 앞서 설명한 일련의 흐름을 그대로 진행하는 언어는 절차 언어 (Procedural Language)라고 부른다. 하지만, 절차 언어는 계산이 순차적인 명령에 의하여 실행되어야 하기 때문에 공유 버스 (Shared Bus) 내에서 폰 노이만 병목 현상이 발생한다. RAM과 CPU의 속도 차이가 발생하는 하드웨어적 한계를 극복하지 못한 것이다. 또한 절차 언어는 많은 자료를 동시에 적용하는 연산, 아직 계산할 값이 아직 할당되지 않은 비결정적인 연산, 혹은 순서에 의존하지 않는 비절차적인 연산을 기술하는 데에 비효율적이다. 그래서 이 한계를 극복하기 위해 나온 방식이 바로 함수형 언어와 논리형 언어이다.   // 절차형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램  // 단계 1: 사용자로부터 두 수를 입력받기 var num1 = parseFloat(prompt(\"첫 번째 숫자를 입력하세요:\")); var num2 = parseFloat(prompt(\"두 번째 숫자를 입력하세요:\"));  // 단계 2: 입력받은 수를 더하기 var sum = addNumbers(num1, num2);  // 단계 3: 결과 출력 alert(\"두 수의 합은 \" + sum + \"입니다.\");  // 함수: 두 수를 더하는 함수 정의 function addNumbers(a, b) {   return a + b; }   함수형 언어 (Functional Language)는 알려진 값들을 함수들에 적용하는 것을 기반에 둔다. 함수형 언어에서의 계산은 아래의 예시와 재귀적 함수를 활용해 기술된다. 함수형 언어에서의 함수는 함수에 변수를 할당하거나 인자로 전달할 수 있는 일급 객체 (First-Class)로 취급하면서, 주어진 입력에 대해 항상 동일한 출력을 생성하는 불변성 (Immutability)의 특성을 가진다. 실제로 함수형 언어는 변수나 변수에 대한 배정문이 존재하지 않는 대신 함수와 함수를 평가하고 호출하는 방법을 제공한다.   // 함수형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램  // 단계 1: 사용자로부터 두 수를 입력받기 var num1 = parseFloat(prompt(\"첫 번째 숫자를 입력하세요:\")); var num2 = parseFloat(prompt(\"두 번째 숫자를 입력하세요:\"));  // 단계 2: 두 수를 더하는 함수 정의 function addNumbers(a, b) {   return a + b; }  // 단계 3: 입력받은 수를 더하기 var sum = addNumbers(num1, num2);  // 단계 4: 결과 출력 alert(\"두 수의 합은 \" + sum + \"입니다.\");   논리형 언어 (Logical Language)은 논리적인 규칙과 규칙 간의 관계를 정의해, 순서가 아닌 무엇을 하고자 하려는지 기술하는 방식으로, 계산의 내용만을 선언하듯이 기술한다. 그렇기 때문에 논리형 언어는 선언적 언어 (Declarative Language)로 불리기도 한다. 그래서 논리형 언어에서의 변수는 기억 장소의 위치보다는 계산 과정의 중간 결과 값에 대한 이름의 성격이 강하다.   // 규칙 정의 function isHuman(animal) {   return animal.species === 'Human'; }  function canSpeak(animal) {   return animal.canSpeak === true; }  // 사람 객체 생성 const person = {   species: 'Human',   canSpeak: true };  // 규칙을 통한 논리적 추론 if (isHuman(person) &amp;&amp; canSpeak(person)) {   console.log('This is a speaking human.'); } else {   console.log('This is not a speaking human.'); }   객체 지향 (Object-Oriented) 언어는 여기서 한 발 더 나아가, 프로그램을 단순히 데이터와 이를 처리하는 방법으로 나누지 않고 수많은 객체들의 집합으로 보았다. 메소드와 변수를 가지는 객체라는 추상적인 개념을 프로그램에 도입하고 이를 객체의 상호 작용으로 봄으로써, 이전에 존재하던 지나치게 많은 이름의 생성으로 인한 네임스페이스 포화 문제를 해결하고 큰 문제를 작은 문제를 하기 위한 객체들로 해결하는 상향식 (Bottom-up) 해결 방식을 적용하는 것이 가능해졌다.   // 클래스 정의 class Animal {   constructor(species, canSpeak) {     this.species = species;     this.canSpeak = canSpeak;   } }  // Human 클래스 정의, Animal 클래스를 상속받음 class Human extends Animal {   constructor(canSpeak) {     // Human은 species가 'Human'으로 고정된다고 가정     super('Human', canSpeak);   }    isSpeakingHuman() {     return this.species === 'Human' &amp;&amp; this.canSpeak === true;   } }  // 사람 객체 생성 const person = new Human(true);  // 객체지향 방식의 논리적 추론 if (person.isSpeakingHuman()) {   console.log('This is a speaking human.'); } else {   console.log('This is not a speaking human.'); }   이제 다시 자바스크립트가 탄생하던 시점으로 돌아오자. 자바스크립트가 탄생한 시점에는 이전에 정적으로만 존재하던 페이지가 브라우저를 통해 동적으로 페이지를 변경하는 방식이 공개되면서 브라우저에서 사용할 언어나 기술이 요구되고 있었다. Java Applet처럼 웹 브라우저에 Java 어플리케이션을 내장해 동적인 페이지를 제공하는 방식으로 동작하는 기술이 있었지만, 성능 및 보안 이슈가 존재하였다. 이때 자바스크립트는 강력한 추상화와 인터프리터 방식를 내세워 꾸준히 개발자들을 유입하였고, Ajax와 JQuery, Node.js를 통해 기존에 가진 문제점 또한 개선해나갔다.   자바스크립트의 강력한 추상화는 앞서 언급한 여러 언어들의 장점들을 채택하는 데에서 비롯되었다. 자바스크립트는 함수형 언어라고 부르지만, 객체나 함수를 통한 추상화를 지원하면서 변수를 선언할 때 타입을 명시적으로 지정할 필요가 없는 동적 타이핑 (Dynamic Typing) 또한 지원한다. 또한 async, Ajax와 같은 비동기 이벤트의 처리를 위해 콜백 (Callback)과 프로미스 (Promises) 또한 지원한다.   인터프리터 방식은 소스 코드를 한 줄씩 기계어로 번역하는 방식이므로 컴파일 방식에 비해 속도는 느리지만, 어떤 코드를 작성한 다음 바로 실행하여 문제가 있으면 바로 수정할 수 있는 디버깅이 가능하다. 그리고 반복적으로 쓰이는 함수, 클래스의 기계어를 캐싱하는 JIT 컴파일러를 인터프리터에 내장하여 속도 또한 이전에 비해 개선되었다. JIT 컴파일러를 통해 오류가 있어도 그전까지 계속 실행되거나 오류를 오류로 처리하지 않는 경우 또한 줄어들었다.           파싱 (Parsing) : 소스 코드가 먼저 브라우저 엔진에 의해 파싱되어 코드의 문법적 구조를 이해하기 위한 토큰들이 생성     AST (Abstract Syntax Tree) 생성 : 파싱된 토큰들은 코드의 추상 구문을 나타내는 트리 구조인 AST로 변환     바이트코드 생성 : 코드를 실행 가능한 형태로 변환하기 위한 중간 단계의 표현 생성     (JIT 컴파일) 후 실행 : 변환된 코드는 런타임 환경에서 실행되거나, JIT 컴파일러에 의해 기계 코드로 컴파일되어 실행      그리고 인터프리터 방식의 장점 중 하나는 프로그래밍 언어의 설계가 쉽다는 점이다. 컴파일 언어가 설계되려면 기계어에 대한 이해가 필요하지만, 스크립트 언어는 컴파일 언어나 심지어 스크립트 언어를 통해 구현될 수 있다. 타입스크립트가 바로 대표적인 예시로, 최근에는 앞서 정의한 타입스크립트 문법을 활용해 다시 문법을 만드는 것 또한 이루어지고 있다.   그렇다면 자바스크립트가 브라우저에서 어떻게 동작하는 걸까? 클라이언트 측에서 동작하는 자바스크립트는 브라우저가 웹 페이지를 로딩할 때 &lt;script&gt; 태그를 통해 위의 컴파일 과정이 이루어진 다음에 단일 스레드로 동작하며, 이벤트 기반 비동기 모델을 활용한다. 이런 비동기 작업을 위해 브라우저는 추가로 이벤트 큐와 이벤트 루프를 활용하고 자바스크르립트 또한 콜백 함수와 Ajax 처리를 지원한다.  ","categories": [],
        "tags": ["Digital Hanaro Study"],
        "url": "/digital_hanaro_study1/",
        "teaser": null
      },{
        "title": "TailwindCSS란? (2024.01.22)",
        "excerpt":"   디지털하나路 스터디 2일차 내용을 정리한 글입니다.    공부하고자 한 이유   토이 프로젝트를 만들 때 부트스트랩 (Bootstrap)을 많이 활용하여 화면을 구성하곤 하였는데, 오늘 강사님께서 TailwindCSS라는 새로운 프론트엔드 프레임워크 기술에 대해 말씀해주시면서, 현재는 부트스트랩보다 TailwindCSS를 사용한 사이트가 훨씬 다수임을 알려주셨다. 그래서 향후 토이 프로젝트에 TailwindCSS를 적용할 수 있도록 부트스트랩과 차이점을 비교해보면서 TailwindCSS에 대해 공부해보고자 한다.   공부한 내용   부트스트랩 (BootStrap)은 2011년에 트위터에서 시작된 오픈 소스 프론트엔드 프레임워크이다. 글자, 인용문, 목록, 표 등 자잘한 요소부터 메뉴, 바, 버튼 등까지 웹 페이지에서 자주 쓰이는 요소들을 모두 내장하고 있어, 부트스트랩의 CSS와 JS를 사이트에 반영만 하면 일정한 디자인을 빠른 시간 내에 제작할 수 있다. 그리고 데스크탑만이 아니라 모바일 화면 또한 비율에 맞게 반응형으로 지원하여 크로스 브라우저 (Cross-Browser) 환경에도 적합하다. 또한 해상도 크기에 맞게 자동으로 정렬되고 크기 조절이 가능한 그리드 시스템 (Grid System)이 내장되어 있어 화면에 특정한 요소를 배치하는 것에 대한 커스텀마이징 또한 매우 간단한 편이다. 부트스트랩 공식 웹 사이트에서 여러 예시 화면들을 볼 수도 있다.   나 같은 경우에는 전문적인 프론트엔드 개발자가 아니라서, 부트스트랩을 처음 접했을 때에는 블로그를 운영하는 과정에서 배운 HTML/CSS/JS에 대한 지식들만 있는 상태였다. 그러나 예시 화면들의 각 요소들을 직접 뜯어보고 수정하는 과정에서 사용해본 내부 클래스들로만으로도 내가 필요로 한 화면들을 금방금방 구성해낼 수 있었다. 아래의 화면은 내가 기획하였던 사이트의 노래 검색 화면으로, 화면 구상에서 실제 구현까지 2~3일 정도 걸린 것으로 기억한다. Header와 Footer 부분은 템플릿 엔진을 통해 이전에 만든 요소를 그대로 사용하였고, 상세 검색 화면은 그리드 시스템과 내장된 글자 및 버튼 속성을 적절히 적용하여 구현하였다. 그리고 버튼을 눌렀을 때 나올 수 있는 동작들, 예를 들어 마우스 포커싱 기능들도 CSS로 구현되어 있어 따로 만들 필요가 없었다. 그리고 작년에 7 버전이 출시될 만큼 꾸준한 개발 및 지원이 이루어지고 있고, 또 부트스트랩을 사용하는 웹 사이트 및 래퍼런스들도 여전히 많이 존재한다.      그럼 부트스트랩 대신에 TailwindCSS가 대세가 된 이유는 무엇일까? 내가 처음 떠올린 이유는 부트스트랩만으로는 생각보다 직접 커스텀마이징을 하는 데에 한계가 있다는 것이다. 물론 오픈 소스이므로 래퍼런스가 정말 많고, 원하는 페이지를 만드는 것도 얼마든지 가능한 것 또한 사실이다. 그런데 사실 이건 HTML/CSS/JS을 다룰 수 있으면 얼마든지 가능한 부분이고, 이젠 피그마 등을 활용해 원하는 화면을 빠르게 배치해 만드는 것도 가능하다. 오히려 부트스트랩 기반으로 한, 비슷한 디자인의 사이트들이 많아져서 타 사이트와의 차별성을 두기 어려운 부분 또한 맞는 말이라고 생각한다. 부트스트랩의 취지는 HTML/CSS/JS들을 미리 만들어 개발자가 사용할 수 있는 것인데, 내가 구현하지 않는 부분까지 빌트인 (built-in)되어 있다보니, 부트스트랩 자제 문법을 공부하는 데에도 시간이 꽤 걸린다.   그러면 TailwindCSS에 대해 알아보자. TailwindCSS는 2017년에 Tailwind Labs에서 개발한 CSS 프레임워크이다. TailwindCSS는 CSS를 작성하지 않고 클래스 이름을 제공하여 HTML에 필요한 CSS 유틸리티만 입혀도 스타일이 완성되는 ‘유틸리티 우선 CSS‘를 지향한다. TailwindCSS 공식 사이트를 보면, 클래스 이름만 적어도 CSS가 적용되는 여러 예시들을 볼 수 있다.   &lt;div&gt;     &lt;style&gt;     .rainbow-block {       display: inline-block;       width: 100%;       height: 150px;       background: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);     }   &lt;/style&gt;   &lt;div class=\"rainbow-block\"&gt;&lt;/div&gt; &lt;/div&gt;              무지개색 블록을 만들고자 할 때, 순수 CSS는 위의 스타일 코드를 적어야 한다. 반면 TailwindCSS는 아래의 예시처럼 미리 정의된 유틸리티 클래스들을 활용하여 클래스 이름만으로 스타일을 적용할 수 있다.   @import 'tailwindcss/base'; @import 'tailwindcss/components'; @import 'tailwindcss/utilities';  .rainbow-block {   @apply inline-block w-32 h-32 bg-gradient-to-r from-violet to-red; }   사실 이게 왜 장점이지? 할 수도 있다. 어쨌든 HTML/CSS 또한 기능 자체를 제공하기는 한다! 하지만 TailwindCSS가 제공하는 유틸리티 클래스는 부트스트랩의 장점인 일관성 있는 디자인을 가지면서, 기본 스타일 값을 직접 커스텀마이징할 수 있는 key-value를 제공한다. 그리고 로우 레벨의 스타일 또한 제공하므로, 미리보기, 자동완성, 신택스 하이라이팅 및 린팅을 지원하는 IntelliSense 플러그인을 활용하여 필요한 디자인을 세밀하게 구현할 수 있다. 무엇보다 프론트엔드 개발자가 가장 장점으로 꼽는 부분은 클래스 이름을 고민하지 않아도 된다는 점인데, 이건 함수의 이름을 잘 짓기 위해 프로젝트 시작 전에 매번 고민하는 시간을 갖는 나에게도 와닿는 문제라 공감이 가는 부분이 많다.  ","categories": [],
        "tags": ["Digital Hanaro Study"],
        "url": "/digital_hanaro_study2/",
        "teaser": null
      },{
        "title": "[SpringBoot] 2. SpringBoot Common Task",
        "excerpt":"어플리케이션 설정 관리 : 여러 환경에 따른 설정 정보의 다중화      개발 환경의 다중화 → 개발 (dev), 테스트 (test), 스테이징 (staging), 배포 (prod)            여러 환경에 배포할 때 설정 정보는 매번 변경되어야 하지만, 소스 코드는 변경되어선 안됨       즉, 설정 정보를 외부화하여 관리할 필요성이 있음              어플리케이션 설정 관리 방법의 우선순위          명령행 인자     운영 체제의 환경 변수     설정 정보 파일 (application.properties 혹은 application.yml)     @PropertySource     SpringApplication      SpringApplication 클래스 사용      소스 코드로 정의하는 방식이므로 한 번 정의하면 나중에 바뀌지 않는 경우에 적합함   java.util.Properties나 java.util.Map&lt;String, Object&gt;가 인자인 setDefaultProperties() 메소드 호출            Properties나 Map&lt;String, Object&gt;를 통해 설정 정보를 어플리케이션에 적용                 application.properties 파일은 다른 설정 파일들을 spring.config.import 프로퍼티를 통해 임포트해서 사용            spring.config.import=classpath:additional-application.properties를 추가하면 스프링부트는 additional-application.properties 파일에 있는 설정 정보를 읽어 사용할 수 있음                    만약 클래스패스에 파일이 없으면, ConfigDataLocationNotFoundException 예외가 발생           spring.config.on-not-found에 ignore를 지정하면, 클래스파일에 설정 파일이 없을 때 예외 처리를 하고 종료하는 대신 어플리케이션 시동 작업을 계속 진행하게 할 수 있음                           @PropertySource 사용      설정 파일의 위치를 어노테이션을 사용해 지정 (자바 8 이후로는 동일한 어노테이션을 여러 번 사용할 수 있음)            src/main/resources/의 파일은 JAR로 패키징된 후 클래스패스에 위치하므로, 해당 디렉터리에 설정 파일 작성                 스프링이 제공하는 Environment 인스턴스를 주입받으면, 설정 파일에 있는 정보를 읽을 수 있음   @SpringBootApplication public class SpringBootApplication {     public static final Logger log = Logger.getLogger(SpringBootApplication.class);      public static void main(String[] args) {         ConfigurableApplicationContext configurableApplicationContext          = SpringApplication.run(SpringBootApplication.class, args);          CustomConfiguration customConfiguration          = applicationContext.getBean(CustomConfiguration.class);          log.info(customConfiguration.toString());     } }      @PropertySource로는 .yml 파일 지정해서 사용할 수 없으므로, 추가적인 작업이 필요   환경 설정 파일 (application.properties 또는 application.yml)      환경 설정 파일에 명시된 설정 프로퍼티 정보는 스프리의 Environment 객체에 로딩            어플리케이션 클래스에서 Environment 인스턴스나 @Value 어노테이션을 통해 설정 정보를 읽을 수 있음       spring.config.name 프로퍼티로 환경 설정 파일의 이름을 지정할 수 있음              스프링부트가 기본적으로 읽는 환경 설정 파일의 위치는,          클래스패스 루트     클래스패스 /config 패키지     현재 디렉터리     현재 디렉터리 /config 디렉터리     /config 디렉터리의 바로 하위에 위치한 디렉터리       추가로, spring.config.location 프로퍼티를 통해 상대 경로나 절대 경로의 환경 설정 파일을 읽을 수 있음 (optional: 접두어를 통해 해당된 경로에 환경 설정 파일이 없더라도, 예외 처리 없이 스프링부트 기본 설정값으로 실행할 수 있음)     java -jar target/config-data-file.jar --spring.config.location=optional:data/application.yml            spring.config.name과 spring.config.properties는 환경 설정 파일에 지정할 수 없음 → SpringApplication.setDefaultProperties() 메소드나 환경 변수, 혹은 명령행 인자를 통해 지정          application-{profile}.properties : 프로파일 (profile)별로 프로퍼티 파일 지정 가능            환경 설정 파일의 spring.profile.active 프로퍼티를 통해 프로파일를 지정하면, 프로퍼티 파일의 내용이 로딩           @Configuration(proxyBeanMethods = false) @Profile(\"production\") public class ProductionConfiguration {     // ... }      설정 파일의 로딩 순서          어플리케이션 JAR 파일 안에 패키징되는 환경 설정 파일     어플리케이션 JAR 파일 안에 패키징되는 profile별 환경 설정 파일     어플리케이션 JAR 파일 밖에서 패키징되는 환경 설정 파일     어플리케이션 JAR 파일 안에 패키징되는 profile별 환경 설정 파일      운영 체제의 환경 변수      application.properties 파일에서 app.timeout 커스텀 프로퍼티를 활용   app.timeout=${APP_TIMEOUT}         ConfigurableApplicationContext 인스턴스에 접근   Environment 빈을 가져옴   프로퍼티 값을 env.getProperty() 메소드로 읽어 콘솔 로그로 출력   @ConfigurationProperties : 커스텀 프로퍼티 생성      스프링부트 빌트인 프로퍼티 전체 목록은 공식 래퍼런스 문서에서 확인 가능       스프링 어플리케이션이 복잡해지고 기능이 많아질수록, 커스텀 프로퍼티의 필요성이 높아짐            외부 REST 웹 서비스 URL이나 특정 기능 활성화 여부를 지정할 boolean 플래그 등           Environment 인스턴스 주입을 통한 프로퍼티 값 사용      스프링의 Environment 인스턴스에 프로퍼티가 바인딩 → Environment 인스턴스를 주입받아 프로퍼티 값 사용 가능   프로퍼티 값의 타입 안정성 (Type-Safety)이 보장되지 않아, 이로 인해 런타임 에러가 발생할 수 있음            URL이나 이메일 주소를 프로퍼티로 사용할 때 유효성 검증 (Vadlidation)을 수행할 수 없음           프로퍼티 값을 일정한 단위로 묶어서 읽을 수 없음            @Value 어노테이션이나 스프링의 Environment 인스턴스를 사용해서 하나하나 개별적으로만 읽을 수 있음           @ConfigurationProperties 어노테이션을 사용한 커스텀 프로퍼티 정의      요구 사항 : 커스텀 프로퍼티에 대한 타입 안정성을 보장하고, 값의 유효성을 검증해야 한다.       스프링부트 설정 처리기 (Configuration Processor)를 통해 @ConfigurationProperties이 붙은 클래스에 대한 메타데이터 생성            spring-boot-configuration-processor 의존 관계를 추가해 스프링부트 설정 처리기를 활성화       생성된 메타데이터는 환경 설정 파일에 기술된 프로퍼티에 대한 자동 완성이나 문서화 지원           spring.config.import와 @ConfigurationProperties을 함께 사용해, 연관된 프로퍼티들을 그룹화한 프로퍼티 파일로 관리 가능   @ConfigurationProperties 어노테이션을 클래스 안에서 빈을 생성하는 @Bean 메소드에도 붙일 수 있음   아래처럼 생성자를 사용해서 바인딩하는 방식이 아닌, setter 메소드를 통해 바인딩하는 방식 또한 가능         커스텀 프로퍼티를 사용하려면 환경 설정 파일에 해당 프로퍼티에 대한 정보를 추가해야 함         프로퍼티를 정의하고 이를 담은 AppProperties 클래스를 통해 서비스 클래스에서 AppProperties 객체를 주입받을 수 있음         스프링부트 어플리케이션 클래스는 서비스 클래스를 사용해서 AppProperties 객체에 접근하여 프로퍼티 값을 사용            @EnableConfigurationProperties 어노테이션은 @ConfigurationProperties이 붙은 클래스를 스프링 컨테이너에 등록       @ConfigurationPropertiesScan 어노테이션으로 기준 패키지을 지정하면, 지정 패키지 하위에 있는 @ConfigurationProperties가 붙은 클래스를 모두 탐색해서 스프링 컨테이너에 등록       @ConfigurationProperties 어노테이션이 붙은 클래스를 자동 탐색해서 등록하는 것이 아니라 직접 명시해야 함                 ConstructorBinding 어노테이션을 POJO 클래스에 사용하면, 생성자를 통해 프로퍼티 정보값이 설정            생성자가 하나만 있으면 클래스에, 생성자가 여러 개라면 프로퍼티 정보값 설정에 사용할 생성자에 어노테이션을 붙이면 됨       설정 정보 클래스의 불변성을 보장하기 위해선 세터 바인딩 대신 생성자 바인딩으로 프로퍼티 값을 설정해야 함              ","categories": [],
        "tags": ["SpringBoot"],
        "url": "/springboot2/",
        "teaser": null
      },{
        "title": "자바스크립트 프로토타입 (2024.01.24)",
        "excerpt":"   디지털하나路 스터디 3일차 내용을 정리한 글입니다.    공부하고자 한 이유   자바스크립트에서는 자바와 달리 클래스라는 개념이 없었고 대신 프로토타입을 통해 새로운 객체를 만드는 방식이라는 것을 알게 되었는데, 자바스크립트가 객체지향 프로그래밍을 하기 위해 어떻게 프로토타입이라는 개념을 사용하는지 궁금하였다.   공부한 내용   소프트웨어를 개발하는 과정에서 우리는 수많은 문제점들을 마주치고, 그에 대한 해결책을 찾아 문제를 해결하곤 한다. 소프트웨어 디자인 패턴은 이러한 수많은 문제점들에서 공통점을 가진 것들을 모아 여러 카테고리로 나누고, 이에 대한 해결책을 제시하여 이를 재사용이 가능하도록 한다. 소프트웨어 디자인 패턴은 크게 객체의 생성 방법과 클래스의 인스턴스화를 다루는 생성 패턴 (Creational Pattern), 클래스나 객체를 더 큰 구조로 합치는 구조 패턴 (Structural Pattern), 객체 간의 상호 작용 및 역할 분배를 다루는 행동 패턴 (Behavioral Pattern)으로 나뉜다. 프로토타입 패턴은 이들 중에 생성 패턴에 해당되며, 자신을 복제해서 인스턴스를 생성하는 방법에 대해 다룬다.   사전적인 의미의 프로토타입 (Prototype)이란, 원래의 형태 또는 전형적인 표준을 가리킨다. 소프트웨어 디자인 패턴에서는 생성한 객체들의 타입을 프로토타입인 인스턴스로부터 결정되도록 하고, 인스턴스는 새 객체를 만들기 위해 자신을 복제하는 프로토타입 패턴 (Prototype Pattern)의 개념으로 확장하였다.   Java에서 클래스의 인스턴스를 만들기 위해서는, 우리는 일반적으로 new()를 통해 클래스 이름을 지정하고 인스턴스를 생성한다. 프로토타입 패턴은 new()를  통해 생성자로 인스턴스를 복제하는 것이 아닌, clone() 메소드를 선언하는 추상 베이스 클래스를 하나 만들어 생성자가 필요한 클래스가 있으면 이 클래스를 상속하고 clone() 메소드 내의 코드를 구현하게끔 한다.      Prototype : 프로토타입을 만드려는 객체 클래스의 인터페이스            인터페이스를 통해서 clone을 상속받고, 프로토타입 객체들을 이 공통 타입으로 받음 (다형성 보장)           public interface Prototype {     public Prototype clone(); }      ConcretePrototype : 프로토타입의 인터페이스 구현            clone() : 생성자에 자신의 타입을 가진 객체를 넘기고, 초기화를 위해 패러미터로 받는 생성자를 생성함           public class Circle implements Prototype {     private int x;     private int y;      public Circle(Circle prototype) {         this.x = prototype.x;         this.y = prototype.y;     }      public Circle(int x, int y) {         this.x = x;         this.y = y;     }      @Override     public Prototype clone() {         return new Circle(this);     } }      Sub-Class : 상위 클래스에 값을 전달할 하위 클래스   public class RedCircle extends Circle {     private String color;      public RedCircle(RedCircle prototype) {         super(prototype);         this.color = prototype.color;     }      public RedCircle(Circle circle, String color) {         super(circle);         this.color = color;     }      public RedCircle(int x, int y, String color) {         super(x, y);         this.color = color;     }      public getColor() {       return this.color;     }      public Prototype clone() {         return new RedCircle(this);     } }      클라이언트 클래스 : 프로토타입 인터페이스를 통해 객체를 생성함   public class Client {     Prototype circle = new Circle(3, 5);     Prototype redCircle1 = new RedCircle(3, 5, \"red\");     Prototype redCircle2 = new RedCircle((Circle) circle, \"red\");      Prototype newCircle = circle.clone();     Prototype newRedCircle = redCircle1.clone();      newCircle.getColor(); // 에러     newRedCircle.getColor(); }   위 예시는 자바에서 프로토타입 패턴을 적용한 사례이다. 프로토타입 패턴을 통해 객체를 복제하는 책임이 기존 클래스에서 복제하는 객체로 넘어가나, 이럴 경우에는 객체를 이용하려면 타입을 알아야 한다. 타입이 동적으로 변하는 자바스크립트의 경우에는 이 패턴을 객체를 생성하는 방식으로 활용한다. 자바스크립트는 기본 데이터 타입을 제외한 나머지는 모두 객체인데, 객체 안에 __proto__ 속성이 존재한다. __proto__ 속성은 객체가 만들어지기 위해 사용되는 원형인 프로토타입 객체를 숨은 경로로 참조하는 역할을 한다.   모든 객체는 프로토타입 객체에 접근할 수 있으며, 프로토타입 객체 역시 동적으로 런타임에 멤버를 추가할 수 있다. 또한 같은 원형을 복사로 생성된 모든 객체는 추가된 멤버를 사용할 수 있다. 코드 재사용의 대표적인 방식인 상속을 예시로 들어보자. 자바스크립트의 상속을 classical이 아닌 prototypal 방식으로 생성한다면, 리터럴 혹은 Object.create()를 이용해 객체를 생성하고 확장한다.   var person = {   type: 'person',   getType: function() { return this.type; },   getValue: function () { return this.value; }; }  var pocj8ur4in = Object.create(person); pocj8ur4in.type = \"developer\";  ","categories": [],
        "tags": ["Digital Hanaro Study"],
        "url": "/digital_hanaro_study3/",
        "teaser": null
      },{
        "title": "[JS] 자바스크립트 (JavaScript)",
        "excerpt":"자바스크립트 (JavaScript) : 동적 클라이언트 사이드 스크립트 언어           인터프리터 언어 (Interpreter Language) : 코드를 한 줄씩 읽어 해당 줄을 즉시 실행하는 프로그래밍 언어                런타임에 코드를 한 줄씩 해석해 실행 → 실행 단계에서 번역 (Interpretation at Runtime)         변수의 타입을 런타임에 동적으로 결정 → 동적 타이핑 (Dynamic Typing)                   → 컴파일 언어에 비해 런타임은 비교적 느린 실행 속도를 갖고 있으나, 메모리를 비교적 작게 사용       웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 개발            초창기에는 웹 서버로부터 전달받은 HTML/CSS를 단순히 렌더링하는 수준에 머무름       1999년, 비동기로 데이터를 교환하는 Ajax 기능이 도입돼, 필요한 데이터만 받아 렌더링하는 것이 가능해짐       2006년, DOM을 쉽게 제어할 수 있는 JQuery가 등장       2008년, 구글의 크롬 V8 자바스크립트 엔진으로 웹 서버에서 수행되던 로직이 브라우저로 이동       2009년, Node.js로 브라우저 이외의 환경에서도 자바스크립트 엔진을 동작시킬 수 있게 됨                    프런트엔드와 백엔드 모두에서 활용될 수 있는 동형성 (isomorphic)이 보장           비동기 I/O를 지원하고 단일 스레드 이벤트 루프를 기반하여, 실시간 데이터 처리가 빈번한 SPA에 적합                            SPA (Single Page Application) : React, Vue.js 등                                                   모든 브라우저에 내장된 브라우저 표준 프로그래밍 언어로 자리잡음            개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어 (Interpreter Language)       모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해, 비교적 속도가 느린 인터프리터의 단점 해결       명령형 (imperative), 함수형 (functional), 프로토타입 기반 (prototype-based), 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어           Node.js : 브라우저 밖에서 자바스크립트 코드를 실행하게 해주는 런타임 환경      HTML/CSS/JS를 실행하여 웹 페이지를 브라우저 화면에 렌더링하는 브라우저와 달리, Node.js 는 브라우저 외부에서 자바스크립트를 실행할 수 있는 환경을 제공          브라우저와 동일하게 자바스크립트의 코어인 ECMScript를 제공     파싱된 HTML 요소를 선택 및 조작하는 DOM API이나 클라이언트 사이드 Web API를 제공되지 않음     파일을 생성 및 수정할 수 있는 파일 시스템 및 Node.js 고유 API 제공       브라우저가 제공하는 개발자 도구 (DevTools) 기능            npm : Node.js의 패키지를 관리할 수 있는 도구            Node.js에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 CLI 제공       npx (node package execute)을 통해 패키지를 설치 및 실행       국내에서는 패키지 중복 문제를 링크 방식으로 해결한 yarn을 많이 사용하는 추세           변수 (variable) : 하나의 값을 저장할 수 있는 메모리 공간      변수 = 선언 + 식별자 + 타입 + 값 + 소코프       메모리 주소를 통해 값에 직접 접근하는 것은 위험 → 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음   변수 이름을 어떤 값을 구별해 식별 가능한 고유한 이름이란 의미에서, 식별자 (Identifier)라고도 함            식별자는 값이 아닌 메모리 주소를 기억하고 있어, 식별자로 메모리 공간에 저장된 값에 접근           var userId = 1; var userName = 'John';  var user = { id: 1, name: 'John' };  var users = {     { id: 1, name: 'John' } }      변수 선언 (variable declaration)을 통해 변수를 생성            var, let, const 키워드로 변수를 선언       변수에 값을 할당하지 않았으면, 자바스크립트 엔진에 의해 undefined 값이 할당되어 초기화       선언하지 않은 식별자에 접근하면 참조 에러 (ReferenceError)가 발생           호이스팅 (Hoisting) : 선언문을 코드 맨 위에 올려진 것처럼 동작시키는 것      평가 (evaluation) : 표현식을 해석해서 값을 생성하거나 참조하는 것          평가 = 인터프리터로서의 컴파일 (선언문 실행 + 호이스팅)     인터프리터로서의 실행 순서 : 전역 코드 평가 → 전역 코드 실행 → 함수 코드 평가 → 함수 코드 실행 → 복귀         변수, 함수, 클래스와 같이 키워드를 사용해서 선언하는 모든 식별자는 호이스팅됨   스코프 별로 평가가 이루어지면서 호이스팅이 일어남 → 해당 스코프의 상단으로 올려 메모리 선점 (Linking)            let, const도 호이스팅되지만, 초기화되기 전에 접근하면 안됨 (notInitializedYey 상태로 호이스팅)       선언문이 없는 변수는 호이스팅되지 않으며, 평가한 다음에 코드를 실행할 때 정의           console.log(a); var a = 10; &gt; undefined  let v; console.log(v); // 에러  z = 9; // 암묵적으로 var로 정의 console.log(z); &gt; 9  console.log(globalThis['z']);  let z = 11; // 에러 (암묵적 정의 → 호이스팅)           코드를 평가하는 시점에 호이스팅이 일어나 선언부와 구현부로 구분     → 선언부는 스택 영역에, 구현부는 힙 영역에 저장            선언문의 실행 시점 : 선언문은 런타임 (Runtime)이 아닌 그 이전인 평가 과정에 실행            소스 코드를 한 줄씩 순차적으로 실행하기 앞서, 먼저 소스 코드의 평가 과정에서 선언문을 먼저 실행       즉, 식별자를 선언하는 선언문과 값을 할당하는 할당문의 실행 시점은 서로 다름           값 (value) : 표현식이 평가되어 생성된 결과   10 + 20; // 30      리터럴 (literal) : 사람이 이해할 수 있는 문자 혹인 기호를 통해 값을 생성하는 표기법         표현식 (expression) : 값으로 평가될 수 있는 구문            구문 (statement) : 프로그램을 이루는 기본 단위이자 최소 실행 단위 (선언문, 할당문, 조건문, 반복문 등)                    토큰 (token) : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소                           데이터 타입 (Date Type) : 값의 종류         숫자 타입 : 정수 및 실수를 모두 포함하는 타입으로 존재 (모든 수를 실수로 처리) → 큰 수를 위한 BigInt 타입과는 다름! (BigInt는 객체 타입으로, 모든 수를 정수로 처리)   문자열 타입 : ‘’, “”, ``로 문자열을 감싼 텍스트 데이터            템플릿 (template) 리터럴 : 로 감싼 문자열 (ES6``부터 도입)                    멀티라인 문자열 : 백슬레시 (\\n) 없이 개행 가능           표현식 삽입 : +으로 ${}로 감싼 표현식을 문자열로 변환해 삽입할 수 있음                           불리언 타입 : 참 (true)과 거짓 (false) → 제일 작은 값 (1bit)   심볼 (symbol) 타입 : 변경 불가능한 원시 타입 (다른 값과 중복되지 않는 유일무이한 값)            Symbol 함수를 호출해 생성되며, 값은 외부에 노출되지 않음 (var key = Symbol('key');)       프로퍼티 값에 고유한 값을 저장하고 싶을 때 사용될 수 있음           undefined 타입 : 변수 선언에 의해 확보된 메모리 공간은 쓰레기 값이 아닌 undefined로 초기화   null 타입 : 변수에 값이 없다는 것을 의도적으로 명시 (intentional absence)하기 위해 사용   동적 타이핑 (Dynamic Typing) : 변수를 선언할 때 데이터 타입을 사전에 선언하지 않음      자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론 (Type Inference)이 이루어짐   재할당에 의해 변수의 타입은 언제든지 동적으로 변화할 수 있음 (loosely data)      정적 타입 (Static Typing) : 변수를 선언할 때 데이터 타입을 사전에 선언          변수에 선언한 타입에 해당하는 값만 할당할 수 있음     컴파일 시점에 타입 체크 (Type Check)를 수행하고, 통과하지 못하면 에러를 발생시킴     타입의 일관성을 강제해 안정ㅇ적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임         자바스크립트는 var, let, const 키워드를 통해 변수만 선언            typeof() 연산자를 통해 피연산자의 데이터 타입을 문자열로 반환할 수 있음              동적 타이핑 및 동적 타입 언어의 단점?          동적 타입 언어의 변수 값은 언제든지 변할 수 있음                복잡한 프로그램에서는 변수 값을 추적하기 어려울 수 있음                 동적 타입 언어의 변수는 값의 변경에 의해 타입 또한 언제든지 변경될 수 있음                값을 확인하기 전에는 타입을 확신할 수 없음         자바스크립트 엔진에 의해 타입이 자동으로 변환될 수도 있음                   → 동적 타입 언어는 유연성 (Flexibility)은 높지만 신뢰성 (Reliability)는 떨어진다.          변수를 사용할 때 지켜면 좋은 규칙              변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.       변수의 유효 범위인 스코프는 최대한 좁게 만들어 변수의 부작용을 억제한다.       전역 변수는 최대한 자제한다.       변수보다는 상수를 사용해 값의 변경을 억제한다.       변수 이름은 목적 및 의미를 파악할 수 있도록 네이밍하고, 특히 스코프가 넓을수록 명확하게 명명한다.           암묵적 타입 변환 : 자바스크립트 엔진에서 에러를 발생시키지 않도록 타입을 바꿔 표현식을 평가하는 것      문자열 타입 변환 : +의 피연산자 중 하나가 문자열이면, 문자열 연결 연산자로 동작하므로 다른 것을 문자열로 변환   숫자 타입 변환 : 산술 및 비교 연산자의 피연산자 중에 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환   불리언 타입 변환 : 논리적 참/거짓을 평가하는 경우에 불리언 타입이 아닌 피연산자를 불리언 타입으로 변환   명시적 타입 변환 : 의도적으로 값의 타입을 변환하는 것 → 타입 캐스팅 (type casting)      문자열 타입으로 변환 : String(), toString(), 문자열 연결 연산자 +   숫자 타입으로 변환 : Number(), parseInt()/parseFloat(), +, *   불리언 타입으로 변환 : Boolean(), 부정 논리 연산자 !를 2번      기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것!          원시 값은 변경 불가능한 값 (immutable value) → 기존 원시 값을 직접 변경 ✘     자바스크립트 엔진에서 표현식을 평가하기 위해 피연산자의 값을 암묵적 타입 변환으로 새로운 타입의 값을 만듬      단축 평가 (short-circuit evaluation) : 표현식을 평가하는 중에 결과가 확정되면, 평가 과정을 생략      논리 평가 : 논리 연산자를 이용한 단축 평가 (좌항에서 우항으로 평가)            논리곱 연산자 &amp;&amp;는 두 피연산자가 모두 true일 때, true 반환                    논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 반환                       논리합 연산자 ||는 두 피연산자 중 하나만  true이여도, true 반환                    논리 연산의 결과를 결정하는 첫번째 피연사자를 그대로 반환                           'Cat' &amp;&amp; 'Dog' // true &amp;&amp; 'Dog' → 'Dog' 'Cat' || 'Dog' // 'Cat'... → 'Cat'      논리 평가를 사용하는 경우?          객체를 가리키기 기대하는 변수가 null 혹은 undefined가 아닌지 확인하고 프로퍼티를 참조할 때       var elem = null; // var value = elem.value; // TypeError var value = elem &amp;&amp; elem.value; // null            함수 매개변수에 undefined가 할당되지 않도록 기본값을 설정할 때       function getStringLength() { str = str || ''; return str.length; } getStringLength(); // 0 getStringLength('hello'); // 5         옵셔널 체이닝 (Optional Chaining) 연산자 ? : 좌항의 피연산자가 null 혹은 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 그대로 진행함   var elem = null; var str = '';  var value1 = elem?.value; console.log(value1); // undefined var value2 = elem &amp;&amp; elem.value; console.log(value2); // null var value3 = str &amp;&amp; str.length; console.log(value3); // '' var value4 = str?.length; console.log(value4); // 0      null 병합 연산자 ?? : 좌항의 피연산자가 null 혹은 undefined이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환 → 변수에 기본값을 설정할 때 사용            논리 연산자 ||를 사용한 단축 평가와 달리, 피연산자가  false로 평가받는 Falsy 값이라도 null 혹은 undefined이 아니면, 좌항의 피연산자를 반환함           var foo = null ?? 'default'; // 'default'           Falsy 값 : 피연산자가 false로 평가받는 값                false, undefined, null, 0, -0, NaN, ''                 Truthy 값 : 피연산자가 True로 평가받는 값                true, …                  객체 (Object) : 소프트웨어에서 속성과 기능을 가지는 프로그램의 단위      원시 값을 제외한 나머지 값들, 즉 객체, 함수, 배열, 정규 표현식 등은 모두 객체 값   var person = {   name: 'John', // \"name: 'John'\"은 프로퍼티,    age: 21       // \"name\"은 프로퍼티 키, \"'John'\"은 프로퍼티 값 };   → 객체는 프로퍼티 및 메소드를 모두 포함하고 있어, 상태와 동작을 하나의 단위로 구조화할 수 있다.      객체는 변경 가능한 값 (mutable)   객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값 (Reference value)에 접근   원시 값과 다르게 여러 개의 식별자들이 하나의 객체를 공유할 수 있음              원시 타입 (Primitive) : 값이 스택 영역에 들어감 (Call-By-Value) (cf. 변수의 주소는 별도로 관리됨)  → (자바스크립트 엔진에 따라) 힙 영역 내의 Symbol Table이나 Constant Pool에 들어갈 수 있음     객체 타입 (Object/Reference) : 값이 힙 영역에 들어감 (Call-By-Reference)            원시 타입과 객체 타입의 차이점? → 메모리 공간에 저장되는 위치에서 비롯된 차이!          원시 값은 변경 불가능한 값 (immutable)이지만, 객체 값은 변경 가능한 값 (mutable)     원시 값을 변수에 할당하면 변수에는 실제 값이 저장되나, 객체를 변수에 할당하면 변수에는 참조 값이 저장     원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 (Pass-By-Value)되나, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 (Pass-By-Reference)            변경 불가능하다는 것은 변수가 아니라 값에 대한 진술!              상수 (재할당이 금지된 변수) != 변경 불가능한 값 (읽기 전용 값)       처음 원시 값을 변수에 할당하면 실제 값이 저장되고, 값을 재할당하면 메모리 공간의 주소가 변경됨           → 원시 값은 상태 변경을 금지해 불변성 (Immutability)을 보장하여, 데이터의 신뢰성을 보장한다!              Call-By-Value, Pass-By-Value 또한 엄격히 표현하면, 변수에 메모리 주소가 전달되는 것을 말한다!       → 식별자는 메모리에 저장된 값을 식별해야 하므로, 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억한다.          Constant Poll : 스택 영역과 힙 영역 외에 리터럴을 저장하기 위해 자바스크립트 V8 엔진에서 도입               Integer가 저장되는 방식                Integer는 기본적으로 스택 영역의 SMI (Small Integer)에 저장         32/64Bit OS에서 32/64Bit를 넘어서면 힙 영역의 Constant Poll에 할당                             String이 저장되는 방식                String은 문자열으로 취급 → 모든 리터럴은 힙 영역의 Constant Poll에 할당                       객체 리터럴에 의한 객체 생성 : 중괄호 ({}) 내에 0개 이상의 프로퍼티를 정의      변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성   객체 리터럴의 중괄호는 코드 블록을 의미하지 않음 → 중괄호 뒤에 세미콜론을 붙이지 않음   var person = {   name: 'John',   sayHello: function() {     console.log('Hello');   } }           C++이나 Java → 클래스 (Class) 기반 객체지향 언어 : 클래스를 사전에 정의하고, 필요한 시점에 new 연산자와 함께 생성자 (constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성     자바스크립트 → 프로토타입 (Prototype) 기반 객체지향 언어 : 다양한 객체 생성 방법을 지원                객체 리터럴, Object 생성자, Object.create 메소드, 클래스                  프로퍼티 (property) : 객체의 상태를 나타내는 값 (data)      객체는 0개 이상의 프로퍼티의 집합 → 프로퍼티는 키 (key)와 값 (value)으로 구성            자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.       프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심볼 값 ('', \"\", 식별자)       프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값           var person = {   name: 'John' }      마침표 프로퍼티 접근 연산자 .나 대괄호 프로퍼티 접근 연산자 []을 통해 프로퍼티 접근, 생성, 갱신, 삭제   // 프로퍼티 접근 console.log(person.name); console.log(person[name]); console.log(person[0]);  // 프로퍼티 갱신 person.name = 'Joo';  // 프로퍼티 동적 생성 person.age = 20;  // 프로퍼티 삭제 delete person.name;      ES6 이후부터 객체 리터럴의 확장된 기능을 제공   // 프로퍼티 축약 표현 let name = 'Kim', age = 10; const person = { name, age };  // 프로퍼티 이름으로 프로퍼티 키를 동적 생성 const prefix = 'person'; let i = 0 ; const obj = {   [ ${prefix}-${++i} ] : i,   [ ${prefix}-${++i} ] : i,   [ ${prefix}-${++i} ] : i };  // 메소드 축약 표현 const obj = {   name: 'Lee',   func() { console.log(this.name); } };      자바스크립트 V8 엔진은 자바스크립트 객체의 프로퍼티에 접근하기 위해 동적 탐색 (Dynamic Lookup) 방식 대신, 히든 클래스 (Hidden Class) 방식으로 사용자 편의성과 일정한 성능을 모두 보장하고자 함    메소드 (method) : 프로퍼티를 참조하고 조작할 수 있는 동작 (behavior)      자바스크립트의 함수는 일급 객체이므로, 값으로 취급할 수 있어 프로퍼티 값으로 사용할 수 있음            일반 함수와 달리, 메소드는 객체에 묶어 있는 함수를 의미           var person = {   name: 'John',   getName: function() {     return this.name;   } }   함수 (function) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것         자바스크립트의 함수는 객체 타입의 값 → 함수 또한 함수 리터럴 (functional literal)로 생성할 수 있음            일반 객체와 달리, 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 가짐              함수 정의 : 함수를 호출하기 이전에 인수를 전달받을 매개변수, 문, 반환값을 지정하는 것      함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되므로, 함수는 정의 (definition)된다.          함수 리터럴는 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음            함수 선언문은 표현식이 아닌 문 (statement) → 함수의 이름을 생략할 수 없음              함수 선언문은 표현식이 아닌 문이므로 변수에 할당될 수 없지만, 아래의 함수 선언문은 변수에 할당되는 것처럼 보인다.     var add = function add (x, y) {   return x + y; };  console.log(add(2, 5));     ","categories": [],
        "tags": ["JS"],
        "url": "/js1/",
        "teaser": null
      }]
