<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-16T13:26:55+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[MicroService] 5. MicroService Design</title><link href="http://localhost:4000/microservice5/" rel="alternate" type="text/html" title="[MicroService] 5. MicroService Design" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/microservice5</id><content type="html" xml:base="http://localhost:4000/microservice5/"><![CDATA[<h2 id="마이크로서비스-설계--응집성-높게-high-cohesion-의존도-낮게-low-coupling">마이크로서비스 설계 : 응집성 높게 (<code class="language-plaintext highlighter-rouge">High Cohesion</code>), 의존도 낮게 (<code class="language-plaintext highlighter-rouge">Low Coupling</code>)</h2>

<ul>
  <li>마이크로서비스의 내부 구조를 구성하는 각 요소들은 역할별로 모듈화 (<code class="language-plaintext highlighter-rouge">Modulation</code>)되어야 함
    <ol>
      <li>자체적인 응집도가 높고, 서로 간의 의존성이 낮은 모듈들이 모여 하나의 마이크로서비스를 이룸</li>
      <li>하나의 마이크로서비스는 다른 마이크로서비스와 의존성이 낮아야 함</li>
    </ol>
  </li>
</ul>

<p>→ 마이크로서비스를 구성하는 각각의 요소들은 모두 유연해야 한다.</p>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[마이크로서비스 설계 : 응집성 높게 (High Cohesion), 의존도 낮게 (Low Coupling)]]></summary></entry><entry><title type="html">[MicroService] 4. Agile Development Process</title><link href="http://localhost:4000/microservice4/" rel="alternate" type="text/html" title="[MicroService] 4. Agile Development Process" /><published>2024-01-15T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/microservice4</id><content type="html" xml:base="http://localhost:4000/microservice4/"><![CDATA[<h2 id="에자일-개발-프로세스-agile-development-process--피드백을-통한-지속적인-개선-추구">에자일 개발 프로세스 (<code class="language-plaintext highlighter-rouge">Agile Development Process</code>) : 피드백을 통한 지속적인 개선 추구</h2>

<ul>
  <li>에자일 방법론 (<code class="language-plaintext highlighter-rouge">Agile Methodology</code>) : 신속한 반복 작업으로 소프트웨어를 지속적으로 제공하고자 함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CI/CD</code>, <code class="language-plaintext highlighter-rouge">DevOps</code> 등의 에자일 방법론 중심의 프랙티스</li>
      <li>효율적인 의사소통 구조와 협업 체계를 가진 다기능 팀으로 만듣 수 있는 결과물 → ‘마이크로서비스’</li>
      <li><code class="language-plaintext highlighter-rouge">XP</code>의 ‘지속적 통합’ 프랙티스 : 품질이 보장된 소프트웨어를 반복적으로 개발할 수 있게 함</li>
      <li>스크럼 프로세스 : ‘스크럼 팀’이라는 조직과 ‘스프린트’라는 짧은 반복 주기를 통해 피드백과 개선 작업을 촉진함</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">XP</code>나 스크럼을 살펴보면 개발 문화 및 관리 프로세스를 자세히 다루나, 설계 및 개발 공정에 대해 자세히 언급하지 않음</p>

  <ul>
    <li>에자일 자체가 성숙한 개발 문화에서 좋은 프랙티스을 가속화하고 기존 공정에서 낭비를 제거하는 방식으로 진행
      <ul>
        <li>개발 문화가 미성숙한 팀을 위해 기민한 반복 주기게 적합하며 핵심 활동에 집중할 수 있는 방법이 필요</li>
      </ul>
    </li>
  </ul>

  <p>→ <code class="language-plaintext highlighter-rouge">DDD</code>를 중심으로 에자일 프로세스와 연계하여 마이크로서비스를 설계 및 개발하는 공정이 필요하다!</p>
</blockquote>

<h3 id="기민한-설계-및-개발을-위한-절차--스크럼-기반-마이크로서비스-개발-프로세스">기민한 설계 및 개발을 위한 절차 → 스크럼 기반 마이크로서비스 개발 프로세스</h3>

<ul>
  <li>스크럼 (<code class="language-plaintext highlighter-rouge">Scrum</code>) : 프로젝트 개발 및 관리를 위한 에자일 개발 방법론 중 하나
    <ol>
      <li>제품 백로그 (<code class="language-plaintext highlighter-rouge">Product Backlog</code>) : 개발할 제품에 대한 요구 사항 목록</li>
      <li>스프린트 계획 회의 (<code class="language-plaintext highlighter-rouge">Sprint Planning Meeting</code>) : 스프린트 목표 및 스프린트 백로그를 계획하는 회의</li>
      <li>스프린트 백로그 (<code class="language-plaintext highlighter-rouge">Sprint Backlog</code>) : 각 스프린트 목표에 도달하기 위해 필요한 작업 목록</li>
      <li>스프린트 (<code class="language-plaintext highlighter-rouge">Sprint</code>) : 반복적인 개발 주기 (계획 회의부터 제품 리뷰가 진행되는 날짜까지의 기간 : 1~4주)</li>
      <li>일일 스크럼 회의 (<code class="language-plaintext highlighter-rouge">Daily Scrum Meeting</code>) : 어제 한 일, 오늘 할 일, 장애 등을 공유하는 회의</li>
      <li>시연 (<code class="language-plaintext highlighter-rouge">Testing</code>) : 초기에 정의한 백로그가 모두 구현되고 그 요건을 만족하는지 확인</li>
      <li>회고 (<code class="language-plaintext highlighter-rouge">Review</code>) : 팀원들이 자기 스스로를 돌아보면서 개선점을 논의하여 다음 스프린트에 적용</li>
    </ol>
  </li>
</ul>

<h4 id="구현-스프린트를-진행하기-위한-준비-및-계획--아키텍처-정의-및-마이크로서비스-도출">구현 스프린트를 진행하기 위한 준비 및 계획 → 아키텍처 정의 및 마이크로서비스 도출</h4>

<ul>
  <li>아키텍처 정의 : 마이크로서비스 내부/외부 아키텍처를 정의하는 공정 → 아키텍처 구성도
    <ul>
      <li>기존 워터풀 개발 방식과 달리, 기술 세부사항은 늦게 결정할 수 있어야 한다. (<code class="language-plaintext highlighter-rouge">Robert C. Martin</code>)</li>
      <li>그러나 최소한의 개발 및 테스팅 환경을 준비하는 게 바람직 : 스프린트에 실제 동작하는 어플리케이션 시연 가능
        <ul>
          <li>도커나 쿠버네티스, 스프링부트 등을 미리 결정한다면, 빠르게 개발 환경을 구축해 개발 과정에 진입 가능</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>마이크로서비스 도출 : 스크럼 팀이 개발할 전체 마이크로서비스를 파악하는 작업 → 컨텍스트 맵
    <ul>
      <li>모든 마이크로서비스를 하나의 스크럼 팀이 개발할 수 없음</li>
      <li><code class="language-plaintext highlighter-rouge">DDD</code>의 전략적 설계로 마이크로서비스를 도출하고, 그것들 간의 대략적인 매핑 관계를 정의해, 우선순위 산정</li>
    </ul>
  </li>
</ul>

<h4 id="백엔드와-프런트엔드-개발-공정의-접목--api-명세--도메인-모델링">백엔드와 프런트엔드 개발 공정의 접목 → <code class="language-plaintext highlighter-rouge">API</code> 명세 &amp; 도메인 모델링</h4>

<blockquote>
  <p>백엔드와 프런트엔드 영역 간 계악으로 해당 작업이 선행되고, 각각의 공정이 영역을 나누어서 진행</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">API</code> 명세 (<code class="language-plaintext highlighter-rouge">API Details</code>) : 각 백엔드 마이크로서비스가 프론트엔드에 제공할 서비스 명제들을 정리</li>
  <li>도메인 모델링 (<code class="language-plaintext highlighter-rouge">Domain Modeling</code>) : 화이트보드, 포스트잇 등으로 도메인 설계 모델을 작성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">OOAD</code> 방식과 다른 점? : <code class="language-plaintext highlighter-rouge">UML</code> 등으로 정형화된 설계 모델을 작성해 소스 코드로 변환하지 않음
        <ul>
          <li>단순한 도구들로 작성해 이를 공유하고 피드백을 받아 곧바로 소스 코드로 도메인을 개발</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">MDD</code>와 다른 점? : 추상적인 모델을 완벽히 만들고, 특정 기술이나 프레임워크를 통해 구체화하지 않음
        <ul>
          <li>코드 자체가 모델의 기본 표현 형식을 그대로 반영하므로, 모델과 코드가 단절되지 않음</li>
        </ul>
      </li>
      <li>핵심 도메인 모델을 이해시키기 위해 역공학 도구를 통해 <code class="language-plaintext highlighter-rouge">UML</code> 모델을 표현할 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="ui-레이아웃-정의-및-백엔드-api-호출--프론트엔드-영역-설계-및-개발"><code class="language-plaintext highlighter-rouge">UI</code> 레이아웃 정의 및 백엔드 <code class="language-plaintext highlighter-rouge">API</code> 호출 → 프론트엔드 영역 설계 및 개발</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 흐름 정의 : 비즈니스 흐름에 따른 <code class="language-plaintext highlighter-rouge">UI</code> 흐름 정의 → <code class="language-plaintext highlighter-rouge">UI</code> 스토리보드</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 레이아수 정의 : 사용자 접점인 사용자 인터페이스 정의 → 발사믹 오븐, 카카오 오븐 등으로 산출</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 이벤트 및 액션 정의 : <code class="language-plaintext highlighter-rouge">UI</code> 레이아웃 내에서 특정 행위를 했을 때 발생하는 이벤트 및 액션 정의</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 개발 : <code class="language-plaintext highlighter-rouge">UI</code> 레아아웃 및 이벤트에 맞게 프론트엔드 어플리케이션 개발 → <code class="language-plaintext highlighter-rouge">UI</code> 프레임워크 등으로 산출</li>
</ul>

<h4 id="어플리케이션을-지속적으로-빌드하고-자동으로-배포--빌드-및-배포-환경-자동화">어플리케이션을 지속적으로 빌드하고 자동으로 배포 → 빌드 및 배포 환경 자동화</h4>

<ul>
  <li>소스 코드 리포지토리 구성 : 프론트엔드, 백엔드 코드를 위한 소스 코드 저장소 구성 (<code class="language-plaintext highlighter-rouge">Git</code>)</li>
  <li>통합 빌드 잡 (<code class="language-plaintext highlighter-rouge">Build Job</code>) 구성 : 리포지토리에 존재하는 소스 코드를 통합해 컴파일 및 테스트 (<code class="language-plaintext highlighter-rouge">Jenkins</code>)</li>
  <li>컨테이너 생성 파일 생성 : 컨테이너 배포 환경에서 운영 체제, <code class="language-plaintext highlighter-rouge">WAS</code>, 어플리케이션을 묶어 이미지 생성 (<code class="language-plaintext highlighter-rouge">Dockerfile</code>)</li>
  <li>배포 스크립트 : 자동으로 배포되는 스크립트 작성 (<code class="language-plaintext highlighter-rouge">Jenkins</code>, <code class="language-plaintext highlighter-rouge">Github Actions</code>)</li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[에자일 개발 프로세스 (Agile Development Process) : 피드백을 통한 지속적인 개선 추구]]></summary></entry><entry><title type="html">[MicroService] 3. MicroService Architecture</title><link href="http://localhost:4000/microservice3/" rel="alternate" type="text/html" title="[MicroService] 3. MicroService Architecture" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/microservice3</id><content type="html" xml:base="http://localhost:4000/microservice3/"><![CDATA[<h2 id="비즈니스-로직-business-logic--시스템이-목표로-하는-비즈니스-영역의-규칙-흐름-개념">비즈니스 로직 (<code class="language-plaintext highlighter-rouge">Business Logic</code>) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념</h2>

<blockquote>
  <ul>
    <li>소프트웨어의 가치는? <code class="language-plaintext highlighter-rouge">by Clean Architecture</code>
      <ul>
        <li>행위 기치 : 소프트웨어의 기능</li>
        <li>구조 가치 : 소프트웨어의 아키텍처 → 소프트웨어를 <code class="language-plaintext highlighter-rouge">Soft</code>하게 만드는 것</li>
      </ul>

      <p>→ 코드나 설계의 구조를 깔끔히 하는 대신 기능 구현만 목표하면, 엉망이 된 소프트웨어 대처에 더 많은 비용 발생</p>
    </li>
    <li>문제 영역에서 비즈니스 로직을 분석 및 이해하고, 프로그래밍 언어로 잘 표현하는 것이 개발자의 역할
      <ul>
        <li>기능이 정확하게 동작하는 것과 더불어, 이해하기 쉽고 변경하기 쉬운 시스템을 만드는 것</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="관심사의-분리-separation-of-concerns--시스템의-각-영역이-처리하는-관심사가-분리해-관리되어야-함">관심사의 분리 (<code class="language-plaintext highlighter-rouge">Separation of Concerns</code>) : 시스템의 각 영역이 처리하는 관심사가 분리해 관리되어야 함</h3>

<ul>
  <li>각 영역은 고유의 관심사에 의해 분리되어 집중되어야 함 → 모듈화, 계층화
    <ul>
      <li>비즈니스 로직은 어플리케이션의 핵심 영역이므로, 기술에 영향을 적게 받게 설계해야</li>
      <li>기술과 비즈니스 로직을 분리했을 때, 어플리케이션의 복잡성이 낮아지고 유지보수성이 높아짐</li>
      <li>비즈니스 로직을 모두가 이해할 수 있게 구조화된 객체 모델로 표현되어야 함</li>
    </ul>

    <p>→ 유연하고 확장성 있는 <code class="language-plaintext highlighter-rouge">MSA</code> 시스템을 개발하려면, 마이크로서비스의 내부 구조를 어떻게 유연하게 만들지 고민해야!</p>
  </li>
</ul>

<h2 id="데이터베이스-중심-아키텍처-database-centric-architecture--데이터-중심-서비스-구현">데이터베이스 중심 아키텍처 (<code class="language-plaintext highlighter-rouge">Database Centric Architecture</code>) : 데이터 중심 서비스 구현</h2>

<ol>
  <li>특정한 관계형 데이터베이스에 의존한 데이터 모델링을 수행한다.</li>
  <li>물리 테이블 모델을 중심에 두고 어플리케이션을 구현한다. (예시 : <code class="language-plaintext highlighter-rouge">SpringBoot Application</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Controller</code>, <code class="language-plaintext highlighter-rouge">Service</code>, <code class="language-plaintext highlighter-rouge">DTO</code>, <code class="language-plaintext highlighter-rouge">Repository &amp; Entity</code>로 어플리케이션을 구성</li>
      <li><code class="language-plaintext highlighter-rouge">SQL</code> 매핑 프레임워크인 <code class="language-plaintext highlighter-rouge">MyBatis</code>나 <code class="language-plaintext highlighter-rouge">Java Persistence API</code>인 <code class="language-plaintext highlighter-rouge">JPA</code>로 데이터를 처리</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>데이터베이스 중심 아키텍처에서 비즈니스 로직은 서비스에 존재해야 한다. 그러나,</p>

  <ul>
    <li>흐름 제어 로직만 서비스에 존재하고, 비즈니스 개념이나 규칙은 테이블이나 <code class="language-plaintext highlighter-rouge">SQL</code> 질의로 존재한다.</li>
    <li><code class="language-plaintext highlighter-rouge">DTO</code>는 <code class="language-plaintext highlighter-rouge">SQL</code> 질의를 통해 정보를 가져오는 정보 묶음 (<code class="language-plaintext highlighter-rouge">Information Holder</code>)의 역할밖에 할 수 없다.</li>
  </ul>

</blockquote>

<ul>
  <li>간단한 처리 로직의 경우에는 적합하나, 업무가 다양해지면 점점 복잡성을 제어할 수 없음</li>
  <li>업무 개념이 특정 관계형 테이블 데이터베이스의 테이블로 표현되어, 데이터 질의어인 <code class="language-plaintext highlighter-rouge">SQL</code>가 필요한 경우가 있음</li>
  <li>서비스의 비즈니스 개념과 규칙이 대부분 데이터베이스에 표현 → 성능이 데이터베이스에 의존
    <ul>
      <li>데이터가 늘어남에 따라 데이터베이스의 성능은 지속적으로 떨이짐
        <ul>
          <li>데이터베이스 서버의 <code class="language-plaintext highlighter-rouge">Scale-out</code>과 <code class="language-plaintext highlighter-rouge">SQL</code> 질의문 튜닝에 의존하게 됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="msa-시스템의-확장성과-유연성을-위한-내부-어플리케이션의-아키텍처-구조"><code class="language-plaintext highlighter-rouge">MSA</code> 시스템의 확장성과 유연성을 위한 내부 어플리케이션의 아키텍처 구조</h2>

<ul>
  <li>클라우드의 풍부한 자원 환경에서는, 어플리케이션 자체의 성능보단 어플리케이션의 확장성과 유연성이 더 중요하다!</li>
</ul>

<h3 id="계층형-아키텍처-layered-architecture">계층형 아키텍처 (<code class="language-plaintext highlighter-rouge">Layered Architecture</code>)</h3>

<ul>
  <li>티어 (<code class="language-plaintext highlighter-rouge">Tear</code>) : 물리적인 장비나 서버 컴퓨터 등의 물리 계층</li>
  <li>레이어 (<code class="language-plaintext highlighter-rouge">Layer</code>) : 물리적인 티어 내부에서 어플리케이션이 처리할 관심사를 구분하는 논리 계층
    <ul>
      <li>프레젠테이션 (<code class="language-plaintext highlighter-rouge">Presentation</code>) : 화면 표현 및 전환 처리</li>
      <li>비즈니스 로직 (<code class="language-plaintext highlighter-rouge">Business Logic</code>) : 비즈니스 개념, 규칙, 흐름 제어</li>
      <li>데이터 액세스 (<code class="language-plaintext highlighter-rouge">Data Access</code>) : 데이터 처리</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>계층형 아키텍처를 개발하기 위하여 지켜야 할 규칙!</p>

  <ul>
    <li>상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.</li>
    <li>상위 계층은 하위의 여러 계층을 모두 알 필요 없이 바로 밑의 근접 계층만을 활용한다.</li>
    <li>상위 계층이 하위 계층에 영향받지 않게 구성해야 한다.</li>
    <li>하위 계층은 자신을 사용하는 상위 계층을 알지 못하게끔 구성해야 한다.</li>
    <li>계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.
      <ul>
        <li>구현 클래스에 직접 의존하지 않게끔 하여 약결합을 유지해야 한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>의존성 역전의 원칙 (<code class="language-plaintext highlighter-rouge">DIP</code>) : ‘유연성이 극대화된 시스템은 코드 의존성이 구체가 아닌 추상에 의존한다.’ → <code class="language-plaintext highlighter-rouge">O</code></li>
  <li>개방 폐쇄의 원칙 (<code class="language-plaintext highlighter-rouge">OCP</code>) : ‘소프트웨어 객체는 확장에 열리되, 변경에 닫혀 있어야 한다.’ → <code class="language-plaintext highlighter-rouge">X</code>
    <ul>
      <li>개체의 행위는 확장될 수 있지만, 이때 객체를 변경해서는 안된다. 그러나 상위 계층에서 하위 계층으로 제어의 흐름 (<code class="language-plaintext highlighter-rouge">Flow of Control</code>)이 흐르는 계층형 아키텍처에서 소스 코드의 의존성 또한 그 방향을 따를 수 밖에 없다.</li>
      <li>상위 계층이 하위 계층의 구체 클래스가 아닌 추상 인터페이스에 의존시키고 그 인터페이스의 구현체를 달리해 의존성을 줄이면서 다형성을 유지할 수 있지만, 인터페이스는 그 계층이 정의하는 추상 특성의 한계를 벗어날 수 없다.</li>
    </ul>

    <p>→ 즉, 하위 계층의 유형이 추가되어 확장될 때, 닫혀 있어야 할 상위 계층이 하위 계층이 정의한 특성이 영향받는다!</p>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DIP</code>를 철저히 적용하여 <code class="language-plaintext highlighter-rouge">OCP</code>가 가능하게 하는, 의존 관계 역전의 방법 또한 존재한다.</p>

  <ul>
    <li>프레젠테이션, 비즈니스 로직, 데이터 액세스을 갖는 3계층 시스템이라 가정할 때,
      <ul>
        <li>고수준 영역인 비즈니스 로직이 저수준 영역인 데이터 액세스에 의존한다. (싱위 != 고수준 → 중요도)</li>
        <li>그러나 데이터 액세스 계층에서 정의한 인터페이스가 경계를 넘어 비즈니스 로직 계층에 존재하도록 하면,
          <ul>
            <li>데이터 액세스의 구현체는 비즈니스 로직 계층의 인터페이스만을 보게 된다.</li>
          </ul>

          <p>→ 아례 계층이 위 계층에 의존하게 하는 것이이 의존 관계 역전!</p>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="헥사고날-아키텍처-hexagonal-architecture">헥사고날 아키텍처 (<code class="language-plaintext highlighter-rouge">Hexagonal Architecture</code>)</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DIP</code>를 적용한 계층형 아키텍처의 한계?</p>

  <ul>
    <li>프레젠테이션, 데이터 액세스 계층만이 아닌 다양한 인터페이스를 필요로 하는 현대 어플리케이션
      <ul>
        <li>어플리케이션을 호출하는 다양한 시스템 유형과 어플리케이션과 상호작용하는 다양한 저장소가 존재</li>
      </ul>
    </li>
  </ul>

  <p>→ 단방향 계층 구조가 가지는 근본적인 한계를 넘어서자!</p>
</blockquote>

<ul>
  <li>포트 엔드 어댑터 아키텍처 (<code class="language-plaintext highlighter-rouge">Port and Adapter Architecture</code>)
    <ul>
      <li>저수준의 외부 영역 : 인터페이스 처리를 담당
        <ul>
          <li>인바운드 어댑터 (<code class="language-plaintext highlighter-rouge">Inbound Adaptor</code>) : 서비스 외부에서 들어오는 요청을 처리
            <ul>
              <li><code class="language-plaintext highlighter-rouge">REST API</code>를 발행하는 컨트롤러</li>
              <li>웹 페이지를 구성하는 스프링 <code class="language-plaintext highlighter-rouge">MVC</code> 컨트롤러</li>
              <li>이벤트 메시지를 구독하는 이벤트 핸들러 등</li>
            </ul>
          </li>
          <li>아웃바운드 어댑터 (<code class="language-plaintext highlighter-rouge">Outbound Adaptor</code>) : 서비스 내부의 비즈니스 로직에 의해 호출되어 외부와 연계
            <ul>
              <li>데이터 액세스 처리를 담당하는 <code class="language-plaintext highlighter-rouge">DAO</code></li>
              <li>이벤트 메시지를 발행하는 이벤트 클래스</li>
              <li>외부 서비스를 호출하는 프락시 (<code class="language-plaintext highlighter-rouge">Proxy</code>)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>고수준의 내부 영역 : 순수한 비즈니스 로직 표현
        <ul>
          <li>외부 영역과 연계되는 포트 (<code class="language-plaintext highlighter-rouge">Port</code>)를 가짐 → 어댑터가 포트를 호출
            <ul>
              <li>인바운드 포트 (<code class="language-plaintext highlighter-rouge">Inbound Port</code>) : 내부 영역의 사용을 위해 표출된 <code class="language-plaintext highlighter-rouge">API</code></li>
              <li>아웃바운드 포트 (<code class="language-plaintext highlighter-rouge">Outbound Port</code>) : 내부 영역이 외부를 호출하는 방법 정의</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>-&gt; 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게끔 한다.</p>

<h3 id="클린-아키텍처-clean-architecture">클린 아키텍처 (<code class="language-plaintext highlighter-rouge">Clean Architecture</code>)</h3>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Robert C. Martin</code> : ‘소프트웨어는 행위 가치와 구조 가치를 가지며, 구조 가치는 더 중요하다.’
      <ul>
        <li>왜? : 소프트웨어를 더 유연하게 하는 것이 구조 가치이므로</li>
        <li>소프트웨어를 유연하게 유지하는 방법? : 구조 중에서 선택할 수 있는 사항들을 오랫동안 여는 것
          <ul>
            <li>특히 열어두어야 할 선택 사항은, 중요하지 않는 세부사항</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>엔티티 (<code class="language-plaintext highlighter-rouge">Entity</code>) : 비즈니스 업무 규칙 (사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙)
    <ul>
      <li>모든 시스템에는 해당 도메인의 업무를 규정하는 업무 규칙이 존재 → 시스템 내에서 자동화</li>
      <li>업무 규칙과 데이터를 결합하여 엔티티 객체로 만들 수 있음</li>
    </ul>
  </li>
  <li>유스케이스 (<code class="language-plaintext highlighter-rouge">UseCase</code>) : 어플리케이션 업무 규칙
    <ul>
      <li>자동화된 시스템을 사용하는 처리 절차를 기술</li>
      <li>어플리케이션에 특화된 업무 규칙을 표현하며, 엔티티 내의 업무 규칙을 호출해 시스템을 사용하는 흐름을 닫음</li>
      <li>엔티티는 프레임워크, 데이터베이스에 의존하지 않고 유스케이스 객체를 통해 조작되는 간단한 객체로 존재해야 함</li>
    </ul>
  </li>
  <li>컨트롤러 (<code class="language-plaintext highlighter-rouge">Controller</code>) : 인터페이스 어댑터 (게이트웨어를 통해 연결)</li>
  <li>인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 프레임워크 &amp; 디바이스 (프레젠터를 통해 연결)</li>
</ul>

<blockquote>
  <ul>
    <li>엔티티와 유스케이스를 감싸고 있는 나머지 모든 영역이 세부 사항
      <ul>
        <li>입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토클 등</li>
      </ul>
    </li>
  </ul>

  <p>→ 세부 사항과 유스케이스의 관계를 <code class="language-plaintext highlighter-rouge">DIP</code>를 통해 플러그인처럼 유연하게 처리해야 한다.</p>
</blockquote>

<h2 id="바람직한-마이크로서비스의-내부-아키텍처--클린-마이크로서비스-clean-microservice">바람직한 마이크로서비스의 내부 아키텍처 → 클린 마이크로서비스 (<code class="language-plaintext highlighter-rouge">Clean Microservice</code>)</h2>

<ul>
  <li>마이크로서비스 시스템에서 정의해야 할 마이크로서비스의 내부 구조가 다양할 수 있음
    <ul>
      <li>자율적인 마이크로서비스 팀에 의한 폴리글랏한 내부 구조를 가질 수 있기 때문</li>
      <li>간단한 기능이면 모노리스를, 복잡한 기능이면 헥사고날/클린 아키텍처의 구조를 기반으로 정의하는 게 바람직</li>
    </ul>
  </li>
</ul>

<h3 id="클린-마이크로서비스-아키텍처가-지향해야-할-원칙">클린 마이크로서비스 아키텍처가 지향해야 할 원칙</h3>

<ul>
  <li>지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.</li>
  <li>업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.</li>
  <li>세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분된다.</li>
  <li>고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 한다.</li>
  <li>저수준 영역은 언제든지 교체 및 확장이 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안 된다.</li>
  <li>인터페이스나 추상 클래스를 지원하는 <code class="language-plaintext highlighter-rouge">Java</code>의 경우, 구체 클래스가 추상 인터페이스에 의존하는 <code class="language-plaintext highlighter-rouge">DIP</code>를 적용한다.</li>
  <li>인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수주느이 어댑터가 이를 구현한다.</li>
</ul>

<h3 id="클린-마이크로서비스-아키텍처의-구조">클린 마이크로서비스 아키텍처의 구조</h3>

<ul>
  <li>
    <h4 id="내부-영역-inbound-area--비즈니스-로직을-표현하는-영역">내부 영역 (<code class="language-plaintext highlighter-rouge">Inbound Area</code>) : 비즈니스 로직을 표현하는 영역</h4>
    <ul>
      <li>
        <h5 id="도메인-domain--내부-영역의-중심부에-존재하는-영역">도메인 (<code class="language-plaintext highlighter-rouge">Domain</code>) : 내부 영역의 중심부에 존재하는 영역</h5>
        <ul>
          <li>핵심 비즈니스 개념과 규칙을 구현</li>
          <li>엔티티 (<code class="language-plaintext highlighter-rouge">Entity</code>)와 값 객체 (<code class="language-plaintext highlighter-rouge">VO</code>)를 갖는 에그리거트 (<code class="language-plaintext highlighter-rouge">Aggregate</code>)로 존재</li>
        </ul>
      </li>
      <li>
        <h5 id="서비스-service---내부-영역에서-도메인을-감싸는-영역">서비스 (<code class="language-plaintext highlighter-rouge">Service</code>) :  내부 영역에서 도메인을 감싸는 영역</h5>
        <ul>
          <li>도메인을 호출하여 업무를 처리하는 절차를 기술</li>
        </ul>
      </li>
      <li>
        <h5 id="서비스-인터페이스-service-if--서비스-처리를-위한-인터페이스">서비스 인터페이스 (<code class="language-plaintext highlighter-rouge">Service I/F</code>) : 서비스 처리를 위한 인터페이스</h5>
        <ul>
          <li>외부에서 내부 영역에 존재하는 서비스를 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">API</code>를 제공</li>
        </ul>
      </li>
      <li>
        <h5 id="api-프록시-인터페이스-api-proxy-if--다른-서비스의-api-프록시-호출을-위한-인터페이스"><code class="language-plaintext highlighter-rouge">API</code> 프록시 인터페이스 (<code class="language-plaintext highlighter-rouge">API Proxy I/F</code>) : 다른 서비스의 <code class="language-plaintext highlighter-rouge">API</code> 프록시 호출을 위한 인터페이스</h5>
        <ul>
          <li>프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>) 패턴 : 프록시에게 어떤 일을 대신하게 함
            <ul>
              <li>어떤 객체를 사용할 때, 객체를 직접 참조하지 않고 이에 대응되는 프록시 객체로 대상 객체에 접근</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <h5 id="레포지토리-인터페이스-repository-if--저장소-처리를-위한-인터페이스">레포지토리 인터페이스 (<code class="language-plaintext highlighter-rouge">Repository I/F</code>) : 저장소 처리를 위한 인터페이스</h5>
        <ul>
          <li>비즈니스를 처리하는 데에 필요한 기본적인 저장소 처리 사항을 추상화해 정의</li>
          <li>외부 영역의 저장소 어댑터가 각 저장소에 맞는 저장소 처리 세부 기술로 구현</li>
        </ul>
      </li>
      <li>
        <h5 id="도메인-이벤트-발행-인터페이스-domain-event-publish-if--이벤트-메시지-발행을-위한-인터페이스">도메인 이벤트 발행 인터페이스 (<code class="language-plaintext highlighter-rouge">Domain Event Publish I/F</code>) : 이벤트 메시지 발행을 위한 인터페이스</h5>
        <ul>
          <li>도메인 이벤트 (<code class="language-plaintext highlighter-rouge">Domain Event</code>) : 어떤 사건에 따른 상태의 변경 사항</li>
          <li>하나의 도메인 이벤트를 각 명칭을 갖는 클래스로 구현 → 컨슈머 (<code class="language-plaintext highlighter-rouge">Consumer</code>)에 전달되어 발행 (<code class="language-plaintext highlighter-rouge">Publish</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="외부-영역-outbound-area--기술-중심의-세부-사항을-의미하는-영역">외부 영역 (<code class="language-plaintext highlighter-rouge">Outbound Area</code>) : 기술 중심의 세부 사항을 의미하는 영역</h4>
    <ul>
      <li>
        <h5 id="api-퍼플리싱-어댑터--클라이언트--서비스-인터페이스"><code class="language-plaintext highlighter-rouge">API</code> 퍼플리싱 어댑터 : 클라이언트 ↔ 서비스 인터페이스</h5>
        <ul>
          <li>내부 영역의 서비스 인터페이스를 호출해 <code class="language-plaintext highlighter-rouge">REST API</code>를 발행하는 인바운드 어댑터</li>
          <li>명시적인 <code class="language-plaintext highlighter-rouge">REST</code> 리소스 명칭을 정의하고, 각 <code class="language-plaintext highlighter-rouge">REST</code> 메소드가 의도에 맞게 서비스 인터페이스를 호출</li>
          <li>엔티티를 직접 제공하지 않고 <code class="language-plaintext highlighter-rouge">API</code>에 맞는 <code class="language-plaintext highlighter-rouge">DTO</code>를 생성해 엔티티를 변환 및 매핑해 전달해야 함</li>
        </ul>
      </li>
      <li>
        <h5 id="api-호출-프록시-어댑터--프록시-인터페이스--다른-서비스"><code class="language-plaintext highlighter-rouge">API</code> 호출 프록시 어댑터 : 프록시 인터페이스 ↔ 다른 서비스</h5>
        <ul>
          <li>내부 영역에 정의된 프록시 인터페이스를 구현하여 다른 서비스의 <code class="language-plaintext highlighter-rouge">API</code>를 호출하는 아웃바운드 어댑터</li>
          <li><code class="language-plaintext highlighter-rouge">REST API</code>, 소켓이나 <code class="language-plaintext highlighter-rouge">SOAP</code> 프로토콜 등 각 기술에 맞는 적절한 통신 방법을 구현해야 함</li>
        </ul>
      </li>
      <li>
        <h5 id="저장소-처리-어댑터--레포지토리-인터페이스--데이터베이스">저장소 처리 어댑터 : 레포지토리 인터페이스 ↔ 데이터베이스</h5>
        <ul>
          <li>데이터 처리 메커니즘의 선택 → <code class="language-plaintext highlighter-rouge">SQL vs OR?</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">SQL</code> 매핑 방식 (<code class="language-plaintext highlighter-rouge">MyBatis</code>) : <code class="language-plaintext highlighter-rouge">SQL</code> 질의문을 수동으로 작성할 수 있어 세밀한 <code class="language-plaintext highlighter-rouge">SQL</code> 제어가 가능</li>
              <li><code class="language-plaintext highlighter-rouge">OR</code> 매핑 방식 (<code class="language-plaintext highlighter-rouge">JPA</code>, <code class="language-plaintext highlighter-rouge">Spring Data</code>) : 런타임 시 <code class="language-plaintext highlighter-rouge">OR</code> 매퍼가 저장소에 따라 자동으로 질의문 생성
                <ul>
                  <li>질의문을 수동으로 작성할 필요가 줄어들어 균일한 질의문 품질과 생산성 향상 가능</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <h5 id="도메인-이벤트-발행-어댑터--이벤트-인터페이스--메시지-브로커">도메인 이벤트 발행 어댑터 : 이벤트 인터페이스 ↔ 메시지 브로커</h5>
        <ul>
          <li>도메인 이벤트를 발행하여 송신하는 아웃바운드 어댑터</li>
          <li>실제 도메인 이벤트가 생성되는 위치는 내부 영역
            <ul>
              <li>에그리거트 패턴을 적용했을 때의 도메인 이벤트는 에그리거트에서 발생한 사건이 됨</li>
            </ul>
          </li>
          <li>도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스의 구현체
            <ul>
              <li>특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <h5 id="도메인-이벤트-핸들러-어댑터--메시지-브로커--서비스-인터페이스">도메인 이벤트 핸들러 어댑터 : 메시지 브로커 ↔ 서비스 인터페이스</h5>
        <ul>
          <li>발행된 도메인 이벤트를 수신할 수 있는 인바운드 어댑터</li>
          <li>외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달</li>
          <li>이벤트의 상태에 따라 적절한 서비스 인터페이스를 호출해서 내부 영역에 이벤트를 전달해야 함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="클린-마이크로서비스의-내부-영역에-참고할-만한-패턴">클린 마이크로서비스의 내부 영역에 참고할 만한 패턴</h3>

<ul>
  <li>서비스 인터페이스는 외부 영역이 내부 영역에 대해 많이 알지 못하게 함
    <ul>
      <li>서비스 인터페이스가 없다면? : 추이 종속성이 발생할 수 있고, 정보 은닉성이 보장될 수 없음</li>
    </ul>
  </li>
  <li>리포지토리 인터페이스, 도메인 이벤트 인터페이스, <code class="language-plaintext highlighter-rouge">API</code> 프록시 인터페이스는 <code class="language-plaintext highlighter-rouge">DIP</code>를 지원
    <ul>
      <li>고수준 영역에 인터페이스가 존재하면, 저수준 영역의 외부 어댑터가 이러한 인터페이스를 구현하도록 해야 함</li>
    </ul>
  </li>
  <li>도메인은 비즈니스 개념을 표현하는 엔티티의 역할울 수행</li>
  <li>서비스는 도메인을 활용하여 시스템의 흐름 처리를 수행하는 유스케이스의 역할을 수행</li>
</ul>

<h4 id="간단한-비즈니스-로직의-처리--트랜잭션-스크립트-transaction-script-패턴">간단한 비즈니스 로직의 처리 → 트랜잭션 스크립트 (<code class="language-plaintext highlighter-rouge">Transaction Script</code>) 패턴</h4>

<ul>
  <li>비즈니스 개념을 표현하는 도메인 객체가 행위를 가지고 있지 않음</li>
  <li>모든 비즈내스 행위, 즉 무언가를 수행하는 책임은 서비스에 있음</li>
  <li>서비스가 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행
    <ul>
      <li>절차식 프로그래밍 방식과 같기 때문에 객체지향 지식이 없어도 일반적으로 쉽게 이해할 수 있는 구조</li>
      <li>기존의 데이터베이스 중심 아키텍처에 익숙하다면 더 빠르게 적응할 수 있음</li>
    </ul>
  </li>
  <li>비즈니스가 복잡해질수록 서비스 코드의 양이 늘어남
    <ul>
      <li>서비스가 비대해지면서, 도메인 객체는 정보 묶음의 역할만을 수행</li>
      <li>비즈니스 로직 처리가 서비스에서 이루어지므로, 비슷한 유스케이스로 중복된 코드가 생겨나 유지보수에 어려움</li>
    </ul>
  </li>
</ul>

<h4 id="복잡한-비즈니스-로직의-처리--도메인-모델-domain-model-패턴">복잡한 비즈니스 로직의 처리 → 도메인 모델 (<code class="language-plaintext highlighter-rouge">Domain Model</code>) 패턴</h4>

<ul>
  <li>도메인 객체가 데이터뿐만이 아니라 비즈니스 행위를 가짐
    <ul>
      <li>도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉</li>
      <li>도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행</li>
    </ul>
  </li>
  <li>서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임하여 처리
    <ul>
      <li>서비스의 책임이 도메인으로 적절히 분산되므로 서비스 메소드가 단순해짐</li>
    </ul>
  </li>
  <li>도메인 모델 패턴의 도메인 모델은 객체지향 설계의 객체 모델
    <ul>
      <li>각기 적절한 책임을 가진 여러 클래스들로 구성되므로 이해하기 쉽고 관리 및 테스트가 용이</li>
      <li>잘 만들어진 도메인 모델은 복잡한 비즈니스 로직의 처리에 유용</li>
      <li>잘 정의된 도메인 모델은 코드의 양을 줄이고 재사용성을 높일 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="복잡한-도메인-모델의-단순화--에그리거트-aggregate-패턴">복잡한 도메인 모델의 단순화 → 에그리거트 (<code class="language-plaintext highlighter-rouge">Aggregate</code>) 패턴</h4>

<blockquote>
  <ul>
    <li>도메인 모델링 : 객체간의 관계를 참조로 표현
      <ul>
        <li>일대다 (<code class="language-plaintext highlighter-rouge">One-to-Many</code>) 관계의 객체를 쉽게 사용할 수 있음</li>
        <li>업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고, 그로 인해 참조 관계가 복잡해짐</li>
      </ul>
    </li>
  </ul>

  <p>→ 즉, 복잡한 도메인 모델은 모델 내부의 경계가 불명확하다. 이 문제를 어떻게 해결할까?</p>
</blockquote>

<ul>
  <li>에그리거트 : 데이터 변경의 단위로 다루는 연관 객체의 묶음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Root Entity</code>에서 개념적으로 묶인 엔티티의 집합</li>
      <li>1개 이상의 연관된 엔티티와 값 객체 (<code class="language-plaintext highlighter-rouge">VO</code>)로 구성된 하나의 묶음 전체</li>
      <li>개별 객체 수준의 모델 → 에그리거트 단위의 모델을 통해 도메인 모델을 단순화</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>에그리거트를 한 단위로 일관되게 처리하기 위한 규칙</p>

  <ul>
    <li>에그리거트 루트만 참조한다.</li>
    <li>에그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해서만 참조해야 한다. 수정할 때도 동일하다.</li>
    <li>에그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.</li>
    <li>기본 키를 사용하면 느슨하게 연관되고 수정이 필요없는 에그리거트를 함께 수정하는 실수를 방지한다.</li>
    <li>하나의 트랜잭션으로 하나의 에그리거트만을 생성 및 수정한다.</li>
  </ul>
</blockquote>

<h3 id="클린-마이크로서비스의-내부-영역에-참고할-만한-패턴-1">클린 마이크로서비스의 내부 영역에 참고할 만한 패턴</h3>

<ul>
  <li>어댑터는 각각의 인터페이스에 대한 동기/비동기 통신 및 저장소 처리를 작업한다.
    <ul>
      <li>외부 영역은 내부 영역에 존재하는 서비스 인터페이스를 사용하는 인바운드 어댑터와,<br />내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 아웃바운드 어댑터로 구성된다.</li>
    </ul>
  </li>
  <li>어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야 한다.
    <ul>
      <li>내부 영역이 먼저 정의된 후에 외부 영역의 세부 사항은 늦게 정의돼도 상관없도록 해야 한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[비즈니스 로직 (Business Logic) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념]]></summary></entry><entry><title type="html">[Java] 1. Java</title><link href="http://localhost:4000/java1/" rel="alternate" type="text/html" title="[Java] 1. Java" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-14T00:00:00+09:00</updated><id>http://localhost:4000/java1</id><content type="html" xml:base="http://localhost:4000/java1/"><![CDATA[<h2 id="자바-java--객체지향-프로그래밍-언어-object-oriented-programming-language">자바 (<code class="language-plaintext highlighter-rouge">Java</code>) : 객체지향 프로그래밍 언어 (<code class="language-plaintext highlighter-rouge">Object-Oriented Programming Language</code>)</h2>

<ul>
  <li>객체지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">OOP</code>) : 초기부터 객체지향 방법론에 의거해 객체 지향 프로그램 언어로 설계
    <ul>
      <li>먼저 객체를 만들고, 이들 객체들을 서로 연결하여 하나의 큰 프로그램을 완성</li>
    </ul>
  </li>
  <li>플랫폼에 독립적 : 동일한 프로그램을 여러 운영체제에서 실행 가능
    <ul>
      <li>어떤 운영체제인지 상괸없이 동일한 <code class="language-plaintext highlighter-rouge">.java</code> 파일을 컴파일하면, 동일한 <code class="language-plaintext highlighter-rouge">.class</code> 파일이 생성</li>
      <li><code class="language-plaintext highlighter-rouge">WORA</code> : <code class="language-plaintext highlighter-rouge">Write Once, Run Anywhere</code></li>
    </ul>
  </li>
  <li>메모리를 자동으로 정리 : 가비지 콜렉터 등을 활용해 <code class="language-plaintext highlighter-rouge">RAM</code>을 자동으로 관리</li>
  <li>풍부한 래퍼런스 : 오픈 소스 라이브러리를 기반으로 한 자바 생태계가 장기간 구축되어왔음</li>
</ul>

<h3 id="java-se--java의-표준-문법-standard-edition"><code class="language-plaintext highlighter-rouge">Java SE</code> : <code class="language-plaintext highlighter-rouge">Java</code>의 표준 문법 (<code class="language-plaintext highlighter-rouge">Standard Edition</code>)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Java</code>가 어떤 문법적인 구성을 가졌는지, 와 같은 것들을 정의</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Oracle</code>에서 <a href="https://www.oracle.com/kr/java/technologies/java-se-support-roadmap.html"><code class="language-plaintext highlighter-rouge">Java</code> 공식 로드맵</a>을 통해 자바의 미래 버전 적용 상황을 볼 수 있음</p>
</blockquote>

<h3 id="jdk-java-development-kit--java-se의-구현체"><code class="language-plaintext highlighter-rouge">JDK</code> (<code class="language-plaintext highlighter-rouge">Java Development Kit</code>) : <code class="language-plaintext highlighter-rouge">Java SE</code>의 구현체</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Java</code> 프로그램을 개발하고 실행하기 위해 <code class="language-plaintext highlighter-rouge">JRE</code> 및 여러 개발 도구들을 제공</li>
</ul>

<h3 id="자바-런타임-환경-java-runtime-environment--java를-위한-서비스를-제공하는-소프트웨어-계층">자바 런타임 환경 (<code class="language-plaintext highlighter-rouge">Java Runtime Environment</code>) : <code class="language-plaintext highlighter-rouge">Java</code>를 위한 서비스를 제공하는 소프트웨어 계층</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JRE</code>는 컴퓨터 운영체제 위에서 존재하며, <code class="language-plaintext highlighter-rouge">JVM</code> 및 라이브러리로 구성</li>
  <li>자바 코드를 필요한 라이브러리와 결합한 뒤에 <code class="language-plaintext highlighter-rouge">JVM</code>을 시작하는 온디스크 시스템</li>
</ul>

<h2 id="자바-가상-머신-java-virtual-machine--서로-다른-플랫폼에-동일한-java-실행-환경-제공">자바 가상 머신 (<code class="language-plaintext highlighter-rouge">Java Virtual Machine</code>) : 서로 다른 플랫폼에 동일한 <code class="language-plaintext highlighter-rouge">Java</code> 실행 환경 제공</h2>

<ul>
  <li>플랫폼에 종속적 : 자바에서 소스 파일을 통해 생성된 바이트 코드를 <code class="language-plaintext highlighter-rouge">CPU</code>에 맞게 바이너리 코드로 해석한 후 실행
    <ul>
      <li>소스 코드 (<code class="language-plaintext highlighter-rouge">source code</code>) : <code class="language-plaintext highlighter-rouge">Java</code> 언어로 작성된 소스 파일 (<code class="language-plaintext highlighter-rouge">*.java</code>)</li>
      <li>바이트 코드 (<code class="language-plaintext highlighter-rouge">byte code</code>) : 소스 코드를 <code class="language-plaintext highlighter-rouge">JVM</code>이 이해할 수 있는 언어로 변환한 파일 (<code class="language-plaintext highlighter-rouge">*.class</code>)</li>
      <li>바이너리 코드 (<code class="language-plaintext highlighter-rouge">binary code</code>) : 컴퓨터가 이해할 수 있는 <code class="language-plaintext highlighter-rouge">1bit</code> 크기의 <code class="language-plaintext highlighter-rouge">0</code>과 <code class="language-plaintext highlighter-rouge">1</code>로 이루어진 이진 코드</li>
    </ul>
  </li>
</ul>

<h3 id="클래스-로더-class-loader--jvm-내로-class-파일을-로드하고-이를-실행-엔진에-배치">클래스 로더 (<code class="language-plaintext highlighter-rouge">Class Loader</code>) : <code class="language-plaintext highlighter-rouge">JVM</code> 내로 <code class="language-plaintext highlighter-rouge">.class</code> 파일을 로드하고 이를 실행 엔진에 배치</h3>

<ul>
  <li>메소드 영역에 저장되는 데이터 : <code class="language-plaintext highlighter-rouge">FQCN</code> / 클래스, 인터페이스, <code class="language-plaintext highlighter-rouge">enum</code> / 메소드와 변수</li>
</ul>

<ol>
  <li>
    <h4 id="로딩-loading--jvm이-시작할-때-3개의-클래스-로더가-순서대로-동작">로딩 (<code class="language-plaintext highlighter-rouge">Loading</code>) : <code class="language-plaintext highlighter-rouge">JVM</code>이 시작할 때, 3개의 클래스 로더가 순서대로 동작</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">BootStrap ClassLoader</code> : <code class="language-plaintext highlighter-rouge">JDK</code> 클래스 파일 (코어 자바 <code class="language-plaintext highlighter-rouge">API</code>) 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">Platform ClassLoader</code> : <code class="language-plaintext highlighter-rouge">JAVA_HOME/lib/ext</code> 또는 <code class="language-plaintext highlighter-rouge">java.ext.dirs</code>에 위치한 클래스 파일 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">System ClassLoader</code> : <code class="language-plaintext highlighter-rouge">classPath</code>나 <code class="language-plaintext highlighter-rouge">modulePath</code>에 위치한 클래스 파일 로딩</li>
    </ul>
    <ul>
      <li>마지막까지 클래스를 찾지 못하면 <code class="language-plaintext highlighter-rouge">ClassFoundException</code></li>
    </ul>
  </li>
  <li>
    <h4 id="링크-linking--로드된-class-파일을-검사하고-이를-메소드-영역에-넣음">링크 (<code class="language-plaintext highlighter-rouge">Linking</code>) : 로드된 <code class="language-plaintext highlighter-rouge">.class</code> 파일을 검사하고 이를 메소드 영역에 넣음</h4>
    <ul>
      <li>검증 (<code class="language-plaintext highlighter-rouge">Verify</code>) : <code class="language-plaintext highlighter-rouge">.class</code> 파일 형식이 유효한지 검사</li>
      <li>준비 (<code class="language-plaintext highlighter-rouge">Preparation</code>) : 클래스 변수 (<code class="language-plaintext highlighter-rouge">static</code>)와 기본값에 필요한 메모리를 준비</li>
      <li>교체 (<code class="language-plaintext highlighter-rouge">Resolve</code>) : 심볼릭 메모리 래퍼런스를 메소드 영역에 있는 실제 래퍼런스로 교체</li>
    </ul>
  </li>
  <li>
    <h4 id="초기화-initialization--static-변수-또는-static-블록-내부의-값을-기본값으로-할당">초기화 (<code class="language-plaintext highlighter-rouge">Initialization</code>) : <code class="language-plaintext highlighter-rouge">static</code> 변수 또는 <code class="language-plaintext highlighter-rouge">static</code> 블록 내부의 값을 기본값으로 할당</h4>
  </li>
</ol>

<h3 id="자바-실행-엔진-execution-engine--클래스-로더에-의해-배치된-클래스의-바이트-코드를-실행">자바 실행 엔진 (<code class="language-plaintext highlighter-rouge">Execution Engine</code>) : 클래스 로더에 의해 배치된 클래스의 바이트 코드를 실행</h3>

<ul>
  <li>자바 인터프리터 (<code class="language-plaintext highlighter-rouge">Java Interpreter</code>) : <code class="language-plaintext highlighter-rouge">JVM</code>에서 바이트 코드를 한줄씩 명령어 단위로 읽어 번역</li>
  <li><code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러 : 인터프리터 방식으로 실행하다가, 적절한 시점에 바이트 코드 전체를 바이너리 코드로 번역해 실행</li>
  <li>가비지 콜렉터 (<code class="language-plaintext highlighter-rouge">Garbage Collector</code>) : 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제해 메모리를 관리</li>
</ul>

<h3 id="런타임-데이터-에리어-runtime-data-area--운영체제에서-프로그램-수행을-위해-할당한-메모리-공간">런타임 데이터 에리어 (<code class="language-plaintext highlighter-rouge">Runtime Data Area</code>) : 운영체제에서 프로그램 수행을 위해 할당한 메모리 공간</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PC</code> 레지스터 (<code class="language-plaintext highlighter-rouge">PC Register</code>) : 쓰레드 (<code class="language-plaintext highlighter-rouge">Thread</code>)가 시작될 때 생성되는 공간
    <ul>
      <li>쓰레드가 현재 실행할 스택 프레임을 가리키는 포인터 생성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">JVM stack</code> : 프로그램 실행 과정에서 임시로 할당할 데이터를 저장 (메소드 호출 시 마다 각각의 스택 프레임 생성)</li>
  <li><code class="language-plaintext highlighter-rouge">Native method stack</code> : 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행</li>
  <li>힙 (<code class="language-plaintext highlighter-rouge">Heap</code>) : 모든 쓰레드가 공유하는 객체 저장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">new</code>로 생성된 객체와 배열 혹은 <code class="language-plaintext highlighter-rouge">String</code> 관련 자원이 저장 / <code class="language-plaintext highlighter-rouge">GC</code>에 의해 관리</li>
      <li><code class="language-plaintext highlighter-rouge">Permanent Generation</code> : 생성된 객체들의 정보의 주소값 저장
        <ul>
          <li>리플렉션 (<code class="language-plaintext highlighter-rouge">Reflection</code>) 으로 동적으로 클래스가 로드될 때 사용</li>
          <li>클래스 로더에 의해 로드된 클래스, 메소드 등에 대한 메타 정보가 저장 : <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 사용</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">New</code>/<code class="language-plaintext highlighter-rouge">Young</code> : 생명 주기가 짧은 객체를 <code class="language-plaintext highlighter-rouge">GC</code>의 대상으로 하는 영역 (<code class="language-plaintext highlighter-rouge">Minor GC</code> 발생)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">Eden</code> : 객체들이 처음 생성되는 공간 (첫번째 <code class="language-plaintext highlighter-rouge">GC</code>가 발생)</li>
          <li><code class="language-plaintext highlighter-rouge">Survivor 0, 1</code> : <code class="language-plaintext highlighter-rouge">Eden</code>에서 참조되는 객체들이 저장 (<code class="language-plaintext highlighter-rouge">Major GC</code> 발생 : <code class="language-plaintext highlighter-rouge">Minor GC</code>에 비해 느림)</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">Old</code> : 생명 주기가 긴 객체를 <code class="language-plaintext highlighter-rouge">GC</code>의 대상으로 하는 영역
        <ul>
          <li><code class="language-plaintext highlighter-rouge">New</code>/<code class="language-plaintext highlighter-rouge">Young</code>에서 일정 시간 참조되고 있는 객체들이 저장</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>메소드 영역 (<code class="language-plaintext highlighter-rouge">Method Area</code>) : 클래스를 메모리에 처음 올릴 때 초기화하는 클래스 이름, <code class="language-plaintext highlighter-rouge">static</code> 메소드나 변수 저장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime Constant Pool</code> : 상수 자료형을 저장해 참조 (중복 방지)</li>
    </ul>
  </li>
</ul>

<h3 id="자바-네이티브-인터페이스-java-native-interface--자바-네이티브-코드로-작성된-함수-사용-방법-제공">자바 네이티브 인터페이스 (<code class="language-plaintext highlighter-rouge">Java Native Interface</code>) : 자바 네이티브 코드로 작성된 함수 사용 방법 제공</h3>

<ul>
  <li>자바 네이티브 코드 (<code class="language-plaintext highlighter-rouge">Java Native Code</code>) : 다른 언어로 작성된 라이브러리를 <code class="language-plaintext highlighter-rouge">JVM</code> 내에서 호출하는 코드</li>
  <li>네이티브 메소드 라이브러리 (<code class="language-plaintext highlighter-rouge">Native Method Library</code>) : 네이티브 실행 프로그램을 만들 때 사용되는 라이브러리</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Java" /><summary type="html"><![CDATA[자바 (Java) : 객체지향 프로그래밍 언어 (Object-Oriented Programming Language)]]></summary></entry><entry><title type="html">[Algorithm] 3. 그리디</title><link href="http://localhost:4000/algorithm3/" rel="alternate" type="text/html" title="[Algorithm] 3. 그리디" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-14T00:00:00+09:00</updated><id>http://localhost:4000/algorithm3</id><content type="html" xml:base="http://localhost:4000/algorithm3/"><![CDATA[<h2 id="그리디-greedy--매-순간-가장-좋은-것을-선택-현재의-선택이-나중에-미칠-영향은-고려-x">그리디 (<code class="language-plaintext highlighter-rouge">Greedy</code>) : 매 순간 가장 좋은 것을 선택 (현재의 선택이 나중에 미칠 영향은 고려 <code class="language-plaintext highlighter-rouge">X</code>)</h2>

<ul>
  <li>사전에 외우고 있지 않아도, 풀 수 있을 가능성이 높음</li>
  <li>특정 문제를 만났을 때, 그리디 알고리즘을 적용해 문제를 풀 수 있을지 파악할 수 있어야 함</li>
  <li>‘가장 큰 순서대로’, ‘가장 작은 크기부터’와 같은 기준이 제시됨</li>
  <li>(1) 문제 풀이를 위한 최소한의 아이디어를 떠올리고, (2) 그것이 정당한지 검토해야 답을 도출할 수 있음</li>
</ul>

<h3 id="boj-11047번-동전-0-s4"><a href="https://www.acmicpc.net/problem/11047"><code class="language-plaintext highlighter-rouge">BOJ</code> 11047번. 동전 0 (<code class="language-plaintext highlighter-rouge">S4</code>)</a></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import sys
read = sys.stdin.readline

N, K = map(int, read().split())
O = 0
C = list([read() for i in range(N)])

for i in range(N):
    if (K &lt; int(C[N - 1 - i])):
        continue
    else:
        while (K &gt;= int(C[N - 1 - i])):
            K -= int(C[N - 1 - i])
            O += 1

    print(O)
</code></pre></div></div>

<h3 id="boj-1931번-회의실-배정-s1"><a href="https://www.acmicpc.net/problem/1931"><code class="language-plaintext highlighter-rouge">BOJ</code> 1931번. 회의실 배정 (<code class="language-plaintext highlighter-rouge">S1</code>)</a></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import sys
read = sys.stdin.readline

N = int(read())
li = [list(map(int, read().split())) for i in range(N)]

li.sort(key=lambda x: [x[1], x[0]])

R = 1
C = li[0][1]

for i in range(N - 1):
    if C &lt;= li[i + 1][0]:
        C = li[i + 1][1]
        R += 1

print(R)
</code></pre></div></div>

<h3 id="boj-11399번-atm-s4"><a href="https://www.acmicpc.net/problem/11399"><code class="language-plaintext highlighter-rouge">BOJ</code> 11399번. ATM (<code class="language-plaintext highlighter-rouge">S4</code>)</a></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import sys
read = sys.stdin.readline

N = int(read())
li = list(map(int, read().split()))
li.sort()

s = 0

for i in range(N):
    s += li[i] * (N - i)

print(s)
</code></pre></div></div>

<h3 id="boj-1541번-잃어버린-괄호-s2"><a href="https://www.acmicpc.net/problem/1541"><code class="language-plaintext highlighter-rouge">BOJ</code> 1541번. 잃어버린 괄호 (<code class="language-plaintext highlighter-rouge">S2</code>)</a></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import sys
read = sys.stdin.readline

li = read().split('-')
r = 0

for i in range(len(li)):
    s = li[i]
    s = s.split('+')
    s = list(map(int, s))
    s = sum(s)
    if i == 0:
        r = s
    else:
        r -= s

print(r)
</code></pre></div></div>

<h3 id="boj-13305번-주유소-s3"><a href="https://www.acmicpc.net/problem/13305"><code class="language-plaintext highlighter-rouge">BOJ</code> 13305번. 주유소 (<code class="language-plaintext highlighter-rouge">S3</code>)</a></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import sys
read = sys.stdin.readline

N = int(read())
L = list(map(int, read().split()))
P = list(map(int, read().split()))

C = 0
S = L[C] * P[C]

for i in range(1, N - 1):
    if L[i] * P [C] &gt; L[i] * P[i]:
        C = i
    S += L[i] * P [C]

print(S)
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Algorithm" /><summary type="html"><![CDATA[그리디 (Greedy) : 매 순간 가장 좋은 것을 선택 (현재의 선택이 나중에 미칠 영향은 고려 X)]]></summary></entry><entry><title type="html">[Java] 2. 변수 (variable)</title><link href="http://localhost:4000/java2/" rel="alternate" type="text/html" title="[Java] 2. 변수 (variable)" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-14T00:00:00+09:00</updated><id>http://localhost:4000/java2</id><content type="html" xml:base="http://localhost:4000/java2/"><![CDATA[<h2 id="변수-variable--하나의-값을-저장할-수-있는-메모리-번지에-붙어진-이름">변수 (<code class="language-plaintext highlighter-rouge">variable</code>) : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름</h2>

<ul>
  <li>변수의 선언 : 어떤 차입의 데이터를 저장할지, 그리고 변수의 이름이 무엇인지 결정</li>
  <li>변수의 이름 : 첫번째 글자는 소문자로 시작하되, 캐멀 스타일 (<code class="language-plaintext highlighter-rouge">Camel Style</code>)로 작성하는 것이 관례</li>
  <li>값의 대입 (<code class="language-plaintext highlighter-rouge">=</code>) : 선언된 변수에 값을 저장 → 변수의 초기화</li>
  <li></li>
</ul>

<h3 id="원시-자료형-primitive-type--선언-시-메모리-주소-위치-jvm-stack에-실제-값이-저장">원시 자료형 (<code class="language-plaintext highlighter-rouge">Primitive type</code>) : 선언 시 메모리 주소 위치 (<code class="language-plaintext highlighter-rouge">JVM stack</code>)에 실제 값이 저장</h3>

<h4 id="논리-리터럴-boolean--참과-거짓을-의미">논리 리터럴 (<code class="language-plaintext highlighter-rouge">Boolean</code>) : 참과 거짓을 의미</h4>

<ul>
  <li>논리 타입 (<code class="language-plaintext highlighter-rouge">boolean</code>) : <code class="language-plaintext highlighter-rouge">true</code> / <code class="language-plaintext highlighter-rouge">false</code></li>
</ul>

<h4 id="정수-리터럴-integers--정수를">정수 리터럴 (<code class="language-plaintext highlighter-rouge">Integers</code>) : 정수를</h4>

<ul>
  <li>문자 (<code class="language-plaintext highlighter-rouge">char</code>) : <code class="language-plaintext highlighter-rouge">''</code>를 이용해 표시 (초기값 : <code class="language-plaintext highlighter-rouge">'\0'</code>=<code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>바이트 (<code class="language-plaintext highlighter-rouge">byte</code>) : 데이터를 나타내는 바이트 값 (초기값 : <code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>정수 (<code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>) : <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>바이트 크기 내의 정수 (초기값 : <code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>실수 (<code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>) : <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>바이트 크기 내의 실수 (초기값 : <code class="language-plaintext highlighter-rouge">0.0</code>)</li>
</ul>

<h3 id="참조-자료형-reference-type--선언-시-메모리-주소-위치에-실제-값이-가리키는-다른-주소를-저장">참조 자료형 (<code class="language-plaintext highlighter-rouge">Reference type</code>) : 선언 시 메모리 주소 위치에 실제 값이 가리키는 다른 주소를 저장</h3>
<ul>
  <li>원시 자료형을 기초로 하여 만들어짐 → <code class="language-plaintext highlighter-rouge">Non-Primitive type</code></li>
  <li>실제 값은 <code class="language-plaintext highlighter-rouge">Heap</code>에 저장</li>
</ul>

<blockquote>
  <p>자바는 주소값의 추상화를 금지함, <code class="language-plaintext highlighter-rouge">Call by value</code>만 가능 (<code class="language-plaintext highlighter-rouge">C/C++</code> : 주소값 저장 (<code class="language-plaintext highlighter-rouge">*</code>) 및 추출 (<code class="language-plaintext highlighter-rouge">&amp;</code>) 가능)</p>
</blockquote>

<h3 id="var--데이터-타입을-명시하지-않아도-지역-변수의-타입을-자동으로-추론하는-키워드"><code class="language-plaintext highlighter-rouge">var</code> : 데이터 타입을 명시하지 않아도 지역 변수의 타입을 자동으로 추론하는 키워드</h3>
<ul>
  <li>지역 변수만 사용 가능 (<code class="language-plaintext highlighter-rouge">static</code> 적용 불가)</li>
  <li>선언과 함께 명시적인 초기화를 반드시 해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">NULL</code>로 초기화할 수 없음</li>
  <li>람다 표현식과 같이 사용할 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var s = 'String';
var n = 100;
</code></pre></div></div>

<h2 id="변수의-스코프-scope--변수가-유효한-범위">변수의 스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수가 유효한 범위</h2>

<ul>
  <li>접근 지정자 (<code class="language-plaintext highlighter-rouge">access modifier</code>) : 접근 가능한 수준 지정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code> : 어느 클래스에서든 해당 클래스에 대해 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">protected</code> : 해당 패키지와 같은 패키지 내에 있는 클래스와 상속받은 클래스가 해당 클래스에 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">default</code> : 해당 클래스와 같은 패키지 내에 있는 클래스만이 해당 클래스에 대해 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">private</code> : 해당 클래스 및 그 클래스를 포함한 클래스만이 해당 클래스에 대해 접근 가능</li>
    </ul>
  </li>
</ul>

<h2 id="변수의-라이프타임-lifetime--변수가-메모리-영역에-저장되어-있는-시간">변수의 라이프타임 (<code class="language-plaintext highlighter-rouge">LifeTime</code>) : 변수가 메모리 영역에 저장되어 있는 시간</h2>

<ul>
  <li>인스턴스 변수 (<code class="language-plaintext highlighter-rouge">static block</code>과 <code class="language-plaintext highlighter-rouge">static method</code>를 제외한 클래스 전체) : 객체가 생성되어 메모리에 존재하는 동안</li>
  <li>클래스 변수 (클래스 전체) : 클래스가 초기화되고 프로그램이 끝날 때까지</li>
  <li>로컬 변수 (변수가 선언된 블록의 내부) : 변수 선언 이후부터 블록을 벗어날 때까지</li>
</ul>

<h2 id="변수의-형변환-type-conversion--현재의-타입을-다른-타입올-바꾸는-것">변수의 형변환 (<code class="language-plaintext highlighter-rouge">Type Conversion</code>) : 현재의 타입을 다른 타입올 바꾸는 것</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">boolean</code>을 제외한 나머지 기본 자료형 간의 타입 변환이 가능</p>
</blockquote>

<ul>
  <li>타입 프로모션 (<code class="language-plaintext highlighter-rouge">Type Promotion</code>) : 범위가 작은 데이터 타입의 값을 더 큰 범위의 데이터 타입에 할당 (묵시적 형변환)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">byte</code> &lt; <code class="language-plaintext highlighter-rouge">short</code> &lt; <code class="language-plaintext highlighter-rouge">int</code> &lt; <code class="language-plaintext highlighter-rouge">long</code> &lt; <code class="language-plaintext highlighter-rouge">float</code> &lt; <code class="language-plaintext highlighter-rouge">double</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int intN = 23;
long longN = intN;
</code></pre></div></div>

<ul>
  <li>캐스팅 (<code class="language-plaintext highlighter-rouge">Casting</code>) : 범위가 큰 데이터 타입의 값을 더 작은 범위의 데이터 타입으로 할당 (명시적 형변환)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int n = 100;
c = (char) n;
</code></pre></div></div>

<ul>
  <li>업캐스팅 (<code class="language-plaintext highlighter-rouge">Up-Casting</code>) : 부모-자식 관계의 객체에서 자식 객체를 부모 객체로 형변환 (묵시적 형변환)</li>
  <li>다운캐스팅 (<code class="language-plaintext highlighter-rouge">Down-Casting</code>) : 부모-자식 관계의 객체에서 부모 객체를 자식 객체로 형변환 (명시적 형변환)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass {
  String name;
  String ID;

  public MyClass(String name){
    this.name = name;
  }
}

class StudentClass extends MyClass {
  String grade;

  public StudentClass(String name){
    super(name);
  }
}

public class UpClass {
  public Static void main(String[] args){
    MyClass P;
    StudentClass S = new StudentClass("I");
    
    P = S; // 업캐스팅 발생

    System.out.println(P.name); // 컴파일 오류 없음

    S = (StudentClass) P;   // 다운캐스팅 발생

    System.out.println(S.name); // 컴파일 오류 없음
  }
}
</code></pre></div></div>

<h2 id="배열-array--인덱스-index와-그-인덱스에-대응하는-데이터들로-이루어진-선형-자료구조">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 인덱스 (<code class="language-plaintext highlighter-rouge">Index</code>)와 그 인덱스에 대응하는 데이터들로 이루어진 선형 자료구조</h2>

<ul>
  <li>배열의 생성 : 배열 공간을 할당받는 과정 (배열에 대한 래퍼런스 변수 선언 + 배열 생성)
    <ul>
      <li>래퍼런스 변수 : 메모리 상에 생성된 인스턴스를 가리키는 데에 사용되는 변수 (배열의 주소 값을 가짐)</li>
      <li><code class="language-plaintext highlighter-rouge">new</code> : 클래스의 새로운 객체를 생성할 때, 객체를 저장할 메모리를 할당하고 생성자를 호출해 객체를 초기화</li>
      <li><code class="language-plaintext highlighter-rouge">=</code> : 스택의 래퍼런스 변수가 힙의 배열 데이터를 가리킴</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] intArray;
intArray = new int [10];
int[] intArray = new int [10];
int[] intArray = {1,2,3,4,5,6,7,8,9};
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[][] intArray2;
int intArray2 = new int[2][3];
int intArray2 = { {1, 2, 3}, {4, 5, 6} };
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.length</code> 필드 : 배열이 가진 길이 (원소의 개수)를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len = intArray.length
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len1 = intArray2.length     // 2차원 배열이 가진 행의 개수
len2 = intArray2[n].length  // 2차원 배열 중 n번째 행이 가진 열의 개수
</code></pre></div></div>

<ul>
  <li>비정방형 배열 : 행마다 열의 개수가 서로 다른 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[][] intArray3 = new int[3][];
intArray3[0] = new int[1];
intArray3[1] = new int[2];
intArray3[2] = new int[3];
int intArray3 = { {0}, {1,2}, {3,4,5} };
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int intArray3[][] = { {0}, {1,2}, {3,4,5} };
</code></pre></div></div>

<ul>
  <li>메소드의 배열 반환 : 실제 배열에 대한 래퍼런스가 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int makeArray() {
    int t = new int[4];
    return t;
}

int[] intArr = makeArray();
</code></pre></div></div>

<ul>
  <li>객체 배열 : 객체에 대한 래퍼런스를 원소로 갖는 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person[] people = new Person[20];

for(int i = 0; i &lt; people.length; i++){
    people[i] = new Person();
    people[i].age = 20 + i;
}
</code></pre></div></div>

<h2 id="객체-object--프로그램에서-사용되는-데이터-혹은-식별자에-의해-참조되는-공간">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 프로그램에서 사용되는 데이터 혹은 식별자에 의해 참조되는 공간</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">new</code> : 객체를 생성하는 연산자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = new Person("A");
P.age = 30;
</code></pre></div></div>

<ul>
  <li>생성자 : 객체가 생성될 때 자동으로 호출되는 메소드 (객체에 필요한 초기화 수행)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">this</code> : 객체 자신을 참조</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass {
    int id;

    public MyClass (int x) { // 생성자는 클래스 이름과 동일한 이름을 가짐
        this.id = x;
    }

    public void MyFunc (int id) {
        this.id = id;
    } 
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this()</code> : 동일한 클래스 내의 다른 생성자를 호출할 때 사용 (반드시 생성자의 첫 문장에서 사용되어야 함)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public MyClass {
    String title;
    int price;
    int id = 0;

    public MyClass(String title, int price, int id) {
        this.title = title;
        this.price = price;
        this.id = id;
        id += 1;
    }

    public MyClass(String title, int price, int id) {
        this.title = title;
        this.price = price;
        this.id = id;
        id += 1;
    }

    public MyClass(String title, int price) {
        this(title, price, id);
        id += 1;
    }

    public static void main(String[] args) {
        MyClass mart1 = new MyClass("apple", 100, 1);
        MyClass mart2 = new MyClass("banana", 200);
    }
}
</code></pre></div></div>

<ul>
  <li>가비지 컬렉션 (<code class="language-plaintext highlighter-rouge">garbage Collection</code>) : <code class="language-plaintext highlighter-rouge">new</code>로 할당받고 사용하지 않는 객체의 메모리 공간을 자동으로 <code class="language-plaintext highlighter-rouge">JVM</code>에 반환
    <ul>
      <li>소멸자 (<code class="language-plaintext highlighter-rouge">delete</code>)로 객체의 소멸을 명시해야 하는 <code class="language-plaintext highlighter-rouge">C++</code>과 달리, 자바는 소멸자가 필요 없음</li>
    </ul>
  </li>
</ul>

<h2 id="클래스-class--객체를-생성하기-위해-변수와-메소드를-정의하는-틀">클래스 (<code class="language-plaintext highlighter-rouge">Class</code>) : 객체를 생성하기 위해 변수와 메소드를 정의하는 틀</h2>

<ul>
  <li>필드 (<code class="language-plaintext highlighter-rouge">Field</code>) : 객체의 상태 혹은 속성 (인스턴스 변수, <code class="language-plaintext highlighter-rouge">static</code> 변수)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    String name;
    static long id;
}
</code></pre></div></div>

<ul>
  <li>메소드 (<code class="language-plaintext highlighter-rouge">method</code>) : 객체의 행동 (인스턴스 메소드, <code class="language-plaintext highlighter-rouge">static</code> 메소드)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    long id;

    string getName() {
        return name;
    }
    
    long getID() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }

    void setID(long id) {
        this.id = id;
    }
}
</code></pre></div></div>

<ul>
  <li>생성자 (<code class="language-plaintext highlighter-rouge">Constructor</code>) : 객체를 생성한 후에 필요한 초기화 작업을 수행하는 메소드</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    long id;

    MyClass(String name, long id) {
        this.name = name;
        this.id = id;
    }
}
</code></pre></div></div>

<ul>
  <li>초기화 블럭 (<code class="language-plaintext highlighter-rouge">Initializer</code>) : 객체를 생성한 후에 필요한 초기화 작업을 세분화
    <ul>
      <li>클래스 초기화 블럭 : 클래스가 최초로 로딩될 때</li>
      <li>인스턴스 초기화 블럭 : 인스턴스가 생성되었을 때</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    static long id;
        // 클래스 초기화 블럭
    static {
        id = 1;
    }
        // 인스턴스 초기화 블럭
    {
        name = "이름";
        id += 1;
    }
}
</code></pre></div></div>

<blockquote>
  <p>캡슐화 (<code class="language-plaintext highlighter-rouge">Encapsulation</code>) : 변수나 메소드는 반드시 클래스 내에서만 구현 가능 / 클래스 안의 내부 클래스 구현 가능</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class (클래스 이름) {
    public static void main(String[] args {
        ...
    }

    class (내부 클래스 1 이름) {
        ...
    }

    static class (내부 클래스 2 이름) {
        ...
    }

    void (내부 함수 이름)() {
        ...
    }

   ...
}
</code></pre></div>  </div>

  <p>상속 (<code class="language-plaintext highlighter-rouge">Inheritance</code>) : 부모 클래스에 정의된 필드와 메소드를 자식 클래스가 물려받는 것</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Person {
   Person() { ... }
...
}
public class Student extends Person {
  super(); // 부모 클래스의 생성자를 호출
  ...
}
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">instanceof</code> : 객체의 타입을 검사하는 연산자 (상속 관계 &amp; 구현 관계 모두 포함)</p>

  <p>```
class Lee extends Student implements Person { … }</p>

  <p>Lee lee = new Lee();
assertThat(lee instanceof Lee).isTrue();
assertThat(lee instanceof Student).isTrue();
assertThat(lee instanceof Animal).isTrue();
assertThat(lee instanceof Person).isTrue();</p>
</blockquote>

<blockquote>
  <p>```</p>
</blockquote>

<h3 id="main--해당-클래스를-자바-어플리케이션에서-실행하는-메소드"><code class="language-plaintext highlighter-rouge">main()</code> : 해당 클래스를 자바 어플리케이션에서 실행하는 메소드</h3>

<ul>
  <li>접근 제어자 <code class="language-plaintext highlighter-rouge">public</code>  : 다른 모든 클래스에서 호출 가능 (클래스 외부의 <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 호출되어야 하므로)</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> : 프로그램 시작부터 메모리에 저장됨 (프로그램이 시작할 때부터 <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 호출되어야 하므로)</li>
  <li><code class="language-plaintext highlighter-rouge">void</code> : 종료 코드를 등록하기 위해 <code class="language-plaintext highlighter-rouge">int</code>를 반환해야 하는 ```C``와 달리, 종료 코드를 등록할 필요 없음</li>
  <li><code class="language-plaintext highlighter-rouge">String[] args</code> : 명령줄에 주어진 모든 인자를 문자열로 처리해 <code class="language-plaintext highlighter-rouge">main()</code>에 전달</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class (클래스 이름) {
    public static void main(String[] args {
        ...
    }
}
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">static</code> : 모든 객체에 공통으로 사용하기 위해 정적으로 선언 (프로그램 시작부터 메모리에 저장)</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">static</code> 메소드는 <code class="language-plaintext highlighter-rouge">static</code> 멤버만 사용할 수 있고, <code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용할 수 없음</li>
  </ul>
</blockquote>

<h3 id="final--오직-한-번만-할당할-수-있어-항상-같은-값을-가지는-entity를-정의할-때-사용하는-키워드"><code class="language-plaintext highlighter-rouge">final</code> : 오직 한 번만 할당할 수 있어 항상 같은 값을 가지는 <code class="language-plaintext highlighter-rouge">entity</code>를 정의할 때 사용하는 키워드</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 클래스 : 클래스가 상속받을 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class MyClass { ... }
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 메소드 : 오버라이딩으로 수정할 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class MySuperClass { 
    protected final void MyFunc() { ... }
}
public final class MyClass extends MySuperClass { 
    protected final void MyFunc() { ... } // 컴파일 오류
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 변수 : 한번 값을 할당하면 수정할 수 없는 상수 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static float Pl = 3.141592;
</code></pre></div></div>

<h2 id="어노테이션-annotation--컴파일--실행-과정에서-코드를-어떻게-처리할지-알리는-메타데이터">어노테이션 (<code class="language-plaintext highlighter-rouge">Annotation</code>) : 컴파일 &amp; 실행 과정에서 코드를 어떻게 처리할지 알리는 메타데이터</h2>

<ul>
  <li>클래스나 메소드 위에 붙으며, <code class="language-plaintext highlighter-rouge">@</code>로 시작 : 어노테이션의 유무나 어노테이션에 설정한 값을 통해 클래스를 다르게 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Override // 메소드를 오버라이딩 (상속받은 부모 클래스나 인터페이스에서 해당 메소드가 없으면 컴파일 오류)
</code></pre></div></div>

<h2 id="자바-모듈-java-module--클래스-jar-패키지-수준의-코드-그룹화-제공">자바 모듈 (<code class="language-plaintext highlighter-rouge">Java Module</code>) : 클래스, <code class="language-plaintext highlighter-rouge">JAR</code>, 패키지 수준의 코드 그룹화 제공</h2>

<ul>
  <li>하나의 자바 어플리케이션은 하나 이상의 <code class="language-plaintext highlighter-rouge">.class</code> 파일로 구성</li>
  <li>다수의 클래스 파일을 <code class="language-plaintext highlighter-rouge">.jar</code> 파일로 압축해 배포 및 실행 가능</li>
  <li>서로 관련 있는 클래스들은 하나의 패키지로 묶어서 관리</li>
</ul>

<h2 id="jdk의-scanner-클래스--자바의-키-입력-key-input"><code class="language-plaintext highlighter-rouge">JDK</code>의 <code class="language-plaintext highlighter-rouge">Scanner</code> 클래스 : 자바의 키 입력 (<code class="language-plaintext highlighter-rouge">Key input</code>)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String next()</code> : 문자열 타입으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">Byte nextByte()</code> : 바이트 타입으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">short nextShort()</code>, <code class="language-plaintext highlighter-rouge">int nextInt()</code>, <code class="language-plaintext highlighter-rouge">long nextLong()</code> : 정수 타입 (<code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>)으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">float nextFloat()</code>, <code class="language-plaintext highlighter-rouge">double nextDouble()</code> : 실수 타입 (<code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>)으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">String nextLine()</code> : 한 줄 전체 (<code class="language-plaintext highlighter-rouge">\n</code>)를 일고 문자열 타입으로 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.Scanner;
Scanner scan = new Scanner(System.in);
String name = scan.nextLine();
</code></pre></div></div>

<blockquote>
  <p>자바 표준 입력 스트림 <code class="language-plaintext highlighter-rouge">system.in</code> : 입력되는 키 값을 바이트 정보로 반환 (문자 정보로 변환)</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>InputSteamReader rd = new InputSteamReader(System.in); // 키보드 입력 스트림 생성
int s = rd.read(); // 키보드로부터 문자 하나를 읽고 이를 s에 저장
</code></pre></div>  </div>
</blockquote>

<h2 id="예외-처리-exception-handling--발생한-예외에-대해-작성한-프로그램-내에서-대응하는-것">예외 처리 (<code class="language-plaintext highlighter-rouge">Exception handling</code>) : 발생한 예외에 대해 작성한 프로그램 내에서 대응하는 것</h2>

<ul>
  <li>예외 (<code class="language-plaintext highlighter-rouge">Exception</code>) : 프로그램 실행 중에 발생하는 런타임 오류 (<code class="language-plaintext highlighter-rouge">Runtime error</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Checked Exception</code> : 컴파일러에 의해 예외 발생을 인지 (컴파일 오류)</li>
      <li><code class="language-plaintext highlighter-rouge">Unchecked Exception</code> : <code class="language-plaintext highlighter-rouge">JVM</code>에서 예외 발생을 인지 (예외 객체 생성 후 처리)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자바에서 자주 발생하는 예외</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">NullPointerException</code> : <code class="language-plaintext highlighter-rouge">Null</code> 래퍼런스를 참조할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">ClassCastException</code> : 변환할 수 없는 타입응로 객체를 변환할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">IOException</code> : 입출력 동작 중에 인터럽트가 발생할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">NumberFormatException</code> : 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> : 잘못된 인자를 전달할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">ArrayIndexOutOfBoundsException</code> : 배열의 범위를 벗어나 접근할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">NoSuchMethodException</code> : 런타임 시점에 존재하지 않는 메소드를 호출할 때 발생</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">try-catch-finally</code> : 발생한 예외에 대한 예외처리를 하는 구문
    <ul>
      <li><code class="language-plaintext highlighter-rouge">try</code> : 오류가 발생할 것으로 예상되는 부분</li>
      <li><code class="language-plaintext highlighter-rouge">catch</code> : 발생할 오류에 관련된 예외에 대해 대응할 부분</li>
      <li><code class="language-plaintext highlighter-rouge">finally</code> : 예외 발생 여부에 상관없이 반드시 실행되어야 하는 부분</li>
      <li><code class="language-plaintext highlighter-rouge">throws</code>: 예외 처리의 의무를 현재 예외가 발생한 메소드에서 그 메소드를 호출한 메소드로 전달</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void funcA() {
    try {
        ...
    } catch (Exception e) { // 예외가 발생할 때 생성된 예외 객체와 타입이 일치하면, 래퍼런스 변수가 생성된 예외 객체를 가리킴
        ...
    } finally {
        ...
    }
}

public void funcB() throws Exception { // throws로 예외 처리를 Exception로 전달
    ...
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Java" /><summary type="html"><![CDATA[변수 (variable) : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름]]></summary></entry><entry><title type="html">[Git] Git 개념 및 명령어 정리</title><link href="http://localhost:4000/git1/" rel="alternate" type="text/html" title="[Git] Git 개념 및 명령어 정리" /><published>2024-01-13T00:00:00+09:00</published><updated>2024-01-13T00:00:00+09:00</updated><id>http://localhost:4000/git1</id><content type="html" xml:base="http://localhost:4000/git1/"><![CDATA[<h2 id="버전-관리-version-control--특정한-시간-기준으로-파일-변화를-저장하고-관리">버전 관리 (<code class="language-plaintext highlighter-rouge">Version Control</code>) : 특정한 시간 기준으로 파일 변화를 저장하고 관리</h2>

<ul>
  <li>버전 (<code class="language-plaintext highlighter-rouge">Version</code>) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용</li>
</ul>

<h3 id="1-로컬-버전-관리-local-version-control">1. 로컬 버전 관리 (<code class="language-plaintext highlighter-rouge">Local Version Control</code>)</h3>
<ul>
  <li>로컬 사용자가 서버 없이 로컬 컴퓨터 내의 데이터베이스를 이용해 파일의 변경 정보 관리
    <ul>
      <li>협업에서 사용하기 어려움, 내부 정보가 손상되면 복구할 방법이 없음</li>
    </ul>
  </li>
</ul>

<h3 id="2-중앙집중식-버전-관리-central-version-control--서브-머신-svn">2. 중앙집중식 버전 관리 (<code class="language-plaintext highlighter-rouge">Central Version Control</code>) : 서브 머신 (<code class="language-plaintext highlighter-rouge">SVN</code>)</h3>
<ul>
  <li>클라이언트가 최종본를 관리하는 데이터베이스 서버로부터 개별 파일을 로컬에 다운로드, 수정본을 서버에 올림
    <ul>
      <li>데이터베이스 서버에 의존적, 협업 규모가 커지면 수정 충돌 문제 발생 (유사 사례 : <a href="https://namu.wiki/w/편집%20충돌">나무위키의 편집 충돌</a>)</li>
    </ul>
  </li>
</ul>

<h3 id="3-분산형-버전-관리-distributed-version-control--깃-git">3. 분산형 버전 관리 (<code class="language-plaintext highlighter-rouge">Distributed Version Control</code>) : 깃 (<code class="language-plaintext highlighter-rouge">Git</code>)</h3>
<ul>
  <li>클라이언트가 원격 저장소에서 전체 기록과 각 기록을 추적할 수 있는 정보를 포함한 데이터를 로컬 저장소에 저장
    <ul>
      <li>클라이언트가 자신의 작업을 원격 저장소에 독립적인 로컬 저장소에 버전별로 저장하고 관리</li>
      <li>여러 클라이언트들의 작업을 여러 로컬 저장소로 다원화해 각 클라이언트는 충돌의 염려 없이 작업 가능</li>
      <li>필요한 경우에 클라이언트가 서버의 원격 저장소에 원하는 버전을 통합 (서버 단위의 편집 버전을 +1)
        <ul>
          <li>클라이언트는 원격 저장소에 자신의 작업을 통합시킬 때만 서버와 통신하면 됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="깃-git--분산형-버전-관리-시스템-distributed-version-control-system"><a href="https://git-scm.com">깃</a> (<code class="language-plaintext highlighter-rouge">Git</code>) : 분산형 버전 관리 시스템 (<code class="language-plaintext highlighter-rouge">Distributed Version Control System</code>)</h2>
<ul>
  <li>터미널 창에 다음 명령어를 입력해 <a href="https://pocj8ur4in.github.io/mac/homebrew1/"><code>homebrew</code></a>를 통해 <code class="language-plaintext highlighter-rouge">git</code> 설치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install git
</code></pre></div></div>

<h3 id="gitignore-디렉터리--버전-관리를-하지-않을-파일이나-디렉터리-혹은-파일-확장자를-설정"><code class="language-plaintext highlighter-rouge">.gitignore</code> 디렉터리 : 버전 관리를 하지 않을 파일이나 디렉터리, 혹은 파일 확장자를 설정</h3>

<ul>
  <li>특정한 이름을 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename.txt
</code></pre></div></div>

<ul>
  <li>특정한 확장자를 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*.txt
</code></pre></div></div>

<ul>
  <li>특정한 경로 아래의 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder/
</code></pre></div></div>

<ul>
  <li>특정한 경로 아래의 특정한 확장자를 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder/filename.txt
</code></pre></div></div>

<ul>
  <li>예외 만들기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!filename.txt
</code></pre></div></div>

<h3 id="readmemd-파일--프로젝트에-대한-설명과-사용-방법-license-등의-내용을-작성"><code class="language-plaintext highlighter-rouge">README.md</code> 파일 : 프로젝트에 대한 설명과 사용 방법, <code class="language-plaintext highlighter-rouge">LICENSE</code> 등의 내용을 작성</h3>
<ul>
  <li>기존의 <code><a href="_posts/2022-10-29-markdown1.md">Markdown</a></code>에 깃허브에서만 사용 가능한 기능을 추가한 <code class="language-plaintext highlighter-rouge">Github Flavored Markdown</code>을 이용</li>
  <li><code class="language-plaintext highlighter-rouge">Github</code> 프로젝트 레포지토리 페이지에서 <code class="language-plaintext highlighter-rouge">README.md</code>가 표현된 것을 확인 가능
    <ul>
      <li>자신의 아이디와 같은 이름의 레포지토리의 <code class="language-plaintext highlighter-rouge">README.md</code>는 해당 사용자의 깃허브 프로필에 표시됨</li>
    </ul>
  </li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb18y0K%2FbtruITygdgC%2FV4XYZs3D0ZMlzqlkHZkH9k%2Fimg.png" /></p>

<ul>
  <li><a href="https://shields.io">뱃지</a> : 해당 사이트에서 뱃지의 구성 요소들을 직접 지정해 생성한 후 <code class="language-plaintext highlighter-rouge">img</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/(아이콘 내용)-(아이콘 색상)?style=flat-square&amp;logo=(로고 이름)&amp;logoColor=(로고 색상)"/&gt;
</code></pre></div></div>

<p><img alt="GitHub followers" src="https://img.shields.io/github/followers/pocj8ur4in?style=social" /></p>

<ul>
  <li><a href="https://hits.seeyoufarm.com">방문자 수</a> : 해당 사이트에서 <code class="language-plaintext highlighter-rouge">Target URL</code>과 로고를 선택한 후 <code class="language-plaintext highlighter-rouge">a</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="https://github.com/pocj8ur4in"&gt; ... &lt;/a&gt;
</code></pre></div></div>

<p><a href="https://github.com/pocj8ur4in"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2Fseondal&amp;count_bg=%23000000&amp;title_bg=%23000000&amp;icon=github.svg&amp;icon_color=%23E7E7E7&amp;title=GitHub&amp;edge_flat=false)" /></a></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazassumnida"><code>Solved.ac</code> 티어</a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[![Solved.ac 프로필]
(http://mazassumnida.wtf/api/v2/generate_badge?boj={백준ID})]
(https://solved.ac/{백준ID})
</code></pre></div></div>

<p><a href="https://solved.ac/pocj8ur4in"><img src="http://mazassumnida.wtf/api/v2/generate_badge?boj=pocj8ur4in" alt="Solved.ac 프로필" /></a></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazandi"><code>Solved.ac</code> 잔디</a> : 해당 사이트에서 <code class="language-plaintext highlighter-rouge">img</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="http://mazandi.herokuapp.com/api?handle={백준ID}&amp;theme=warm"/&gt;
</code></pre></div></div>

<p><img src="http://mazandi.herokuapp.com/api?handle=pocj8ur4in&amp;theme=warm" /></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazandi">자주 사용한 언어</a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[![Top Langs]
(https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브ID)]
(https://github.com/깃허브ID/github-readme-stats)
</code></pre></div></div>

<p><a href="https://github.com/pocj8ur4in/github-readme-stats"><img src="https://github-readme-stats.vercel.app/api/top-langs/?username=pocj8ur4in" alt="Top Langs" /></a></p>

<h3 id="git-디렉터리--깃의-버전을-저장할-로컬-저장소"><code class="language-plaintext highlighter-rouge">.git</code> 디렉터리 : 깃의 버전을 저장할 로컬 저장소</h3>
<ul>
  <li>버전 (<code class="language-plaintext highlighter-rouge">Version</code>) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용
    <ul>
      <li>작업 트리 (<code class="language-plaintext highlighter-rouge">working tree</code>) : 파일 수정, 저장 등의 작업을 하는 작업 디렉터리
        <ul>
          <li>스테이징 (<code class="language-plaintext highlighter-rouge">Staging</code>) : 작업 트리에서 작업한 파일을 버전으로 만들기 위해 스테이지로 이동</li>
        </ul>
      </li>
      <li>스테이지 (<code class="language-plaintext highlighter-rouge">stage</code>) : 버전으로 만들 파일이 대기하는 스테이징 영역
        <ul>
          <li>커밋 (<code class="language-plaintext highlighter-rouge">Commit</code>) : 스테이지에서 대기중인 파일을 버전으로 만들어 레포지토리에 저장</li>
        </ul>
      </li>
      <li>레포지토리 (<code class="language-plaintext highlighter-rouge">repository</code>) : 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 저장소</li>
    </ul>
  </li>
</ul>

<h2 id="깃-명령어-git-command--git-command-형식으로-구성">깃 명령어 (<code class="language-plaintext highlighter-rouge">Git Command</code>) : <code class="language-plaintext highlighter-rouge">git &lt;command&gt;</code> 형식으로 구성</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git</code> : 깃 명령 다음에 입력할 수 있는 명령어 옵션 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git
...
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git init</code> : 깃 저장소를 만들 디렉터리 초기화 (깃 저장소인 <code class="language-plaintext highlighter-rouge">.git</code> 디렉터리가 생성)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git init
Initialized empty Git repository in ...
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git status</code> :  깃의 현재 상태 확인
    <ul>
      <li><code class="language-plaintext highlighter-rouge">untracked</code> 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하지 않습니다. (파일이 스테이지에서 대기 : <code class="language-plaintext highlighter-rouge">false</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">tracked</code> 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하고 있습니다. (파일이 스테이지에서 대기 : <code class="language-plaintext highlighter-rouge">true</code>)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">unmodified</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되지 않았습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Working tree clean</code></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">modified</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었으나 스테이징되지 않았습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Changes not stage for commit:</code></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">staged</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었고 스테이징되었습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Changes to be committed:</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
On branch master  // 현재 master 브랜치에 위치해 있음
No commits yet    // 아직 커밋한 파일이 존재하지 않음
nothing to commit // 현재 커밋한 파일이 존재하지 않음
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
On branch master
No commits yet
untracked files   // untracked 상태 : 아직 버전 관리하지 않은 파일들이 존재함
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git add</code> : 작업 트리에서 스테이지로 스테이징</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add helloWorld.txt
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git commit</code> : 스테이지에 있는 파일을 버전으로 커밋
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-m</code> 옵션을 통해 커밋과 함께 메시지 저장</li>
      <li><code class="language-plaintext highlighter-rouge">-am</code> 옵션을 통해 스테이징과 커밋을 동시에 처리</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git commit -m "message1"
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git log</code> : 레포지토리에 저장된 버전 정보 확인
    <ul>
      <li>커밋 해시 (<code class="language-plaintext highlighter-rouge">commit hash</code>) : 커밋을 구별하는 ID (<code class="language-plaintext highlighter-rouge">HEAD-&gt;master</code> : 해당 버전이 가장 최신임을 표시)</li>
      <li>작성자 (<code class="language-plaintext highlighter-rouge">Author</code>) : <code class="language-plaintext highlighter-rouge">git config --global user</code>를 통해 입력한 사용자 정보 (이름과 이메일)</li>
      <li>작성일 (<code class="language-plaintext highlighter-rouge">Date</code>) : 버전이 작성된 시각</li>
      <li>커밋 메시지 (<code class="language-plaintext highlighter-rouge">commit message</code>) : <code class="language-plaintext highlighter-rouge">git commit -m</code>을 통해 저장된 메시지</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Git" /><summary type="html"><![CDATA[버전 관리 (Version Control) : 특정한 시간 기준으로 파일 변화를 저장하고 관리]]></summary></entry><entry><title type="html">[System Design Interview] 1. 사용자 수에 따른 규모 확장성</title><link href="http://localhost:4000/system_design_interview1/" rel="alternate" type="text/html" title="[System Design Interview] 1. 사용자 수에 따른 규모 확장성" /><published>2024-01-12T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/system_design_interview1</id><content type="html" xml:base="http://localhost:4000/system_design_interview1/"><![CDATA[<h2 id="시스템-디자인-면접-system-design-interview--시스템-아키텍처를-설계하는-면접">시스템 디자인 면접 (<code class="language-plaintext highlighter-rouge">System Design Interview</code>) : 시스템 아키텍처를 설계하는 면접</h2>

<ul>
  <li>질문 범위도 매우 크고 모호하며, 답변 절차 또한 정형화되어 있지 않음
    <ul>
      <li>시스템에 따른 변이 (<code class="language-plaintext highlighter-rouge">variation</code>)이 많음
        <ul>
          <li>의사소통 및 문제 해결 능력이 소프트웨어 엔지니어의 필요 능력과 비슷함</li>
          <li>지원자들은 그 모호한 문제를 어떻게 분석하고 단계적으로 해결하는지를 확인
            <ul>
              <li>문제 해결 아이디어를 어떻게 설명하고 토론하는지?</li>
              <li>문제 해결 아이디어를 어떻게 평가하고 개선하는지?</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="사용자-수에-따른-규모-확장성--사용자가-얼마나-되는지에-따라-변화하는-시스템-설계">사용자 수에 따른 규모 확장성 : 사용자가 얼마나 되는지에 따라 변화하는 시스템 설계</h2>

<h3 id="단일-서버--모든-컴포넌트가-단-한-대의-서버에서-실행되는-시스템을-설계">단일 서버 : 모든 컴포넌트가 단 한 대의 서버에서 실행되는 시스템을 설계</h3>

<ul>
  <li>웹, 어플리케이션, 데이터베이스, 캐시 모두가 하나의 서버에서 실행</li>
</ul>

<blockquote>
  <p>단일 서버에서 사용자의 요청이 처리되는 과정</p>

  <ol>
    <li>사용자는 도메인 네임을 이용해 웹 사이트에 접속한다.
      <ol>
        <li>도메인 네임을 <code class="language-plaintext highlighter-rouge">DNS</code> (<code class="language-plaintext highlighter-rouge">Domain Name Service</code>)에 질의한다.</li>
        <li><code class="language-plaintext highlighter-rouge">DNS</code> 조회 결과로 <code class="language-plaintext highlighter-rouge">IP</code> 주소 (웹 서버의 주소)가 반환된다.</li>
      </ol>
    </li>
    <li>해당 <code class="language-plaintext highlighter-rouge">IP</code> 주소로 <code class="language-plaintext highlighter-rouge">HTTP</code> 요청이 전달된다.</li>
    <li>요청을 받은 웹 서버는 <code class="language-plaintext highlighter-rouge">HTML</code> 페이지나 <code class="language-plaintext highlighter-rouge">JSON</code> 형태의 응답을 반환한다.</li>
  </ol>
</blockquote>

<ul>
  <li>그렇다면 실제 요청은 어디에서 오는가?
    <ol>
      <li>웹 어플리케이션인 경우?
        <ol>
          <li>비즈니스 로직의 구현과 데이터 저장의 처리를 위한 서버 구현</li>
          <li>사용자에게 표현하기 위한 클라이언트 구현</li>
        </ol>
      </li>
      <li>모바일 앱인 경우?
        <ol>
          <li>모바일 앱과 웹 서버 간의 통신에는 <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 이용</li>
          <li><code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 통해 반환될 응답 데이터의 포맷으로 <code class="language-plaintext highlighter-rouge">JSON</code>을 사용</li>
        </ol>
      </li>
    </ol>
  </li>
</ul>

<h3 id="데이터베이스-서버--트래픽을-처리할-서버-웹-계층에-db-서버-데이터-계층을-증설">데이터베이스 서버 : 트래픽을 처리할 서버 (웹 계층)에 DB 서버 (데이터 계층)을 증설</h3>

<ul>
  <li>어떤 데이터베이스를 사용할 것인가?
    <ol>
      <li>관계형 데이터베이스를 선택할 경우?
        <ul>
          <li>관계형 데이터베이스 관리 시스템 (<code class="language-plaintext highlighter-rouge">RDBMS</code>) : <code class="language-plaintext highlighter-rouge">MySQL</code>, …</li>
          <li>자료를 테이블, 열, 칼럼으로 표현</li>
          <li>여러 테이블에 있는 데이터를 그 관계에 따라 조인 (<code class="language-plaintext highlighter-rouge">join</code>)</li>
        </ul>
      </li>
      <li>비관계형 데이터베이스 (<code class="language-plaintext highlighter-rouge">NoSQL</code>)를 선택할 경우?
        <ul>
          <li>저장소 : 키-값 (<code class="language-plaintext highlighter-rouge">key-value</code>), 그래프 (<code class="language-plaintext highlighter-rouge">graph</code>), 칼럼 (<code class="language-plaintext highlighter-rouge">column</code>), 문서 (<code class="language-plaintext highlighter-rouge">document</code>)</li>
        </ul>
      </li>
      <li>비관계형 데이터베이스가 최선인 경우는 언제?
        <ul>
          <li>아주 낮은 지연 시간 (<code class="language-plaintext highlighter-rouge">latency</code>)이 요구됨</li>
          <li>다루는 데이터가 비정형 (<code class="language-plaintext highlighter-rouge">unstructured</code>) 데이터임</li>
          <li><code class="language-plaintext highlighter-rouge">JSON</code> 등 데이터를 직렬화 (<code class="language-plaintext highlighter-rouge">serialize</code>)하거나 역직렬화할 수 있기만 하면 됨</li>
          <li>아주 많은 양의 데이터를 저장해야 함</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="수직적-규모-확장-vs-수평적-규모-확장">수직적 규모 확장 vs 수평적 규모 확장?</h3>

<ul>
  <li>수직적 확장 (<code class="language-plaintext highlighter-rouge">scale-up</code>) : 서버에 고사양 자원을 추가
    <ul>
      <li>서버로 유입되는 트래픽의 양이 적을 때 최선</li>
      <li>단순하지만, 한계가 명확함 : 하나의 서버에 <code class="language-plaintext highlighter-rouge">CPU</code>나 메모리를 무한대로 증설할 수 없음</li>
      <li>장애에 대한 자동 복구 (<code class="language-plaintext highlighter-rouge">failover</code>)이나 다중화 (<code class="language-plaintext highlighter-rouge">re-dundancy</code>) 방안을 제시하지 않음
        <ul>
          <li>서버에 장애가 발생하면, 어플리케이션이 그대로 중단된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>수평적 확장 (<code class="language-plaintext highlighter-rouge">scale-out</code>) : 더 많은 서버를 추가하여 성능을 개선
    <ul>
      <li>로드밸런서 (<code class="language-plaintext highlighter-rouge">Load balancer</code>) : 부하 분산 집합 내의 웹 서버들에게 트래픽 부하를 분산
        <ul>
          <li>로드밸런서의 공개 <code class="language-plaintext highlighter-rouge">IP</code>로 접속 : 웹 서버가 클라이언트의 접속을 직접 처리하지 않음</li>
          <li>같은 네트워크 내의 서버 간 통신에는 사설 <code class="language-plaintext highlighter-rouge">IP</code> 주소 사용</li>
          <li>장애를 자동으로 복구하지 못하는 문제 (<code class="language-plaintext highlighter-rouge">no failover</code>) 해소
            <ul>
              <li>서버 <code class="language-plaintext highlighter-rouge">a</code>가 오프라인으로 상태가 변경되어도 모든 트래픽이 서버 b로 전송</li>
            </ul>
          </li>
          <li>웹 계층의 가용성 (<code class="language-plaintext highlighter-rouge">availability</code>) 향상
            <ul>
              <li>로드밸런서를 통해 트래픽을 자동적으로 분산 가능</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>데이터베이스 다중화 : 원본은 <code class="language-plaintext highlighter-rouge">master</code> 서버에, 사본은 <code class="language-plaintext highlighter-rouge">slave</code> 서버에 저장
        <ul>
          <li>쓰기 연산 (<code class="language-plaintext highlighter-rouge">write</code>)과 <code class="language-plaintext highlighter-rouge">DB</code>를 변경하는 명령어의 입력은 <code class="language-plaintext highlighter-rouge">master</code> 서버에서만 가능</li>
          <li><code class="language-plaintext highlighter-rouge">slave</code> 서버는 <code class="language-plaintext highlighter-rouge">master</code> 서버에서 사본을 전달받아, 읽기 연산 (<code class="language-plaintext highlighter-rouge">read</code>)만을 지원
            <ul>
              <li>성능 향상 : 다중화 모델을 통해 병렬로 처리될 수 있는 질의 (<code class="language-plaintext highlighter-rouge">query</code>)의 수 증가</li>
              <li>안정성 (<code class="language-plaintext highlighter-rouge">reliability</code>) : 다중화된 <code class="language-plaintext highlighter-rouge">DB</code>를 여러 곳에 분산 가능</li>
              <li>가용성 (<code class="language-plaintext highlighter-rouge">availability</code>) : 어떤 <code class="language-plaintext highlighter-rouge">DB</code> 서버에 장애가 발생해도 서비스 지속 가능</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">DB</code> 서버 하나가 오프라인 상태가 된다면?
            <ul>
              <li>1대뿐인 <code class="language-plaintext highlighter-rouge">slave</code> 서버가 오프라인 상태인 경우?
                <ul>
                  <li>읽기 연산이 한시적으로 모두 <code class="language-plaintext highlighter-rouge">master</code> 서버로 전달</li>
                </ul>
              </li>
              <li>여러 대의 <code class="language-plaintext highlighter-rouge">slave</code> 서버 중 하나가 오프라인 상태인 경우?
                <ul>
                  <li>읽기 연산이 나머지 <code class="language-plaintext highlighter-rouge">slave</code> 서버로 분산</li>
                </ul>
              </li>
              <li>1대뿐인 <code class="language-plaintext highlighter-rouge">slave</code> 서버를 가진 <code class="language-plaintext highlighter-rouge">master</code> 서버가 오프라인 상태인 경우?
                <ul>
                  <li>해당 <code class="language-plaintext highlighter-rouge">slave</code> 서버가 <code class="language-plaintext highlighter-rouge">master</code> 서버가 돠어 모든 <code class="language-plaintext highlighter-rouge">DB</code> 연산 수행</li>
                  <li>프로덕션 (<code class="language-plaintext highlighter-rouge">production</code>) 환경 : <code class="language-plaintext highlighter-rouge">slave</code> 서버의 데이터가 최신이 아닐 수도 있음
                    <ul>
                      <li>복구 스크립트 (<code class="language-plaintext highlighter-rouge">recovery script</code>)를 통한 추가</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>로드밸런서와 데이터베이스 다중화를 고려한 설계
    <ul>
      <li>사용자는 DNS로부터 로드밸런서의 공개 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 받는다.</li>
      <li>사용자는 해당 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 사용해 로드밸런서에 접속한다.</li>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code> 요청은 서버 1이나 서버 2로 전달된다.</li>
      <li>웹 서버는 사용자의 데이터를 <code class="language-plaintext highlighter-rouge">slave</code> 데이터베이스에서 읽는다.</li>
      <li>웹 서버는 데이터 변경 연산을 <code class="language-plaintext highlighter-rouge">master</code> 데이터베이스로 전달한다.</li>
    </ul>
  </li>
</ul>

<h4 id="캐시-cache--응답-시간-latency-개선을-위해-데이터를-잠시-보관">캐시 (<code class="language-plaintext highlighter-rouge">Cache</code>) : 응답 시간 (<code class="language-plaintext highlighter-rouge">latency</code>) 개선을 위해 데이터를 잠시 보관</h4>

<ul>
  <li>캐시 계층 : 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 보관
    <ul>
      <li>주도형 캐시 전략 (<code class="language-plaintext highlighter-rouge">read-through caching strategy</code>)
        <ol>
          <li>만약 데이터가 캐시에 있다면, 캐시에서 데이터를 읽음
            <ul>
              <li>데이터가 캐시에 없다면, <code class="language-plaintext highlighter-rouge">DB</code>에서 해당 데이터를 읽어 캐시에 씀</li>
            </ul>
          </li>
          <li>캐시에서 웹 서버로 데이터를 반환함</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>캐시를 사용할 때 고려해야 할 점?
    <ul>
      <li>캐시는 어떤 상황에 바람직한가? : 갱신이 드물지만, 참조가 빈번한 데이터</li>
      <li>어떤 데이터를 캐시에 저장? : 영속적이지 않은 데이터</li>
      <li>캐시 내의 데이터는 어떻게 만료 (<code class="language-plaintext highlighter-rouge">expire</code>)할까? : 캐시에서 정책에 따라 삭제</li>
      <li>일관성 (<code class="language-plaintext highlighter-rouge">consistency</code>)는 어떻게 유지할까? : 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션으로 처리되어야</li>
      <li>장애에는 어떻게 대처할까? : 단일 장애 지점의 발생을 피해 캐시 서버를 분산</li>
      <li>캐시 메모리의 크기는? : 캐시 메모리를 과할당 (<code class="language-plaintext highlighter-rouge">over-provision</code>)</li>
      <li>데이터 방출 (<code class="language-plaintext highlighter-rouge">eviction</code>) 정책은? : <code class="language-plaintext highlighter-rouge">LRU</code>, <code class="language-plaintext highlighter-rouge">LFU</code> 등을 경우에 맞게 적용</li>
    </ul>
  </li>
</ul>

<h4 id="컨텐츠-전송-네트워크-cdn--정적-컨텐츠의-전송에-쓰이는-분산-서버-네트워크">컨텐츠 전송 네트워크 (<code class="language-plaintext highlighter-rouge">CDN</code>) : 정적 컨텐츠의 전송에 쓰이는 분산 서버 네트워크</h4>

<ul>
  <li>정적 컨텐츠 (이미지, 비디오, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">JavaScript</code> 파일 등)을 캐시</li>
  <li>사용자가 웹 사이트에 방문하면, 가장 가까운 <code class="language-plaintext highlighter-rouge">CDN</code> 서버가 정적 컨텐츠를 전달</li>
</ul>

<blockquote>
  <ol>
    <li>사용자가 이미지 <code class="language-plaintext highlighter-rouge">URL</code>를 통해 <code class="language-plaintext highlighter-rouge">image.png</code>에 접근한다.
      <ul>
        <li><code class="language-plaintext highlighter-rouge">URL</code>의 도메인은 <code class="language-plaintext highlighter-rouge">CDN</code> 서비스 사업자가 제공</li>
      </ul>
    </li>
    <li><code class="language-plaintext highlighter-rouge">CDN</code> 서버의 캐시에 해당 이미지가 없으면 원본 서버에서 파일을 요청
      <ul>
        <li>원본 서버가 파일을 반환할 때, 응답 <code class="language-plaintext highlighter-rouge">HTTP</code> 헤더는 <code class="language-plaintext highlighter-rouge">TTL</code> 값을 포함</li>
      </ul>
    </li>
    <li><code class="language-plaintext highlighter-rouge">CDN</code> 서버는 파일을 캐시하고 사용자에 반환 (<code class="language-plaintext highlighter-rouge">TTL</code> 값만큼 캐시)
      <ul>
        <li>사용자가 만료가 안된 이미지의 요청을 <code class="language-plaintext highlighter-rouge">CDN</code> 서버에 전송하면, 캐시로 처리</li>
      </ul>
    </li>
  </ol>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CDN</code> 사용 시 고려할 사항?
    <ul>
      <li>비용 : 자주 사용되지 않는 컨텐츠를 캐싱하는 것은 비효율적</li>
      <li>만료 기한 : <code class="language-plaintext highlighter-rouge">time-sensitive</code>한 컨텐츠의 만료 기한은 신중히 설정해야 함</li>
      <li><code class="language-plaintext highlighter-rouge">CDN</code> 장애 대처 방안 : <code class="language-plaintext highlighter-rouge">CDN</code>이 오프라인 상태일 때의 동작에 대한 고려</li>
      <li>컨텐츠 무효화 (<code class="language-plaintext highlighter-rouge">Invalidation</code>) 방법 : <code class="language-plaintext highlighter-rouge">CDN</code> 서비스 사업자가 제공하는 <code class="language-plaintext highlighter-rouge">API</code>를 이용한 컨텐츠 무효화
        <ul>
          <li>컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 (<code class="language-plaintext highlighter-rouge">object versioning</code>) 이용</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CDN</code>과 캐시를 추가한 설계
    <ul>
      <li>정적 컨텐츠는 웹 서버가 아닌 <code class="language-plaintext highlighter-rouge">CDN</code>을 통해 서비스됨</li>
      <li>캐시를 통해 데이터베이스의 부하가 줄어들 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="무상태-stateless-웹-계층--웹-계층을-수평적으로-확장하는-방법">무상태 (<code class="language-plaintext highlighter-rouge">stateless</code>) 웹 계층 : 웹 계층을 수평적으로 확장하는 방법</h3>

<ul>
  <li>사용자 세션 데이터와 같은 상태 정보를 웹 계층에서 제거해야 함</li>
  <li>상태 정보를 관계형 <code class="language-plaintext highlighter-rouge">DB</code>나 <code class="language-plaintext highlighter-rouge">NoSQL</code>과 같은 지속성 저장소에 보관하고 필요할 때 가져옴</li>
</ul>

<h4 id="상태-정보-의존적인-아키텍쳐--클라이언트-정보에-대한-상태를-유지하며-요청들-사이에-공유">상태 정보 의존적인 아키텍쳐 : 클라이언트 정보에 대한 상태를 유지하며 요청들 사이에 공유</h4>

<ul>
  <li>사용자 A의 상태 정보가 서버 1에 저장되면,
    <ul>
      <li>해당 사용자 인증에 대한 HTTP 요청은 해당 서버로만 가야 한다.</li>
      <li>다른 서버로 가면 사용자 인증은 무조건 실패한다.</li>
    </ul>
  </li>
  <li>같은 클라이언트로부터의 요청은 항상 같은 서버로만 전송된다.
    <ul>
      <li>고정 세션 (sticky session) 기능을 지원하는 로드밸런서에 부담을 준다.</li>
      <li>로드밸런서 뒷단에 서버를 추가 및 제거가 어렵고, 서버의 장애 처리 또한 복잡해진다.</li>
    </ul>
  </li>
</ul>

<h4 id="무상태-아키텍처--사용자로부터의-http-요청은-어떤-웹-서버로도-전달-가능함">무상태 아키텍처 : 사용자로부터의 <code class="language-plaintext highlighter-rouge">HTTP</code> 요청은 어떤 웹 서버로도 전달 가능함</h4>

<ul>
  <li>웹 서버는 상태 정보가 필요할 때에 공유 저장소 (<code class="language-plaintext highlighter-rouge">Shared Storage</code>) 에서 데이터를 가져옴
    <ul>
      <li>상태 정보는 웹 서버로부터 물리적으로 분리</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=278536695">가상 면접으로 배우는 대규모 시스템 설계</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="System Design Interview" /><summary type="html"><![CDATA[시스템 디자인 면접 (System Design Interview) : 시스템 아키텍처를 설계하는 면접]]></summary></entry><entry><title type="html">[Engineer Information Processing] 1. 소프트웨어 공학 &amp;amp; 개발 방법론</title><link href="http://localhost:4000/engineer_information_processing1/" rel="alternate" type="text/html" title="[Engineer Information Processing] 1. 소프트웨어 공학 &amp;amp; 개발 방법론" /><published>2024-01-12T00:00:00+09:00</published><updated>2024-01-12T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing1</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing1/"><![CDATA[<h2 id="소프트웨어-software--프로그램과-프로그램-수행에-필요한-절차-규칙-관련-문서-등을-총칭">소프트웨어 (<code class="language-plaintext highlighter-rouge">Software</code>) : 프로그램과 프로그램 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭</h2>

<ul>
  <li>프로그램 (<code class="language-plaintext highlighter-rouge">Program</code>) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합</li>
  <li>자료구조 (<code class="language-plaintext highlighter-rouge">Date Structure</code>) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭
    <ul>
      <li>데이터 간의 논리적 관계나 데이터를 처리하는 알고리즘을 의미</li>
    </ul>
  </li>
  <li>문서 (<code class="language-plaintext highlighter-rouge">Document</code>) : 소프트웨어를 개발하면서 작성하는 문서들을 총칭
    <ul>
      <li>사용자 설명서, 소프트웨어 요구 분석서, 평가서, 명세서, 프로젝트 계획서, 감사 계획서 등을 의미</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어의-특징">소프트웨어의 특징</h3>

<ul>
  <li>상품성 : 소프트에어를 개발하면 상품이 되어 판매할 수 있다.</li>
  <li>복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.</li>
  <li>변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.</li>
  <li>복제성 : 복제가 쉬워 쉅게 복사 및 유통이 가능하다.</li>
  <li>순응성 : 기술의 발전, 사용자 요구, 사회적 흐름의 변화에 맞춰 적절히 변형된다.</li>
  <li>비가시성 : 소프트웨어 구조는 외관으로 나타나 있지 않고 코드로 내재되어 있다.</li>
</ul>

<h3 id="소프트웨어의-분류">소프트웨어의 분류</h3>

<ul>
  <li>시스템 소프트웨어 (<code class="language-plaintext highlighter-rouge">System Software</code>) : 하드웨어를 관리하고 컴퓨터 자원을 활용하는 소프트웨어
    <ul>
      <li>운영체제, 컴파일러, 로더, 디버거 등</li>
    </ul>
  </li>
  <li>응용 소프트웨어 (<code class="language-plaintext highlighter-rouge">Application Software</code>) : 사용자가 원하는 목적에 맞게 만들어진 소프트웨어
    <ul>
      <li>엑셀, 파워포인트, 워드프로세서, 포토샵 등</li>
    </ul>
  </li>
  <li>미들웨어 소프트웨어 (<code class="language-plaintext highlighter-rouge">Middleware</code>) : 시스템 소프트웨어와 응용 소프트웨어를 연결해주는 중간 단계의 소프트웨어
    <ul>
      <li>데이터베이스 관리 시스템, 웹 서버, 어플리케이션 서버, 트랜잭션 처리 모니터 등</li>
    </ul>
  </li>
</ul>

<h3 id="시스템-system--컴퓨터로-처리할-자료를-입력해-저장-처리-가공해-출력하도록-설계-및-구현된-정보-체계">시스템 (<code class="language-plaintext highlighter-rouge">System</code>) : 컴퓨터로 처리할 자료를 입력해 저장, 처리, 가공해 출력하도록 설계 및 구현된 정보 체계</h3>

<ul>
  <li>하나의 목적을 위해 시스템의 여러 요소들이 유기적으로 결합된 것
    <ul>
      <li>입력 (<code class="language-plaintext highlighter-rouge">Input</code>) : 처리 방법, 제어 조건, 처리할 데이터를 시스템이 투입하는 요소</li>
      <li>출력 (<code class="language-plaintext highlighter-rouge">Output</code>) : 처리된 결과를 시스템에서 출력하는 요소</li>
      <li>처리 (<code class="language-plaintext highlighter-rouge">Process</code>) : 입력된 자료를 처리 조건에 따라 변환 및 가공하는 요소</li>
      <li>제어 (<code class="language-plaintext highlighter-rouge">Control</code>) : 시스템의 기본 요소들이 각 과정을 올바르게 행하는지 감독하는 요소</li>
      <li>피드백 (<code class="language-plaintext highlighter-rouge">Feedback</code>) : 처리된 결과를 측정 및 파악하여 목표에 도달되었는지 검사하고, 만약 불충분한 경우에 목표 달성을 위해 다시 입력하는 요소</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어의-위기-software-crisis--소프트웨어-개발-속도가-하드웨어-개발-속도을-따라가지-못함">소프트웨어의 위기 (<code class="language-plaintext highlighter-rouge">Software Crisis</code>) : 소프트웨어 개발 속도가 하드웨어 개발 속도을 따라가지 못함</h3>

<ul>
  <li>하드웨어 비용을 초과하는 개발 비용의 증가</li>
  <li>개발 기간의 지연</li>
  <li>개발 인력의 부족 및 인건비 상승 → 개발 인력을 최대한 많이 투입하는 것은 해결책이 아님</li>
  <li>성능 및 신뢰성 부족</li>
  <li>유지보수의 어려움에 따른 엄청난 비용</li>
</ul>

<h2 id="소프트웨어-공학-software-engineering--경제적으로-신뢰도-높은-소프트웨어를-만드는-체계">소프트웨어 공학 (<code class="language-plaintext highlighter-rouge">Software Engineering</code>) : 경제적으로 신뢰도 높은 소프트웨어를 만드는 체계</h2>

<ul>
  <li>전기전자공학자협회 (<code class="language-plaintext highlighter-rouge">IEEE</code>) → 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법으로 정의</li>
</ul>

<h3 id="소프트웨어의-등장-배경">소프트웨어의 등장 배경</h3>

<ul>
  <li>소프트웨어 개발에 필요한 시간과 비용 예측력이 부족</li>
  <li>개발된 소프트웨어의 품질 수준이 부족</li>
  <li>하드웨어에 대한 소프트웨어의 상대적인 비용이 증대</li>
  <li>유지보수 역할의 증대</li>
  <li>하드웨어 및 소프트웨어 기술의 급속한 발전</li>
  <li>크고 복잡한 소프트웨어에 대한 수요의 증가</li>
  <li>특정 개인에 의존하는 시스템의 개발</li>
</ul>

<h3 id="소프트웨어-공학의-분류">소프트웨어 공학의 분류</h3>

<ul>
  <li>소프트웨어 개발 생명주기 모형 : 소프트웨어를 개발하는 과정을 단계별로 분류한 모형
    <ul>
      <li>폭포수 모형, 프로토타입 모형, 나선형 모형, 에자일 개발 방법론 등</li>
    </ul>
  </li>
  <li>소프트웨어 프로세스 모형 : 소프트웨어 개발을 위한 절차와 방법을 제공하는 모형
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ISO/IEE 12207</code>, <code class="language-plaintext highlighter-rouge">CMM1</code> 등</li>
    </ul>
  </li>
  <li>소프트웨어 품질 관리 : 소프트웨어 개발 과정에서 품질을 유지하고 향상시키기 위한 관리 기법을 연구하는 것
    <ul>
      <li>테스트, 코드 리뷰, 정적 분석 등</li>
    </ul>
  </li>
  <li>소프트웨어 유지보수 : 개발된 소프트웨어를 사용하고 보수하는 과정을 연구하는 것
    <ul>
      <li>버그 수정, 기능 추가, 기술 업그레이드 등</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어-공학의-기본-원칙">소프트웨어 공학의 기본 원칙</h3>

<ul>
  <li>현대적인 프로그래밍 기술이 적용되어야 한다.</li>
  <li>신뢰성이 높아야 한다.</li>
  <li>사용의 편리성과 유지보수성이 높아야 한다.</li>
  <li>지속적인 검증 시행을 해야 한다.</li>
  <li>사용자가 원하는 대로 동작해야 한다.</li>
  <li>시스템의 안전성와 보안에 최선을 다해야 한다.</li>
  <li>최신 프로그램 언어, 최신 알고리즘 사용 현황을 확인해야 한다.</li>
  <li>소프트웨어 개발 비용을 최소화하도록 노력해야 한다.</li>
  <li>개발 단계와 소스 코드 등의 문서화를 통해 명확성을 유지해야 한다.</li>
</ul>

<h3 id="공학적으로-좋은-소프트웨어의-조건">공학적으로 좋은 소프트웨어의 조건</h3>

<ul>
  <li>신뢰성이 높고 효율적이여야 하며, 사용자의 의도대로 동작해야 한다.</li>
  <li>편리성 제공 및 잠재적 에러를 최소화해야 한다.</li>
  <li>유지보수성이 쉬워야 한다.</li>
</ul>

<h3 id="소프트웨어-공학-계층-구조">소프트웨어 공학 계층 구조</h3>

<ul>
  <li>도구 : 프로세스와 방법을 처리하는 기능을 제공</li>
  <li>방법론 : 소프트웨어를 설계하는 데 기술적인 방법을 제공하는 것</li>
  <li>프로세스 : 소프트웨어의 가장 기초가 되며, 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미</li>
</ul>

<h3 id="소프트웨어-공학의-목표">소프트웨어 공학의 목표</h3>

<ul>
  <li>최소의 비용으로 단기간에 적합한 소프트웨어를 개발하는 것</li>
  <li>소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[소프트웨어 (Software) : 프로그램과 프로그램 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭]]></summary></entry><entry><title type="html">[Clean Code] 1. 깨끗한 코드</title><link href="http://localhost:4000/clean_code1/" rel="alternate" type="text/html" title="[Clean Code] 1. 깨끗한 코드" /><published>2024-01-11T00:00:00+09:00</published><updated>2024-01-11T00:00:00+09:00</updated><id>http://localhost:4000/clean_code1</id><content type="html" xml:base="http://localhost:4000/clean_code1/"><![CDATA[<h2 id="코드-code--프로그래밍의-결과로서-요구사항을-상세히-표현하는-수단">코드 (<code class="language-plaintext highlighter-rouge">Code</code>) : 프로그래밍의 결과로서 요구사항을 상세히 표현하는 수단</h2>

<ul>
  <li>프로그래밍 (<code class="language-plaintext highlighter-rouge">Programming</code>) : 요구사항을 상세히 명시하는 작업
    <ul>
      <li>나쁜 코드는 프로젝트의 개발 속도를 떨어뜨리며, 팀 생산성을 떨어뜨림</li>
      <li>나쁜 코드는 나쁜 코드를 ‘유혹’한다 : 나쁜 코드를 고치면서 오히려 더 나쁜 코드를 만들어냄</li>
    </ul>
  </li>
</ul>

<h3 id="그렇다면-깨끗한-코드란-무엇인가">그렇다면, 깨끗한 코드란 무엇인가?</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">by</code> 비야네 스트롭스트룹
    <ul>
      <li>보는 사람에게 즐거움을 선사하는 ‘우아한’ 코드</li>
      <li>시간과 자원을 낭비하지 않는 ‘효율적인’ 코드</li>
      <li>세세한 사항까지 철저히 오류 처리를 하는 코드</li>
      <li>‘깨끗한 코드란 한 가지를 잘한다.’ : 나쁜 코드는 많은 일을 하려 애쓰다가 의도와 목적이 흐려진다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 그래디 부치
    <ul>
      <li>‘잘 쓴 문장처럼 읽혀야 한다.’ → 가독성 높은 코드</li>
      <li>‘명쾌한 추상화와 단순한 제어문’ → 추측이 아니라 사실에 기반한 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 데이브 토마스
    <ul>
      <li>다른 사람이 고치기 쉬운 코드</li>
      <li>테스트 케이스가 존재하는 코드</li>
      <li>작을수록 좋은, ‘최소한의’ 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 마이클 페더스
    <ul>
      <li>작성자가 모든 사항을 고려하여, 주의 깊게 작성한 코드</li>
      <li>시간을 들여 깔끔하고 단정하게 정리된 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 론 제프리스
    <ul>
      <li>중복을 피하고, 한 기능만을 수행하면서, 표현력이 높으며, 초반부터 간단한 추상화를 고려한 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 워드 커닝햄
    <ul>
      <li>읽으면서 ‘짐작했던 기능을 그대로 수행’하는 코드</li>
      <li>언어를 단순하게 보이도록 만드는 책임이 우리에게 달려 있음</li>
    </ul>
  </li>
</ul>

<h3 id="우리가-저자다--저자에게는-독자와-잘-소통할-책임이-있다">우리가 저자다 : 저자에게는 독자와 잘 소통할 책임이 있다.</h3>
<ul>
  <li>코드를 짤 때에는 자신이 저자라는 사실을, 그리고 저자의 노력을 보고 판단할 독자가 잊지 말자!</li>
  <li>저자 역시 독자다 : 새 코드를 짜면서 끊임없이 기존 코드를 읽기에, 읽기 쉽게 만들면 짜기 또한 쉽다.</li>
</ul>

<h3 id="보이스카우트-규칙--캠프장은-처음-왔을-때보다-더-깨끗하게-해놓고-떠나라">보이스카우트 규칙 : “캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.”</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Check-out</code>할 때보다 좀 더 깨끗한 코드를 <code class="language-plaintext highlighter-rouge">Check-in</code>한다면, 코드는 절대 나빠지지 않는다.</li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=248640013">클린 코드 Clean Code</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Clean Code" /><summary type="html"><![CDATA[코드 (Code) : 프로그래밍의 결과로서 요구사항을 상세히 표현하는 수단]]></summary></entry></feed>