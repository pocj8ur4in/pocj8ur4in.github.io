<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-13T22:22:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[MicroService] 3. Microservice Architecture</title><link href="http://localhost:4000/microservice3/" rel="alternate" type="text/html" title="[MicroService] 3. Microservice Architecture" /><published>2024-01-13T00:00:00+09:00</published><updated>2024-01-13T00:00:00+09:00</updated><id>http://localhost:4000/microservice3</id><content type="html" xml:base="http://localhost:4000/microservice3/"><![CDATA[<h2 id="비즈니스-로직-business-logic--시스템이-목표로-하는-비즈니스-영역의-규칙-흐름-개념">비즈니스 로직 (<code class="language-plaintext highlighter-rouge">Business Logic</code>) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념</h2>

<blockquote>
  <ul>
    <li>소프트웨어의 가치는? <code class="language-plaintext highlighter-rouge">by Clean Architecture</code>
      <ul>
        <li>행위 기치 : 소프트웨어의 기능</li>
        <li>구조 가치 : 소프트웨어의 아키텍처 → 소프트웨어를 <code class="language-plaintext highlighter-rouge">Soft</code>하게 만드는 것</li>
      </ul>

      <p>→ 코드나 설계의 구조를 깔끔히 하는 대신 기능 구현만 목표하면, 엉망이 된 소프트웨어 대처에 더 많은 비용 발생</p>
    </li>
    <li>문제 영역에서 비즈니스 로직을 분석 및 이해하고, 프로그래밍 언어로 잘 표현하는 것이 개발자의 역할
      <ul>
        <li>기능이 정확하게 동작하는 것과 더불어, 이해하기 쉽고 변경하기 쉬운 시스템을 만드는 것</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="관심사의-분리-separation-of-concerns--시스템의-각-영역이-처리하는-관심사가-분리해-관리되어야-함">관심사의 분리 (<code class="language-plaintext highlighter-rouge">Separation of Concerns</code>) : 시스템의 각 영역이 처리하는 관심사가 분리해 관리되어야 함</h3>

<ul>
  <li>각 영역은 고유의 관심사에 의해 분리되어 집중되어야 함 → 모듈화, 계층화
    <ul>
      <li>비즈니스 로직은 어플리케이션의 핵심 영역이므로, 기술에 영향을 적게 받게 설계해야</li>
      <li>기술과 비즈니스 로직을 분리했을 때, 어플리케이션의 복잡성이 낮아지고 유지보수성이 높아짐</li>
      <li>비즈니스 로직을 모두가 이해할 수 있게 구조화된 객체 모델로 표현되어야 함</li>
    </ul>

    <p>→ 유연하고 확장성 있는 <code class="language-plaintext highlighter-rouge">MSA</code> 시스템을 개발하려면, 마이크로서비스의 내부 구조를 어떻게 유연하게 만들지 고민해야!</p>
  </li>
</ul>

<h2 id="데이터베이스-중심-아키텍처-database-centric-architecture--데이터-중심-서비스-구현">데이터베이스 중심 아키텍처 (<code class="language-plaintext highlighter-rouge">Database Centric Architecture</code>) : 데이터 중심 서비스 구현</h2>

<ol>
  <li>특정한 관계형 데이터베이스에 의존한 데이터 모델링을 수행한다.</li>
  <li>물리 테이블 모델을 중심에 두고 어플리케이션을 구현한다. (예시 : <code class="language-plaintext highlighter-rouge">SpringBoot Application</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Controller</code>, <code class="language-plaintext highlighter-rouge">Service</code>, <code class="language-plaintext highlighter-rouge">DTO</code>, <code class="language-plaintext highlighter-rouge">Repository &amp; Entity</code>로 어플리케이션을 구성</li>
      <li><code class="language-plaintext highlighter-rouge">SQL</code> 매핑 프레임워크인 <code class="language-plaintext highlighter-rouge">MyBatis</code>나 <code class="language-plaintext highlighter-rouge">Java Persistence API</code>인 <code class="language-plaintext highlighter-rouge">JPA</code>로 데이터를 처리</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>데이터베이스 중심 아키텍처에서 비즈니스 로직은 서비스에 존재해야 한다. 그러나,</p>

  <ul>
    <li>흐름 제어 로직만 서비스에 존재하고, 비즈니스 개념이나 규칙은 테이블이나 <code class="language-plaintext highlighter-rouge">SQL</code> 질의로 존재한다.</li>
    <li><code class="language-plaintext highlighter-rouge">DTO</code>는 <code class="language-plaintext highlighter-rouge">SQL</code> 질의를 통해 정보를 가져오는 정보 묶음 (<code class="language-plaintext highlighter-rouge">Information Holder</code>)의 역할밖에 할 수 없다.</li>
  </ul>

</blockquote>

<ul>
  <li>간단한 처리 로직의 경우에는 적합하나, 업무가 다양해지면 점점 복잡성을 제어할 수 없음</li>
  <li>업무 개념이 특정 관계형 테이블 데이터베이스의 테이블로 표현되어, 데이터 질의어인 <code class="language-plaintext highlighter-rouge">SQL</code>가 필요한 경우가 있음</li>
  <li>서비스의 비즈니스 개념과 규칙이 대부분 데이터베이스에 표현 → 성능이 데이터베이스에 의존
    <ul>
      <li>데이터가 늘어남에 따라 데이터베이스의 성능은 지속적으로 떨이짐
        <ul>
          <li>데이터베이스 서버의 <code class="language-plaintext highlighter-rouge">Scale-out</code>과 <code class="language-plaintext highlighter-rouge">SQL</code> 질의문 튜닝에 의존하게 됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="msa-시스템의-확장성과-유연성을-위한-내부-어플리케이션의-아키텍처-구조"><code class="language-plaintext highlighter-rouge">MSA</code> 시스템의 확장성과 유연성을 위한 내부 어플리케이션의 아키텍처 구조</h2>

<ul>
  <li>클라우드의 풍부한 자원 환경에서는, 어플리케이션 자체의 성능보단 어플리케이션의 확장성과 유연성이 더 중요하다!</li>
</ul>

<h3 id="계층형-아키텍처-layered-architecture">계층형 아키텍처 (<code class="language-plaintext highlighter-rouge">Layered Architecture</code>)</h3>

<ul>
  <li>티어 (<code class="language-plaintext highlighter-rouge">Tear</code>) : 물리적인 장비나 서버 컴퓨터 등의 물리 계층</li>
  <li>레이어 (<code class="language-plaintext highlighter-rouge">Layer</code>) : 물리적인 티어 내부에서 어플리케이션이 처리할 관심사를 구분하는 논리 계층
    <ul>
      <li>프레젠테이션 (<code class="language-plaintext highlighter-rouge">Presentation</code>) : 화면 표현 및 전환 처리</li>
      <li>비즈니스 로직 (<code class="language-plaintext highlighter-rouge">Business Logic</code>) : 비즈니스 개념, 규칙, 흐름 제어</li>
      <li>데이터 액세스 (<code class="language-plaintext highlighter-rouge">Data Access</code>) : 데이터 처리</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>계층형 아키텍처를 개발하기 위하여 지켜야 할 규칙!</p>

  <ul>
    <li>상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.</li>
    <li>상위 계층은 하위의 여러 계층을 모두 알 필요 없이 바로 밑의 근접 계층만을 활용한다.</li>
    <li>상위 계층이 하위 계층에 영향받지 않게 구성해야 한다.</li>
    <li>하위 계층은 자신을 사용하는 상위 계층을 알지 못하게끔 구성해야 한다.</li>
    <li>계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.
      <ul>
        <li>구현 클래스에 직접 의존하지 않게끔 하여 약결합을 유지해야 한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>의존성 역전의 원칙 (<code class="language-plaintext highlighter-rouge">DIP</code>) : ‘유연성이 극대화된 시스템은 코드 의존성이 구체가 아닌 추상에 의존한다.’ → <code class="language-plaintext highlighter-rouge">O</code></li>
  <li>개방 폐쇄의 원칙 (<code class="language-plaintext highlighter-rouge">OCP</code>) : ‘소프트웨어 객체는 확장에 열리되, 변경에 닫혀 있어야 한다.’ → <code class="language-plaintext highlighter-rouge">X</code>
    <ul>
      <li>개체의 행위는 확장될 수 있지만, 이때 객체를 변경해서는 안된다. 그러나 상위 계층에서 하위 계층으로 제어의 흐름 (<code class="language-plaintext highlighter-rouge">Flow of Control</code>)이 흐르는 계층형 아키텍처에서 소스 코드의 의존성 또한 그 방향을 따를 수 밖에 없다.</li>
      <li>상위 계층이 하위 계층의 구체 클래스가 아닌 추상 인터페이스에 의존시키고 그 인터페이스의 구현체를 달리해 의존성을 줄이면서 다형성을 유지할 수 있지만, 인터페이스는 그 계층이 정의하는 추상 특성의 한계를 벗어날 수 없다.</li>
    </ul>

    <p>→ 즉, 하위 계층의 유형이 추가되어 확장될 때, 닫혀 있어야 할 상위 계층이 하위 계층이 정의한 특성이 영향받는다!</p>
  </li>
</ul>

<h3 id="헥사고날-아키텍처-hexagonal-architecture">헥사고날 아키텍처 (<code class="language-plaintext highlighter-rouge">Hexagonal Architecture</code>)</h3>

<h3 id="클린-아키텍처-clean-architecture">클린 아키텍처 (<code class="language-plaintext highlighter-rouge">Clean Architecture</code>)</h3>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[비즈니스 로직 (Business Logic) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념]]></summary></entry><entry><title type="html">[Git] Git 개념 및 명령어 정리</title><link href="http://localhost:4000/git1/" rel="alternate" type="text/html" title="[Git] Git 개념 및 명령어 정리" /><published>2024-01-13T00:00:00+09:00</published><updated>2024-01-13T00:00:00+09:00</updated><id>http://localhost:4000/git1</id><content type="html" xml:base="http://localhost:4000/git1/"><![CDATA[<h2 id="버전-관리-version-control--특정한-시간-기준으로-파일-변화를-저장하고-관리">버전 관리 (<code class="language-plaintext highlighter-rouge">Version Control</code>) : 특정한 시간 기준으로 파일 변화를 저장하고 관리</h2>

<ul>
  <li>버전 (<code class="language-plaintext highlighter-rouge">Version</code>) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용</li>
</ul>

<h3 id="1-로컬-버전-관리-local-version-control">1. 로컬 버전 관리 (<code class="language-plaintext highlighter-rouge">Local Version Control</code>)</h3>
<ul>
  <li>로컬 사용자가 서버 없이 로컬 컴퓨터 내의 데이터베이스를 이용해 파일의 변경 정보 관리
    <ul>
      <li>협업에서 사용하기 어려움, 내부 정보가 손상되면 복구할 방법이 없음</li>
    </ul>
  </li>
</ul>

<h3 id="2-중앙집중식-버전-관리-central-version-control--서브-머신-svn">2. 중앙집중식 버전 관리 (<code class="language-plaintext highlighter-rouge">Central Version Control</code>) : 서브 머신 (<code class="language-plaintext highlighter-rouge">SVN</code>)</h3>
<ul>
  <li>클라이언트가 최종본를 관리하는 데이터베이스 서버로부터 개별 파일을 로컬에 다운로드, 수정본을 서버에 올림
    <ul>
      <li>데이터베이스 서버에 의존적, 협업 규모가 커지면 수정 충돌 문제 발생 (유사 사례 : <a href="https://namu.wiki/w/편집%20충돌">나무위키의 편집 충돌</a>)</li>
    </ul>
  </li>
</ul>

<h3 id="3-분산형-버전-관리-distributed-version-control--깃-git">3. 분산형 버전 관리 (<code class="language-plaintext highlighter-rouge">Distributed Version Control</code>) : 깃 (<code class="language-plaintext highlighter-rouge">Git</code>)</h3>
<ul>
  <li>클라이언트가 원격 저장소에서 전체 기록과 각 기록을 추적할 수 있는 정보를 포함한 데이터를 로컬 저장소에 저장
    <ul>
      <li>클라이언트가 자신의 작업을 원격 저장소에 독립적인 로컬 저장소에 버전별로 저장하고 관리</li>
      <li>여러 클라이언트들의 작업을 여러 로컬 저장소로 다원화해 각 클라이언트는 충돌의 염려 없이 작업 가능</li>
      <li>필요한 경우에 클라이언트가 서버의 원격 저장소에 원하는 버전을 통합 (서버 단위의 편집 버전을 +1)
        <ul>
          <li>클라이언트는 원격 저장소에 자신의 작업을 통합시킬 때만 서버와 통신하면 됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="깃-git--분산형-버전-관리-시스템-distributed-version-control-system"><a href="https://git-scm.com">깃</a> (<code class="language-plaintext highlighter-rouge">Git</code>) : 분산형 버전 관리 시스템 (<code class="language-plaintext highlighter-rouge">Distributed Version Control System</code>)</h2>
<ul>
  <li>터미널 창에 다음 명령어를 입력해 <a href="https://pocj8ur4in.github.io/mac/homebrew1/"><code>homebrew</code></a>를 통해 <code class="language-plaintext highlighter-rouge">git</code> 설치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install git
</code></pre></div></div>

<h3 id="gitignore-디렉터리--버전-관리를-하지-않을-파일이나-디렉터리-혹은-파일-확장자를-설정"><code class="language-plaintext highlighter-rouge">.gitignore</code> 디렉터리 : 버전 관리를 하지 않을 파일이나 디렉터리, 혹은 파일 확장자를 설정</h3>

<ul>
  <li>특정한 이름을 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename.txt
</code></pre></div></div>

<ul>
  <li>특정한 확장자를 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*.txt
</code></pre></div></div>

<ul>
  <li>특정한 경로 아래의 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder/
</code></pre></div></div>

<ul>
  <li>특정한 경로 아래의 특정한 확장자를 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder/filename.txt
</code></pre></div></div>

<ul>
  <li>예외 만들기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!filename.txt
</code></pre></div></div>

<h3 id="readmemd-파일--프로젝트에-대한-설명과-사용-방법-license-등의-내용을-작성"><code class="language-plaintext highlighter-rouge">README.md</code> 파일 : 프로젝트에 대한 설명과 사용 방법, <code class="language-plaintext highlighter-rouge">LICENSE</code> 등의 내용을 작성</h3>
<ul>
  <li>기존의 <code><a href="_posts/2022-10-29-markdown1.md">Markdown</a></code>에 깃허브에서만 사용 가능한 기능을 추가한 <code class="language-plaintext highlighter-rouge">Github Flavored Markdown</code>을 이용</li>
  <li><code class="language-plaintext highlighter-rouge">Github</code> 프로젝트 레포지토리 페이지에서 <code class="language-plaintext highlighter-rouge">README.md</code>가 표현된 것을 확인 가능
    <ul>
      <li>자신의 아이디와 같은 이름의 레포지토리의 <code class="language-plaintext highlighter-rouge">README.md</code>는 해당 사용자의 깃허브 프로필에 표시됨</li>
    </ul>
  </li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb18y0K%2FbtruITygdgC%2FV4XYZs3D0ZMlzqlkHZkH9k%2Fimg.png" /></p>

<ul>
  <li><a href="https://shields.io">뱃지</a> : 해당 사이트에서 뱃지의 구성 요소들을 직접 지정해 생성한 후 <code class="language-plaintext highlighter-rouge">img</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/(아이콘 내용)-(아이콘 색상)?style=flat-square&amp;logo=(로고 이름)&amp;logoColor=(로고 색상)"/&gt;
</code></pre></div></div>

<p><img alt="GitHub followers" src="https://img.shields.io/github/followers/pocj8ur4in?style=social" /></p>

<ul>
  <li><a href="https://hits.seeyoufarm.com">방문자 수</a> : 해당 사이트에서 <code class="language-plaintext highlighter-rouge">Target URL</code>과 로고를 선택한 후 <code class="language-plaintext highlighter-rouge">a</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="https://github.com/pocj8ur4in"&gt; ... &lt;/a&gt;
</code></pre></div></div>

<p><a href="https://github.com/pocj8ur4in"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2Fseondal&amp;count_bg=%23000000&amp;title_bg=%23000000&amp;icon=github.svg&amp;icon_color=%23E7E7E7&amp;title=GitHub&amp;edge_flat=false)" /></a></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazassumnida"><code>Solved.ac</code> 티어</a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[![Solved.ac 프로필]
(http://mazassumnida.wtf/api/v2/generate_badge?boj={백준ID})]
(https://solved.ac/{백준ID})
</code></pre></div></div>

<p><a href="https://solved.ac/pocj8ur4in"><img src="http://mazassumnida.wtf/api/v2/generate_badge?boj=pocj8ur4in" alt="Solved.ac 프로필" /></a></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazandi"><code>Solved.ac</code> 잔디</a> : 해당 사이트에서 <code class="language-plaintext highlighter-rouge">img</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="http://mazandi.herokuapp.com/api?handle={백준ID}&amp;theme=warm"/&gt;
</code></pre></div></div>

<p><img src="http://mazandi.herokuapp.com/api?handle=pocj8ur4in&amp;theme=warm" /></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazandi">자주 사용한 언어</a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[![Top Langs]
(https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브ID)]
(https://github.com/깃허브ID/github-readme-stats)
</code></pre></div></div>

<p><a href="https://github.com/pocj8ur4in/github-readme-stats"><img src="https://github-readme-stats.vercel.app/api/top-langs/?username=pocj8ur4in" alt="Top Langs" /></a></p>

<h3 id="git-디렉터리--깃의-버전을-저장할-로컬-저장소"><code class="language-plaintext highlighter-rouge">.git</code> 디렉터리 : 깃의 버전을 저장할 로컬 저장소</h3>
<ul>
  <li>버전 (<code class="language-plaintext highlighter-rouge">Version</code>) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용
    <ul>
      <li>작업 트리 (<code class="language-plaintext highlighter-rouge">working tree</code>) : 파일 수정, 저장 등의 작업을 하는 작업 디렉터리
        <ul>
          <li>스테이징 (<code class="language-plaintext highlighter-rouge">Staging</code>) : 작업 트리에서 작업한 파일을 버전으로 만들기 위해 스테이지로 이동</li>
        </ul>
      </li>
      <li>스테이지 (<code class="language-plaintext highlighter-rouge">stage</code>) : 버전으로 만들 파일이 대기하는 스테이징 영역
        <ul>
          <li>커밋 (<code class="language-plaintext highlighter-rouge">Commit</code>) : 스테이지에서 대기중인 파일을 버전으로 만들어 레포지토리에 저장</li>
        </ul>
      </li>
      <li>레포지토리 (<code class="language-plaintext highlighter-rouge">repository</code>) : 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 저장소</li>
    </ul>
  </li>
</ul>

<h2 id="깃-명령어-git-command--git-command-형식으로-구성">깃 명령어 (<code class="language-plaintext highlighter-rouge">Git Command</code>) : <code class="language-plaintext highlighter-rouge">git &lt;command&gt;</code> 형식으로 구성</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git</code> : 깃 명령 다음에 입력할 수 있는 명령어 옵션 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git
...
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git init</code> : 깃 저장소를 만들 디렉터리 초기화 (깃 저장소인 <code class="language-plaintext highlighter-rouge">.git</code> 디렉터리가 생성)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git init
Initialized empty Git repository in ...
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git status</code> :  깃의 현재 상태 확인
    <ul>
      <li><code class="language-plaintext highlighter-rouge">untracked</code> 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하지 않습니다. (파일이 스테이지에서 대기 : <code class="language-plaintext highlighter-rouge">false</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">tracked</code> 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하고 있습니다. (파일이 스테이지에서 대기 : <code class="language-plaintext highlighter-rouge">true</code>)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">unmodified</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되지 않았습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Working tree clean</code></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">modified</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었으나 스테이징되지 않았습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Changes not stage for commit:</code></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">staged</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었고 스테이징되었습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Changes to be committed:</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
On branch master  // 현재 master 브랜치에 위치해 있음
No commits yet    // 아직 커밋한 파일이 존재하지 않음
nothing to commit // 현재 커밋한 파일이 존재하지 않음
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
On branch master
No commits yet
untracked files   // untracked 상태 : 아직 버전 관리하지 않은 파일들이 존재함
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git add</code> : 작업 트리에서 스테이지로 스테이징</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add helloWorld.txt
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git commit</code> : 스테이지에 있는 파일을 버전으로 커밋
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-m</code> 옵션을 통해 커밋과 함께 메시지 저장</li>
      <li><code class="language-plaintext highlighter-rouge">-am</code> 옵션을 통해 스테이징과 커밋을 동시에 처리</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git commit -m "message1"
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git log</code> : 레포지토리에 저장된 버전 정보 확인
    <ul>
      <li>커밋 해시 (<code class="language-plaintext highlighter-rouge">commit hash</code>) : 커밋을 구별하는 ID (<code class="language-plaintext highlighter-rouge">HEAD-&gt;master</code> : 해당 버전이 가장 최신임을 표시)</li>
      <li>작성자 (<code class="language-plaintext highlighter-rouge">Author</code>) : <code class="language-plaintext highlighter-rouge">git config --global user</code>를 통해 입력한 사용자 정보 (이름과 이메일)</li>
      <li>작성일 (<code class="language-plaintext highlighter-rouge">Date</code>) : 버전이 작성된 시각</li>
      <li>커밋 메시지 (<code class="language-plaintext highlighter-rouge">commit message</code>) : <code class="language-plaintext highlighter-rouge">git commit -m</code>을 통해 저장된 메시지</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Git" /><summary type="html"><![CDATA[버전 관리 (Version Control) : 특정한 시간 기준으로 파일 변화를 저장하고 관리]]></summary></entry><entry><title type="html">[Java] 1. Java 기초</title><link href="http://localhost:4000/java1/" rel="alternate" type="text/html" title="[Java] 1. Java 기초" /><published>2024-01-13T00:00:00+09:00</published><updated>2024-01-13T00:00:00+09:00</updated><id>http://localhost:4000/java1</id><content type="html" xml:base="http://localhost:4000/java1/"><![CDATA[<h2 id="java--객체지향-프로그래밍-언어-object-oriented-programming-language"><code class="language-plaintext highlighter-rouge">Java</code> : 객체지향 프로그래밍 언어 (<code class="language-plaintext highlighter-rouge">Object-Oriented Programming Language</code>)</h2>

<ul>
  <li>객체지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">OOP</code>) : 초기부터 객체지향 방법론에 의거해 객체 지향 프로그램 언어로 설계</li>
  <li>플랫폼에 독립적 : 동일한 프로그램을 여러 운영체제에서 실행 가능
    <ul>
      <li>어떤 운영체제인지 상괸없이 동일한 <code class="language-plaintext highlighter-rouge">.java</code> 파일을 컴파일하면, 동일한 <code class="language-plaintext highlighter-rouge">.class</code> 파일이 생성</li>
    </ul>
  </li>
</ul>

<h3 id="자바-가상-머신-java-virtual-machine--서로-다른-플랫폼에-동일한-자바-실행-환경-제공">자바 가상 머신 (<code class="language-plaintext highlighter-rouge">Java Virtual Machine</code>) : 서로 다른 플랫폼에 동일한 자바 실행 환경 제공</h3>
<ul>
  <li>플랫폼에 종속적 : 자바에서 소스 파일을 통해 생성된 바이트 코드를 <code class="language-plaintext highlighter-rouge">CPU</code>에 맞게 바이너리 코드로 해석한 후 실행
    <ul>
      <li>소스 코드 (<code class="language-plaintext highlighter-rouge">source code</code>) : <code class="language-plaintext highlighter-rouge">Java</code> 언어로 작성된 소스 파일 (<code class="language-plaintext highlighter-rouge">*.java</code>)</li>
      <li>바이트 코드 (<code class="language-plaintext highlighter-rouge">byte code</code>) : 소스 코드를 <code class="language-plaintext highlighter-rouge">JVM</code>이 이해할 수 있는 언어로 변환한 파일 (<code class="language-plaintext highlighter-rouge">*.class</code>)</li>
      <li>바이너리 코드 (<code class="language-plaintext highlighter-rouge">binary code</code>) : 컴퓨터가 이해할 수 있는 <code class="language-plaintext highlighter-rouge">1bit</code> 크기의 <code class="language-plaintext highlighter-rouge">0</code>과 <code class="language-plaintext highlighter-rouge">1</code>로 이루어진 이진 코드</li>
    </ul>
  </li>
</ul>

<h3 id="클래스-로더-class-loader--jvm-내로-class-파일을-로드하고-이를-실행-엔진에-배치">클래스 로더 (<code class="language-plaintext highlighter-rouge">Class Loader</code>) : <code class="language-plaintext highlighter-rouge">JVM</code> 내로 <code class="language-plaintext highlighter-rouge">.class</code> 파일을 로드하고 이를 실행 엔진에 배치</h3>
<ul>
  <li>메소드 영역에 저장되는 데이터 : <code class="language-plaintext highlighter-rouge">FQCN</code> / 클래스, 인터페이스, <code class="language-plaintext highlighter-rouge">enum</code> / 메소드와 변수</li>
</ul>

<ol>
  <li>
    <h4 id="로딩-loading--jvm이-시작할-때-3개의-클래스-로더가-순서대로-동작">로딩 (<code class="language-plaintext highlighter-rouge">Loading</code>) : <code class="language-plaintext highlighter-rouge">JVM</code>이 시작할 때, 3개의 클래스 로더가 순서대로 동작</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">BootStrap ClassLoader</code> : <code class="language-plaintext highlighter-rouge">JDK</code> 클래스 파일 (코어 자바 <code class="language-plaintext highlighter-rouge">API</code>) 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">Platform ClassLoader</code> : <code class="language-plaintext highlighter-rouge">JAVA_HOME/lib/ext</code> 또는 <code class="language-plaintext highlighter-rouge">java.ext.dirs</code>에 위치한 클래스 파일 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">System ClassLoader</code> : <code class="language-plaintext highlighter-rouge">classPath</code>나 <code class="language-plaintext highlighter-rouge">modulePath</code>에 위치한 클래스 파일 로딩</li>
    </ul>
    <ul>
      <li>마지막까지 클래스를 찾지 못하면 <code class="language-plaintext highlighter-rouge">ClassFoundException</code></li>
    </ul>
  </li>
  <li>
    <h4 id="링크-linking--로드된-class-파일을-검사하고-이를-메소드-영역에-넣음">링크 (<code class="language-plaintext highlighter-rouge">Linking</code>) : 로드된 <code class="language-plaintext highlighter-rouge">.class</code> 파일을 검사하고 이를 메소드 영역에 넣음</h4>
    <ul>
      <li>검증 (<code class="language-plaintext highlighter-rouge">Verify</code>) : <code class="language-plaintext highlighter-rouge">.class</code> 파일 형식이 유효한지 검사</li>
      <li>준비 (<code class="language-plaintext highlighter-rouge">Preparation</code>) : 클래스 변수 (<code class="language-plaintext highlighter-rouge">static</code>)와 기본값에 필요한 메모리를 준비</li>
      <li>교체 (<code class="language-plaintext highlighter-rouge">Resolve</code>) : 심볼릭 메모리 래퍼런스를 메소드 영역에 있는 실제 래퍼런스로 교체</li>
    </ul>
  </li>
  <li>
    <h4 id="초기화-initialization--static-변수-또는-static-블록-내부의-값을-기본값으로-할당">초기화 (<code class="language-plaintext highlighter-rouge">Initialization</code>) : <code class="language-plaintext highlighter-rouge">static</code> 변수 또는 <code class="language-plaintext highlighter-rouge">static</code> 블록 내부의 값을 기본값으로 할당</h4>
  </li>
</ol>

<h3 id="실행-엔진-execution-engine--클래스-로더에-의해-배치된-클래스의-바이트-코드를-실행">실행 엔진 (<code class="language-plaintext highlighter-rouge">Execution Engine</code>) : 클래스 로더에 의해 배치된 클래스의 바이트 코드를 실행</h3>
<ul>
  <li>자바 인터프리터 (<code class="language-plaintext highlighter-rouge">Java Interpreter</code>) : <code class="language-plaintext highlighter-rouge">JVM</code>에서 바이트 코드를 한줄씩 명령어 단위로 읽어 번역</li>
  <li><code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러 : 인터프리터 방식으로 실행하다가, 적절한 시점에 바이트 코드 전체를 바이너리 코드로 번역해 실행</li>
  <li>가비지 콜렉터 (<code class="language-plaintext highlighter-rouge">Garbage Collector</code>) : 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제해 메모리를 관리</li>
</ul>

<h3 id="런타임-데이터-에리어-runtime-data-area--운영체제에서-프로그램-수행을-위해-할당한-메모리-공간">런타임 데이터 에리어 (<code class="language-plaintext highlighter-rouge">Runtime Data Area</code>) : 운영체제에서 프로그램 수행을 위해 할당한 메모리 공간</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">PC</code> 레지스터 (<code class="language-plaintext highlighter-rouge">PC Register</code>) : 쓰레드 (<code class="language-plaintext highlighter-rouge">Thread</code>)가 시작될 때 생성되는 공간
    <ul>
      <li>쓰레드가 현재 실행할 스택 프레임을 가리키는 포인터 생성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">JVM stack</code> : 프로그램 실행 과정에서 임시로 할당할 데이터를 저장 (메소드 호출 시 마다 각각의 스택 프레임 생성)</li>
  <li><code class="language-plaintext highlighter-rouge">Native method stack</code> : 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행</li>
  <li>힙 (<code class="language-plaintext highlighter-rouge">Heap</code>) : 모든 쓰레드가 공유하는 객체 저장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">new</code>로 생성된 객체와 배열 혹은 <code class="language-plaintext highlighter-rouge">String</code> 관련 자원이 저장 / <code class="language-plaintext highlighter-rouge">GC</code>에 의해 관리</li>
      <li><code class="language-plaintext highlighter-rouge">Permanent Generation</code> : 생성된 객체들의 정보의 주소값 저장
        <ul>
          <li>리플렉션 (<code class="language-plaintext highlighter-rouge">Reflection</code>) 으로 동적으로 클래스가 로드될 때 사용</li>
          <li>클래스 로더에 의해 로드된 클래스, 메소드 등에 대한 메타 정보가 저장 : <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 사용</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">New</code>/<code class="language-plaintext highlighter-rouge">Young</code> : 생명 주기가 짧은 객체를 <code class="language-plaintext highlighter-rouge">GC</code>의 대상으로 하는 영역 (<code class="language-plaintext highlighter-rouge">Minor GC</code> 발생)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">Eden</code> : 객체들이 처음 생성되는 공간 (첫번째 <code class="language-plaintext highlighter-rouge">GC</code>가 발생)</li>
          <li><code class="language-plaintext highlighter-rouge">Survivor 0, 1</code> : <code class="language-plaintext highlighter-rouge">Eden</code>에서 참조되는 객체들이 저장 (<code class="language-plaintext highlighter-rouge">Major GC</code> 발생 : <code class="language-plaintext highlighter-rouge">Minor GC</code>에 비해 느림)</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">Old</code> : 생명 주기가 긴 객체를 <code class="language-plaintext highlighter-rouge">GC</code>의 대상으로 하는 영역
        <ul>
          <li><code class="language-plaintext highlighter-rouge">New</code>/<code class="language-plaintext highlighter-rouge">Young</code>에서 일정 시간 참조되고 있는 객체들이 저장</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>메소드 영역 (<code class="language-plaintext highlighter-rouge">Method Area</code>) : 클래스를 메모리에 처음 올릴 때 초기화하는 클래스 이름, <code class="language-plaintext highlighter-rouge">static</code> 메소드나 변수 저장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime Constant Pool</code> : 상수 자료형을 저장해 참조 (중복 방지)</li>
    </ul>
  </li>
</ul>

<h3 id="자바-네이티브-인터페이스-java-native-interface--자바-네이티브-코드로-작성된-함수-사용-방법-제공">자바 네이티브 인터페이스 (<code class="language-plaintext highlighter-rouge">Java Native Interface</code>) : 자바 네이티브 코드로 작성된 함수 사용 방법 제공</h3>
<ul>
  <li>자바 네이티브 코드 (<code class="language-plaintext highlighter-rouge">Java Native Code</code>) : 다른 언어로 작성된 라이브러리를 <code class="language-plaintext highlighter-rouge">JVM</code> 내에서 호출하는 코드</li>
  <li>네이티브 메소드 라이브러리 (<code class="language-plaintext highlighter-rouge">Native Method Library</code>) : 네이티브 실행 프로그램을 만들 때 사용되는 라이브러리</li>
</ul>

<h2 id="변수-variable--데이터를-저장하는-공간">변수 (<code class="language-plaintext highlighter-rouge">variable</code>) : 데이터를 저장하는 공간</h2>
<ul>
  <li>원시 자료형 (<code class="language-plaintext highlighter-rouge">Primitive type</code>) : 선언 시 메모리 주소 위치 (<code class="language-plaintext highlighter-rouge">JVM stack</code>)에 실제 값이 저장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">boolean</code> : <code class="language-plaintext highlighter-rouge">true</code> / <code class="language-plaintext highlighter-rouge">false</code> (초기값 : <code class="language-plaintext highlighter-rouge">false</code>)</li>
      <li>문자 (<code class="language-plaintext highlighter-rouge">char</code>) : <code class="language-plaintext highlighter-rouge">''</code>를 이용해 표시 (초기값 : <code class="language-plaintext highlighter-rouge">'\0'</code>=<code class="language-plaintext highlighter-rouge">0</code>)</li>
      <li>바이트 (<code class="language-plaintext highlighter-rouge">byte</code>) : 데이터를 나타내는 바이트 값 (초기값 : <code class="language-plaintext highlighter-rouge">0</code>)</li>
      <li>정수 (<code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>) : <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>바이트 크기 내의 정수 (초기값 : <code class="language-plaintext highlighter-rouge">0</code>)</li>
      <li>실수 (<code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>) : <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>바이트 크기 내의 실수 (초기값 : <code class="language-plaintext highlighter-rouge">0.0</code>)</li>
    </ul>
  </li>
  <li>래퍼런스 자료형 (<code class="language-plaintext highlighter-rouge">Reference type</code>) : 선언 시 메모리 주소 위치에 실제 값이 가리키는 다른 주소를 저장
    <ul>
      <li>실제 값은 <code class="language-plaintext highlighter-rouge">Heap</code>에 저장</li>
      <li>배열, 클래스, 인터페이스에 대한 래퍼런스</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자바는 주소값의 추상화를 금지함, <code class="language-plaintext highlighter-rouge">Call by value</code>만 가능 (<code class="language-plaintext highlighter-rouge">C/C++</code> : 주소값 저장 (<code class="language-plaintext highlighter-rouge">*</code>) 및 추출 (<code class="language-plaintext highlighter-rouge">&amp;</code>) 가능)</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">var</code> : 데이터 타입을 명시하지 않아도 지역 변수의 타입을 자동으로 추론하는 키워드
    <ul>
      <li>지역 변수만 사용 가능 (<code class="language-plaintext highlighter-rouge">static</code> 적용 불가)</li>
      <li>선언과 함께 명시적인 초기화를 반드시 해야 함</li>
      <li><code class="language-plaintext highlighter-rouge">NULL</code>로 초기화할 수 없음</li>
      <li>람다 표현식과 같이 사용할 수 없음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var s = 'String';
var n = 100;
</code></pre></div></div>

<h3 id="변수의-스코프-scope--변수가-유효한-범위">변수의 스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수가 유효한 범위</h3>
<ul>
  <li>접근 지정자 (<code class="language-plaintext highlighter-rouge">access modifier</code>) : 접근 가능한 수준 지정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code> : 어느 클래스에서든 해당 클래스에 대해 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">protected</code> : 해당 패키지와 같은 패키지 내에 있는 클래스와 상속받은 클래스가 해당 클래스에 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">default</code> : 해당 클래스와 같은 패키지 내에 있는 클래스만이 해당 클래스에 대해 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">private</code> : 해당 클래스 및 그 클래스를 포함한 클래스만이 해당 클래스에 대해 접근 가능</li>
    </ul>
  </li>
</ul>

<h3 id="변수의-라이프타임-lifetime--변수가-메모리-영역에-저장되어-있는-시간">변수의 라이프타임 (<code class="language-plaintext highlighter-rouge">LifeTime</code>) : 변수가 메모리 영역에 저장되어 있는 시간</h3>
<ul>
  <li>인스턴스 변수 (<code class="language-plaintext highlighter-rouge">static block</code>과 <code class="language-plaintext highlighter-rouge">static method</code>를 제외한 클래스 전체) : 객체가 생성되어 메모리에 존재하는 동안</li>
  <li>클래스 변수 (클래스 전체) : 클래스가 초기화되고 프로그램이 끝날 때까지</li>
  <li>로컬 변수 (변수가 선언된 블록의 내부) : 변수 선언 이후부터 블록을 벗어날 때까지</li>
</ul>

<h3 id="변수의-형변환-type-conversion--현재의-타입을-다른-타입올-바꾸는-것">변수의 형변환 (<code class="language-plaintext highlighter-rouge">Type Conversion</code>) : 현재의 타입을 다른 타입올 바꾸는 것</h3>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">boolean</code>을 제외한 나머지 기본 자료형 간의 타입 변환이 가능</p>
</blockquote>

<ul>
  <li>타입 프로모션 (<code class="language-plaintext highlighter-rouge">Type Promotion</code>) : 범위가 작은 데이터 타입의 값을 더 큰 범위의 데이터 타입에 할당 (묵시적 형변환)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">byte</code> &lt; <code class="language-plaintext highlighter-rouge">short</code> &lt; <code class="language-plaintext highlighter-rouge">int</code> &lt; <code class="language-plaintext highlighter-rouge">long</code> &lt; <code class="language-plaintext highlighter-rouge">float</code> &lt; <code class="language-plaintext highlighter-rouge">double</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int intN = 23;
long longN = intN;
</code></pre></div></div>

<ul>
  <li>캐스팅 (<code class="language-plaintext highlighter-rouge">Casting</code>) : 범위가 큰 데이터 타입의 값을 더 작은 범위의 데이터 타입으로 할당 (명시적 형변환)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int n = 100;
c = (char) n;
</code></pre></div></div>

<ul>
  <li>업캐스팅 (<code class="language-plaintext highlighter-rouge">Up-Casting</code>) : 부모-자식 관계의 객체에서 자식 객체를 부모 객체로 형변환 (묵시적 형변환)</li>
  <li>다운캐스팅 (<code class="language-plaintext highlighter-rouge">Down-Casting</code>) : 부모-자식 관계의 객체에서 부모 객체를 자식 객체로 형변환 (명시적 형변환)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass {
  String name;
  String ID;

  public MyClass(String name){
    this.name = name;
  }
}

class StudentClass extends MyClass {
  String grade;

  public StudentClass(String name){
    super(name);
  }
}

public class UpClass {
  public Static void main(String[] args){
    MyClass P;
    StudentClass S = new StudentClass("I");
    
    P = S; // 업캐스팅 발생

    System.out.println(P.name); // 컴파일 오류 없음

    S = (StudentClass) P;   // 다운캐스팅 발생

    System.out.println(S.name); // 컴파일 오류 없음
  }
}
</code></pre></div></div>

<h2 id="배열-array--인덱스-index와-그-인덱스에-대응하는-데이터들로-이루어진-선형-자료구조">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 인덱스 (<code class="language-plaintext highlighter-rouge">Index</code>)와 그 인덱스에 대응하는 데이터들로 이루어진 선형 자료구조</h2>
<ul>
  <li>배열의 생성 : 배열 공간을 할당받는 과정 (배열에 대한 래퍼런스 변수 선언 + 배열 생성)
    <ul>
      <li>래퍼런스 변수 : 메모리 상에 생성된 인스턴스를 가리키는 데에 사용되는 변수 (배열의 주소 값을 가짐)</li>
      <li><code class="language-plaintext highlighter-rouge">new</code> : 클래스의 새로운 객체를 생성할 때, 객체를 저장할 메모리를 할당하고 생성자를 호출해 객체를 초기화</li>
      <li><code class="language-plaintext highlighter-rouge">=</code> : 스택의 래퍼런스 변수가 힙의 배열 데이터를 가리킴</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] intArray;
intArray = new int [10];
int[] intArray = new int [10];
int[] intArray = {1,2,3,4,5,6,7,8,9};
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[][] intArray2;
int intArray2 = new int[2][3];
int intArray2 = { {1, 2, 3}, {4, 5, 6} };
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.length</code> 필드 : 배열이 가진 길이 (원소의 개수)를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len = intArray.length
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len1 = intArray2.length     // 2차원 배열이 가진 행의 개수
len2 = intArray2[n].length  // 2차원 배열 중 n번째 행이 가진 열의 개수
</code></pre></div></div>

<ul>
  <li>비정방형 배열 : 행마다 열의 개수가 서로 다른 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[][] intArray3 = new int[3][];
intArray3[0] = new int[1];
intArray3[1] = new int[2];
intArray3[2] = new int[3];
int intArray3 = { {0}, {1,2}, {3,4,5} };
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int intArray3[][] = { {0}, {1,2}, {3,4,5} };
</code></pre></div></div>

<ul>
  <li>메소드의 배열 반환 : 실제 배열에 대한 래퍼런스가 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int makeArray() {
    int t = new int[4];
    return t;
}

int[] intArr = makeArray();
</code></pre></div></div>

<ul>
  <li>객체 배열 : 객체에 대한 래퍼런스를 원소로 갖는 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person[] people = new Person[20];

for(int i = 0; i &lt; people.length; i++){
    people[i] = new Person();
    people[i].age = 20 + i;
}
</code></pre></div></div>

<h2 id="객체-object--프로그램에서-사용되는-데이터-혹은-식별자에-의해-참조되는-공간">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 프로그램에서 사용되는 데이터 혹은 식별자에 의해 참조되는 공간</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">new</code> : 객체를 생성하는 연산자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = new Person("A");
P.age = 30;
</code></pre></div></div>

<ul>
  <li>생성자 : 객체가 생성될 때 자동으로 호출되는 메소드 (객체에 필요한 초기화 수행)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">this</code> : 객체 자신을 참조</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass {
    int id;

    public MyClass (int x) { // 생성자는 클래스 이름과 동일한 이름을 가짐
        this.id = x;
    }

    public void MyFunc (int id) {
        this.id = id;
    } 
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this()</code> : 동일한 클래스 내의 다른 생성자를 호출할 때 사용 (반드시 생성자의 첫 문장에서 사용되어야 함)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public MyClass {
    String title;
    int price;
    int id = 0;

    public MyClass(String title, int price, int id) {
        this.title = title;
        this.price = price;
        this.id = id;
        id += 1;
    }

    public MyClass(String title, int price, int id) {
        this.title = title;
        this.price = price;
        this.id = id;
        id += 1;
    }

    public MyClass(String title, int price) {
        this(title, price, id);
        id += 1;
    }

    public static void main(String[] args) {
        MyClass mart1 = new MyClass("apple", 100, 1);
        MyClass mart2 = new MyClass("banana", 200);
    }
}
</code></pre></div></div>

<ul>
  <li>가비지 컬렉션 (<code class="language-plaintext highlighter-rouge">garbage Collection</code>) : <code class="language-plaintext highlighter-rouge">new</code>로 할당받고 사용하지 않는 객체의 메모리 공간을 자동으로 <code class="language-plaintext highlighter-rouge">JVM</code>에 반환
    <ul>
      <li>소멸자 (<code class="language-plaintext highlighter-rouge">delete</code>)로 객체의 소멸을 명시해야 하는 <code class="language-plaintext highlighter-rouge">C++</code>과 달리, 자바는 소멸자가 필요 없음</li>
    </ul>
  </li>
</ul>

<h2 id="클래스-class--객체를-생성하기-위해-변수와-메소드를-정의하는-틀">클래스 (<code class="language-plaintext highlighter-rouge">Class</code>) : 객체를 생성하기 위해 변수와 메소드를 정의하는 틀</h2>
<ul>
  <li>필드 (<code class="language-plaintext highlighter-rouge">Field</code>) : 객체의 상태 혹은 속성 (인스턴스 변수, <code class="language-plaintext highlighter-rouge">static</code> 변수)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    String name;
    static long id;
}
</code></pre></div></div>

<ul>
  <li>메소드 (<code class="language-plaintext highlighter-rouge">method</code>) : 객체의 행동 (인스턴스 메소드, <code class="language-plaintext highlighter-rouge">static</code> 메소드)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    long id;

    string getName() {
        return name;
    }
    
    long getID() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }

    void setID(long id) {
        this.id = id;
    }
}
</code></pre></div></div>

<ul>
  <li>생성자 (<code class="language-plaintext highlighter-rouge">Constructor</code>) : 객체를 생성한 후에 필요한 초기화 작업을 수행하는 메소드</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    long id;

    MyClass(String name, long id) {
        this.name = name;
        this.id = id;
    }
}
</code></pre></div></div>

<ul>
  <li>초기화 블럭 (<code class="language-plaintext highlighter-rouge">Initializer</code>) : 객체를 생성한 후에 필요한 초기화 작업을 세분화
    <ul>
      <li>클래스 초기화 블럭 : 클래스가 최초로 로딩될 때</li>
      <li>인스턴스 초기화 블럭 : 인스턴스가 생성되었을 때</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    static long id;
        // 클래스 초기화 블럭
    static {
        id = 1;
    }
        // 인스턴스 초기화 블럭
    {
        name = "이름";
        id += 1;
    }
}
</code></pre></div></div>

<blockquote>
  <p>캡슐화 (<code class="language-plaintext highlighter-rouge">Encapsulation</code>) : 변수나 메소드는 반드시 클래스 내에서만 구현 가능 / 클래스 안의 내부 클래스 구현 가능</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class (클래스 이름) {
    public static void main(String[] args {
        ...
    }

    class (내부 클래스 1 이름) {
        ...
    }

    static class (내부 클래스 2 이름) {
        ...
    }

    void (내부 함수 이름)() {
        ...
    }

   ...
}
</code></pre></div>  </div>

  <p>상속 (<code class="language-plaintext highlighter-rouge">Inheritance</code>) : 부모 클래스에 정의된 필드와 메소드를 자식 클래스가 물려받는 것</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Person {
   Person() { ... }
...
}
public class Student extends Person {
  super(); // 부모 클래스의 생성자를 호출
  ...
}
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">instanceof</code> : 객체의 타입을 검사하는 연산자 (상속 관계 &amp; 구현 관계 모두 포함)</p>

  <p>```
class Lee extends Student implements Person { … }</p>

  <p>Lee lee = new Lee();
assertThat(lee instanceof Lee).isTrue();
assertThat(lee instanceof Student).isTrue();
assertThat(lee instanceof Animal).isTrue();
assertThat(lee instanceof Person).isTrue();</p>
</blockquote>

<blockquote>
  <p>```</p>
</blockquote>

<h3 id="main--해당-클래스를-자바-어플리케이션에서-실행하는-메소드"><code class="language-plaintext highlighter-rouge">main()</code> : 해당 클래스를 자바 어플리케이션에서 실행하는 메소드</h3>
<ul>
  <li>접근 제어자 <code class="language-plaintext highlighter-rouge">public</code>  : 다른 모든 클래스에서 호출 가능 (클래스 외부의 <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 호출되어야 하므로)</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> : 프로그램 시작부터 메모리에 저장됨 (프로그램이 시작할 때부터 <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 호출되어야 하므로)</li>
  <li><code class="language-plaintext highlighter-rouge">void</code> : 종료 코드를 등록하기 위해 <code class="language-plaintext highlighter-rouge">int</code>를 반환해야 하는 ```C``와 달리, 종료 코드를 등록할 필요 없음</li>
  <li><code class="language-plaintext highlighter-rouge">String[] args</code> : 명령줄에 주어진 모든 인자를 문자열로 처리해 <code class="language-plaintext highlighter-rouge">main()</code>에 전달</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class (클래스 이름) {
    public static void main(String[] args {
        ...
    }
}
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">static</code> : 모든 객체에 공통으로 사용하기 위해 정적으로 선언 (프로그램 시작부터 메모리에 저장)</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">static</code> 메소드는 <code class="language-plaintext highlighter-rouge">static</code> 멤버만 사용할 수 있고, <code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용할 수 없음</li>
  </ul>
</blockquote>

<h3 id="final--오직-한-번만-할당할-수-있어-항상-같은-값을-가지는-entity를-정의할-때-사용하는-키워드"><code class="language-plaintext highlighter-rouge">final</code> : 오직 한 번만 할당할 수 있어 항상 같은 값을 가지는 <code class="language-plaintext highlighter-rouge">entity</code>를 정의할 때 사용하는 키워드</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 클래스 : 클래스가 상속받을 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class MyClass { ... }
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 메소드 : 오버라이딩으로 수정할 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class MySuperClass { 
    protected final void MyFunc() { ... }
}
public final class MyClass extends MySuperClass { 
    protected final void MyFunc() { ... } // 컴파일 오류
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 변수 : 한번 값을 할당하면 수정할 수 없는 상수 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static float Pl = 3.141592;
</code></pre></div></div>

<h2 id="어노테이션-annotation--컴파일--실행-과정에서-코드를-어떻게-처리할지-알리는-메타데이터">어노테이션 (<code class="language-plaintext highlighter-rouge">Annotation</code>) : 컴파일 &amp; 실행 과정에서 코드를 어떻게 처리할지 알리는 메타데이터</h2>
<ul>
  <li>클래스나 메소드 위에 붙으며, <code class="language-plaintext highlighter-rouge">@</code>로 시작 : 어노테이션의 유무나 어노테이션에 설정한 값을 통해 클래스를 다르게 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Override // 메소드를 오버라이딩 (상속받은 부모 클래스나 인터페이스에서 해당 메소드가 없으면 컴파일 오류)
</code></pre></div></div>

<h2 id="자바-모듈-java-module--클래스-jar-패키지-수준의-코드-그룹화-제공">자바 모듈 (<code class="language-plaintext highlighter-rouge">Java Module</code>) : 클래스, <code class="language-plaintext highlighter-rouge">JAR</code>, 패키지 수준의 코드 그룹화 제공</h2>
<ul>
  <li>하나의 자바 어플리케이션은 하나 이상의 <code class="language-plaintext highlighter-rouge">.class</code> 파일로 구성</li>
  <li>다수의 클래스 파일을 <code class="language-plaintext highlighter-rouge">.jar</code> 파일로 압축해 배포 및 실행 가능</li>
  <li>서로 관련 있는 클래스들은 하나의 패키지로 묶어서 관리</li>
</ul>

<h2 id="jdk의-scanner-클래스--자바의-키-입력-key-input"><code class="language-plaintext highlighter-rouge">JDK</code>의 <code class="language-plaintext highlighter-rouge">Scanner</code> 클래스 : 자바의 키 입력 (<code class="language-plaintext highlighter-rouge">Key input</code>)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">String next()</code> : 문자열 타입으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">Byte nextByte()</code> : 바이트 타입으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">short nextShort()</code>, <code class="language-plaintext highlighter-rouge">int nextInt()</code>, <code class="language-plaintext highlighter-rouge">long nextLong()</code> : 정수 타입 (<code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>)으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">float nextFloat()</code>, <code class="language-plaintext highlighter-rouge">double nextDouble()</code> : 실수 타입 (<code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>)으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">String nextLine()</code> : 한 줄 전체 (<code class="language-plaintext highlighter-rouge">\n</code>)를 일고 문자열 타입으로 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.Scanner;
Scanner scan = new Scanner(System.in);
String name = scan.nextLine();
</code></pre></div></div>

<blockquote>
  <p>자바 표준 입력 스트림 <code class="language-plaintext highlighter-rouge">system.in</code> : 입력되는 키 값을 바이트 정보로 반환 (문자 정보로 변환)</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>InputSteamReader rd = new InputSteamReader(System.in); // 키보드 입력 스트림 생성
int s = rd.read(); // 키보드로부터 문자 하나를 읽고 이를 s에 저장
</code></pre></div>  </div>
</blockquote>

<h2 id="예외-처리-exception-handling--발생한-예외에-대해-작성한-프로그램-내에서-대응하는-것">예외 처리 (<code class="language-plaintext highlighter-rouge">Exception handling</code>) : 발생한 예외에 대해 작성한 프로그램 내에서 대응하는 것</h2>
<ul>
  <li>예외 (<code class="language-plaintext highlighter-rouge">Exception</code>) : 프로그램 실행 중에 발생하는 런타임 오류 (<code class="language-plaintext highlighter-rouge">Runtime error</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Checked Exception</code> : 컴파일러에 의해 예외 발생을 인지 (컴파일 오류)</li>
      <li><code class="language-plaintext highlighter-rouge">Unchecked Exception</code> : <code class="language-plaintext highlighter-rouge">JVM</code>에서 예외 발생을 인지 (예외 객체 생성 후 처리)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자바에서 자주 발생하는 예외</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">NullPointerException</code> : <code class="language-plaintext highlighter-rouge">Null</code> 래퍼런스를 참조할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">ClassCastException</code> : 변환할 수 없는 타입응로 객체를 변환할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">IOException</code> : 입출력 동작 중에 인터럽트가 발생할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">NumberFormatException</code> : 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> : 잘못된 인자를 전달할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">ArrayIndexOutOfBoundsException</code> : 배열의 범위를 벗어나 접근할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">NoSuchMethodException</code> : 런타임 시점에 존재하지 않는 메소드를 호출할 때 발생</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">try-catch-finally</code> : 발생한 예외에 대한 예외처리를 하는 구문
    <ul>
      <li><code class="language-plaintext highlighter-rouge">try</code> : 오류가 발생할 것으로 예상되는 부분</li>
      <li><code class="language-plaintext highlighter-rouge">catch</code> : 발생할 오류에 관련된 예외에 대해 대응할 부분</li>
      <li><code class="language-plaintext highlighter-rouge">finally</code> : 예외 발생 여부에 상관없이 반드시 실행되어야 하는 부분</li>
      <li><code class="language-plaintext highlighter-rouge">throws</code>: 예외 처리의 의무를 현재 예외가 발생한 메소드에서 그 메소드를 호출한 메소드로 전달</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void funcA() {
    try {
        ...
    } catch (Exception e) { // 예외가 발생할 때 생성된 예외 객체와 타입이 일치하면, 래퍼런스 변수가 생성된 예외 객체를 가리킴
        ...
    } finally {
        ...
    }
}

public void funcB() throws Exception { // throws로 예외 처리를 Exception로 전달
    ...
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Java" /><summary type="html"><![CDATA[Java : 객체지향 프로그래밍 언어 (Object-Oriented Programming Language)]]></summary></entry><entry><title type="html">[System Design Interview] 1. 사용자 수에 따른 규모 확장성</title><link href="http://localhost:4000/system_design_interview1/" rel="alternate" type="text/html" title="[System Design Interview] 1. 사용자 수에 따른 규모 확장성" /><published>2024-01-12T00:00:00+09:00</published><updated>2024-01-12T00:00:00+09:00</updated><id>http://localhost:4000/system_design_interview1</id><content type="html" xml:base="http://localhost:4000/system_design_interview1/"><![CDATA[<h2 id="시스템-디자인-면접-system-design-interview--시스템-아키텍처를-설계하는-면접">시스템 디자인 면접 (<code class="language-plaintext highlighter-rouge">System Design Interview</code>) : 시스템 아키텍처를 설계하는 면접</h2>

<ul>
  <li>질문 범위도 매우 크고 모호하며, 답변 절차 또한 정형화되어 있지 않음
    <ul>
      <li>시스템에 따른 변이 (<code class="language-plaintext highlighter-rouge">variation</code>)이 많음
        <ul>
          <li>의사소통 및 문제 해결 능력이 소프트웨어 엔지니어의 필요 능력과 비슷함</li>
          <li>지원자들은 그 모호한 문제를 어떻게 분석하고 단계적으로 해결하는지를 확인
            <ul>
              <li>문제 해결 아이디어를 어떻게 설명하고 토론하는지?</li>
              <li>문제 해결 아이디어를 어떻게 평가하고 개선하는지?</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="사용자-수에-따른-규모-확장성--사용자가-얼마나-되는지에-따라-변화하는-시스템-설계">사용자 수에 따른 규모 확장성 : 사용자가 얼마나 되는지에 따라 변화하는 시스템 설계</h2>

<h3 id="단일-서버--모든-컴포넌트가-단-한-대의-서버에서-실행되는-시스템을-설계">단일 서버 : 모든 컴포넌트가 단 한 대의 서버에서 실행되는 시스템을 설계</h3>

<ul>
  <li>웹, 어플리케이션, 데이터베이스, 캐시 모두가 하나의 서버에서 실행</li>
</ul>

<blockquote>
  <p>단일 서버에서 사용자의 요청이 처리되는 과정</p>

  <ol>
    <li>사용자는 도메인 네임을 이용해 웹 사이트에 접속한다.
      <ol>
        <li>도메인 네임을 <code class="language-plaintext highlighter-rouge">DNS</code> (<code class="language-plaintext highlighter-rouge">Domain Name Service</code>)에 질의한다.</li>
        <li><code class="language-plaintext highlighter-rouge">DNS</code> 조회 결과로 <code class="language-plaintext highlighter-rouge">IP</code> 주소 (웹 서버의 주소)가 반환된다.</li>
      </ol>
    </li>
    <li>해당 <code class="language-plaintext highlighter-rouge">IP</code> 주소로 <code class="language-plaintext highlighter-rouge">HTTP</code> 요청이 전달된다.</li>
    <li>요청을 받은 웹 서버는 <code class="language-plaintext highlighter-rouge">HTML</code> 페이지나 <code class="language-plaintext highlighter-rouge">JSON</code> 형태의 응답을 반환한다.</li>
  </ol>
</blockquote>

<ul>
  <li>그렇다면 실제 요청은 어디에서 오는가?
    <ol>
      <li>웹 어플리케이션인 경우?
        <ol>
          <li>비즈니스 로직의 구현과 데이터 저장의 처리를 위한 서버 구현</li>
          <li>사용자에게 표현하기 위한 클라이언트 구현</li>
        </ol>
      </li>
      <li>모바일 앱인 경우?
        <ol>
          <li>모바일 앱과 웹 서버 간의 통신에는 <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 이용</li>
          <li><code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 통해 반환될 응답 데이터의 포맷으로 <code class="language-plaintext highlighter-rouge">JSON</code>을 사용</li>
        </ol>
      </li>
    </ol>
  </li>
</ul>

<h3 id="데이터베이스-서버--트래픽을-처리할-서버-웹-계층에-db-서버-데이터-계층을-증설">데이터베이스 서버 : 트래픽을 처리할 서버 (웹 계층)에 DB 서버 (데이터 계층)을 증설</h3>

<ul>
  <li>어떤 데이터베이스를 사용할 것인가?
    <ol>
      <li>관계형 데이터베이스를 선택할 경우?
        <ul>
          <li>관계형 데이터베이스 관리 시스템 (<code class="language-plaintext highlighter-rouge">RDBMS</code>) : <code class="language-plaintext highlighter-rouge">MySQL</code>, …</li>
          <li>자료를 테이블, 열, 칼럼으로 표현</li>
          <li>여러 테이블에 있는 데이터를 그 관계에 따라 조인 (<code class="language-plaintext highlighter-rouge">join</code>)</li>
        </ul>
      </li>
      <li>비관계형 데이터베이스 (<code class="language-plaintext highlighter-rouge">NoSQL</code>)를 선택할 경우?
        <ul>
          <li>저장소 : 키-값 (<code class="language-plaintext highlighter-rouge">key-value</code>), 그래프 (<code class="language-plaintext highlighter-rouge">graph</code>), 칼럼 (<code class="language-plaintext highlighter-rouge">column</code>), 문서 (<code class="language-plaintext highlighter-rouge">document</code>)</li>
        </ul>
      </li>
      <li>비관계형 데이터베이스가 최선인 경우는 언제?
        <ul>
          <li>아주 낮은 지연 시간 (<code class="language-plaintext highlighter-rouge">latency</code>)이 요구됨</li>
          <li>다루는 데이터가 비정형 (<code class="language-plaintext highlighter-rouge">unstructured</code>) 데이터임</li>
          <li><code class="language-plaintext highlighter-rouge">JSON</code> 등 데이터를 직렬화 (<code class="language-plaintext highlighter-rouge">serialize</code>)하거나 역직렬화할 수 있기만 하면 됨</li>
          <li>아주 많은 양의 데이터를 저장해야 함</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="수직적-규모-확장-vs-수평적-규모-확장">수직적 규모 확장 vs 수평적 규모 확장?</h3>

<ul>
  <li>수직적 확장 (<code class="language-plaintext highlighter-rouge">scale-up</code>) : 서버에 고사양 자원을 추가
    <ul>
      <li>서버로 유입되는 트래픽의 양이 적을 때 최선</li>
      <li>단순하지만, 한계가 명확함 : 하나의 서버에 <code class="language-plaintext highlighter-rouge">CPU</code>나 메모리를 무한대로 증설할 수 없음</li>
      <li>장애에 대한 자동 복구 (<code class="language-plaintext highlighter-rouge">failover</code>)이나 다중화 (<code class="language-plaintext highlighter-rouge">re-dundancy</code>) 방안을 제시하지 않음
        <ul>
          <li>서버에 장애가 발생하면, 어플리케이션이 그대로 중단된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>수평적 확장 (<code class="language-plaintext highlighter-rouge">scale-out</code>) : 더 많은 서버를 추가하여 성능을 개선
    <ul>
      <li>로드밸런서 (<code class="language-plaintext highlighter-rouge">Load balancer</code>) : 부하 분산 집합 내의 웹 서버들에게 트래픽 부하를 분산
        <ul>
          <li>로드밸런서의 공개 <code class="language-plaintext highlighter-rouge">IP</code>로 접속 : 웹 서버가 클라이언트의 접속을 직접 처리하지 않음</li>
          <li>같은 네트워크 내의 서버 간 통신에는 사설 <code class="language-plaintext highlighter-rouge">IP</code> 주소 사용</li>
          <li>장애를 자동으로 복구하지 못하는 문제 (<code class="language-plaintext highlighter-rouge">no failover</code>) 해소
            <ul>
              <li>서버 <code class="language-plaintext highlighter-rouge">a</code>가 오프라인으로 상태가 변경되어도 모든 트래픽이 서버 b로 전송</li>
            </ul>
          </li>
          <li>웹 계층의 가용성 (<code class="language-plaintext highlighter-rouge">availability</code>) 향상
            <ul>
              <li>로드밸런서를 통해 트래픽을 자동적으로 분산 가능</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>데이터베이스 다중화 : 원본은 <code class="language-plaintext highlighter-rouge">master</code> 서버에, 사본은 <code class="language-plaintext highlighter-rouge">slave</code> 서버에 저장
        <ul>
          <li>쓰기 연산 (<code class="language-plaintext highlighter-rouge">write</code>)과 <code class="language-plaintext highlighter-rouge">DB</code>를 변경하는 명령어의 입력은 <code class="language-plaintext highlighter-rouge">master</code> 서버에서만 가능</li>
          <li><code class="language-plaintext highlighter-rouge">slave</code> 서버는 <code class="language-plaintext highlighter-rouge">master</code> 서버에서 사본을 전달받아, 읽기 연산 (<code class="language-plaintext highlighter-rouge">read</code>)만을 지원
            <ul>
              <li>성능 향상 : 다중화 모델을 통해 병렬로 처리될 수 있는 질의 (<code class="language-plaintext highlighter-rouge">query</code>)의 수 증가</li>
              <li>안정성 (<code class="language-plaintext highlighter-rouge">reliability</code>) : 다중화된 <code class="language-plaintext highlighter-rouge">DB</code>를 여러 곳에 분산 가능</li>
              <li>가용성 (<code class="language-plaintext highlighter-rouge">availability</code>) : 어떤 <code class="language-plaintext highlighter-rouge">DB</code> 서버에 장애가 발생해도 서비스 지속 가능</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">DB</code> 서버 하나가 오프라인 상태가 된다면?
            <ul>
              <li>1대뿐인 <code class="language-plaintext highlighter-rouge">slave</code> 서버가 오프라인 상태인 경우?
                <ul>
                  <li>읽기 연산이 한시적으로 모두 <code class="language-plaintext highlighter-rouge">master</code> 서버로 전달</li>
                </ul>
              </li>
              <li>여러 대의 <code class="language-plaintext highlighter-rouge">slave</code> 서버 중 하나가 오프라인 상태인 경우?
                <ul>
                  <li>읽기 연산이 나머지 <code class="language-plaintext highlighter-rouge">slave</code> 서버로 분산</li>
                </ul>
              </li>
              <li>1대뿐인 <code class="language-plaintext highlighter-rouge">slave</code> 서버를 가진 <code class="language-plaintext highlighter-rouge">master</code> 서버가 오프라인 상태인 경우?
                <ul>
                  <li>해당 <code class="language-plaintext highlighter-rouge">slave</code> 서버가 <code class="language-plaintext highlighter-rouge">master</code> 서버가 돠어 모든 <code class="language-plaintext highlighter-rouge">DB</code> 연산 수행</li>
                  <li>프로덕션 (<code class="language-plaintext highlighter-rouge">production</code>) 환경 : <code class="language-plaintext highlighter-rouge">slave</code> 서버의 데이터가 최신이 아닐 수도 있음
                    <ul>
                      <li>복구 스크립트 (<code class="language-plaintext highlighter-rouge">recovery script</code>)를 통한 추가</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>로드밸런서와 데이터베이스 다중화를 고려한 설계
    <ul>
      <li>사용자는 DNS로부터 로드밸런서의 공개 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 받는다.</li>
      <li>사용자는 해당 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 사용해 로드밸런서에 접속한다.</li>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code> 요청은 서버 1이나 서버 2로 전달된다.</li>
      <li>웹 서버는 사용자의 데이터를 <code class="language-plaintext highlighter-rouge">slave</code> 데이터베이스에서 읽는다.</li>
      <li>웹 서버는 데이터 변경 연산을 <code class="language-plaintext highlighter-rouge">master</code> 데이터베이스로 전달한다.</li>
    </ul>
  </li>
</ul>

<h4 id="캐시-cache--응답-시간-latency-개선을-위해-데이터를-잠시-보관">캐시 (<code class="language-plaintext highlighter-rouge">Cache</code>) : 응답 시간 (<code class="language-plaintext highlighter-rouge">latency</code>) 개선을 위해 데이터를 잠시 보관</h4>

<ul>
  <li>캐시 계층 : 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 보관
    <ul>
      <li>주도형 캐시 전략 (<code class="language-plaintext highlighter-rouge">read-through caching strategy</code>)
        <ol>
          <li>만약 데이터가 캐시에 있다면, 캐시에서 데이터를 읽음
            <ul>
              <li>데이터가 캐시에 없다면, <code class="language-plaintext highlighter-rouge">DB</code>에서 해당 데이터를 읽어 캐시에 씀</li>
            </ul>
          </li>
          <li>캐시에서 웹 서버로 데이터를 반환함</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>캐시를 사용할 때 고려해야 할 점?
    <ul>
      <li>캐시는 어떤 상황에 바람직한가? : 갱신이 드물지만, 참조가 빈번한 데이터</li>
      <li>어떤 데이터를 캐시에 저장? : 영속적이지 않은 데이터</li>
      <li>캐시 내의 데이터는 어떻게 만료 (<code class="language-plaintext highlighter-rouge">expire</code>)할까? : 캐시에서 정책에 따라 삭제</li>
      <li>일관성 (<code class="language-plaintext highlighter-rouge">consistency</code>)는 어떻게 유지할까? : 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션으로 처리되어야</li>
      <li>장애에는 어떻게 대처할까? : 단일 장애 지점의 발생을 피해 캐시 서버를 분산</li>
      <li>캐시 메모리의 크기는? : 캐시 메모리를 과할당 (<code class="language-plaintext highlighter-rouge">over-provision</code>)</li>
      <li>데이터 방출 (<code class="language-plaintext highlighter-rouge">eviction</code>) 정책은? : <code class="language-plaintext highlighter-rouge">LRU</code>, <code class="language-plaintext highlighter-rouge">LFU</code> 등을 경우에 맞게 적용</li>
    </ul>
  </li>
</ul>

<h4 id="컨텐츠-전송-네트워크-cdn--정적-컨텐츠의-전송에-쓰이는-분산-서버-네트워크">컨텐츠 전송 네트워크 (<code class="language-plaintext highlighter-rouge">CDN</code>) : 정적 컨텐츠의 전송에 쓰이는 분산 서버 네트워크</h4>
<ul>
  <li>정적 컨텐츠 (이미지, 비디오, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">JavaScript</code> 파일 등)을 캐시</li>
  <li>사용자가 웹 사이트에 방문하면, 가장 가까운 <code class="language-plaintext highlighter-rouge">CDN</code> 서버가 정적 컨텐츠를 전달</li>
</ul>

<blockquote>
  <ol>
    <li>사용자가 이미지 <code class="language-plaintext highlighter-rouge">URL</code>를 통해 <code class="language-plaintext highlighter-rouge">image.png</code>에 접근한다.
      <ul>
        <li><code class="language-plaintext highlighter-rouge">URL</code>의 도메인은 <code class="language-plaintext highlighter-rouge">CDN</code> 서비스 사업자가 제공</li>
      </ul>
    </li>
    <li><code class="language-plaintext highlighter-rouge">CDN</code> 서버의 캐시에 해당 이미지가 없으면 원본 서버에서 파일을 요청
      <ul>
        <li>원본 서버가 파일을 반환할 때, 응답 <code class="language-plaintext highlighter-rouge">HTTP</code> 헤더는 <code class="language-plaintext highlighter-rouge">TTL</code> 값을 포함</li>
      </ul>
    </li>
    <li><code class="language-plaintext highlighter-rouge">CDN</code> 서버는 파일을 캐시하고 사용자에 반환 (<code class="language-plaintext highlighter-rouge">TTL</code> 값만큼 캐시)
      <ul>
        <li>사용자가 만료가 안된 이미지의 요청을 <code class="language-plaintext highlighter-rouge">CDN</code> 서버에 전송하면, 캐시로 처리</li>
      </ul>
    </li>
  </ol>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CDN</code> 사용 시 고려할 사항?
    <ul>
      <li>비용 : 자주 사용되지 않는 컨텐츠를 캐싱하는 것은 비효율적</li>
      <li>만료 기한 : <code class="language-plaintext highlighter-rouge">time-sensitive</code>한 컨텐츠의 만료 기한은 신중히 설정해야 함</li>
      <li><code class="language-plaintext highlighter-rouge">CDN</code> 장애 대처 방안 : <code class="language-plaintext highlighter-rouge">CDN</code>이 오프라인 상태일 때의 동작에 대한 고려</li>
      <li>컨텐츠 무효화 (<code class="language-plaintext highlighter-rouge">Invalidation</code>) 방법 : <code class="language-plaintext highlighter-rouge">CDN</code> 서비스 사업자가 제공하는 <code class="language-plaintext highlighter-rouge">API</code>를 이용한 컨텐츠 무효화
        <ul>
          <li>컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 (<code class="language-plaintext highlighter-rouge">object versioning</code>) 이용</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CDN</code>과 캐시를 추가한 설계
    <ul>
      <li>정적 컨텐츠는 웹 서버가 아닌 <code class="language-plaintext highlighter-rouge">CDN</code>을 통해 서비스됨</li>
      <li>캐시를 통해 데이터베이스의 부하가 줄어들 수 있음</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=278536695">가상 면접으로 배우는 대규모 시스템 설계</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="System Design Interview" /><summary type="html"><![CDATA[시스템 디자인 면접 (System Design Interview) : 시스템 아키텍처를 설계하는 면접]]></summary></entry><entry><title type="html">[Engineer Information Processing] 1. 소프트웨어 공학 &amp;amp; 개발 방법론</title><link href="http://localhost:4000/engineer_information_processing1/" rel="alternate" type="text/html" title="[Engineer Information Processing] 1. 소프트웨어 공학 &amp;amp; 개발 방법론" /><published>2024-01-12T00:00:00+09:00</published><updated>2024-01-12T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing1</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing1/"><![CDATA[<h2 id="소프트웨어-software--프로그램과-프로그램-수행에-필요한-절차-규칙-관련-문서-등을-총칭">소프트웨어 (<code class="language-plaintext highlighter-rouge">Software</code>) : 프로그램과 프로그램 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭</h2>

<ul>
  <li>프로그램 (<code class="language-plaintext highlighter-rouge">Program</code>) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합</li>
  <li>자료구조 (<code class="language-plaintext highlighter-rouge">Date Structure</code>) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭
    <ul>
      <li>데이터 간의 논리적 관계나 데이터를 처리하는 알고리즘을 의미</li>
    </ul>
  </li>
  <li>문서 (<code class="language-plaintext highlighter-rouge">Document</code>) : 소프트웨어를 개발하면서 작성하는 문서들을 총칭
    <ul>
      <li>사용자 설명서, 소프트웨어 요구 분석서, 평가서, 명세서, 프로젝트 계획서, 감사 계획서 등을 의미</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어의-특징">소프트웨어의 특징</h3>

<ul>
  <li>상품성 : 소프트에어를 개발하면 상품이 되어 판매할 수 있다.</li>
  <li>복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.</li>
  <li>변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.</li>
  <li>복제성 : 복제가 쉬워 쉅게 복사 및 유통이 가능하다.</li>
  <li>순응성 : 기술의 발전, 사용자 요구, 사회적 흐름의 변화에 맞춰 적절히 변형된다.</li>
  <li>비가시성 : 소프트웨어 구조는 외관으로 나타나 있지 않고 코드로 내재되어 있다.</li>
</ul>

<h3 id="소프트웨어의-분류">소프트웨어의 분류</h3>

<ul>
  <li>시스템 소프트웨어 (<code class="language-plaintext highlighter-rouge">System Software</code>) : 하드웨어를 관리하고 컴퓨터 자원을 활용하는 소프트웨어
    <ul>
      <li>운영체제, 컴파일러, 로더, 디버거 등</li>
    </ul>
  </li>
  <li>응용 소프트웨어 (<code class="language-plaintext highlighter-rouge">Application Software</code>) : 사용자가 원하는 목적에 맞게 만들어진 소프트웨어
    <ul>
      <li>엑셀, 파워포인트, 워드프로세서, 포토샵 등</li>
    </ul>
  </li>
  <li>미들웨어 소프트웨어 (<code class="language-plaintext highlighter-rouge">Middleware</code>) : 시스템 소프트웨어와 응용 소프트웨어를 연결해주는 중간 단계의 소프트웨어
    <ul>
      <li>데이터베이스 관리 시스템, 웹 서버, 어플리케이션 서버, 트랜잭션 처리 모니터 등</li>
    </ul>
  </li>
</ul>

<h3 id="시스템-system--컴퓨터로-처리할-자료를-입력해-저장-처리-가공해-출력하도록-설계-및-구현된-정보-체계">시스템 (<code class="language-plaintext highlighter-rouge">System</code>) : 컴퓨터로 처리할 자료를 입력해 저장, 처리, 가공해 출력하도록 설계 및 구현된 정보 체계</h3>

<ul>
  <li>하나의 목적을 위해 시스템의 여러 요소들이 유기적으로 결합된 것
    <ul>
      <li>입력 (<code class="language-plaintext highlighter-rouge">Input</code>) : 처리 방법, 제어 조건, 처리할 데이터를 시스템이 투입하는 요소</li>
      <li>출력 (<code class="language-plaintext highlighter-rouge">Output</code>) : 처리된 결과를 시스템에서 출력하는 요소</li>
      <li>처리 (<code class="language-plaintext highlighter-rouge">Process</code>) : 입력된 자료를 처리 조건에 따라 변환 및 가공하는 요소</li>
      <li>제어 (<code class="language-plaintext highlighter-rouge">Control</code>) : 시스템의 기본 요소들이 각 과정을 올바르게 행하는지 감독하는 요소</li>
      <li>피드백 (<code class="language-plaintext highlighter-rouge">Feedback</code>) : 처리된 결과를 측정 및 파악하여 목표에 도달되었는지 검사하고, 만약 불충분한 경우에 목표 달성을 위해 다시 입력하는 요소</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어의-위기-software-crisis--소프트웨어-개발-속도가-하드웨어-개발-속도을-따라가지-못함">소프트웨어의 위기 (<code class="language-plaintext highlighter-rouge">Software Crisis</code>) : 소프트웨어 개발 속도가 하드웨어 개발 속도을 따라가지 못함</h3>

<ul>
  <li>하드웨어 비용을 초과하는 개발 비용의 증가</li>
  <li>개발 기간의 지연</li>
  <li>개발 인력의 부족 및 인건비 상승 → 개발 인력을 최대한 많이 투입하는 것은 해결책이 아님</li>
  <li>성능 및 신뢰성 부족</li>
  <li>유지보수의 어려움에 따른 엄청난 비용</li>
</ul>

<h2 id="소프트웨어-공학-software-engineering--경제적으로-신뢰도-높은-소프트웨어를-만드는-체계">소프트웨어 공학 (<code class="language-plaintext highlighter-rouge">Software Engineering</code>) : 경제적으로 신뢰도 높은 소프트웨어를 만드는 체계</h2>

<ul>
  <li>전기전자공학자협회 (<code class="language-plaintext highlighter-rouge">IEEE</code>) → 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법으로 정의</li>
</ul>

<h3 id="소프트웨어의-등장-배경">소프트웨어의 등장 배경</h3>

<ul>
  <li>소프트웨어 개발에 필요한 시간과 비용 예측력이 부족</li>
  <li>개발된 소프트웨어의 품질 수준이 부족</li>
  <li>하드웨어에 대한 소프트웨어의 상대적인 비용이 증대</li>
  <li>유지보수 역할의 증대</li>
  <li>하드웨어 및 소프트웨어 기술의 급속한 발전</li>
  <li>크고 복잡한 소프트웨어에 대한 수요의 증가</li>
  <li>특정 개인에 의존하는 시스템의 개발</li>
</ul>

<h3 id="소프트웨어-공학의-분류">소프트웨어 공학의 분류</h3>

<ul>
  <li>소프트웨어 개발 생명주기 모형 : 소프트웨어를 개발하는 과정을 단계별로 분류한 모형
    <ul>
      <li>폭포수 모형, 프로토타입 모형, 나선형 모형, 에자일 개발 방법론 등</li>
    </ul>
  </li>
  <li>소프트웨어 프로세스 모형 : 소프트웨어 개발을 위한 절차와 방법을 제공하는 모형
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ISO/IEE 12207</code>, <code class="language-plaintext highlighter-rouge">CMM1</code> 등</li>
    </ul>
  </li>
  <li>소프트웨어 품질 관리 : 소프트웨어 개발 과정에서 품질을 유지하고 향상시키기 위한 관리 기법을 연구하는 것
    <ul>
      <li>테스트, 코드 리뷰, 정적 분석 등</li>
    </ul>
  </li>
  <li>소프트웨어 유지보수 : 개발된 소프트웨어를 사용하고 보수하는 과정을 연구하는 것
    <ul>
      <li>버그 수정, 기능 추가, 기술 업그레이드 등</li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어-공학의-기본-원칙">소프트웨어 공학의 기본 원칙</h3>

<ul>
  <li>현대적인 프로그래밍 기술이 적용되어야 한다.</li>
  <li>신뢰성이 높아야 한다.</li>
  <li>사용의 편리성과 유지보수성이 높아야 한다.</li>
  <li>지속적인 검증 시행을 해야 한다.</li>
  <li>사용자가 원하는 대로 동작해야 한다.</li>
  <li>시스템의 안전성와 보안에 최선을 다해야 한다.</li>
  <li>최신 프로그램 언어, 최신 알고리즘 사용 현황을 확인해야 한다.</li>
  <li>소프트웨어 개발 비용을 최소화하도록 노력해야 한다.</li>
  <li>개발 단계와 소스 코드 등의 문서화를 통해 명확성을 유지해야 한다.</li>
</ul>

<h3 id="공학적으로-좋은-소프트웨어의-조건">공학적으로 좋은 소프트웨어의 조건</h3>

<ul>
  <li>신뢰성이 높고 효율적이여야 하며, 사용자의 의도대로 동작해야 한다.</li>
  <li>편리성 제공 및 잠재적 에러를 최소화해야 한다.</li>
  <li>유지보수성이 쉬워야 한다.</li>
</ul>

<h3 id="소프트웨어-공학-계층-구조">소프트웨어 공학 계층 구조</h3>

<ul>
  <li>도구 : 프로세스와 방법을 처리하는 기능을 제공</li>
  <li>방법론 : 소프트웨어를 설계하는 데 기술적인 방법을 제공하는 것</li>
  <li>프로세스 : 소프트웨어의 가장 기초가 되며, 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미</li>
</ul>

<h3 id="소프트웨어-공학의-목표">소프트웨어 공학의 목표</h3>

<ul>
  <li>최소의 비용으로 단기간에 적합한 소프트웨어를 개발하는 것</li>
  <li>소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[소프트웨어 (Software) : 프로그램과 프로그램 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭]]></summary></entry><entry><title type="html">[Clean Code] 1. 깨끗한 코드</title><link href="http://localhost:4000/clean_code1/" rel="alternate" type="text/html" title="[Clean Code] 1. 깨끗한 코드" /><published>2024-01-11T00:00:00+09:00</published><updated>2024-01-11T00:00:00+09:00</updated><id>http://localhost:4000/clean_code1</id><content type="html" xml:base="http://localhost:4000/clean_code1/"><![CDATA[<h2 id="코드-code--프로그래밍의-결과로서-요구사항을-상세히-표현하는-수단">코드 (<code class="language-plaintext highlighter-rouge">Code</code>) : 프로그래밍의 결과로서 요구사항을 상세히 표현하는 수단</h2>

<ul>
  <li>프로그래밍 (<code class="language-plaintext highlighter-rouge">Programming</code>) : 요구사항을 상세히 명시하는 작업
    <ul>
      <li>나쁜 코드는 프로젝트의 개발 속도를 떨어뜨리며, 팀 생산성을 떨어뜨림</li>
      <li>나쁜 코드는 나쁜 코드를 ‘유혹’한다 : 나쁜 코드를 고치면서 오히려 더 나쁜 코드를 만들어냄</li>
    </ul>
  </li>
</ul>

<h3 id="그렇다면-깨끗한-코드란-무엇인가">그렇다면, 깨끗한 코드란 무엇인가?</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">by</code> 비야네 스트롭스트룹
    <ul>
      <li>보는 사람에게 즐거움을 선사하는 ‘우아한’ 코드</li>
      <li>시간과 자원을 낭비하지 않는 ‘효율적인’ 코드</li>
      <li>세세한 사항까지 철저히 오류 처리를 하는 코드</li>
      <li>‘깨끗한 코드란 한 가지를 잘한다.’ : 나쁜 코드는 많은 일을 하려 애쓰다가 의도와 목적이 흐려진다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 그래디 부치
    <ul>
      <li>‘잘 쓴 문장처럼 읽혀야 한다.’ → 가독성 높은 코드</li>
      <li>‘명쾌한 추상화와 단순한 제어문’ → 추측이 아니라 사실에 기반한 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 데이브 토마스
    <ul>
      <li>다른 사람이 고치기 쉬운 코드</li>
      <li>테스트 케이스가 존재하는 코드</li>
      <li>작을수록 좋은, ‘최소한의’ 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 마이클 페더스
    <ul>
      <li>작성자가 모든 사항을 고려하여, 주의 깊게 작성한 코드</li>
      <li>시간을 들여 깔끔하고 단정하게 정리된 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 론 제프리스
    <ul>
      <li>중복을 피하고, 한 기능만을 수행하면서, 표현력이 높으며, 초반부터 간단한 추상화를 고려한 코드</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">by</code> 워드 커닝햄
    <ul>
      <li>읽으면서 ‘짐작했던 기능을 그대로 수행’하는 코드</li>
      <li>언어를 단순하게 보이도록 만드는 책임이 우리에게 달려 있음</li>
    </ul>
  </li>
</ul>

<h3 id="우리가-저자다--저자에게는-독자와-잘-소통할-책임이-있다">우리가 저자다 : 저자에게는 독자와 잘 소통할 책임이 있다.</h3>
<ul>
  <li>코드를 짤 때에는 자신이 저자라는 사실을, 그리고 저자의 노력을 보고 판단할 독자가 잊지 말자!</li>
  <li>저자 역시 독자다 : 새 코드를 짜면서 끊임없이 기존 코드를 읽기에, 읽기 쉽게 만들면 짜기 또한 쉽다.</li>
</ul>

<h3 id="보이스카우트-규칙--캠프장은-처음-왔을-때보다-더-깨끗하게-해놓고-떠나라">보이스카우트 규칙 : “캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.”</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Check-out</code>할 때보다 좀 더 깨끗한 코드를 <code class="language-plaintext highlighter-rouge">Check-in</code>한다면, 코드는 절대 나빠지지 않는다.</li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=248640013">클린 코드 Clean Code</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Clean Code" /><summary type="html"><![CDATA[코드 (Code) : 프로그래밍의 결과로서 요구사항을 상세히 표현하는 수단]]></summary></entry><entry><title type="html">[Linux] tmux</title><link href="http://localhost:4000/tmux1/" rel="alternate" type="text/html" title="[Linux] tmux" /><published>2024-01-09T00:00:00+09:00</published><updated>2024-01-09T00:00:00+09:00</updated><id>http://localhost:4000/tmux1</id><content type="html" xml:base="http://localhost:4000/tmux1/"><![CDATA[<h2 id="tmux--터미널-멀티플렉서-terminal-multiplexer"><code class="language-plaintext highlighter-rouge">tmux</code> : 터미널 멀티플렉서 (<code class="language-plaintext highlighter-rouge">Terminal Multiplexer</code>)</h2>

<ul>
  <li>단일 단말기 창 혹은 원격 터미널에서 여러 터미널 세션에 액세스할 수 있도록 가상 콘솔을 다중화
    <ul>
      <li>하나의 터미널에서 화면을 분할하여 사용할 수 있음</li>
      <li>영구적인 세션을 제공하기에 작업 중에 원격 서버와의 연결이 끊겨도 작업 내용이 사라지지 않음</li>
    </ul>
  </li>
</ul>

<h3 id="tmux-구조--tmux-서버와-tmux-클라이언트로-구성"><code class="language-plaintext highlighter-rouge">tmux</code> 구조 : <code class="language-plaintext highlighter-rouge">tmux</code> 서버와 <code class="language-plaintext highlighter-rouge">tmux</code> 클라이언트로 구성</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tmux</code>를 실행하면 하나의 윈도우를 가진 새로운 세션이 생성되어 화면에 출력
    <ul>
      <li>화면 아래의 상태 표시줄에 현재 세션에 대한 정보가 표시, <code class="language-plaintext highlighter-rouge">interactive commands</code>를 입력할 때 사용</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/447ea4a0-758d-4a8e-9f12-8a4cff8df627" /></p>

<ul>
  <li>
    <h4 id="세션-session--하나-이상의-윈도우가-있는-독립된-작업-공간">세션 (<code class="language-plaintext highlighter-rouge">Session</code>) : 하나 이상의 윈도우가 있는 독립된 작업 공간</h4>
    <ul>
      <li>세션은 <code class="language-plaintext highlighter-rouge">tmux</code> 서버에서 실행되는 프로세스로, <code class="language-plaintext highlighter-rouge">tmux</code>가 관리하는 가상 터미널</li>
      <li>세션은 1개 이상의 <code class="language-plaintext highlighter-rouge">tmux</code> 클라이언트로 접속할 수 있음</li>
    </ul>
  </li>
  <li>
    <h4 id="윈도우-window--동일한-세션에서-시각적으로-분리된-부분">윈도우 (<code class="language-plaintext highlighter-rouge">Window</code>) : 동일한 세션에서 시각적으로 분리된 부분</h4>
    <ul>
      <li>세션은 무조건 1개 이상의 윈도우를 가짐</li>
      <li>윈도우는 인덱스로 구분되며, 0번부터 시작</li>
    </ul>
  </li>
  <li>
    <h4 id="패널-panel--동일한-윈도우에서-분리된-부분">패널 (<code class="language-plaintext highlighter-rouge">Panel</code>) : 동일한 윈도우에서 분리된 부분</h4>
    <ul>
      <li>패널은 윈도우 내에 1개 이상 존재하면서, 입력을 받는 부분</li>
    </ul>
  </li>
</ul>

<h3 id="tmux-명령어"><code class="language-plaintext highlighter-rouge">tmux</code> 명령어</h3>

<table>
    <thead>
        <tr>
            <th>tmux 명령어 이름</th>
            <th>tmux 명령어 설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" style="text-align: center;">세션 관련</td>
        </tr>
        <tr>
            <td>tmux</td>
            <td>새로운 세션 시작</td>
        </tr>
        <tr>
            <td>tmux new -s {이름}</td>
            <td>특정 이름을 가진 새로운 세션 시작</td>
        </tr>
        <tr>
            <td>tmux ls</td>
            <td>현재 열린 세션 목록 나열</td>
        </tr>
        <tr>
            <td>tmux -a</td>
            <td>마지막 세션으로 접속</td>
        </tr>
        <tr>
            <td>tmux -a -t {이름}</td>
            <td>특정 이름을 가진 세션으로 접속</td>
        </tr>
        <tr>
            <td>(tmux에서) exit</td>
            <td>현재 세션 종료</td>
        </tr>
        <tr>
            <td colspan="2" style="text-align: center;">윈도우 관련</td>
        </tr>
        <tr>
            <td>ctrl+b → c</td>
            <td>새로운 윈도우 생성</td>
        </tr>
        <tr>
            <td>ctrl+d</td>
            <td>현재 윈도우 닫기</td>
        </tr>
        <tr>
            <td>ctrl+b → p</td>
            <td>이전 윈도우로 이동</td>
        </tr>
        <tr>
            <td>ctrl+b → n</td>
            <td>다음 윈도우로 이동</td>
        </tr>
        <tr>
            <td>ctrl+b → l</td>
            <td>마지막 윈도우로 이동</td>
        </tr>
        <tr>
            <td>ctrl+b → ,</td>
            <td>현재 윈도우 이름 바꾸기</td>
        </tr>
        <tr>
            <td>ctrl+b → w</td>
            <td>현재 열린 윈도우 목록 나열</td>
        </tr>
         <tr>
            <td>ctrl+b → [</td>
            <td>copy 모드로 전환 (스크롤 가능)</td>
        </tr>
        <tr>
            <td colspan="2" style="text-align: center;">패널 관련</td>
        </tr>
        <tr>
            <td>ctrl+b → "</td>
            <td>현재 패널을 가로로 나누기</td>
        </tr>
        <tr>
            <td>ctrl+b → %</td>
            <td>현재 페널을 세로로 나누기</td>
        </tr>
        <tr>
            <td>ctrl+b → {방향키}</td>
            <td>현재 패널에서 방향키 방향의 패널으로 이동</td>
        </tr>
        <tr>
            <td>ctrl+b → z</td>
            <td>현재 패널 확대/축소 전환</td>
        </tr>
        <tr>
            <td>ctrl+b → ␣</td>
            <td>현재 패널에서 다른 패널으로 순환</td>
        </tr>
        <tr>
            <td>ctrl+b → x</td>
            <td>현재 패널 삭제</td>
        </tr>
    </tbody>
</table>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Linux" /><summary type="html"><![CDATA[tmux : 터미널 멀티플렉서 (Terminal Multiplexer)]]></summary></entry><entry><title type="html">[TIL] 2024년 01월 TIL</title><link href="http://localhost:4000/til1/" rel="alternate" type="text/html" title="[TIL] 2024년 01월 TIL" /><published>2023-12-31T00:00:00+09:00</published><updated>2024-01-03T00:00:00+09:00</updated><id>http://localhost:4000/til1</id><content type="html" xml:base="http://localhost:4000/til1/"><![CDATA[<h2 id="january-2024--til를-작성하자"><code class="language-plaintext highlighter-rouge">January, 2024</code> : <code class="language-plaintext highlighter-rouge">TIL</code>를 작성하자!</h2>

<p>2023년은 내게 있어 다사다난한 해였다. 교수님 밑에서 친구들과 함께 프로젝트도 해보고, 기업에 취업하고자 여러 군데에 서류도 넣어 면접까지 진행하였다. 그리고 내가 부족하다고 느낀 부분을 메꾸기 위해 여러 도서들을 사서 정리하기도 하였으며, 주니어 개발자를 위한 여러 행사들 또한 참여하였다. 그런데 지금 올해를 회고하는 내게 있어서 아쉬운 점은 <b>내가 경험한 것들, 내가 공부한 것들, 내가 작업한 것들을 성실히 기록하지 않았다는 점</b>이다. 그래서 이제 하루 앞으로 다가온 2024년에는, 내가 매일매일 성장한 기록을 글의 형태로 남기고자 한다.<br /></p>

<p><code class="language-plaintext highlighter-rouge">TIL</code>은 <code class="language-plaintext highlighter-rouge">Today I Learned</code>의 약자로, 오늘 하루동안 배운 것 혹은 경험하고 느낀 것들을 기록하면서 회고하는 것이다. 이미 여러 개발 블로그들을 보면, <a href="https://github.com/cheese10yun/TIL">김남윤님의 <code class="language-plaintext highlighter-rouge">TIL</code></a>이나 <a href="https://wayhome25.github.io">초보몽키님의 <code class="language-plaintext highlighter-rouge">TIL</code></a>처럼 많이들 <code class="language-plaintext highlighter-rouge">TIL</code>을 쓰시는 것을 볼 수 있다. <code class="language-plaintext highlighter-rouge">TIL</code>이 정해진 양식이나 규칙 없이 자유롭게 자신의 스타일로 작성하다 보니 보고서처럼 쓰시는 분들도, 일기처럼 쓰시는 분들도 있어 정말 다양하게 쓰신다는 것을 알 수 있었다. 원래는 양식이나 규칙을 확실히 정해놓고 매일매일 쓰려고 하였는데 일단은<code class="language-plaintext highlighter-rouge">TIL</code>을 한번도 작성해본 적이 없다보니, 일단은 한 달 정도는 여러 형태로 글을 써보면서 나한테 적합한 글쓰기 방식을 찾아봐야할 것 같다. 대신에 내가 왜 <code class="language-plaintext highlighter-rouge">TIL</code>을 작성해야 하는지에 대해 생각해보았다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TIL</code>을 쓰는 이유 1. 내가 매일 경험한 것을 회고하기 위해<br />
  하루를 보내면서 내가 모르는 내용이나 개념을 만나는 경우가 정말 많다. 그리고 나의 솔루션이 옳은지에 대한 기술적인 고민을 하는 과정 또한 경험하게 된다. 그러나 그동안 내가 경험한 것들을 기록할 때에는, 이런 과정을 생략하고 개조식으로 글을 써서 내가 중요하다고 생각한 부분 위주로 잘 정리하고자 노력하였다. 지금 와서 내가 정리한 글들을 보면 <b>‘내가 어떤 문제 상황에서 어떻게 해결하였는지?’</b>에 대한 과정이 결여되었다는 느낌을 받았다. 하지만 <code class="language-plaintext highlighter-rouge">TIL</code>처럼 매일 내가 경험한 것들을 작성한다면, 나의 문제 해결 과정이 잘 들어난 글쓰기가 되지 않을까 생각하였다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TIL</code>을 쓰는 이유 2. 나 자신의 노력을 증명하기 위해<br />
  기업에서 원하는 주니어 개발자는 어떤 인재일까? 에 대해 고민을 많이 해보았다. 사실 시니어들의 눈에 주니어 개발자 모두가 고만고만한 실력이나 기술 스택을 가진 것처럼 보일 것 같았다. 그렇다면 내가 남들보다 더 낫다고 할 수 있는 부분은 무엇일까? 나는 그것이 <b>성장 가능성</b>이지 않을까 생각하였다. <code class="language-plaintext highlighter-rouge">TIL</code>은 내가 성장에 대한 갈망이 높고, 성실함과 꾸준함을 겸비하였음을 어필할 수 있어, 내가 남들보다 더 성장할 수 있는 사람이라는 것을 보여줄 수 있을 것이라고 기대한다.</p>
  </li>
</ul>

<h3 id="2024년-01월-01일-월">2024년 01월 01일 (월)</h3>

<ul>
  <li>신년을 맞아 앞으로 내가 해야할 일들을 아래와 같이 정리해보는 시간을 가졌다.
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Python</code>으로 알고리즘 문제를 풀면서 코딩 테스트 준비하기</li>
      <li><code class="language-plaintext highlighter-rouge">Java</code>, <code class="language-plaintext highlighter-rouge">Spring</code>과 같이 백엔드 개발자에 있어 필요한 내용을 공부해 포스트로 정리하기</li>
      <li>기획부터 배포까지의 일련의 과정을 경험할 수 있는 협업 프로젝트 진행하기</li>
      <li>정보처리기사, <code class="language-plaintext highlighter-rouge">SQLD</code>와 같이 취업에 도움이 될 수 있는 자격증 취득하기</li>
      <li>내가 목표로 하는 회사들에 지원하여 서류, 코딩 테스트, 면접과 같은 채용 프로세스 경험하기</li>
      <li>하루동안 내가 경험한 일들을 기록하는 <code class="language-plaintext highlighter-rouge">TIL</code> 작성하기</li>
      <li>자신의 기술과 역량을 보여줄 수 있는 개발자 포트폴리오 만들기</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 1장의 내용을 정리하였다.</li>
  <li><code class="language-plaintext highlighter-rouge">Goodnotes</code> 앱으로 필기하기 위해 알라딘으로 구매한 전자책을 스캔하는 <code class="language-plaintext highlighter-rouge">Automator</code> 워크플로우 파일을 작성하였다.</li>
</ul>

<h3 id="2024년-01월-02일-화">2024년 01월 02일 (화)</h3>

<ul>
  <li>어제 작성한 <code class="language-plaintext highlighter-rouge">Automator</code> 워크플로우 파일을 오전에 실행해보니 같은 파일명으로 파일을 덮어쓰는 오류가 있었다. 그래서 스크린샷을 찍어 이를 각각 다른 이름으로 저장하고, 필요한 경우에 색상 반전을 실행하는 파이썬 코드를 작성하였다.
    <ul>
      <li>사실 저장된 스크린샷 이미지들을 하나의 <code class="language-plaintext highlighter-rouge">PDF</code>로 만드는 것까지 코드로 작성하였는데, 막상 실행해보니 출력된 결과물의 화질이 그렇게 좋지 않아 이 부분은 수작업으로 진행하였다.</li>
      <li>알라딘으로 구매한 전자책 37권과 재학 기간에 스캔한 전공 서적 6권을 대상으로 진행하였다. 전자책을 스캔하는 작업과 색상 반전을 실행하는 작업 모두 내 예상보다 많은 시간이 소요되서 하루 내내 여기에만 매달린 거 같다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from PIL import ImageGrab
import time
import pyautogui


def take_screenshot(filename):
    # 로딩 시간 지연
    time.sleep(2)

    # 현재 화면 전체를 캡처
    screenshot = ImageGrab.grab()

    # 파일로 저장
    screenshot.save(filename)

    # 오른쪽 방향키 누르기
    pyautogui.press('right')


if __name__ == "__main__":
    # 초기 시간 지연
    time.sleep(5)

    for i in range(1, 256):
        file_path = "page" + str(i) + ".png"

        # 스크린샷 찍기
        take_screenshot(file_path)

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from PIL import Image


def invert_colors(image_path, output_path):
    # 이미지 열기
    image = Image.open(image_path)

    # 이미지 모드 확인 및 변경 (모드가 'RGBA' 또는 'LA'인 경우에 대비)
    if image.mode in ('RGBA', 'LA'):
        r, g, b, a = image.split()
        rgb_image = Image.merge('RGB', (r, g, b))
    else:
        rgb_image = image.convert('RGB')

    # 이미지 크기 및 모드 확인
    width, height = rgb_image.size

    # 각 픽셀의 RGB 값을 반전
    inverted_image = Image.new('RGB', (width, height))
    for x in range(width):
        for y in range(height):
            pixel = rgb_image.getpixel((x, y))
            inverted_pixel = tuple(255 - value for value in pixel)
            inverted_image.putpixel((x, y), inverted_pixel)

    # 반전된 이미지 저장
    inverted_image.save(output_path)


if __name__ == "__main__":
    for i in range(1, 256):
        input_image_path = "page" + str(i) + ".png"
        output_image_path = "pages" + str(i) + ".png"
        invert_colors(input_image_path, output_image_path)

</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 2장의 내용을 정리하였다.</li>
</ul>

<h3 id="2024년-01월-03일-수">2024년 01월 03일 (수)</h3>

<ul>
  <li>오늘 아침, 지난달에 면접을 진행한 <a href="https://hanaro.recruiter.co.kr">디지털하나路</a> 2기 금융서비스개발 분야에 합격하였다는 전화를 받았다.
    <ul>
      <li>솔직히 말하면 면접을 진행하면서 아쉬운 점들이 많았고, 경쟁률도 내 예상보다 높은 편이였기에 이렇게 합격을 하게 될 줄은 전혀 몰랐다. 6개월이라는 짧지 않은 기간에 매일 9시간씩 심도 깊게 진행되는 프로그램인 만큼, 본 과정에 열심히 참여하여 이전보다 성장할 수 있도록 노력해야겠다.</li>
      <li><a href="https://hanaro.recruiter.co.kr/career/introduce">공고문</a>에 따르면 디지털하나路 금융서비스개발의 커리큘럼은 금융의 이해, 서비스 개발의 요소, <code class="language-plaintext highlighter-rouge">FrontEnd</code> 개발, <code class="language-plaintext highlighter-rouge">BackEnd</code> 개발, 데이터베이스와 보안, 3차례의 팀 프로젝트로 구성되어 있다. 과정 하나하나가 <code class="language-plaintext highlighter-rouge">BackEnd</code> 개발자를 지망하는 내게 큰 도움이 될 것 같고, 특히 부족한 협업 경험이 아킬레스건이라 생각한 내게 있어 팀 프로젝트를 3차례 진행해보는 것은 굉장한 메리트가 될 수 있을 것이라고 생각한다.</li>
      <li>하나은행 <code class="language-plaintext highlighter-rouge">HR</code> 담당자 분들이 진행하시는 채용설명회 및 채용상담 또한, 자소서나 포트폴리오를 어떻게 작성하고 관리할지 고민이 많고 실제 면접 경험이 부족한 나에게 큰 도움이 될 것 같다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9422a984-6808-4fa6-987f-31b724c0afa9" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 3장의 내용을 정리하였다.
    <ul>
      <li>디지털하나路 일정을 감안힌다면, 보다 빠른 기획서의 작성이 필요하다. 오는 1월 13일에 인프라 매니저와의 만남을 약속하였고 1월 15일에 디지털하나路 과정이 시작될 예정이니, 1월 11일에 기획서 초안을 완성하도록 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-01월-04일-목">2024년 01월 04일 (목)</h3>

<ul>
  <li><del>내일배움카드 발급이 이렇게 오래 걸릴 줄은 몰랐다. 디지털하나路 일정이 촉박하다보니, 카드를 직접 수령하려고 은행만 세 군데 다녀왔다. 그건 그렇고 그동안 작성한 내용을 읽어보니 점점 일기장이 되는 것 같다? 그래도 일단은 괜찮겠지..?</del></li>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 4장의 내용을 정리하였다.</li>
</ul>

<h3 id="2024년-01월-05일-금">2024년 01월 05일 (금)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 5장의 내용을 정리하였다.
    <ul>
      <li>책의 내용이 7장으로 구성되어 있는데, 7장은 후일담이라 내일 6~7장의 내용을 정리해 마무리하면 될 것 같다.</li>
      <li>정리를 마무리한 다음에는 정리된 내용을 토대로 기획서의 뼈대를 잡을 계획이다. 내가 기획하고 있는 프로젝트는 기존 프로젝트의 언어 전환이 아닌 신규 서비스의 구현이긴 하지만, 실제로 어떻게 프로젝트를 관리할지에 대해 다시 한 번 생각해볼 수 있었으며 기획서에도 분명 채용할 만한 부분이 많음을 느끼고 있다.
        <ul>
          <li>기획서는 현재 1. 기획 배경, 2. 타 사이트 분석, 3. 서비스 설계의 흐름으로 작성하고 있으며, 현재 1번의 내용은 완성하고 2번의 내용을 작성하고 있는 상태이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2024년-01월-06일-토">2024년 01월 06일 (토)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 6~7장의 내용을 정리하였다.</li>
  <li>이전에 작성하였던 <a href="https://pocj8ur4in.github.io/homebrew1/">홈브류 (<code class="language-plaintext highlighter-rouge">Homebrew</code>)와 관련된 게시글</a>을 수정하여 포스팅하였다.</li>
</ul>

<h3 id="2024년-01월-07일-일">2024년 01월 07일 (일)</h3>

<ul>
  <li>이전에 작성하였던 <a href="https://pocj8ur4in.github.io/html1/"><code class="language-plaintext highlighter-rouge">HTML</code>와 관련된 게시글</a>과 <a href="https://pocj8ur4in.github.io/css1/"><code class="language-plaintext highlighter-rouge">CSS</code>와 관련된 게시글</a>을 수정하여 포스팅하였다.</li>
</ul>

<h3 id="2024년-01월-08일-월">2024년 01월 08일 (월)</h3>

<ul>
  <li>이전에 작성하였던 <a href="https://pocj8ur4in.github.io/algorithm2/">구현 알고리즘과 관련된 게시글</a>을 수정하여 포스팅하였다. 사실 예제 느낌으로 문제들도 풀었던 것 같은데, 아무리 찾아봐도 안보여서 백준에서 구현 문제를 몇 개 풀고 이에 대한 해설까지 더해서 다시 올려야 할 것 같다.</li>
</ul>

<h3 id="2024년-01월-09일-화">2024년 01월 09일 (화)</h3>

<ul>
  <li>리눅스를 공부하는 과정에 <code class="language-plaintext highlighter-rouge">tmux</code>에 대해 알게 되어 맥북 로컬 환경에 설치하여 직접 실습해보고, <a href="https://pocj8ur4in.github.io/tmux1/"><code class="language-plaintext highlighter-rouge">tmux</code>에 관련된 게시글</a>을 작성해 포스팅하였다. 간단한 구조나 직접 사용하면서 필요하다고 생각된 명령어들 위주로 게시글을 작성하긴 하였는데, 아무래도 직접 사용해보면서 이 툴에 익숙해지는 것이 무엇보다 중요해보인다.</li>
</ul>

<h3 id="2024년-01월-10일-수">2024년 01월 10일 (수)</h3>

<ul>
  <li>이전에 작성하였던 <a href="https://pocj8ur4in.github.io/python1/"><code class="language-plaintext highlighter-rouge">python</code>과 관련된 게시글</a>을 수정하여 포스팅하였다. 조만간 이 게시글의 내용을 참고하여 <code class="language-plaintext highlighter-rouge">SpringBoot</code>가 기반으로 하는 <code class="language-plaintext highlighter-rouge">Java</code>에 대해서도 심층 깊게 작성할 계획이다.</li>
  <li>도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 <code class="language-plaintext highlighter-rouge">MSA</code>에 대한 게시글을 작성중이다.
    <ul>
      <li>2장의 내용이 길기도 하고, 인프라 영역에 대해 내가 모르는 부분이 많아 완성하는 데에 시간이 더 길릴 것 같다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-01월-11일-목">2024년 01월 11일 (목)</h3>

<ul>
  <li>도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 <code class="language-plaintext highlighter-rouge">MSA</code>에 대한 게시글을 작성중이다.
    <ul>
      <li>마이크로서비스의 흐름을 주도하고 있는 넷플릭스와 쿠버네티스가 대단하다는 생각이 많이 드는 시간이었다.</li>
    </ul>
  </li>
  <li><a href="http://pocj8ur4in.github.io/clean_code1">클린 코드 1장을 읽으면서 정리한 내용을 바탕으로 한 게시글</a>을 작성하였다.
    <ul>
      <li>깨끗한 코드가 무엇인가에 대한 여러 의견들을 보면서 그동안 작성해본 코드에 대해 반추하면서 과연 과연 내가 저자로서의 책임을 갖고 코드를 작성하였는지에 대해 생각해볼 수 있었다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-01월-12일-금">2024년 01월 12일 (금)</h3>

<ul>
  <li>
    <p>을지로입구역에 위치한 하나은행 사옥에서 디지털하나路 2기 입학식 행사에 참여하였다. 행사는 교육 커리큘럼이나 출결 관리와 같은 전달 사항들을 안내하는 오리엔테이션 위주로 진행되었고, 디지털하나路에 같이 참여하게 될 직원 분들과 수강생들 또한 처음 만나뵙게 되었다. 이제 다음주부터 본격적인 일정이 시작되는 만큼, 열심히 참여하여 내가 원하는 바를 이뤘으면 한다.</p>
  </li>
  <li>도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 마이크로서비스 <code class="language-plaintext highlighter-rouge">MSA</code>에 대한 게시글을 작성중이다.
    <ul>
      <li>이제 인프라 영역에 해당되는 부분을 마치고, 내가 다루는 어플리케이션 영역에 대한 내용을 다루고 있다. 이전에 운영 관리 패턴에 대해 공부하면서 인프라 영역이 다루는 범위가 넓어지면서 어플리케이션 영역이 하는 업무가 줄어든건가? 라는 생각이 들었는데, 그렇지 않다는 것을 깨닫게 되었다.</li>
    </ul>
  </li>
  <li>가상 면접으로 배우는 대규모 시스템 설계 1장을 공부하면서 시스템 설계에 대한 게시글을 작성하고 있다.</li>
</ul>

<h3 id="2024년-01월-13일-토">2024년 01월 13일 (토)</h3>

<ul>
  <li>월요일에 찾았던 구현 문제를 푼 기록을 오늘 <code class="language-plaintext highlighter-rouge">Notion</code>에서 발견해서, 이전에 작성하였던 <a href="https://pocj8ur4in.github.io/algorithm2/">구현 알고리즘과 관련된 게시글</a>을 수정하여 포스팅하였다. 추가로 그리디와 브루트포스 알고리즘에 대한 내용까지 완성되어 있어서, 이를 마크다운 파일로 수정해서 포스트로 작성할 계획이다.</li>
  <li>도메인 주도 개발로 시작하는 마이크로서비스 개발 2장을 공부하면서 <a href="https://pocj8ur4in.github.io/microservice2/">마이크로서비스 <code class="language-plaintext highlighter-rouge">MSA</code>에 대한 게시글</a>을 작성하였다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">MSA</code>이 발전하는 과정에서의 문제들과 이에 대한 해결책으로서의 패턴들을 접하면서, 내가 이전에 고민한 아키텍처 설계에 대해 회고하는 시간을 가질 수 있었고, 앞으로 새롭게 진행될 나의 작업이 이를 반영해보고 싶다는 생각이 들었다. 특히 인프라 영역의 쿠버네티스와, 어플리케이션 영역의 메시지 브로커 및 이벤트 아키텍처, 데이터베이스 영역의 <code class="language-plaintext highlighter-rouge">NoSQL</code> 저장소는 빨리 공부하여 프로젝트에 적용할 필요성을 느꼈다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TIL" /><summary type="html"><![CDATA[January, 2024 : TIL를 작성하자!]]></summary></entry><entry><title type="html">[vocawik] 1. vocawik 프로젝트 소개</title><link href="http://localhost:4000/vocawik1/" rel="alternate" type="text/html" title="[vocawik] 1. vocawik 프로젝트 소개" /><published>2023-12-27T00:00:00+09:00</published><updated>2023-12-29T00:00:00+09:00</updated><id>http://localhost:4000/vocawik1</id><content type="html" xml:base="http://localhost:4000/vocawik1/"><![CDATA[<h2 id="1-들어가며">1. 들어가며</h2>

<p>음성 합성 (<code class="language-plaintext highlighter-rouge">Speech Synthesis</code>)은 인간의 육성 혹은 그와 비슷한 주파수를 합성하여 인공적인 음성을 자동으로 만들 수 있는 기술을 말한다. 인간의 말소리 혹은 이와 유사한 소리를 일정한 단위로 분할해 각 조각에 부호를 붙이는 방식으로 데이터화해 음성 라이브러리 (<code class="language-plaintext highlighter-rouge">Vocal Library</code>)에 저장하면, 음성 합성 엔진 (<code class="language-plaintext highlighter-rouge">Speech Synthesis Engine</code>)이 사용자의 지시에 따라 음성 라이브러리에 필요한 음성 단위를 불러오고 이를 기반으로 하여 인공적인 음성을 합성한다. 음성 합성 기술 문자를 대신 읽어주는 스크린 리더 (<code class="language-plaintext highlighter-rouge">Screen Reader</code>)로서, 1984년 애플 매킨토시 (<code class="language-plaintext highlighter-rouge">Apple Macintosh</code>)에 매킨토크 (<code class="language-plaintext highlighter-rouge">MacInTalk</code>) 기능으로 탑재된 이후 오랜 기간에 걸쳐 다양한 분야에서 활용되고 있다.<br /></p>

<p>2003년 2월 야마하 (<code class="language-plaintext highlighter-rouge">Yamaha</code>)에서 개발된 보컬로이드 (<code class="language-plaintext highlighter-rouge">VOCALOID</code>) 엔진 역시 음성 합성을 기반으로 한 소프트웨어로, 사용자가 프로그램만으로 사람의 노랫소리를 활용한 음원을 작곡하는 것을 목표로 한다. 그러나 기존 음성 합성 기술이 산업적인 용도에 초점을 맞춰져 있던 것과 달리, 보컬로이드를 비롯한 음성 합성 엔진은 음성 데이터에 다이폰 (<code class="language-plaintext highlighter-rouge">Diphone</code>), 음성의 강약, 비브라토, 숨소리 등의 부가적인 정보들을 더한 가수 라이브러리 (<code class="language-plaintext highlighter-rouge">Singer Library</code>)를 제공해 인간의 음성에 흡사한 소리를 생성할 수 있다. 또한 스코어 에디터 (<code class="language-plaintext highlighter-rouge">Score Editor</code>)는 노래의 가사나 음표만이 아닌, 음원의 억양와 높낮이 등을 가변하여 사용자가 자유롭게 음원을 조절할 수 있게끔 한다.<br /></p>

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" width="640" height="360" src="https://www.youtube.com/embed/dv_pMzr5Roo"></iframe>
<p><br /></p>

<p>야마하가 보컬로이드를 발표한 이후, 여러 기업들이 음성 제공자 (<code class="language-plaintext highlighter-rouge">Voice Provider</code>)의 목소리를 활용한 가수 라이브러리를 발표하였다. 2007년 8월 31일 크립톤 퓨처 미디어 (<code class="language-plaintext highlighter-rouge">Crypton Future Media</code>)에서 발매한 하츠네 미쿠 (<code class="language-plaintext highlighter-rouge">初音ミク</code>)는 대표적인 음성 합성 이미지 캐릭터로, 현대 일본 캐릭터 문화의 상징 중 하나로 여겨질 만큼 어마어마한 성공을 거두었다. 최근까지도 <code class="language-plaintext highlighter-rouge">Project SEKAI COLORFUL STAGE! feat. 初音ミク</code>, <code class="language-plaintext highlighter-rouge">ポケモン feat. 初音ミク Project VOLTAGE 18 Types/Songs</code>와 같은 관련 컨텐츠나 피규어, 넨도로이드 등 굿즈들이 끊임없이 나오고 있으며, <code class="language-plaintext highlighter-rouge">SONY</code>, <code class="language-plaintext highlighter-rouge">TOYOTA</code> 등 유명 회사들과의 콜라보 역시 지속적으로 이루어지고 있다.</p>

<p>음성 합성 소프트웨어를 활용한 음악 산업의 성공에는 관련 창작물들을 하나의 ‘창작 문화’로 여기면서 자발적으로 생산·유통·소비 활동에 참여하는 팬덤의 영향력이 뒷받침되었다고 본다. 아마추어 작곡가들이 가수나 밴드를 통해 자신이 작곡한 곡을 재상산하는 것은 현실적인 어려움이 존재한다. 그러나 음성 합성 소프트웨어를 통해 손쉽게 자신의 곡에 가수의 음성을 넣는 것이 가능해지면서, 음성 합성 소프트웨어를 활용한 자신의 곡을 투고하는 프로듀서 (<code class="language-plaintext highlighter-rouge">Producer</code>)들이 등장하였다. 그리고 유튜브 (<code class="language-plaintext highlighter-rouge">Youtube</code>), 니코니코 동화 (<code class="language-plaintext highlighter-rouge">ニコニコ動画</code>)와 같이 사용자가 동영상을 자유롭게 올리거나 시청할 수 있는 비디오 플랫폼을 통해 생산자와 소비자가 시공간의 제약을 넘어 자유롭게 교류할 수 있는 환경 또한 조성되었다. 거기에 더해 소비자가 단순히 컨텐츠를 즐기는 것을 넘어, 직접 프로듀서로 활동하거나 일러스트, <code class="language-plaintext highlighter-rouge">MMD</code>와 같은 2차 창작물을 생산하는 활동을 하면서 문화적 파급력을 갖게 되었다고 볼 수 있다.<br /></p>

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" width="100%" height="480" src="https://piapro.net/miku10th/"></iframe>
<p><br /></p>

<p>국내에서도 이런 음성 합성 소프트웨어를 활용한 음악 산업의 성공과 파급력에 주목하여, 한국어를 지원하는 보컬로이드 가수 라이브러리인 시유 (<code class="language-plaintext highlighter-rouge">SeeU</code>)나 유니 (<code class="language-plaintext highlighter-rouge">UNI</code>)가 출시되었고, 크리크루 (<code class="language-plaintext highlighter-rouge">CreCrew</code>)나 보카로 가사 위키 등 음성 합성 소프트웨어 관련 웹 사이트 또한 개설된 바가 있다. 그러나 음성 합성 소프트웨어가 일본이나 전세계에 미친 영향력에 비하면 국내에서의 파급력은 매우 제한적이었으며, 특히 관련 웹 사이트의 경우에는 운영되었던 사이트들이 폐쇄되면서 이용자들에게 불편함을 겪거나 수년간 축적된 데이터가 소실되는 경우가 발생하곤 하였다. 그래서 이번에는 <b>음성 합성 소프트웨어를 주제로 한 지속 가능한 웹 사이트의 구현</b>을 목표로 하여 웹 사이트를 기획하고 이를 바탕으로 설계하고자 한다.</p>

<h2 id="2-vocawik-프로젝트-기획--설계">2. <code class="language-plaintext highlighter-rouge">vocawik</code> 프로젝트 기획 &amp; 설계</h2>

<h3 id="1-도메인-정의">(1) 도메인 정의</h3>
<ul>
  <li>서버에서 제공할 기능들을 정리해, 도메인별로 명확하게 제공할 기능과 책임을 분리해야 함
    <ul>
      <li>도메인 (<code class="language-plaintext highlighter-rouge">Domain</code>) : 소프트웨어로 해결하고자 하는 문제 영역 (한 도메인은 여러 하위 도메인으로 나눌 수 있음)</li>
    </ul>
  </li>
</ul>

<h3 id="2-언어-및-프레임워크-도입">(2) 언어 및 프레임워크 도입</h3>
<ul>
  <li>더 나은 품질, 더 빠른 개발 속도, 개발자들이 높은 이해도와 숙련도를 갖춰 높은 생산성을 가져올 도구들을 도입해야 함
    <ul>
      <li>언어 : 보다 높은 유지보수성 (동적 프로그래밍 언어 vs 정적 프로그래밍 언어?)</li>
      <li>프레임워크 : 보다 높은 비즈니스 집중도 (비즈니스 문제들에 필요한 환경과 기술들이 풍부한 개발 생태계!)</li>
    </ul>
  </li>
</ul>

<h3 id="3-코드-패키지-관리">(3) 코드 패키지 관리</h3>
<ul>
  <li>패키지 내 공통된 규칙을 통해 일관성 있는 코드를 작성해야 함</li>
  <li>화면만을 위해 동작하는, 혹은 중복된 코드에 대한 리펙터링이 가능한 환경을 구축해야 함</li>
</ul>

<blockquote>
  <p>참고문헌</p>

  <ol>
    <li>논문
      <ul>
        <li>김도희. (2018). 보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼.</li>
        <li>임현정. (2012). 보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문.</li>
      </ul>
    </li>
    <li>기사
      <ul>
        <li><a href="https://www.newslight.kr/news/655301">안태춘, ‘한국 보컬로이드는 어떻게 나아가야할까?’</a></li>
      </ul>
    </li>
    <li>도서
      <ul>
        <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=295601741">조이, 서비스를 성공시키는 기획자의 비법 노트</a></li>
        <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">남경호, 사례로 배우는 언어 전환 프로젝트 관리</a></li>
        <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">한정현 외 3인, 도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
      </ul>
    </li>
  </ol>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[1. 들어가며]]></summary></entry><entry><title type="html">[MicroService] 2. MSA</title><link href="http://localhost:4000/microservice2/" rel="alternate" type="text/html" title="[MicroService] 2. MSA" /><published>2023-12-14T00:00:00+09:00</published><updated>2024-01-13T00:00:00+09:00</updated><id>http://localhost:4000/microservice2</id><content type="html" xml:base="http://localhost:4000/microservice2/"><![CDATA[<h2 id="마이크로서비스-아키텍처-msa--마이크로서비스를-접목한-아키텍처-구조">마이크로서비스 아키텍처 (<code class="language-plaintext highlighter-rouge">MSA</code>) : 마이크로서비스를 접목한 아키텍처 구조</h2>

<ul>
  <li>클라우드 인프라와 접목해 아마존, 넷플릭스에 의해 구체화 → 비즈니스 성공 사례</li>
  <li>각 서비스는 개별 프로세스에서 실행되며, <code class="language-plaintext highlighter-rouge">HTTP API</code>를 통해 통신</li>
  <li>각 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용해 독립적으로 배포</li>
</ul>

<blockquote>
  <p>마이크로서비스 아키텍처 (<code class="language-plaintext highlighter-rouge">MSA</code>)와 서비스 지향 아키텍처 (<code class="language-plaintext highlighter-rouge">SOA</code>)의 비교</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">SOA</code> : 컴포넌트를 모아 비즈니스적으로 의미있고 완결적인 서비스 단위로 모듈화
      <ul>
        <li><code class="language-plaintext highlighter-rouge">SOA</code>와 <code class="language-plaintext highlighter-rouge">MSA</code>의 공통점 : 비즈니스 서비스의 집합으로 시스템을 개발</li>
        <li><code class="language-plaintext highlighter-rouge">SOA</code>와 <code class="language-plaintext highlighter-rouge">MSA</code>의 차이점 : 이론적인 <code class="language-plaintext highlighter-rouge">SOA</code>와 달리, <code class="language-plaintext highlighter-rouge">MSA</code>는 클라우드 인프라와 접목해 구체화</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MSA</code> 내부 아키텍처 : <code class="language-plaintext highlighter-rouge">API</code>, 비즈니스 로직, 이벤트 발행, 데이터 처리의 구조화 등 <code class="language-plaintext highlighter-rouge">MSA</code> 내부 구조를 정의한 것</li>
  <li><code class="language-plaintext highlighter-rouge">MSA</code> 외부 아키텍처 : 인프라, 플랫폼, 어플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것</li>
</ul>

<h3 id="리액티브-선언-the-reactive-manifesto--어플리케이션이-요청에-즉각-응답하고-가동되길-기대">리액티브 선언 (<code class="language-plaintext highlighter-rouge">The Reactive Manifesto</code>) : 어플리케이션이 요청에 즉각 응답하고 가동되길 기대</h3>
<ul>
  <li>응답성 (<code class="language-plaintext highlighter-rouge">Responsive</code>) : 사용자에게 신뢰성 있는 응답을 빠르고 적절히 제공하는 능력</li>
  <li>탄력성 (<code class="language-plaintext highlighter-rouge">Resilient</code>) : 장애가 발생하더라도 시스템 전체에 영향을 주지 않고 복구하는 능력</li>
  <li>유연성 (<code class="language-plaintext highlighter-rouge">Elastic</code>) : 사용량에 변화가 있더라도 그에 비례해 자원을 조절해 균일한 응답성을 제공하는 능력</li>
  <li>메시지 기반 (<code class="language-plaintext highlighter-rouge">Message Driven</code>) : 비동기 메시지로 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향</li>
</ul>

<p>→ 4가지 요건을 만족하는 시스템을, 급변하는 상황을 적응할 수 있는 리엑티브 시스템 (<code class="language-plaintext highlighter-rouge">Reactive System</code>)이라 정의</p>

<h3 id="강결합에서-약결합의-아키텍처로의-변화">강결합에서 약결합의 아키텍처로의 변화</h3>
<ul>
  <li>소프트웨어 아키텍처 : 소프트웨어를 구성하는 요소와 그 구성 요소 간의 관계를 정의한 것
    <ul>
      <li>아키텍처를 정의하는 과정 : 시스템 구축을 위한 여러 비기능 요건들을 만족하는 해결 방법을 찾는 과정
        <ul>
          <li>비기능 요건 : 시스템 성능, 시스템 가용성, 보안, 유지보수성, 확장성 등</li>
        </ul>
      </li>
      <li>마이크로서비스 아키텍처는 ‘클라우드’라는 가상화된 인프라를 활용한 것이므로, 이를 고려해 설계해야 함</li>
    </ul>
  </li>
  <li>아키텍처 유연성 (<code class="language-plaintext highlighter-rouge">Architecture Flexibility</code>) : 시스템 자체가 변화 및 확장에 언제든지 대응할 수 있는 능력
    <ul>
      <li>시스템을 구성하는 구성 요소 간의 관계들이 느슨하게 결합되어 언제든지 대체되거나 확장될 수 있음</li>
      <li>리액티브 시스템이 리액티브하기 위해서 반드시 갖춰야 할 특성 중 하나</li>
      <li>클라우드 인프라 자체가 유연성과 확장성을 갖추므로, 어플리케이션 아키텍처 또한 아키텍처 유연성이 필요</li>
    </ul>
  </li>
</ul>

<iframe width="90%" height="350" style="border:none" src="https://landscape.cncf.io/?category=automation-configuration&amp;grouping=category&amp;fullscreen=yes"></iframe>

<ul>
  <li>과거 : 아키텍처 구성 요소들이 특정 벤더의 제품에 전적으로 의존
    <ul>
      <li>유명한 제품군을 사용함으로 품질이 보장될 수 있음</li>
      <li>특정 기술에 락인 (<code class="language-plaintext highlighter-rouge">lock-in</code>)되어 시스템을 쉽게 변경하거나 확장하기 어려움</li>
    </ul>
  </li>
  <li>현재 : 클라우드 환경 아래에서 사용하는 오픈 소스 기반 제품들이 충분한 기능, 품질, 호환성을 제공
    <ul>
      <li>아키텍처 설계가 필요한 레이어에서 적절한 솔루션을 선택하고 이를 조합하는 개방적 방식으로 변화</li>
      <li>클라우드 기반 어플리케이션의 구축에 필요한 인프라 및 어플리케이션 영역에 다양한 제품들이 등장</li>
    </ul>
  </li>
</ul>

<h2 id="msa-패턴--msa의-문제-영역에-대해-여러-사람들에-의해-검증되어-정리된-스타일-혹은-패턴"><code class="language-plaintext highlighter-rouge">MSA</code> 패턴 : <code class="language-plaintext highlighter-rouge">MSA</code>의 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 스타일 혹은 패턴</h2>
<ul>
  <li>인프라 구성 요소 : 마이크로서비스를 지탱하는 인프라스트럭처를 구축하는 데에 필요한 구성 요소</li>
  <li>플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴</li>
  <li>어플리케이션 패턴 : 마이크로서비스 어플리케이션을 구성하는 데에 필요한 패턴</li>
</ul>

<h3 id="인프라-구성-요소를-서비스-유형별로-나누어-해당되는-제품-중-하나를-의사결정--클라우드-인프라">인프라 구성 요소를 서비스 유형별로 나누어 해당되는 제품 중 하나를 의사결정 → 클라우드 인프라</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IaaS</code> (<code class="language-plaintext highlighter-rouge">Infrastructure as a Service</code>) : 가상 머신, 스트리지, 네트워크 등 인프라 제공
    <ul>
      <li>고객이 관리할 수 있는 범위가 가장 넓은 클라우드 컴퓨팅 서비스</li>
      <li><code class="language-plaintext highlighter-rouge">AWS</code> 등 퍼플릭 클라우드 공급 업체 (<code class="language-plaintext highlighter-rouge">CSP</code>)가 준비한 환경을 고객이 선택할 수 있음</li>
      <li>가상화된 물리적 자원을 <code class="language-plaintext highlighter-rouge">UI</code> 형태의 대시보드 혹은 <code class="language-plaintext highlighter-rouge">API</code> 형태로 제공</li>
      <li>고객은 서버와 스트리지에 접근할 수 있지만, 클라우드 내 가상 데이터 센터를 통해 리소스를 전달받는 형태</li>
      <li>개발자는 운영체제와 어플리케이션을 직접 관리해야 함 : 개발자와 인프라 관리자의 역할이 분담</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">AWS EC2</code>, <code class="language-plaintext highlighter-rouge">AWS S3</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CaaS</code> (<code class="language-plaintext highlighter-rouge">Container as a Service</code>) : 업로드, 구성, 실행, 확장, 중지할 수 있는 컨테이너 제공
    <ul>
      <li>가상 머신이 아닌 컨테이너를 기본 리소스로 활용해 어플리케이션을 개발, 실행, 관리</li>
      <li>컨테이너화된 어플리케이션을 빌드하고 배포하는 개발 환경은 퍼플릭 클라우드 공급 업체 (<code class="language-plaintext highlighter-rouge">CSP</code>)가 제공</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">Kubernetes Service</code>, <code class="language-plaintext highlighter-rouge">AWS ECS</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PaaS</code> (<code class="language-plaintext highlighter-rouge">Platform as a Service</code>) : 어플리케이션에 미들웨어, 런타임까지 탑재한 플랫폼을 제공
    <ul>
      <li>가상화된 클라우드 위에 원하는 서비스를 개발할 수 있도록 개발 환경을 미리 구축해 서비스 형태로 제공</li>
      <li>고객은 개발 환경을 고려할 필요 없이 어플리케이션 자체에 집중할 수 있음</li>
      <li>어플리케이션이 플랫폼에 종속되어 개발되므로, 다른 플랫폼으로의 이식이 어려울 수도 있음</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">Lambda</code>, <code class="language-plaintext highlighter-rouge">AWS Elastic Beanstalk</code></li>
    </ul>
  </li>
</ul>

<h3 id="시스템의-기반이-되는-인프라-레이어의-구축--베어메탈-장비-혹은-가상-인프라-환경을-통한-구축">시스템의 기반이 되는 인프라 레이어의 구축 → 베어메탈 장비 혹은 가상 인프라 환경을 통한 구축</h3>
<ul>
  <li>가상 인프라 환경 : 하이퍼바이저 (<code class="language-plaintext highlighter-rouge">Hypervisor</code>)의 사용 여부 및 게스트 OS 유무에 따라 나뉨
    <ul>
      <li>가상 머신 (<code class="language-plaintext highlighter-rouge">Virtual Machine</code>) : 하이퍼바이저를 통해 하나의 시스템에서 여러 운영체제를 사용
        <ul>
          <li>운영체제 패치 및 관련 라이브러리 설치로 인한 오버헤드가 지속적으로 발생</li>
        </ul>
      </li>
      <li>컨테이너 (<code class="language-plaintext highlighter-rouge">Container</code>) : 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성
        <ul>
          <li>도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 제어
            <ul>
              <li>이식성 : 도커만 실행할 수 있으면 호스트 커널에 상관없이 동일하게 사용</li>
              <li>신속성 : 크기가 작고 가벼워 빠른 배포가 가능 + 문제 발생 시 다시 가동하면 됨</li>
              <li>재사용성 : 동일한 환경을 재사용해 쉽게 설정 가능 → 서버 환경 구축이 쉬워짐</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>컨테이너 오케스트레이션 (<code class="language-plaintext highlighter-rouge">Container Orchestration</code>) : 컨테이너 관리 기술
        <ul>
          <li>컨테이너 배치 및 복제, 확장 및 축소, 장애 복구 컨테이너 간 통신, 로드밸런싱 등</li>
          <li>쿠버네티스 (<code class="language-plaintext highlighter-rouge">Kubernetes</code>) : <code class="language-plaintext highlighter-rouge">Pod</code>, <code class="language-plaintext highlighter-rouge">Deployment</code>, <code class="language-plaintext highlighter-rouge">Replica Sets</code> 정보 확인 가능
            <ul>
              <li>각 컨테이너가 요구하는 자원을 쿠버네티스에 요청하면 노드에 맞춰 자동 배치</li>
              <li>컨테이너 이상을 점검해, 실패하면 컨테이너를 자동으로 교체하고 리스케줄링</li>
              <li>일정량의 <code class="language-plaintext highlighter-rouge">CPU</code> 및 메모리 사용량을 초과하면 자동으로 수평 확장</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="마이크로서비스의-운영과-관리를-지원할-클라우드-플랫폼-미들웨어의-구축--플랫폼-패턴">마이크로서비스의 운영과 관리를 지원할 클라우드 플랫폼 (미들웨어)의 구축 → 플랫폼 패턴</h3>
<ul>
  <li>데비옵스 (<code class="language-plaintext highlighter-rouge">DevOps</code>) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화
    <ul>
      <li>소프트웨어를 빠르게 개발하게끔 지원하는 빌드, 테스트, 배포를 위한 자동화 환경</li>
      <li>지속적 제공 (<code class="language-plaintext highlighter-rouge">CI</code>) : 빌드된 소스 코드의 실행 파일을 실행 환경에 반영하기 전에 진행</li>
      <li>지속적 배포 (<code class="language-plaintext highlighter-rouge">CD</code>) : 저장소에 빌드한 소스 코드의 실행 파일을 실행 환경까지 자동으로 배포</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자동 빌드 및 배포 절차</p>
  <ol>
    <li>매일 자신이 작성한 소스 코드와 이를 테스트할 테스트 코드를 형상관리 시스템에 보낸다. (<code class="language-plaintext highlighter-rouge">Push</code>)</li>
    <li>매일 빌드 도구에서 형상관리 서버의 코드를 가져와 (<code class="language-plaintext highlighter-rouge">Pull</code>) 통합하고, 자동으로 빌드하고 테스트를 수행한다.</li>
    <li>테스트 수행 결과를 리포트에 기록하고, 빌드된 소스 코드를 스테이징 환경에 자동으로 배포한다.</li>
    <li>테스터가 스테이징 환경에서 테스트를 수행할 때 혹은 리포트 결과에 문제가 있으면, 소스 코드를 수정한다.</li>
  </ol>
</blockquote>

<ul>
  <li>빌드·배포 파이프라인의 설계 : 빌드·배포 과정동안 수행해야 할 업무 (<code class="language-plaintext highlighter-rouge">task</code>)를 정의한 것
    <ul>
      <li>리포지토리에서 소스 코드를 가져와 빌드해 실행 파일을 만드는 작업</li>
      <li>이전 작업이 성공하면, 다음 작업이 자동으로 수행히게끔 위의 작업들을 관리하는 작업</li>
      <li>실행할 어플리케이션을 실행 환경에 배포하는 작업</li>
    </ul>

    <p>→ <code class="language-plaintext highlighter-rouge">Infrastructure as Code</code>를 통해 빌드·배포 파이프라인의 절차를 완벽하게 자동화할 수 있음</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Infrastructure as Code</code> : 인프라 구성을 프로그래밍하는 것처럼 처리해 많은 컨테이너 배포 처리를 함
    <ul>
      <li>형상관리 리포지토리에서 소스 코드를 가져와 빌드하여 실행 파일을 만드는 작업</li>
      <li>실행 파일을 실행 환경에서 배포하는 작업</li>
      <li>작업들을 통제하고 연결해서 모든 작업이 성공하면 다음 작업이 자동으로 수행되도록 연계하는 작업</li>
    </ul>
  </li>
</ul>

<h3 id="마이크로서비스가-실제-구동되는-환경에서-동작될-수-있도록-운영-관리-요소--운영-관리-패턴">마이크로서비스가 실제 구동되는 환경에서 동작될 수 있도록 운영 관리 요소 → 운영 관리 패턴</h3>
<ul>
  <li>마이크로서비스의 발전 과정에서 아키텍처의 문제 영역들이 지속적으로 논의되었고, 이에 따른 해결책을 모색해옴
    <ul>
      <li>1999년 <code class="language-plaintext highlighter-rouge">XP</code> 방법론, 2001년 에자일 선언을 통해 빠른 실패와 피드백을 기반하는 실용적인 실천법 적용</li>
      <li>2010년 넷플릭스가 <code class="language-plaintext highlighter-rouge">AWS EC2</code>로 인프라를 전환하면서 발생한 문제점들을 해결하기 위한 넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code> 개발
        <ul>
          <li>여러 마이크로서비스 간의 라우팅을 위한 줄 (<code class="language-plaintext highlighter-rouge">Zuul</code>)</li>
          <li>적절한 부하 분산을 하는 로드밸런싱을 위한 리본 (<code class="language-plaintext highlighter-rouge">Ribbon</code>)</li>
          <li>모니터링을 위한 히스트릭스 (<code class="language-plaintext highlighter-rouge">Hystrix</code>)</li>
          <li>서비스 등록을 위한 유레카 (<code class="language-plaintext highlighter-rouge">Eureka</code>)</li>
        </ul>
      </li>
      <li>2013년 마이크로서비스를 쉽게 개발할 수 있는 스프링부트 (<code class="language-plaintext highlighter-rouge">SpringBoot</code>) 프레임워크가 발표</li>
      <li>2013년 도커, 2014년 쿠버네티스와 같은 컨테이너 기반 기술들이 개발</li>
    </ul>

    <p>→ 클라우드 환경, 넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code>, 프레임워크, 컨테이너 기반 기술이 아울러져 마이크로서비스 생태계를 계속 발전시킴</p>
  </li>
  <li>스프링 클라우드 : 스프링부트 + 넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code>
    <ul>
      <li>스프링 진영에서 기존 스프링 프레임워크에 넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code>들이 더 잘 돌아갈 수 있도록 통합하여 발표</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>마이크로서비스 서비스와 스프링 클라우드 서비스의 연계 흐름</p>
  <ol>
    <li>스프링 클라우드를 포함한 모든 마이크로서비스가 인프라에 종속되지 않도록 <code class="language-plaintext highlighter-rouge">DB</code>, 파일 등에 저장된 설정 정보를 형상관리 시스템에 연계된 <code class="language-plaintext highlighter-rouge">Config</code> 서비스에서 가져와 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩</li>
    <li>로딩과 동시에 ‘서비스 레지스트리’에 자신의 서비스 이름과 클라우드 인프라로부터 할당받은 물리 주소를 매핑</li>
    <li>클라이언트가 ‘<code class="language-plaintext highlighter-rouge">API</code> 게이트웨이’를 통해 마이크로서비스에 접근하면, …
      <ul>
        <li><code class="language-plaintext highlighter-rouge">API</code> 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드밸런싱을 수행</li>
        <li><code class="language-plaintext highlighter-rouge">API</code> 게이트웨이’는 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 ‘서비스 레지스트리’ 검색을 통해 서비스의 위치를 가져옴</li>
        <li>’<code class="language-plaintext highlighter-rouge">API</code> 게이트웨이’는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 확인하기 위해 ‘권한 서비스’와 연계해 인증 및 인가 처리를 수행</li>
      </ul>
    </li>
    <li>모든 마이크로서비스 간의 호출 흐름은 ‘모니터링 서비스’와 ‘추적 서비스’에 의해 모니터링되고 추적됨</li>
  </ol>
</blockquote>

<h4 id="다양한-서비스의-등록-및-탐색--서비스-레지스트리-서비스-디스커버리-패턴">다양한 서비스의 등록 및 탐색 → 서비스 레지스트리, 서비스 디스커버리 패턴</h4>

<ul>
  <li>예시 : 넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code> 유레카 (<code class="language-plaintext highlighter-rouge">Eureka</code>), 스프링 유레카 (<code class="language-plaintext highlighter-rouge">Spring Eureka</code>), 쿠버네티스 <code class="language-plaintext highlighter-rouge">DNS</code> 및 서비스</li>
</ul>

<blockquote>
  <ul>
    <li>프런트엔드 클라이언트가 여러 백엔드 마이크로서비스를 어떻게 호출해야 할까?</li>
    <li>
      <p>스케일 아웃을 통해 인스턴스가 여러 개로 복제되었을 때 어떻게 부하를 적절히 분산할 수 있을까?</p>

      <p>→ 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드밸런싱 기능이 제공되어야 한다!</p>
    </li>
    <li>라우터가 최적 경로를 탐색하려면 서비스 이름에 해당하는 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 알아야 함
      <ul>
        <li>그런데 이러한 라우팅 정보를 클라이언트가 가진다면, 클라우드 환경에서 동적으로 변경되는 백엔드의 유동 <code class="language-plaintext highlighter-rouge">IP</code> 정보를 매번 전송받아 변경해야 함 → 제3의 공간이 필요</li>
      </ul>

      <p>→ 마이크로서비스의 이름과 유동적인 백엔드의 유동 <code class="language-plaintext highlighter-rouge">IP</code> 정보를 보관할 저장소를 제공하자!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>각 서비스 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 레지스트리에 등록</li>
  <li>클라이언트가 해당 서비스 이름을 호출할 때, 라우터가 레지스트리 서비스를 검색해 매핑된 <code class="language-plaintext highlighter-rouge">IP</code> 주소를 호출</li>
  <li>즉, 레지스트리는 모든 마이크로서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소</li>
  <li>모든 마이크로서비스가 처음 가동될 때 자신의 위치 정보를 레지스트리에 저장하고, 서비스가 종료될 때 삭제</li>
  <li>레지스트리는 <code class="language-plaintext highlighter-rouge">Config</code>, 모니터링, 추적과 같이 관리와 운영을 위한 기반 서비스의 주소 또한 함께 보관</li>
</ul>

<h4 id="서비스-단일-진입--api-게이트웨이-패턴">서비스 단일 진입 → <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이 패턴</h4>

<ul>
  <li>예시 : 스프링 클라우드 <code class="language-plaintext highlighter-rouge">Spring API Gateway</code>, 쿠버네티스 인그레스 리소스 (<code class="language-plaintext highlighter-rouge">Ingress Resources</code>) 및 서비스</li>
</ul>

<blockquote>
  <ul>
    <li>
      <p>여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하면 호출 관계가 매우 복잡해짐</p>

      <p>→ 이러한 복잡한 호출 관계를 통제할 수 있는 방법이 필요하다!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">API</code> 게이트웨이 (<code class="language-plaintext highlighter-rouge">Gateway</code>) : 다양한 클라이언트가 다양한 서비스에 접근하기 위한 단일 진입점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">L4</code> 하드웨어 장비나 소프트웨어로 구현된 서비스 흐름 제어를 위한 서비스 라우팅 기능을 수행
        <ul>
          <li>다른 유형의 클라이언트에게 서로 다른 <code class="language-plaintext highlighter-rouge">API</code> 조합을 제공할 수 있음</li>
          <li>각 서비스에 접근할 때 필요한 인증 및 인가 기능을 한번에 처리할 수 있음</li>
          <li>서비스에 문제가 발생해 요청에 대한 응답 지연이 발생할 때 다른 서비스로 요청 경로를 변경할 수 있음</li>
        </ul>
      </li>
      <li>레지스트리 서비스와 연계하여 여러 인스턴스로 부하를 분산하는 동적 라우팅이나 로드밸런싱이 가능</li>
      <li>권한 서비스와 연계하여 인증 및 인가 처리를 수행할 수 있음</li>
      <li>로그 집계 서비스와 연계하여 요청 및 응답 데이터 등에 대한 로깅이 가능</li>
      <li>에러율, 평균/최고 지연 시간, 호출 빈도와 같이 시간에 따른 환경 변화를 추적할 수 있는 메트릭 (<code class="language-plaintext highlighter-rouge">Metric</code>) 데이터를 시계열 형태로 저장할 수 있음</li>
      <li>트래킹 <code class="language-plaintext highlighter-rouge">ID</code> 추적과 같이 트레이싱 서비스와 연계하여 서비스 추적이 가능</li>
      <li>모니터링 서비스와 연계해 장애 격리가 가능 → 서킷 브레이커 패턴</li>
    </ul>
  </li>
</ul>

<h4 id="다양한-클라이언트에-대한-특화된-처리--bff-패턴">다양한 클라이언트에 대한 특화된 처리 → <code class="language-plaintext highlighter-rouge">BFF</code> 패턴</h4>

<ul>
  <li>진입점을 하나로 두는 <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이와 달리, 프런트엔드의 유형에 따라 각각의 진입점을 둠</li>
  <li>프런트엔드를 위한 백엔드라는 의미에서 <code class="language-plaintext highlighter-rouge">Backend for Frontend</code></li>
  <li>각 프런트엔드에 대한 처리만 수행하는 <code class="language-plaintext highlighter-rouge">BFF</code> 이후에 통합 <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이를 두어, 공통 처리를 통제할 수도 있음</li>
</ul>

<h4 id="마이크로서비스-어플리케이션-구성-정보의-관리--외부-구성-저장소-패턴">마이크로서비스 어플리케이션 구성 정보의 관리 → 외부 구성 저장소 패턴</h4>

<ul>
  <li>예시 : 스프링 클라우드 <code class="language-plaintext highlighter-rouge">Spring Cloud Config</code>, 쿠버네티스 컨피그맵 (<code class="language-plaintext highlighter-rouge">ConfigMap</code>)</li>
</ul>

<blockquote>
  <ul>
    <li>클라우드 인프라를 사용할 때, 어플리케이션이 마이크로서비스가 사용하는 자원의 설정 정보를 포함하면?
      <ul>
        <li>자원의 설정 정보이 변경될 때 어플리케이션이 반드시 재배포해야 하므로 서비스가 중단되어야 함</li>
        <li>여러 마이크로서비스가 동일한 구성 정보를 사용한다면 이를 일일이 변경하기가 어려움</li>
        <li>여러 마이크로서비스를 변경하는 시점에 일부 마이크로서비스의 구성 정보가 불일치할 수도 있음</li>
      </ul>

      <p>→ 마이크로서비스가 사용하는 자원의 설정 정보를 쉽고 일관되게 변경 가능하도록 관리해야 한다!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>외부 저장소 : <code class="language-plaintext highlighter-rouge">DB</code> 연결 정보, 파일 스토리지 정보와 같이 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 관리</li>
  <li><code class="language-plaintext highlighter-rouge">Config</code> 원칙 : <code class="language-plaintext highlighter-rouge">Staging</code>, <code class="language-plaintext highlighter-rouge">Dev</code>, <code class="language-plaintext highlighter-rouge">Test</code>처럼 어플리케이션 배포 환경은 매번 달라지니, 코드와 설정 정보는 분리돼야
    <ul>
      <li>클라우드에서 운영되는 어플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안됨
        <ul>
          <li>배포 시 변경될 호스트명, 백엔드 서비스의 연결을 위한 리소스 정보, 서버의 <code class="language-plaintext highlighter-rouge">IP</code> 주소나 포트 정보 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="사용자의-신원을-증명하고-접근-권한을-부여--인증-및-인가-패턴">사용자의 신원을 증명하고, 접근 권한을 부여 → 인증 및 인가 패턴</h4>

<blockquote>
  <ul>
    <li>
      <p>여러 마이크로서비스에 대한 인증 및 인가에 대한 접근 제어는 어떻게 구현해야 할까?</p>

      <p>→ 각 서비스가 모두 인증 및 인가를 중복으로 구현하는 것은… 당연히 비효율적!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>중앙 집중식 세션 관리
    <ul>
      <li>마이크로서비스는 사용량에 따라 수시로 수평 확장되어 로드밸런싱이 되기 때문에 세션 데이터가 손상될 수 있음</li>
      <li>각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장해 모든 서비스가 같은 사용자 데이터를 얻게 함</li>
      <li>레디스 (<code class="language-plaintext highlighter-rouge">Redis</code>) 등을 세션 저장소로 사용</li>
    </ul>
  </li>
  <li>클라이언트 토큰
    <ul>
      <li>중앙 서버에 저장되는 세션과 달리, 토큰은 사용자의 브라우저에 저장</li>
      <li>사용자의 신원 정보를 가진 토큰은 서버로 요청을 보낼 때 전송되기 때문에 서버에서 인가 처리를 할 수 있음</li>
      <li><code class="language-plaintext highlighter-rouge">JWT</code> : 토큰 형식을 정의하고 암호화되는 공개 표준 (<code class="language-plaintext highlighter-rouge">RFC 7519</code>)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>클라이언트 토큰을 통한 사용자 인증의 흐름</p>

  <ol>
    <li>브라우저가 사버에 사용자 이름과 패스워드로 인증을 요청한다.</li>
    <li>서버는 인증 후에 사용자 정보의 인증 및 인가 정보를 포함하여 토큰을 생성하고 브라우저에 전송한다.</li>
    <li>브라우저는 서버 자원을 요청할 때 토큰을 함께 보내고, 서버는 토큰 정보를 확인한 후 자원 접근을 허가한다.</li>
  </ol>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">API</code> 게이트웨이를 사용한 클라이언트 토큰
    <ul>
      <li><code class="language-plaintext highlighter-rouge">API</code> 게이트웨이가 외부 요청의 입구로 추가되어 인증 프로세스를 진행</li>
      <li>인증 및 인가를 위한 별도의 전담 서비스가 <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이와 연동하여 다른 서비스의 인증 및 인가 처리를 위임
→ 인증 서비스 (<code class="language-plaintext highlighter-rouge">Auth Service</code>)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">API</code> 게이트웨이와 인증 서비스를 활용한 클라이언트 토큰을 통한 사용자 인증의 흐름</p>

  <ol>
    <li>클라이언트가 리소스 서비스에 접근을 요청하면, <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이는 인증 서비스에 전달한다.</li>
    <li>인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지 확인하고 (→ 인증),</li>
    <li>인증 서비스는 해당 요청이 해당 리소스에 대한 접근 권한이 있는지 확인하고 (→ 인가),</li>
    <li>모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토큰 (<code class="language-plaintext highlighter-rouge">Access Token</code>)을 발급한다.</li>
    <li>클라이언트는 다시 액세스 토큰을 활용해 접근을 요청한다.</li>
    <li>각 리소스 서비스는 이러한 요청이 액세스 토큰을 포함하고 있는지 판단하여 리소스에 대한 접근을 허용한다.</li>
  </ol>
</blockquote>

<h4 id="장애-및-실패-처리--서킷-브레이커-패턴">장애 및 실패 처리 → 서킷 브레이커 패턴</h4>

<blockquote>
  <ul>
    <li>여러 서비스로 구성된 시스템에서 한 서비스에 장애가 생기면, 다른 서비스가 영향을 받을텐데…?
      <ul>
        <li>전체 시스템은 정상적인데, 특정 기능을 누르면 한참 대기하는 경우 → 장애가 다른 서비스로 전이되었다!</li>
      </ul>

      <p>→ 장애가 발생한 서비스를 격리해서 유연하게 처리하자!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>서킷 브레이켜 (<code class="language-plaintext highlighter-rouge">Circuit Breaker</code>) : 시스템 과부하나 특정 서비스에 문제가 생겼을 때, 자연스럽게 다른 정상적인 서비스로 요청 흐름을 변경하는 것 → 장애가 다른 서비스로 전이되지 않게 하자!
    <ul>
      <li><code class="language-plaintext highlighter-rouge">A → B → A</code>의 서비스 흐름에서 <code class="language-plaintext highlighter-rouge">B</code> 서비스가 장애가 생겼을 때, <code class="language-plaintext highlighter-rouge">A</code>가 동기 요청을 보내면? : 계속 기다린다…
        <ul>
          <li><code class="language-plaintext highlighter-rouge">B</code> 서비스 호출에 대한 연속 실패 횟수가 임계값을 초과하면, 이후 서비스 호출 시도를 모두 실패로 처리</li>
          <li>풀백 (<code class="language-plaintext highlighter-rouge">Fallback</code>) 메소드를 지정해 정상 응답을 대신할 대체 응답을 사용자에게 제공</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="마이크로서비스의-장애-감지--모니터링-및-추적-패턴">마이크로서비스의 장애 감지 → 모니터링 및 추적 패턴</h4>

<ul>
  <li>예시 : 스프링 클라우드 히스트릭스 (<code class="language-plaintext highlighter-rouge">Hystrix</code>) + 집킨 (<code class="language-plaintext highlighter-rouge">Zipkin</code>)</li>
</ul>

<blockquote>
  <ul>
    <li>
      <p>그래서 서킷 브레이커는 언제, 어떻게 작동하는데…?</p>

      <p>→ 각 마이크로서비스의 장애를 실시간으로 감지할 수 있고, 서비스 간의 호출을 파악하자!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>히스트릭스 대시보드 : 각 요청의 트래픽이 원형으로 표현 → 서비스 성능에 문제가 생기면, 서킷 브레이커 발동 (<b style="color: red;">⦁</b>)</li>
  <li>집킨 대시보드 : 각 서비스 트랜잭션의 호출을 추적하거나, 지연 구간별 장애 포인트를 확인할 수 있음
    <ul>
      <li>서비스 <code class="language-plaintext highlighter-rouge">API</code>를 선택하면, 각 <code class="language-plaintext highlighter-rouge">API</code>가 다른 <code class="language-plaintext highlighter-rouge">API</code>를 어떻게 호출하는지 확인 가능
        <ul>
          <li>전체적인 <code class="language-plaintext highlighter-rouge">API</code> 간의 호출 빈도를 확인할 수 있는 정적 다이어그램 또한 제공</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="마이크로서비스의-로그-관리--중앙화된-로그-집계-패턴">마이크로서비스의 로그 관리 → 중앙화된 로그 집계 패턴</h4>

<blockquote>
  <ul>
    <li>마이크로서비스가 사용량에 따라 탄력적으로 변화하면, 그 인스턴스가 삭제되면 로컬 로그는 초기화..?
      <ul>
        <li>로그 (<code class="language-plaintext highlighter-rouge">Logs</code>) 원칙 : 로그는 이벤트 스트림 (<code class="language-plaintext highlighter-rouge">Event Streams</code>)로 처리되어야 함
          <ul>
            <li>로그는 시작과 끝이 고정된 것이 아니라, 서비스가 실행되는 동안 계속 흐르는 흐름</li>
            <li>서비스는 스트림의 전달 및 저장에 절대 관여하면 안됨!
              <ul>
                <li>로그를 전달하거나 저장하는 매커니즘 자체가 특정한 기술 및 인프라에 의존하게 됨</li>
                <li>마이크로서비스가 로그 관련 매커니즘을 직접 구현하면 유연성이 떨어짐</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

      <p>→ 서비스에서 발생한 이벤트 스트림 형태의 로그를 수집하고 분석할 방법을 찾자!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ELK</code> 스택 : 엘라스틱서치 &amp; 로그스태시 &amp; 키바나를 기반으로 하는 데이터 분석 환경을 구성
    <ul>
      <li>엘라스틱서치 (<code class="language-plaintext highlighter-rouge">ElasticSearch</code>) : 분산형 검색 및 분석 엔진
        <ul>
          <li>정형, 비정형, 위치 정보, 메트릭 등 원하는 방법으로 검색을 수행 및 결합 가능</li>
        </ul>
      </li>
      <li>로그스태시 (<code class="language-plaintext highlighter-rouge">Logstash</code>) : 서버 측의 로그 집합기
        <ul>
          <li>여러 소스에서 동시에 데이터를 수집 및 변한하여 특정 보관소로 데이터를 전송하는 데이터 처리 파이프라인</li>
        </ul>
      </li>
      <li>키바나 (<code class="language-plaintext highlighter-rouge">Kibana</code>) : 시각적으로 로그 내역을 보여주는 대시보드
        <ul>
          <li>위치 데이터, 시계열 분석, 그래프 관계 등을 히스토그램, 막대 그래프, 파이차트 등의 형태로 표현</li>
        </ul>
      </li>
    </ul>

    <p>→ 각 서비스의 인스턴스 로그를 집계해서 중앙에서 집중 관리할 수 있고, 특정 로그를 검색 및 분석할 수 있음</p>
  </li>
</ul>

<blockquote>
  <ol>
    <li>마이크로서비스 내의 로그를 중앙 서버의 레디스로 전송한다.</li>
    <li>중앙 서버의 레디스에서 중앙 로그 저장소에 해당 로그들을 전송한다.</li>
    <li>중앙 로그 저장소에 엘라스틱서치 엔진이 로그를 인덱싱한다.</li>
    <li>해당 로그 정보를 키바나 대시보드를 통해 표현한다.</li>
  </ol>

  <ul>
    <li>중간 지점에 레디스가 존재하는 이유? : 마이크로서비스의 로그스태시에서 보낸 로그 스트림이 중앙 로그 저장소에 몰리면 성능상의 문제가 생길 수 있으므로 임시 저장소 역할의 레디스를 추가</li>
  </ul>
</blockquote>

<h4 id="msa-운영-관리-패턴의-변화-1--쿠버네티스-kubernetes"><code class="language-plaintext highlighter-rouge">MSA</code> 운영 관리 패턴의 변화 1 : 쿠버네티스 (<code class="language-plaintext highlighter-rouge">Kubernetes</code>)</h4>

<ul>
  <li>기존 : 문제마다 상이한 기술들로 접근하여 해결
    <ul>
      <li>넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code>나 스프링 클라우드를 이용해 각각의 서비스를 별도로 둠</li>
      <li>유연성처럼 수평 확장이 필요한 요소들은 <code class="language-plaintext highlighter-rouge">AWS IaaS</code> 서비스를 통해 해결</li>
    </ul>
  </li>
  <li>현재 : 쿠버네티스 하나로 모든 문제들을 해결
    <ul>
      <li>인프라 차원의 <code class="language-plaintext highlighter-rouge">AWS IaaS</code> → 컨테이너 레플리카 기술로 탐색 및 호출을 통합한 소프트웨어 차원의 쿠버네티스</li>
    </ul>
  </li>
</ul>

<h4 id="msa-운영-관리-패턴의-변화-2--서비스-메시-service-mash"><code class="language-plaintext highlighter-rouge">MSA</code> 운영 관리 패턴의 변화 2 : 서비스 메시 (<code class="language-plaintext highlighter-rouge">Service Mash</code>)</h4>

<ul>
  <li>기존 : <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이, 서비스 레지스트리, <code class="language-plaintext highlighter-rouge">Config</code> 서비스와 같이 운영 관리를 위한 여러 기반 서비스를 별도로 둠
    <ul>
      <li>업무 처리 마이크로서비스에 스프링 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함께 탑재</li>
      <li>스프링 클라우드는 <code class="language-plaintext highlighter-rouge">Java</code> 기반이므로, 다른 언어로 폴리글랏하게 구현할 수 없음</li>
    </ul>
  </li>
  <li>현재 : 이스티오과 같은 서비스 메시 패턴을 적용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">MSA</code> 문제 영역 해걸을 위한 기능을 비즈니스 로직과 분리해 네트워크 인프라 계층에서 수행</li>
      <li>인프라 레이어로서 서비스 간의 통신을 처리하여 문제 해결 패턴을 포괄해 처리</li>
    </ul>
  </li>
  <li>이스티오 (<code class="language-plaintext highlighter-rouge">Istio</code>) : 서비스 메시 패턴의 대표적인 구현체
    <ul>
      <li>사이드카 (<code class="language-plaintext highlighter-rouge">Sidecar</code>) 패턴 : 어플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포
        <ul>
          <li>마이크로서비스마다 함께 배포되는 사이드카 프락시에 운영 관리를 위한 기능이 별도로 존재</li>
          <li>운영 관리 기능과 별개로 존재하는 마이크로서비스는 순수한 비즈니스 로직으로 제공될 수 있음</li>
          <li>컨트롤 플레인 (<code class="language-plaintext highlighter-rouge">Control Plain</code>)으로 중앙에서 통제되며, 사이드카끼리 통신하여 관련 운영 관리 기능 제공</li>
        </ul>

        <p>→ 쿠버네티스의 파드 (<code class="language-plaintext highlighter-rouge">Pod</code>)에 서비스 컨테이너와 사이드카 구현체인 엔보이 (<code class="language-plaintext highlighter-rouge">Envoy</code>) 컨테이너가 함께 배포</p>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>넷플릭스 <code class="language-plaintext highlighter-rouge">OSS</code> &amp; 스프링 클라우드와 이스티오의 차이점</p>

  <ul>
    <li>이스티오는 사이드카로 격리되어 <code class="language-plaintext highlighter-rouge">YAML</code>과 같은 설정 파일르 정의되어 어플리케이션 코드 변경이 거의 없음</li>
    <li><code class="language-plaintext highlighter-rouge">Java</code>만이 아닌, 폴리글랏 어플리케이션도 지원 가능</li>
    <li>쿠버네티스와 완벽하게 통합된 환경을 지원</li>
  </ul>
</blockquote>

<h3 id="마이크로서비스-어플리케이션-구현을-위한-마이크로서비스-구성-및-설계--어플리케이션-패턴">마이크로서비스 어플리케이션 구현을 위한 마이크로서비스 구성 및 설계 → 어플리케이션 패턴</h3>

<ul>
  <li>어플리케이션 영역에서도 유연성, 확장성, 독립성을 염두에 두어 설계되어야 함 → 백엔드, 프론트엔드 영역 모두!</li>
</ul>

<h4 id="마이크로-프론트엔드--ui-컴포넌트-패턴">마이크로 프론트엔드 → <code class="language-plaintext highlighter-rouge">UI</code> 컴포넌트 패턴</h4>

<blockquote>
  <ul>
    <li>마이크로서비스의 장점인 서비스의 독립적인 변경 및 배포를, 기존 모노리스 프론트엔드로는 힘들텐데…?
      <ul>
        <li>모노리스 프론트엔드 : 백엔드의 여러 <code class="language-plaintext highlighter-rouge">API</code>를 호출하고 조합하여 화면을 구성해 표현</li>
      </ul>
    </li>
  </ul>

  <p>→ 프론트엔드도 마이크로서비스처럼 기능별로 분리하고 각 프런트엔드를 조합하여 동작하게 하자!</p>
</blockquote>

<ul>
  <li>프레임 (<code class="language-plaintext highlighter-rouge">Frame</code>) 형태의 부모 창에 각 마이크로 프론트엔드를 조합해 동작
    <ul>
      <li>실제 각 기능의 표현은 마이크로 프런트엔드 조각이 구현 → 여러 백엔드 마이크로서비스 <code class="language-plaintext highlighter-rouge">API</code> 호출</li>
    </ul>
  </li>
</ul>

<h4 id="프론트엔드--백엔드-백엔드--백엔드-간의-통신--마이크로서비스-통신-패턴">프론트엔드 ↔ 백엔드, 백엔드 ↔ 백엔드 간의 통신 → 마이크로서비스 통신 패턴</h4>

<ul>
  <li>동기 호출 방식 : 클라이언트에서 서버 측에 존재하는 마이크로서비스 <code class="language-plaintext highlighter-rouge">REST API</code>를 호출할 때 사용
    <ul>
      <li>사용자가  <code class="language-plaintext highlighter-rouge">A</code> 서비스에 <code class="language-plaintext highlighter-rouge">B</code> 서비스가 필요한 <code class="language-plaintext highlighter-rouge">HTTP GET</code> 방식의 요청을 보내면,
        <ol>
          <li><code class="language-plaintext highlighter-rouge">A</code> 서비스가 <code class="language-plaintext highlighter-rouge">B</code> 서비스에 <code class="language-plaintext highlighter-rouge">HTTP GET</code> 방식의 동기 호출을 수행하고,</li>
          <li><code class="language-plaintext highlighter-rouge">B</code> 서비스가 응답을 발생한다. (성공 시 <code class="language-plaintext highlighter-rouge">200 OK</code>)</li>
        </ol>
      </li>
      <li>다양한 클라이언트 채널 연계나 라우팅, 로드밸런싱을 원활하기 위해 <code class="language-plaintext highlighter-rouge">API</code> 게이트웨이를 둘 수 있음</li>
      <li>요청을 보내면 바로 응답이 오는 직관적인 방식이므로, 가장 많이 쓰이고 구현하기 쉬움</li>
      <li>호출을 받은 마이크로서비스에 장애가 생긴다면, 요청을 보낸 서비스는 응답할 때까지 대기하면서 재호출
        <ul>
          <li>여러 서비스 간의 연계를 통해 업무를 처리하는 마이크로서비스에서는 장애가 연쇄적으로 발생할 수 있음</li>
          <li>서비스가 다른 서비스를 호출해서 얻은 정보로 기능을 제공한다는 것은, 서비스 간의 의존도가 높다는 의미</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>메시지 기반 비동기 (<code class="language-plaintext highlighter-rouge">asynchronous</code>) 통신 방식 : 메시지를 보내면, 응답을 기다리지 않고 다음 업무 처리
    <ul>
      <li>메시지 브로커 (<code class="language-plaintext highlighter-rouge">Message Broker</code>) : 동기식처럼 완결성을 보장할 수 없으니, 이를 보장하는 메커니즘을 활용
        <ul>
          <li>아파치 카프카 (<code class="language-plaintext highlighter-rouge">Apache Kafka</code>), 레빗엠큐 (<code class="language-plaintext highlighter-rouge">RabbitMQ</code>) 등</li>
          <li>메시지를 보내는 생산자 (<code class="language-plaintext highlighter-rouge">Producer</code>)와 메시지를 받아 처리하는 소비자 (<code class="language-plaintext highlighter-rouge">Consumer</code>)
            <ul>
              <li>생산자와 소비자가 서로 직접 접속하지 않고 메시지 브로커를 통해 연결</li>
              <li>메시지 브로커에 메시지를 전달하고 자신의 일을 처리하면, 메시지 브로커가 전송을 보장</li>
            </ul>
          </li>
          <li>메시지 브로커으로 중계되므로, 서로 통신하는 서비스들이 물리적으로 동일한 시스템에 위치하지 않아도 됨</li>
          <li>서로 프로세스를 공유할 필요도 없으며, 동일한 시간대에 동시에 동작하지 않아도 됨</li>
        </ul>
      </li>
      <li>비동기 방식의 이벤트 기반 아키텍처 (<code class="language-plaintext highlighter-rouge">Event-driven Architecture</code>) : 비동기 통신 방식으로 느슨한 연계 지향
        <ol>
          <li>분산 시스템 간에 발신자가 이벤트를 생성 및 발행 (<code class="language-plaintext highlighter-rouge">Publish</code>)하여,</li>
          <li>해당 이벤트를 필요로 하는 수신자에게 전송하면,</li>
          <li>이벤트를 구독 (<code class="language-plaintext highlighter-rouge">Subscribe</code>)하고 있던 수신자가 이벤트를 받아 처리한다.</li>
        </ol>

        <p>→ 순서에 따라 특정 행동이 발생하는 기존의 방식이 아닌, ‘상태의 변화’를 의미하는 이벤트에 대한 반응으로 동작</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="마이크로서비스를-독립적으로-수정-및-배포--저장소-분리-패턴">마이크로서비스를 독립적으로 수정 및 배포 → 저장소 분리 패턴</h4>

<blockquote>
  <ul>
    <li>기존 모노리스 시스템의 저장소인 통합 저장소의 문제점?
      <ul>
        <li>어플리케이션 모듈은 분리하되 저장 처리는 모듈별로 격리하지 않고 다른 모듈에서의 호출을 허용</li>
        <li>모든 비즈니스 로직이 데이터베이스의 <code class="language-plaintext highlighter-rouge">SQL</code> 처리에 몰려있는 경우가 대부분</li>
        <li>데이터 중심 어플리케이션은 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려움</li>
        <li>성능 문제가 발생하였을 때, <code class="language-plaintext highlighter-rouge">SQL</code> 구문 튜닝이나 <code class="language-plaintext highlighter-rouge">Scale-up</code>에 의존할 수 밖에 없음</li>
        <li>여러 마이크로서비스로 분리해도 요쳥이 증가하면 데이터베이스만 바쁜 상태가 됨
          <ul>
            <li>자동으로 확장되는 마이크로서비스의 <code class="language-plaintext highlighter-rouge">Scale-out</code>이 무의미함</li>
          </ul>
        </li>
      </ul>

      <p>→ 여러 개의 마이크로서비스에 적합하게 데이터베이스 벤더를 운영하는 방법을 찾자!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다!</li>
  <li>자신이 가진 데이터는 다른 서비스에 직접 노출하지 않고 각자 공개한 <code class="language-plaintext highlighter-rouge">API</code>를 통해서 접근 가능 → 정보 은닉</li>
  <li>저장소가 격리되어 있기 때문에 각 저장소를 자율적으로 선택할 수 있음 → 폴리글랏 저장소</li>
  <li>해당 제약을 통해 데이터를 통한 변경의 파급 효과를 줄여 서비스를 독립적으로 만듬</li>
</ul>

<h4 id="여러-분산된-서비스를-하나의-일관된-트랜잭션으로--분산-트랜잭션-처리-패턴">여러 분산된 서비스를 하나의 일관된 트랜잭션으로 → 분산 트랜잭션 처리 패턴</h4>

<blockquote>
  <ul>
    <li>저장소 분리 패턴의 문제점?
      <ul>
        <li>여러 분산된 서비스에 걸친 비즈니스 처리를 하면, 비즈니스 정합성과 데이터 일관성은 어떻게 보장하지?</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>2단계 커밋 : 분산 데이터베이스 환경에서 원자성 (<code class="language-plaintext highlighter-rouge">atomicity</code>)을 보장하기 위해,
    <ul>
      <li>분산 트랜잭션에 포함된 모든 노드가 커밋 (<code class="language-plaintext highlighter-rouge">commit</code>) 혹은 롤백 (<code class="language-plaintext highlighter-rouge">rollback</code>)되는 메커니즘</li>
      <li>각 서비스에 <code class="language-plaintext highlighter-rouge">lock-in</code>이 걸려 발생하는 성능 문제로 비효율적인 방법</li>
      <li>각 서비스가 다른 인스턴스로 로딩되므로 이를 통제하기 어려움</li>
      <li>서비스의 저장소가 각각 다를 경우에 문제가 발생 (<code class="language-plaintext highlighter-rouge">NoSQL</code> 저장소 : 2단계 커밋 미지원)</li>
      <li>네트워크 장애 등으로 특정 서비스의 트랜잭션을 처리하지 않는 경우 트랜잭션이 묶인 서비스에 즉시 영향</li>
    </ul>
  </li>
  <li>사가 (<code class="language-plaintext highlighter-rouge">Saga</code>) 패턴 : 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴
    <ul>
      <li>여러 분산된 서비스 내에서 각각의 로컬 트랜잭션과 보상 트랜잭션을 통해 비즈니스 및 데이터의 정합성을 맞춤
        <ol>
          <li>각 로컬 트랜잭션을 통해 자신의 데이터베이스를 갱신한다.</li>
          <li>사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 이벤트를 발행하여 데이터의 일관성을 맞춘다.</li>
          <li>서비스에서 트랜잭션 처리에 실패하면, 앞선 다른 서비스에 처리된 트랜잭션을 롤백할 보상 트랜잭션을 준다.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>데이터 일관성에 대한 생각의 전환 → 결과적 일관성
    <ul>
      <li>이전엔 비즈니스 처리를 위한 규칙을 만족시킬, 데이터 일관성을 반드시 실시간으로 맞춰야 한다고 생각했다.</li>
      <li>그러나 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것이 아니다. 어떤 비즈니스들은 어느 일정 시점이 되었을 때 일관성을 만족해도 된다. → 결과적 일관성 (<code class="language-plaintext highlighter-rouge">Eventual Consistency</code>)</li>
      <li>이벤트 기반 비동기 통신 및 사가 패턴을 적용한 아키텍처, 메시지 브로커을 활용하여, 결과적 일관성을 반영해 비즈니스 및 시스템의 가용성을 극대화할 수 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="읽기와-쓰기의-분리--cqrs-패턴">읽기와 쓰기의 분리 → <code class="language-plaintext highlighter-rouge">CQRS</code> 패턴</h4>

<blockquote>
  <ul>
    <li>마이크로서비스의 서비스별 데이터 저장소에서 전통적인 <code class="language-plaintext highlighter-rouge">DB</code> 트랜잭션을 사용하면?
      <ul>
        <li>데이터 읽기 및 수정 작업으로 인한 리소스 교착 상태가 발생할 수 있다.</li>
      </ul>

      <p>→ 동일한 저장소에 데이터를 넣은 뒤에 <code class="language-plaintext highlighter-rouge">CRUD</code>를 처리하는, 기존의 패러다임을 전환하는 것은 어떨까!</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>명령 조회 책임 분리 (<code class="language-plaintext highlighter-rouge">Command Query Responsibility Segregation</code>)
    <ul>
      <li>사용자의 비즈니스 요청은 시스템의 상태를 변경하는 연산과 시스템의 상태를 조회하는 연산으로 나눠짐</li>
      <li>일반적인 비즈니스 모델에서는 입력, 수정, 삭제보다 조회가 더 많이 사용됨
        <ul>
          <li>서비스 내에 모든 기능을 넣으면 조회 요청 빈도가 증가함에 따라 다른 명령 기능 또한 확장되니 비효율적</li>
        </ul>
      </li>
      <li>하나의 저장소에 쓰기 모델과 읽기 모델을 분리하거나, 쓰기 저장소와 조회 저장소를 따로 두자!
        <ul>
          <li>쓰기 시스템의 부하를 줄이면서, 조회 대기 시간을 줄일 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">CQRS</code> 패턴을 적용한 예시</p>

  <ol>
    <li>명령 측면의 마이크로서비스
      <ul>
        <li>입력, 수정, 삭제 처리를 수행</li>
        <li>쓰기에 최적화된 관계형 데이터베이스를 저장소로 활용</li>
        <li>업무 규칙을 표한하기 좋은 언어 (<code class="language-plaintext highlighter-rouge">Java</code>)를 프로그래밍 언어로 사용</li>
      </ul>
    </li>
    <li>조회 측면의 마이크로서비스
      <ul>
        <li>조회 서비스는 사용량이 많으므로, 스케일 아웃을 통해 인스턴스를 증가시킴</li>
        <li>조회 성능이 높은 <code class="language-plaintext highlighter-rouge">NoSQL</code> 데이터베이스를 저장소로 활용</li>
        <li>조회를 간단하게 구현할 수 있는 언어 (<code class="language-plaintext highlighter-rouge">Node.js</code>)를 프로그래밍 언어로 사용</li>
      </ul>
    </li>
    <li>이벤트 주도 아키텍처
      <ul>
        <li>명령 서비스를 사용함에 따라 조회 서비스와의 데이터 일관성이 깨지므로 이를 유지하는 목적</li>
      </ul>
      <ol>
        <li>명령 서비스가 저장소에 데이터를 쓸 때, 저장 내역이 담긴 이벤트를 발생시켜 메시지 브로커에 전달</li>
        <li>메시지 브로커의 이벤트를 구독하는 조회 서비스는 이벤트 데이터를 가져와 데이터를 최신으로 동기화
          <ul>
            <li>시간 간격이 있으나 어느 시점에 일치하는 결과적 일관성이 이루어짐</li>
          </ul>
        </li>
      </ol>
    </li>
  </ol>
</blockquote>

<h4 id="저장소가-격리된-여러-마이크로서비스의-기능들을-연계한-서비스-제공--api-조합과-cors">저장소가 격리된 여러 마이크로서비스의 기능들을 연계한 서비스 제공 → <code class="language-plaintext highlighter-rouge">API</code> 조합과 <code class="language-plaintext highlighter-rouge">CORS</code></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">API</code> 조합 (<code class="language-plaintext highlighter-rouge">API Composition</code>) : 기능을 제공하는 마이크로서비스를 조합할 상위 마이크로서비스로 조합된 기능 제공
    <ul>
      <li>하위 서비스는 각자 독립적인 <code class="language-plaintext highlighter-rouge">API</code>를 제공하면서 연계 <code class="language-plaintext highlighter-rouge">API</code>를 위해 상위 서비스에 정보 제공</li>
    </ul>

    <p>→ 상위 서비스가 하위 서비스에 의존되는 결과를 가져옴 : 하위 서비스의 실패가 상위 서비스에 영향을 준다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CQRS</code> 패턴을 활용한 기능 연계 : 상위 마이크로서비스에 통합 이벤트 핸들러와 통합 저장소를 두자
    <ol>
      <li>독자 저장소를 갖는 하위 서비스에서 자신의 서비스 내 정보가 변경될 때 변경 내역을 각 변경 이벤트로 발행</li>
      <li>상위 서비스는 구독한 이벤트를 가져와서 자신의 서비스 저장소에 기록해 데이터 일관성을 맞춤</li>
    </ol>
  </li>
</ul>

<h4 id="쓰기-연산의-최적화--이벤트-소싱-패턴">쓰기 연산의 최적화 → 이벤트 소싱 패턴</h4>

<blockquote>
  <ul>
    <li>사가 패턴과 <code class="language-plaintext highlighter-rouge">CQRS</code> 패턴에서 비즈니스 불일치를 피하려면,
      <ul>
        <li>저장소에 저장하는 것과 메시지를 보내는 것은 언제나 완전하게 진행되어야 하지만,
          <ul>
            <li>객체의 상태를 관계형 데이터베이스에 저장하기 위해 <code class="language-plaintext highlighter-rouge">SQL</code> 질의어로 변환하는 것은 번거로움</li>
            <li>메시지 발행과 저장 처리의 두 가지 기능을 수행하는 것 또한 빠르지 않음</li>
          </ul>
        </li>
      </ul>

      <p>→ 메시지 발행과 저장 처리를 언제나 완전하게 처리하면서 성능도 최적화시킬 방법을 찾자!</p>
    </li>
    <li>비즈니스를 처리할 때 데이터의 처리는 항상 처리 상태의 결괏값을 계산하고 데이터의 최종 상태를 확정해 저장
      <ol>
        <li>일반적인 관계형 데이터베이스와 <code class="language-plaintext highlighter-rouge">Java</code>를 사용할 때,</li>
        <li>품목에 대한 데이터 모델이 정의되어 있다면,</li>
        <li>품목의 상태가 변경될 때 매번 트랜잭션 결과를 반영해서,</li>
        <li>품목 데이터 모델의 결과를 계산해야 한다.</li>
      </ol>

      <p>→ 객체의 상태 변경에 따라 데이터 모델로 처리하여 최종값을 반영하는 과정은 복잡하고 속도가 느림</p>
    </li>
  </ul>
</blockquote>

<ul>
  <li>객체의 상태를 데이터 모델에 맞춰 계산하지 않고, 상태 트랜잭션 자체를 이벤트 저장소에 그대로 저장
    <ul>
      <li>메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있음 → 쓰기 속도가 매우 빠름</li>
      <li>상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산</li>
      <li>매일 자정 상태를 계산하고 스냅샵으로 저장한 후에, 현재 상태 정보가 필요할 때 스냅샵 이후의 트랜잭션만 처리</li>
      <li>명령 측면, 조희 측면의 서비스가 이벤트 저장소의 모든 <code class="language-plaintext highlighter-rouge">CRUD</code> 처리하는 대신, 입력 및 조회만 처리하면 됨
        <ul>
          <li>저장소에서 변경 및 삭제가 발생하지 않으므로, 명령 측면의 서비스를 여러 개로 확장해도 동시 업데이트 및 교착 상태가 발생하지 않음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>이벤트 저장소의 데이터 형태 예시</p>

  <ul>
    <li>이벤트 아이디</li>
    <li>이벤트 타입 : 어떠한 상태인지?</li>
    <li>엔티티 타입 : 어떠한 객체의 이벤트인지?</li>
    <li>엔티티 데이터 : 변경 내용을 <code class="language-plaintext highlighter-rouge">JSON</code> 형태로 저장 → 상태 객체가 그대로 들어감</li>
  </ul>

  <p>→ 이벤트 소싱은 모든 트랜잭션의 상태를 즉시 계산하지 않고, 별도의 이벤트 스트림으로 이벤트 스트림 저장소에 저장</p>
</blockquote>

<ul>
  <li>이벤트 스트림 저장소 : 오로지 추가만 가능하게끔 하여, 계속 이벤트들이 쌓이게끔 함
    <ul>
      <li>실제 내가 필요한 데이터를 구체화하는 시점에 그때까지 축적된 트랜잭션을 바탕으로 상태를 계산해 구성</li>
      <li>이벤트 데이터베이스의 역할뿐만이 아니라 메시지 브로커 처럼 작동</li>
      <li>데이터 저장 처리 메커니즘이나 메시지 큐와 같은 이벤트를 전달하기 위한 메커니즘을 통합</li>
      <li>저장된 상태를 통해 정확한 검사 로깅을 제공하고, 객체의 예전 상태를 재구성하는 것이 가능</li>
      <li>외부 어플리케이션에 이벤트를 전달하는 것 또한 저장한 이벤트를 그대로 전송하면 됨</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[마이크로서비스 아키텍처 (MSA) : 마이크로서비스를 접목한 아키텍처 구조]]></summary></entry></feed>