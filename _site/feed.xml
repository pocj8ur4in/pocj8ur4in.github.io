<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-05T16:59:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[JS] 9. 비동기 처리 (Asynchronous Processing)</title><link href="http://localhost:4000/js9/" rel="alternate" type="text/html" title="[JS] 9. 비동기 처리 (Asynchronous Processing)" /><published>2024-02-05T00:00:00+09:00</published><updated>2024-02-05T00:00:00+09:00</updated><id>http://localhost:4000/js9</id><content type="html" xml:base="http://localhost:4000/js9/"><![CDATA[<h2 id="비동기-처리-asynchronous-processing--프로세스의-완료를-기다리지-않고-다른-작업을-진행">비동기 처리 (<code class="language-plaintext highlighter-rouge">Asynchronous Processing</code>) : 프로세스의 완료를 기다리지 않고 다른 작업을 진행</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a3f7aa41-e708-45b7-8397-068980fc6f3c" width="70%" /></p>

<ul>
  <li>싱글 쓰레드 (<code class="language-plaintext highlighter-rouge">Single Thread</code>) : 한번에 하나의 함수만 실행 → 동기 처리 (<code class="language-plaintext highlighter-rouge">Synchronous Processing</code>)과 동일
    <ul>
      <li>자바스크립트는 콜 스택이 하나 → 콜 스택에 쌓인 함수나 코드를 위에서 아래로 차례대로 실행</li>
    </ul>
  </li>
  <li>논블로킹 (<code class="language-plaintext highlighter-rouge">Non-Blocking</code>) : <code class="language-plaintext highlighter-rouge">I/O</code>를 수행하는 비동기 함수는 백그라운드에 넘김</li>
  <li>멀티 프로세스 (<code class="language-plaintext highlighter-rouge">Multi Processes</code>) : 백그라운드는 <code class="language-plaintext highlighter-rouge">OS</code> 프로세스에 의존</li>
</ul>

<blockquote>
  <p>비동기 처리의 순서?</p>

  <ol>
    <li>런타임 (<code class="language-plaintext highlighter-rouge">Runtime</code>) → 실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) → 콜 스택 (<code class="language-plaintext highlighter-rouge">CallStack</code>)</li>
    <li>백그라운드 (<code class="language-plaintext highlighter-rouge">Background</code>) → 운영체제 (<code class="language-plaintext highlighter-rouge">OS</code>)</li>
    <li>테스크 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>) → 콜 스택 (<code class="language-plaintext highlighter-rouge">Call Stack</code>)</li>
  </ol>
</blockquote>

<h3 id="자바스크립트-런타임-javascript-runtime--자바스크립트가-실행되는-환경">자바스크립트 런타임 (<code class="language-plaintext highlighter-rouge">JavaScript Runtime</code>) : 자바스크립트가 실행되는 환경</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c9726e-4743-4b62-aa15-5a5cde2cdef9" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Web API</code> : 브라우저에서 제공하는 <code class="language-plaintext highlighter-rouge">API</code> (<code class="language-plaintext highlighter-rouge">setTimeout</code>, <code class="language-plaintext highlighter-rouge">HTTP</code> 요청 메소드, <code class="language-plaintext highlighter-rouge">DOM</code> 이벤트)</li>
  <li>테스트 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>) : 이벤트가 발생한 뒤에 호출되어야 할 콜백 함수들이 대기하는 공간</li>
  <li>이벤트 루프 (<code class="language-plaintext highlighter-rouge">Event Loop</code>) : 이벤트 발생 시 콜백 함수들을 관리, 호출된 콜백 함수의 실행 순서 결정</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1ebeb0a1-a9fc-4234-ab64-f4b720b9cc43" width="80%" /></p>

<h3 id="비동기-콜백-패턴-asynchronous-callback-pattern--비동기-작업의-완료를-다루는-전통적인-방식">비동기 콜백 패턴 (<code class="language-plaintext highlighter-rouge">Asynchronous Callback Pattern</code>) : 비동기 작업의 완료를 다루는 전통적인 방식</h3>

<ul>
  <li>현재 실행되고 있는 함수가 끝난 뒤에 실행되는 콜백 함수를 통해 실행 순서를 지정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(function() {
  console.log('task1', new Date());
  setTimeout(function() {
    console.log('task2', new Date());
    setTimeout(function() {
      console.log('task3', new Date());
      console.log('END&gt;&gt;', new Date());
    }, 1000 );
  }, 2000);
}, 3000);
console.log('START', new Date());
</code></pre></div></div>

<blockquote>
  <p>콜백 함수를 여러 개 중첩하면, 코드의 가독성이 떨어지는 콜백 지옥 (<code class="language-plaintext highlighter-rouge">Callback Hell</code>)이 발생!</p>
</blockquote>

<h2 id="프로미스-promise--비동기-작업의-성공-및-실패에-대한-완료-결과를-처리하는-객체">프로미스 (<code class="language-plaintext highlighter-rouge">Promise</code>) : 비동기 작업의 성공 및 실패에 대한 완료 결과를 처리하는 객체</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/6acaa363-7157-4636-9f62-1da04e7a6a9c" width="90%" /></p>

<ul>
  <li>콜백 지옥을 피하고 비동기 처리를 쉽게 처리할 수 있도록 <code class="language-plaintext highlighter-rouge">ES6</code>부터 <code class="language-plaintext highlighter-rouge">then</code> 도입</li>
  <li>프로미스를 호출하면 프로미스 인스턴스 (<code class="language-plaintext highlighter-rouge">Promise Instance</code>)를 반환한 후 <code class="language-plaintext highlighter-rouge">Resolve</code> &amp; <code class="language-plaintext highlighter-rouge">Reject</code></li>
</ul>

<blockquote>
  <p>프로미스의 3가지 상태 (<code class="language-plaintext highlighter-rouge">Status</code>)</p>

  <ul>
    <li>대기 (<code class="language-plaintext highlighter-rouge">Pending</code>) : 비동기 처리 로직이 미완료된 초기 상태, 성공 또는 실패할 때까지 대기</li>
    <li>이행 (<code class="language-plaintext highlighter-rouge">Fulfilled</code> ): 비동기 처리가 완료되어, 프로미스가 결과 값을 반환한 상태</li>
    <li>거부 (<code class="language-plaintext highlighter-rouge">Rejected</code>) : 비동기 처리가 실패하거나 오류가 발생한 상태</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        const now = Date.now();
        
        if (now % 2 === 0) {
            resolve(console.log('[Fulfilled]'), now);    
        } else reject('Rejected');
    }, 1000);

    setTimeout(() =&gt; {
        reject(new Error('[TimeExceeded]'),);
    }, 1001);
});

promise.then(
    success =&gt; console.log('[Resolved]'),
    fail =&gt; console.log('[Rejected]')
)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로미스를 클래스로 표현한다면?
class Promise {
  constructor(callback) {
    console.log('[Promise 생성자]')
    callback (this.resolve.bind(this), this.reject.bind(this));
}

  then(resolve) {
    console.log('[then 메소드 실행]')
    this.success = callback;
  }

  catch(x) {
    console.log('[catch 메소드 실행]')
    this.failure = callback;
  }

  success(x) {
    console.log('[success 메소드 실행] ' + x)
  }

  failure(x) {
    console.log('[failure 메소드 실행] ' + x)
  }

  resolve(x) { 
    console.log('[resolve 메소드 실행]')
    return this.success(x);
  }

  reject(x) {
    console.log('[reject 메소드 실행]')
    return this.failure(x);
  }

  callback(resolve, reject) {
    console.log('[callback 메소드 실행]')
  }
};

let promise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            const now = Date.now();
            console.log('이행 :', now)

            if (now % 2 === 0)
                resolve(now)
            else
                reject(new Error("실패"))

            console.log("[setTimeout 메소드 실행]")
        }, 1000)
    }
);
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/71628456-0e58-4bbb-b1f7-45cff3e5b96a" width="90%" /></p>

<h3 id="프로미스-클래스-메소드-promise-class-method--프로미스에서-비동기-작업을-다루기-위해-제공">프로미스 클래스 메소드 (<code class="language-plaintext highlighter-rouge">Promise Class Method</code>) : 프로미스에서 비동기 작업을 다루기 위해 제공</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Promise.resolve</code> : 주어진 값을 성공 상태의 프로미스로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.resolve(x).then(val =&gt; console.log(val));</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.reject</code> : 주어진 값을 실패 상태의 프로미스로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.reject(new Error('...')).catch(console.error);</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.all</code> : 여러 프로미스가 모두 성공 시 <b>시간과 무관하게 순서를 보장하여</b> 프로미스들을 모두 반환, 하나라도 실패하면 첫번째로 실패한 프로미스 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.all(iterables).then().catch(...)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.race</code> : 여러 프로미스 중에서 가장 빠른 것을 반환, 하나라도 실패하면 첫번째로 실패한 프로미스 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.race(iterables).then().catch(...)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.any</code> : 여러 프로미스 중에서 제일 빨리 성공한 것을 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.any(iterables).then().catch(...)</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Node.js</code> 모듈의 <code class="language-plaintext highlighter-rouge">util.promisify</code> : 콜백 함수 기반의 비동기 함수를 프로미스 기반으로 변환</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function promisify(fn) {
  return new Promise( (resolve, reject) =&gt; {
    try {
      const ret = fn();
      resolve(ret);
    } catch(err) {
      reject(err);
    }
  })
}

const exec = util.promisify(execute);
exec.then(...).catch(...)
</code></pre></div>  </div>
</blockquote>

<h2 id="async-await--프로미스를-생성하고-소비하기-위한-문법적-설탕"><code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> : 프로미스를 생성하고 소비하기 위한 문법적 설탕</h2>

<blockquote>
  <p>문법적 설탕 (<code class="language-plaintext highlighter-rouge">Syntax Sugar</code>) : 문법적 기능은 그대로인데, 사람이 직관적으로 읽을 수 있게끔 만드는 것</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4297057d-9df5-4864-aaf9-1fa77598e056" width="40%" /></p>

<ul>
  <li>비동기 함수에서 콜백을 사용하는 대신에, 단순한 논리적 흐름을 작성
    <ul>
      <li>프로미스의 <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">catch</code>, <code class="language-plaintext highlighter-rouge">finally</code>를 사용할 필요 없음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">async</code>는 프로미스를 반환하고, <code class="language-plaintext highlighter-rouge">await</code>는 <code class="language-plaintext highlighter-rouge">resolve</code> 및 <code class="language-plaintext highlighter-rouge">reject</code>와 매핑
    <ul>
      <li>성공 : <code class="language-plaintext highlighter-rouge">return</code> → <code class="language-plaintext highlighter-rouge">resolve</code> → <code class="language-plaintext highlighter-rouge">result</code></li>
      <li>실패 : <code class="language-plaintext highlighter-rouge">error</code> → <code class="language-plaintext highlighter-rouge">reject</code> → <code class="language-plaintext highlighter-rouge">throw</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// const fn = async() =&gt; {...}
async function fn() {   // Promise 반환
  ...
  result = await fetch(url);  // fetch.then().catch()
}
console.log(await fn());
</code></pre></div></div>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Promise</code> &amp; <code class="language-plaintext highlighter-rouge">then</code> : 각각이 별도의 쓰레드로 실행되므로 <b>병렬</b></li>
    <li><code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> : 단일 쓰레드를 차례로 실행하므로 <b>직렬</b></li>
  </ul>

  <p>→ 연관이 없는 비동기 함수 실행에 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code>을 남발하지 말자!</p>

</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// promise, async, await을 활용하여 페치한 뒤에 2초간 sleep 구현
const f = async () =&gt; {
  const res = await fetch("https://jsonplaceholder.typicode.com/users/1");  
  if (!res.ok) throw new Error("Fail to Fetch!!");
  console.log(Date.now())
  await new Promise((resolve) =&gt; {setTimeout(resolve, 2000)});
  const data = await res.json();
  return data.name;
};

console.log(await f());
console.log(Date.now())
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// promise, async, await을 활용하여 1초 간격으로 3번 출력하는 depthTimer 구현
let depthTimer = async (str) =&gt; {
  console.log(str, new Date());
  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));
};
  
(async function () {
  await depthTimer('START!');
  await depthTimer('depth1');
  await depthTimer('depth2');
  await depthTimer('depth3');
  console.log('Already 3-depth!!');
})();
</code></pre></div></div>

<h3 id="for-await-of--비동기적으로-이터레이터-iterator를-반복하는-문법"><code class="language-plaintext highlighter-rouge">for-await-of</code> : 비동기적으로 이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>)를 반복하는 문법</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async</code> 함수에서 비동기적으로 값을 가져와 처리할 때 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const afterTime = sec =&gt; new Promise(
    resolve =&gt; setTimeout(resolve, sec * 1000, sec
  ));
  console.time('for-await-of ');
  const arr = [afterTime(1), afterTime(2)];
  
  for (const fo of arr.values()) {
    console.log('fo =', fo);
  }
  
  for await (const fao of arr.values()) {
    console.log('fao =', fao);
  }
  
  console.timeEnd('for-await-of ');

// &gt; fo = Promise { &lt;pending&gt; }
// &gt; fo = Promise { &lt;pending&gt; }
// &gt; fao = 1
// &gt; fao = 2
// &gt; for-await-of : 2.003s
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[비동기 처리 (Asynchronous Processing) : 프로세스의 완료를 기다리지 않고 다른 작업을 진행]]></summary></entry><entry><title type="html">자바스크립트 프록시 (2024.02.04)</title><link href="http://localhost:4000/digital_hanaro_6/" rel="alternate" type="text/html" title="자바스크립트 프록시 (2024.02.04)" /><published>2024-02-04T00:00:00+09:00</published><updated>2024-02-05T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_6</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_6/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 6일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부한-이유">공부한 이유</h2>

<p>프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>)를 번역하면 어떤 일을 대신 수행하는 대리자, 대변인의 의미를 갖고 있다. 디자인패턴에서도 어떤 객체를 사용하고자 할 때, 객체를 직접 참조하는 것이 아니라 해댱 객체를 대행할 수 있는 프록시 객체를 통해 대상하고자 하는 객체에 접근하는 방식을 프록시 패턴 (<code class="language-plaintext highlighter-rouge">Proxy Pattern</code>)이라고 부른다. 자바스크립트에서도 프록시 객체가 있다는 것을 이번 수업을 통해 알게 되어 이에 대해 정리하고자 하였다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9a0c5c88-3e49-43f9-a2e1-55ae60429d27" width="60%" /></p>

<ul>
  <li>프록시 객체 (<code class="language-plaintext highlighter-rouge">Proxy Object</code>) : 원본 객체의 어떤 작업을 가로채 대신 처리하는 객체
    <ul>
      <li>타겟 (<code class="language-plaintext highlighter-rouge">target</code>) : 프록시 객체가 감쌀 (<code class="language-plaintext highlighter-rouge">wrapping</code>) 원본 객체</li>
      <li>핸들러 (<code class="language-plaintext highlighter-rouge">handler</code>) : 동작을 가로채는 ‘트랩 (<code class="language-plaintext highlighter-rouge">trap</code>)’이 담겨 타겟의 동작을 제어하는 메소드를 정의한 객체</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let target = {};
let proxy = new Proxy(target, handler)

proxy.test = 5;
alert(proxy.test); // 5
</code></pre></div></div>

<blockquote>
  <p>특정 객체를 감싸 해당 객체에 작업이 가해지고, 핸들러에 상응하는 트랩이 있다면 중간에서 작업을 트랩</p>
</blockquote>

<ul>
  <li>프록시는 일반 객체와 달리 프로퍼티가 없는 ‘특수 객체’
    <ul>
      <li>핸들러가 비어 있으면 프록시에 가해지는 작업은 원본 객체인 타겟으로 바로 전달</li>
    </ul>
  </li>
  <li>프록시의 트랩은 원본 객체에 수행하는 동작을 수행하는 내부 메소드의 호출을 가로챔</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4c6317c5-a2b0-4643-994f-ba45f073239b" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let numbers = [0, 1, 2];

numbers = new Proxy(numbers, {
  get(target, prop) {
    if (prop in target) return target[prop];
    return 0;
  }
});

alert( numbers[1] ); // 1
alert( numbers[123] ); // 0
</code></pre></div></div>

<blockquote>
  <p>프록시가 <code class="language-plaintext highlighter-rouge">Reflect</code>와 다른 점?</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Reflect</code>는 타겟 객체의 상태를 <code class="language-plaintext highlighter-rouge">Boolean</code>으로 반환하는 여러 메소드를 가진 자바스크립트 기본 객체
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Reflect</code>의 메소드가 프록시와 연동하여, <code class="language-plaintext highlighter-rouge">Reflect</code>의 메소드를 통해 검증하는 값을 프록시에도 핸들러에 할당해 처리 가능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#1</code>. 프록시는 비싼 함수 호출을 캐싱 (<code class="language-plaintext highlighter-rouge">Caching</code>)할 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function calculateCost(price, taxRate) {
  console.log('계산 : ');
  return price * (1 + taxRate);
}

const cache = new Map();

const proxy = new Proxy(calculateCost, {
  apply(target, thisArg, args) {
    const key = args.join('-');
    if (cache.has(key)) {
      console.log('캐시된 결과 반환 : ');
      return cache.get(key);
    } else {
      const result = Reflect.apply(target, thisArg, args);
      cache.set(key, result);
      return result;
    }
  },
});

console.log(proxy(10, 0.2)); // 계산 : 12
console.log(proxy(10, 0.2)); // 캐시된 결과 반환 : 12
console.log(proxy(20, 0.2)); // 계산 : 24
console.log(proxy(20, 0.3)); // 계산 : 26
console.log(proxy(20, 0.3)); // 캐시된 결과 반환 : 26
</code></pre></div></div>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#2</code>. 프록시는 데이터 검증에 활용하는 유효성 검사기 (<code class="language-plaintext highlighter-rouge">Validator</code>)로 활용될 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = {
  name: 'John',
  password: '',
};

const proxy = new Proxy(user, {
  set(target, prop, value) {
    if (prop === 'password' &amp;&amp; value.length &lt; 8) {
      throw new Error('Password must be at least 8 characters long');
    }
    target[prop] = value;
    return true;
  },
});

console.log(proxy.name); // John
console.log(proxy.password); // 

proxy.password = '12345678';
console.log(proxy.password); // 12345678

proxy.password = '123'; // 'Password must be at least 8 characters long' 에러 반환
</code></pre></div></div>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#3</code>. 프록시는 데이터 변화를 감지하는 로거 (<code class="language-plaintext highlighter-rouge">logger</code>)로 활용될 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = {
  name: 'John',
  email: 'john@example.com',
};

const proxy = new Proxy(user, {
  get(target, prop) {
    console.log(`Getting ${prop} property`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} property to ${value}`);
    target[prop] = value;
    return true;
  },
});

console.log(proxy.name); // Getting name property -&gt; John
proxy.email = 'bob@example.com'; // Setting email property to bob@example.com
console.log(proxy.email); // Getting email property -&gt; bob@example.com
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 6일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[vocawik] 2. vocawik 프로젝트 설계</title><link href="http://localhost:4000/vocawik2/" rel="alternate" type="text/html" title="[vocawik] 2. vocawik 프로젝트 설계" /><published>2024-02-03T00:00:00+09:00</published><updated>2024-02-03T00:00:00+09:00</updated><id>http://localhost:4000/vocawik2</id><content type="html" xml:base="http://localhost:4000/vocawik2/"><![CDATA[<h2 id="프로젝트-목표-project-goal--프로젝트-진행-과정에서-이루고자-하는-사항들을-정리">프로젝트 목표 (<code class="language-plaintext highlighter-rouge">Project Goal</code>) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">목표</td>
        <td nowrap="">설명</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">도메인 정의<br />(<code>Domain Definition</code>)</td>
        <td><ul>
          <li>사이트에서 제공하고자 하는 기능 및 책임들이 도메인별로 명확히 분리되어야 한다.</li>
        </ul></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="아키텍처-구조도-architecture-structure--사이트의-아키텍처를-설계">아키텍처 구조도 (<code class="language-plaintext highlighter-rouge">Architecture Structure</code>) : 사이트의 아키텍처를 설계</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<h2 id="유저-프로필-user-profile--사이트의-이용자들을-정의하여-분류">유저 프로필 (<code class="language-plaintext highlighter-rouge">User Profile</code>) : 사이트의 이용자들을 정의하여 분류</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">관리자<br />(<code>Manager; MA</code>)</td>
        <td>사이트 및 사이트 내부 기능들의 기획, 설계, 개발, 운영, 관리를 담당하는 사람들을 총칭한다.</td>
      </tr>
      <tr>
        <td nowrap="">회원<br />(<code>Member; ME</code>)</td>
        <td>사이트 이용자들 중에 회원 데이터베이스에 등록된 사람들을 총칭한다.</td>
      </tr>
      <tr>
        <td nowrap="">비회원<br />(<code>NonMember; NE</code>)</td>
        <td>사이트 이용자들 중에 회원 데이터베이스에 등록되지 않은 사람들을 총칭한다.</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="기능-명세서-functional-specification--사이트에서-구현할-기능들을-정리">기능 명세서 (<code class="language-plaintext highlighter-rouge">Functional Specification</code>) : 사이트에서 구현할 기능들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">분류</td>
        <td nowrap="">ID</td>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
        <td nowrap="">상태</td>
        <td nowrap="">우선<br />순위</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="32">회원<br />(<code>Member</code>)</td>
        <td nowrap=""><code>ME-001</code></td>
        <td nowrap="">회원 <code>ID</code> 로그인<br />(<code>MemberIdLogin</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '아이디' 또는 '이메일'과 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 때, '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되면 '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-002</code></td>
        <td nowrap="">회원 <code>OAuth</code> 로그인<br />(<code>MemberOAuthLogin</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 로그인 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-003</code></td>
        <td nowrap="">회원 <code>OTP</code> 로그인<br />(<code>MemberLoginCertifyByOTP</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (<code>OTP</code>) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행할 경우에 (즉 로그인이 정상적으로 수행되었다면), '일회용 비밀번호'를 확인할 수 있는 '<code>OTP</code> 키'를 발급하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-004</code></td>
        <td nowrap="">회원 로그인 이메일 인증<br />(<code>MemberLoginCertifyByEmail</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (이메일 인증) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되는 경우에 (즉 로그인이 정상적으로 수행되었다면), '일회용 비밀번호'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-005</code></td>
        <td nowrap="">회원 자동 로그인 방지<br />(<code>MemberLoginCAPTCHA</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 5회 이상 '로그인'에 실패할 경우, <code>google reCAPTCHA</code>를 통해 보안 문자를 입력한 다음에 로그인을 시도할 수 있도록 한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-006</code></td>
        <td nowrap="">회원 로그인 유지<br />(<code>MemberCreateRememberMe</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '로그인 유지 옵션'을 활성화한 상태로 로그인을 성공하였을 때, '회원'이 브라우저를 끄고 다시 접속하더라도 로그인 상태를 2주간 유지한다.</td>
        <td nowrap="">비회원<br />↓<br />회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-007</code></td>
        <td nowrap="">회원 비밀번호 재설정 이메일 인증<br />(<code>MemberResetPasswordCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '비밀번호 재설정' 버튼을 누르면, '비밀번호 재설정 아이디/이메일 입력 화면'으로 이동한다. 입력받은 값과 일치하는 회원 정보가 존재한다면, '임시 비밀번호'를 생성하여 30분간 유효한 '임시 비밀번호'를 포함한 '비밀번호 재설정 이메일'을 생성 및 전송한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-008</code></td>
        <td nowrap="">회원 비밀번호 재설정<br />(<code>MemberResetPassword</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '로그인'을 시도할 때 '비밀번호 재설정'에서 생성된 '임시 비밀번호'를 입력받았거나, '회원'이 '회원정보 갱신 화면'에서 '비밀번호 재설정' 버튼을 누른 경우, '비밀번호 재설정' 화면으로 이동한다. 입력받은 '비밀번호' 및 '비밀번호 확인'이 이전에 사용된 적이 있는 '중복된 비밀번호'가 아니면서 유효성 검사가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였다면, 입력한 값을 포함하여 회원 정보를 갱신한다. 그리고 이전에 이루어진 '회원 로그인 유지'를 모두 해제한 다음에 '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-009</code></td>
        <td nowrap="">회원 로그아웃<br />(<code>MemberLogout</code>)</td>
        <td>'회원'이 어떤 화면에서 '로그아웃 버튼'을 누르면, (만약 '회원 로그인 유지'가 이루어지고 있다면 이를 해제한 다음에) '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-010</code></td>
        <td nowrap="">회원가입<br />(<code>MemberRegister</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 바탕으로 서버 내 데이터베이스에 '회원'을 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-011</code></td>
        <td nowrap=""><code>OAuth</code> 회원가입<br />(<code>MemberOAuthRegister</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 회원가입 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원가입 화면'으로 이동한다. '회원가입' 화면에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 바탕으로 데이터베이스에 '회원'을 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원<br />↓<br />비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-012</code></td>
        <td nowrap="">회원가입 이메일 인증<br />(<code>MemberRegisterCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '이메일'을 입력하고 '이메일 인증 버튼'을 눌렀을 때, '유효성 검사'가 정상적으로 이루어진다면, '인증 문자열'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고 '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '인증 문자열'과 일치한다면, 인증에 성공하였다는 것을 알린다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-013</code></td>
        <td nowrap="">회원 개인정보 조회<br />(<code>MemberReadMyInfo</code>)</td>
        <td>'회원'이 어떤 화면에 존재하는 '회원 개인정보 조회' 버튼을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '비밀번호 확인 화면'으로 이동한다. 입력한 값이 해당 회원의 '비밀번호'와 일치하고 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '개인정보 조회 화면'을 제공한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-014</code></td>
        <td nowrap="">회원 개인정보 갱신<br />(<code>MemberUpdateMyInfo</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인정보를 수정하고 '개인정보 갱신 버튼'을 눌렀을 때, 각각의 '개인정보'에 대한 유효성 검사가 정상적으로 이루어지고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원'의 '개인정보'에 해당하는 값들을 데이터베이스에 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-015</code></td>
        <td nowrap="">회원 개인정보 갱신 이메일 인증<br />(<code>MemberUpdateMyInfoCertifyByEmail</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인정보 중에 '이메일'을 수정하고 '이메일 인증' 버튼을 눌렀을 때, '이메일'에 대한 유효성 검사가 정상적으로 이루어지고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '인증 주소'를 생성하여 30분간 유효한 '인증 주소'를 포함한 '인증 이메일'을 생성 및 전송한다. 만약 해당 '인증 주소'을 열람한다면, 인증이 성공하였다는 것을 알린다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-016</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동<br />(<code>MemberUpdateMyOAuth</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인 정보 중에 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 연동 버튼'을 눌렀을 때 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '<code>OAuth</code>'에 대한 정보를 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-017</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동 해제<br />(<code>MemberDeleteMyOAuth</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인 정보 중에 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 연동 해제 버튼'을 눌렀을 때 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '<code>OAuth</code>'에 대한 정보를 삭제한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-018</code></td>
        <td nowrap="">회원 탈퇴 (회원 개인정보 삭제)<br />(<code>MemberDeleteMyAccount</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 탈퇴 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '비밀번호 재확인 화면'을 제공한다. 입력한 값이 해당 회원의 '비밀번호'와 일치하고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원 탈퇴 안내 화면'을 제공한다. 만약 '회원 탈퇴 안내 화면'에서 '회원 탈퇴 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '개인정보'를 삭제한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-019</code></td>
        <td nowrap="">회원 로그인 기록 조회<br />(<code>MemberReadLoginHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '로그인 기록 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '로그인 기록' ('로그인 일시', '로그인 <code>IP</code>', '로그인 국가', '로그인 기기')을 제공하는 '로그인 기록 화면'으로 이동한다. (이때 '로그인 기록'은 최근 3개월까지의 기록을 한정해 제공하며, 최대 1,000건까지 한정해 제공한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-020</code></td>
        <td nowrap="">회원 비밀번호 재설정 기록 조회<br />(<code>MemberReadResetPasswordHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '비밀번호 재설정 기록 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '비밀번호 재설정 기록' ('비밀번호 재설정 일시', '비밀번호 재설정 <code>IP</code>', '비밀번호 재설정 국가')을 제공하는 '비밀번호 재설정 기록 화면'으로 이동한다. (이때 '비밀번호 재설정 기록'은 최근 6개월까지의 기록을 한정해 제공하며, 최대 1,000건까지 한정해 제공한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-021</code></td>
        <td nowrap="">회원 중복 로그인 설정<br />(<code>MemberSetDuplicateLogin</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 중복 로그인 설정 옵션'을 비활성화할 때, 팝업 창을 통해 비활성화가 이루어질 때 수행될 작업에 대해 안내한다. 만약 팝업 창에 참인 값이 반환되었다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원이 로그인을 유지하고 있는 기기가 모두 해제되고, 회원이 앞으로 로그인 유지를 활성화한 상태로 로그인을 시도하더라도 로그인 유지가 이루어지지 않는다. '회원 중복 로그인 설정 옵션'을 활성화하면, 활성화가 이루어질 때 수행될 작업에 대해 안내한다. 만약 팝업 창에 참인 값이 반환되었다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원이 앞으로 로그인 유지를 활성화한 상태로 로그인을 시도한다면 로그인 유지가 이루어진다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-022</code></td>
        <td nowrap="">회원 로그인 유지 기기 조회<br />(<code>MemberReadRememberMeHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 로그인 유지 기기 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원 로그인 유지 기기 기록' ('운영체제', '브라우저', '로그인 <code>IP</code>', '최근 접속 일시', '최초 로그인 일시')를 제공하는 '로그인 유지 기기 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-023</code></td>
        <td nowrap="">회원 로그인 유지 기기 해제<br />(<code>MemberDeleteRememberMe</code>)</td>
        <td>'회원'이 '로그인 유지 기기 화면'에서 특정 기기에 대한 '로그아웃 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 특정 기기에 대한 로그인 유지 기록을 삭제한다. (이때, 현재 접속 중인 기기는 삭제할 수 없도록 한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-024</code></td>
        <td nowrap="">회원 프로필 조회<br />(<code>MemberReadMyProfile</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '프로필'을 조회해야 할 때, 해당 '회원'에 대한 프로필 정보를 제공하는 '프로필 화면'을 제공한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-025</code></td>
        <td nowrap="">회원 프로필 갱신<br />(<code>MemberUpdateMyProfile</code>)</td>
        <td>'회원'이 해당 회원에 대한 '프로필 화면'에서 '프로필 갱신' 버튼을 눌렀을 때, 해당 '회원'에 대한 인가가 정상적으로 수행될 경우에 프로필 정보를 갱신할 수 있는 '프로필 갱신 화면'을 제공한다. 만약 '프로필 갱신 화면'에서 '프로필 갱신 버튼'을 누른다면 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 프로필 정보를 갱신한다.</td>
        <td nowrap="">현재 회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-026</code></td>
        <td nowrap="">회원 인터페이스 설정 조회<br />(<code>MemberReadMyInterface</code>)</td>
        <td>'회원'이 어떤 화면에 존재하는 특정 회원에 대한 '인터페이스 설정 조회' 버튼을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 '회원'에 대한 인터페이스 정보를 제공하는 '인터페이스 설정 화면'을 제공한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-027</code></td>
        <td nowrap="">회원 인터페이스 설정 갱신<br />(<code>MemberUpdateMyInterface</code>)</td>
        <td>'회원'이 '인터페이스 설정 화면'에 존재하는 특정 정보를 갱신한다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 이를 반영한 화면을 즉각적으로 표현한다. 만약 '인터페이스 화면'에 존재하는 '인터페이스 설정 저장 버튼'을 누른다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 인터페이스 설정 정보를 갱신한다. 또한 '인터페이스 화면'에 존재하는 '인터페이스 설정 초기화' 버튼을 누르거나 '인터페이스 설정 저장 버튼'을 누르지 않고 다른 화면을 이동한다면, 기존 값을 반영한 화면을 표현한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-028</code></td>
        <td nowrap="">회원 상태 조회<br />(<code>MemberReadMyStatus</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '상태'를 조회해야 할 때, 해당 '회원'에 대한 상태 정보를 제공하는 '상태 화면'을 제공한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-029</code></td>
        <td nowrap="">회원 상태 갱신<br />(<code>MemberUpdateMyStatus</code>)</td>
        <td>특정 '회원'이 사이트 내에서 어떤 작업을 실행할 때, 해당 '회원'에 대한 상태 정보가 '오프라인'이라면, 이를 '오프라인'에서 '온라인'으로 갱신한다. 만약 '회원'이 어떤 화면에서 '방해 금지 활성화 버튼'을 눌렀다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원의 상태 정보를 '방해 금지'으로 갱신한다. ('방해 금지'가 활성화된 상태에서는 중요한 알림을 제외한 모든 알림들을 전달받지 않늗다.) 만약 '회원'이 어떤 화면에서 '방해 금지 비활성화 버튼'을 눌렀다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원의 상태 정보를 '온라인'으로 갱신한다. 만약 로그인 유지 기기가 하나일 때 로그아웃을 실행하거나 1시간 이상 사이트 내에서 작업이 이루어지지 않는다면, 해당 '회원'에 대한 상태 정보가 '온라인'에서 '오프라인'으로 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-030</code></td>
        <td nowrap="">회원 권한 조회<br />(<code>MemberReadAuth</code>)</td>
        <td>'회원'이 어떤 화면으로 이동할 때, 특정 작업에 대한 '권한'을 갖고 있다면 '회원'에 대한 인가가 정상적으로 수행될 경우에 특정 작업의 실행을 위해 이를 '관리자 서비스'에 요청할 수 있는 '권한 버튼'을 표시한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-031</code></td>
        <td nowrap="">회원 권한 요청<br />(<code>MemberPublishAuth</code>)</td>
        <td>'회원'이 어떤 화면에서 특정 작업에 대한 '권한 버튼'을 눌렀을 때, 특정 작업의 실행을 위해 이를 '관리자 서비스'에 요청하여 요청에 대한 응답을 반환한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-032</code></td>
        <td nowrap="">회원 권한 기록 조회<br />(<code>MemberReadAuthHistory</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '권한 기록 버튼'을 눌렀을 때, 해당 회원이 '관리자 서비스'에 권한을 요청하여 응답받은 '권한 기록' ('권한 요청 일시', '권한 응답 일시', '권한 이름', '권한 내용', '권한 응답 결과', '권한 요청자', '관한 실행자')를 제공하는 '권한 기록 화면'으로 이동한다.</td>
        <td nowrap="">-</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="10">관리자<br />(<code>Manager</code>)</td>
        <td nowrap=""><code>MA-001</code></td>
        <td nowrap="">관리자 보안 로그인<br />(<code>ManagerSecureLogin</code>)</td>
        <td>지정된 <code>IP</code>에서 접속한 '비회원'이 '관리자 로그인 화면'에서 '아이디'와 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 대, '유효성 검사' 및 관리자에 대한 '인증'이 정상적으로 수행되면 '관리자'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (보안)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-002</code></td>
        <td nowrap="">관리자 보안 로그아웃<br />(<code>ManagerSecureLogout</code>)</td>
        <td>'관리자'가 어떤 화면에서 '로그아웃 버튼'을 누를 때, 관리자에 대한 '인증'이 정상적으로 수행되면 '관리자'에 대한 '인가'를 비활성화하고 '관리자 로그인 화면'으로 이동한다.</td>
        <td nowrap="">관리자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-003</code></td>
        <td nowrap="">관리자 과도한 로그인 시도 제한<br />(<code>ManagerLimitExcessiveLogin</code>)</td>
        <td>지정된 <code>IP</code>에서 접속한 '비회원'이 '관리자 로그인 화면'에서 5회 이상 '로그인'에 실패할 경우에 해당 <code>IP</code>에서 접속하는 것을 30분간 금지한다.</td>
        <td nowrap="">비회원 (보안)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-004</code></td>
        <td nowrap="">관리자 회원 권한 갱신<br />(<code>ManagerUpdateAuthOnUser</code>)</td>
        <td>'관리자'가 '관리자 콘솔 화면'에서 '회원 권한 갱신 버튼'을 누르면, 관리자에 대한 '인증'이 정상적으로 수행되면 회원 <code>ID</code>를 검색할 수 있는 '(관리자) 회원 검색 화면'을 제공한다. 입력한 값과 일치하는 회원 <code>ID</code>이 존재할 때, 관리자에 대한 '인증'이 정상적으로 수행되면 회원 프로필 정보를 제공하고 회원 권한을 갱신할 수 있는 '(관리자) 회원 권한 갱신 화면'을 제공한다. '회원 권한 갱신 버튼'을 눌렀을 때, 관리자에 대한 '인증'이 정상적으로 수행되면 '회원 서비스'에 존재하는 해당 회원의 권한 정보를 갱신한다. (이 기능은 해당 권한을 가진 회원 또한 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-005</code></td>
        <td nowrap="">관리자 권한 실행 기록 조회<br />(<code>ManagerReadAuthRequestHistory</code>)</td>
        <td>'관리자'가 '관리자 콘솔 화면'에서 '권한 실행 기록 조회 버튼'을 누르면, 관리자에 대한 '인증'이 정상적으로 수행되면 모든 '회원'이 '관리자 서비스'에 권한을 요청하여 응답받은 '권한 기록' ('권한 요청 일시', '권한 응답 일시', '권한 이름', '권한 내용', '권한 응답 결과', '권한 요청자', '관한 실행자') (이 기능은 해당 권한을 가진 회원 또한 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-006</code></td>
        <td nowrap="">관리자 IP 차단<br />(<code>ManagerBlockIP</code>)</td>
        <td> (이 기능은 해당 권한을 가진 회원 또한 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-007</code></td>
        <td nowrap="">관리자 회원 제재<br />(<code>ManagerPenaltyMember</code>)</td>
        <td> (이 기능은 해당 권한을 가진 회원 또한 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-008</code></td>
        <td nowrap=""><br />(<code>Manager</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-009</code></td>
        <td nowrap=""><br />(<code>Manager</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-010</code></td>
        <td nowrap=""><br />(<code>Manager</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="19">위키<br />(<code>Wiki</code>)</td>
        <td nowrap=""><code>WI-001</code></td>
        <td nowrap="">카테고리 생성<br />(<code>~CreateCategory</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-002</code></td>
        <td nowrap="">카테고리 갱신<br />(<code>~UpdateCategory</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-003</code></td>
        <td nowrap="">카테고리 읽기<br />(<code>~ReadCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-004</code></td>
        <td nowrap="">카테고리 삭제<br />(<code>~DeleteCategory</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-005</code></td>
        <td nowrap="">문서 생성<br />(<code>~CreateDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-006</code></td>
        <td nowrap="">문서 갱신<br />(<code>~UpdateDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-007</code></td>
        <td nowrap="">문서 읽기<br />(<code>~ReadDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-008</code></td>
        <td nowrap="">문서 삭제<br />(<code>~DeleteDocument</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-009</code></td>
        <td nowrap="">특정 카테고리에서 문서 검색<br />(<code>~SearchDocumentOnCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-010</code></td>
        <td nowrap="">모든 카테고리에서 문서 검색<br />(<code>~SearchDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-011</code></td>
        <td nowrap="">카테고리 검색<br />(<code>~SearchCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DO-012</code></td>
        <td nowrap="">특정 카테고리 기록 조회<br />(<code>~ReadCategoryHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-013</code></td>
        <td nowrap="">특정 문서 기록 조회<br />(<code>~ReadDocumentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-014</code></td>
        <td nowrap="">템플릿 생성<br />(<code>~CreateTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-015</code></td>
        <td nowrap="">템플릿 갱신<br />(<code>~UpdateTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-016</code></td>
        <td nowrap="">템플릿 읽기<br />(<code>~ReadTemplate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-017</code></td>
        <td nowrap="">템플릿 삭제<br />(<code>~DeleteTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-018</code></td>
        <td nowrap="">템플릿 검색<br />(<code>~SearchTemplate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-019</code></td>
        <td nowrap="">문서에 템플릿 가져오기<br />(<code>~AddTemplateOnDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">토론<br />(<code>Debate</code>)</td>
        <td nowrap=""><code>DE-001</code></td>
        <td nowrap="">문서에 토론 생성<br />(<code>CreateDebateOnDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-002</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-003</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-004</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-005</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="15">게시판<br />(<code>Board</code>)</td>
        <td nowrap=""><code>BO-001</code></td>
        <td nowrap="">게시판 생성<br />(<code>~CreateBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-002</code></td>
        <td nowrap="">게시판 조회<br />(<code>~ReadBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-003</code></td>
        <td nowrap="">게시판 갱신<br />(<code>~UpdateBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-004</code></td>
        <td nowrap="">게시판 삭제<br />(<code>~DeleteBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-005</code></td>
        <td nowrap="">특정 게시판에서 게시글 조회<br />(<code>~ReadPostOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-006</code></td>
        <td nowrap="">특정 게시판에서 게시글 갱신<br />(<code>~UpdatePostOnBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />게시글 작성자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-007</code></td>
        <td nowrap="">특정 게시판에서 게시글 삭제<br />(<code>~DeletePostOnBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />게시글 작성자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-008</code></td>
        <td nowrap="">특정 게시판에서 게시글 목록 조회<br />(<code>~ReadPostHistoryOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-009</code></td>
        <td nowrap="">게시판 검색<br />(<code>~SearchBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-010</code></td>
        <td nowrap="">특정 게시판에서 게시글 검색<br />(<code>~SearchPostOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-011</code></td>
        <td nowrap="">모든 게시판에서 게시글 검색<br />(<code>~SearchPost</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-012</code></td>
        <td nowrap="">회원이 작성한 게시글 기록 조회<br />(<code>~ReadUserPostHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-013</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-014</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-015</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="6">댓글<br />(<code>Comment</code>)</td>
        <td nowrap=""><code>CO-001</code></td>
        <td nowrap="">댓글 생성<br />(<code>~CreateComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-002</code></td>
        <td nowrap="">댓글 조회<br />(<code>~ReadComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-003</code></td>
        <td nowrap="">댓글 갱신<br />(<code>~UpdateComment</code>)</td>
        <td></td>
        <td nowrap="">댓글 작성자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-004</code></td>
        <td nowrap="">댓글 삭제<br />(<code>~DeleteComment</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />댓글 작성자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-005</code></td>
        <td nowrap="">회원이 작성한 댓글 기록 조회<br />(<code>~ReadUserCommentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-006</code></td>
        <td nowrap="">최근에 등록된 댓글 기록 조회<br />(<code>~ReadCreateCommentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">알림<br />(<code>Notice</code>)</td>
        <td nowrap=""><code>NO-001</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-002</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-003</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-004</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-005</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">채팅<br />(<code>Chat</code>)</td>
        <td nowrap=""><code>CH-001</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-002</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-003</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-004</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-005</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="래퍼런스-references--프로젝트-설계-과정에-참고한-자료">래퍼런스 (<code class="language-plaintext highlighter-rouge">References</code>) : 프로젝트 설계 과정에 참고한 자료</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="" style="padding-left: 4%; padding-right: 4%;">분류</td>
        <td nowrap="">이름</td>
        <td nowrap="">저자</td>
        <td nowrap="">주소</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="" rowspan="2">논문</td>
        <td>보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼 (2018)</td>
        <td nowrap="">김도희</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td>보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문. (2012)</td>
        <td nowrap="">임현정</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="1">기사</td>
        <td>한국 보컬로이드는 어떻게 나아가야할까?</td>
        <td nowrap="">안태춘</td>
        <td nowrap=""><a href="https://www.newslight.kr/news/655301">더뉴스라이트</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">도서</td>
        <td>서비스를 성공시키는 기획자의 비법 노트</td>
        <td nowrap="">조이</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=295601741">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>사례로 배우는 언어 전환 프로젝트 관리</td>
        <td nowrap="">남경호</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>도메인 주도 설계로 시작하는 마이크로서비스 개발</td>
        <td nowrap="">한정헌, 유해식, 최은정, 이주영</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">문서</td>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말">문서</a></td>
      </tr>
      <tr>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말/심화</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말/심화">문서</a></td>
      </tr>
      <tr>
        <td>공공기관 웹사이트 구축·운영 가이드</td>
        <td nowrap="">행정안전부</td>
        <td nowrap=""><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj204K9zoKEAxWtLUQIHQsyB4AQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.mois.go.kr%2Fcmm%2Ffms%2FFileDown.do%3FatchFileId%3DFILE_00084689_1WeMtZ%26fileSn%3D1&amp;usg=AOvVaw1TqMgiQXNjFgQfouwTtQh2&amp;opi=89978449">문서</a></td>
      </tr>
            <tr>
        <td nowrap="" rowspan="2">사이트</td>
        <td nowrap="" colspan="2">나무위키</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:대문">홈페이지</a></td>
      </tr>
      <tr>
        <td nowrap="" colspan="2">openNAMU</td>
        <td nowrap=""><a href="https://github.com/openNAMU/openNAMU">깃허브 저장소</a></td>
      </tr>
    </tbody>
  </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[프로젝트 목표 (Project Goal) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리]]></summary></entry><entry><title type="html">[JS] 8. 모듈 (Module)</title><link href="http://localhost:4000/js8/" rel="alternate" type="text/html" title="[JS] 8. 모듈 (Module)" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/js8</id><content type="html" xml:base="http://localhost:4000/js8/"><![CDATA[<h2 id="모듈-module--코드를-재사용-가능한-파일-단위의-조각으로-나눈-것">모듈 (<code class="language-plaintext highlighter-rouge">Module</code>) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것</h2>

<ul>
  <li>자신만의 모듈 스코프를 갖고, 어플리케이션과 독립적으로 자체 컴파일한 단위</li>
  <li>코드의 변수, 상수, 함수, 클래스 등을  선택적으로 공개 (<code class="language-plaintext highlighter-rouge">Export</code>)</li>
  <li>이름 충돌, 종속성 등 문제 해결 및 엄격 모드 자동 적용</li>
  <li><code class="language-plaintext highlighter-rouge">Read-Only</code>로 로드되며 동일 영역에 중복 <code class="language-plaintext highlighter-rouge">import</code> 가능</li>
</ul>

<h3 id="모듈-시스템-module-system--현재는-esm-ecmascript-module이-표준">모듈 시스템 (<code class="language-plaintext highlighter-rouge">Module System</code>) → 현재는 <code class="language-plaintext highlighter-rouge">ESM</code> (<code class="language-plaintext highlighter-rouge">ECMAScript Module</code>)이 표준!</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">"type": "module",</code> 추가</li>
  <li>모든 파일의 확장자를 <code class="language-plaintext highlighter-rouge">mjs</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm i esm → $&gt; node -r esm mod.js</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "name": "js",
  "version": "1.0.0",
  "description": "package.json for test",
  "main": "npm.js",
  "author": "pocj8ur4in",
  "type": "module", 
  "license": "ISC"
}
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/76d1a998-c16d-4823-8f8b-18e7c9399904" width="50%" /></p>

<h3 id="임포트-import--익스포트-export--특정-모듈에서-export한-것을-import">임포트 (<code class="language-plaintext highlighter-rouge">Import</code>) &amp; 익스포트 (<code class="language-plaintext highlighter-rouge">Export</code>) : 특정 모듈에서 <code class="language-plaintext highlighter-rouge">Export</code>한 것을 <code class="language-plaintext highlighter-rouge">Import</code></h3>

<ul>
  <li>모듈을 찾을 위치를 문자열로 지정하는 모듈 지정자 (<code class="language-plaintext highlighter-rouge">Module Specifier</code>) 사용</li>
  <li>중복으로 임포트하더라도 실행 컨텍스트 단위 하나당 한번만 로드 (<code class="language-plaintext highlighter-rouge">Module Map</code>/<code class="language-plaintext highlighter-rouge">Tree</code>)</li>
  <li>임포트 및 익스포트 선언은 최상위 스코프에서만 가능, 표현식이 아니라 선언이므로 호이스팅</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export function fn() { ... }
export const value = 1;
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import {} from './mod.js';
import '.mod.js'; // side-effect only! → 임포트로 실행만 할 경우에 선언
</code></pre></div></div>

<h4 id="간접-익스포트-indirect-export--aggregating--다른-모듈의-일부-혹은-전체를-받아-다시-익스포트">간접 익스포트 (<code class="language-plaintext highlighter-rouge">Indirect Export &amp; Aggregating</code>) : 다른 모듈의 일부 혹은 전체를 받아 다시 익스포트</h4>

<ul>
  <li>필요한 모듈만 모아놓은 또 다른 모듈을 만들 때에 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export { xxx } from './mod1.js';
export { yyy } from './mod2.js';
export { zzz } from './mod3.js'; // 사용하려면 명시적으로 import한 후 export해야 함

→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

// import 후 export
import { xxx } from './mod3.js';
export { xxx };

→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

// 개선된 방법 with Aggregating
import { xxx, yyy, zzz } from './agg.js';

export * from './mod1.js';
export * from './mod2.js';
export * from './mod3.js';

import * as agg from './agg.js';
</code></pre></div></div>

<h3 id="동적-임포트-dynamic-import--코드-실행-중에-모듈을-비동기적으로-불러옴">동적 임포트 (<code class="language-plaintext highlighter-rouge">Dynamic Import</code>) : 코드 실행 중에 모듈을 비동기적으로 불러옴</h3>

<ul>
  <li>어플리케이션 초기 로딩 시 모든 모듈을 불러오지 않고, 필요한 모듈만 필요한 시점에 불러와서 성능을 최적화</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 동적 임포트
import('./path/to/module')
  .then((module) =&gt; {
    // 모듈을 사용
    console.log(module);
  })
  .catch((error) =&gt; {
    // 에러 처리
    console.error('모듈을 불러오는 동안 에러 발생:', error);
  });
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 조건에 따라 모듈 동적으로 로드
const condition = true;

if (condition) {
  import('./path/to/someModule')
    .then((someModule) =&gt; {
      someModule.doSomething();
    })
    .catch((error) =&gt; {
      console.error('모듈을 불러오는 동안 에러 발생:', error);
    });
}
</code></pre></div></div>

<h3 id="모듈-로더-module-loader--내부에서-임포트-및-익스포트를-관리">모듈 로더 (<code class="language-plaintext highlighter-rouge">Module Loader</code>) : 내부에서 임포트 및 익스포트를 관리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[ImportEntries]</code>와 <code class="language-plaintext highlighter-rouge">[ExportEntries]</code>라는 내장 슬롯으로 관리
    <ol>
      <li>임포트 &amp; 파싱 (구문 분석) : 모듈 레코드, 모듈 맵을 생성</li>
      <li>인스턴스화 : 모듈의 바인딩 및 환경 레코드를 생성</li>
      <li>모듈 실행 : 모듈 코드를 실행, 모듈이 ‘평가됨’으로 표시</li>
    </ol>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/fbced0dc-3bf5-4cd8-83f1-c98863730512" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { a } from './A.js'

Name: 'a'
Type: identifier
Value: 100
Mutable: false
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d48c71cd-d17e-4267-93f8-41aff403005f" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/19645c89-cbc7-4c04-a114-99a01716f725" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/07c4ee10-d19f-44d9-8170-9df928164a5b" /></p>

<h3 id="npm-모듈-생성-및-업로드-httpswwwnpmjscom"><code class="language-plaintext highlighter-rouge">npm</code> 모듈 생성 및 업로드 (<a href="https://www.npmjs.com"><code class="language-plaintext highlighter-rouge">https://www.npmjs.com</code></a>)</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">npm</code> : <code class="language-plaintext highlighter-rouge">Node.js</code>의 패키지를 관리할 수 있는 도구</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Node.js</code>에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 <code class="language-plaintext highlighter-rouge">CLI</code> 제공</li>
    <li><code class="language-plaintext highlighter-rouge">npx</code> (<code class="language-plaintext highlighter-rouge">node package execute</code>)을 통해 패키지를 설치 및 실행</li>
    <li>국내에서는 패키지 중복 문제를 링크 방식으로 해결한 <code class="language-plaintext highlighter-rouge">yarn</code>을 많이 사용하는 추세</li>
  </ul>
</blockquote>

<ol>
  <li>패키지 이름 정하기 (<code class="language-plaintext highlighter-rouge">npm info &lt;pkg&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">npm init</code>으로 <code class="language-plaintext highlighter-rouge">package.json</code> 작성</li>
  <li>의존 관계가 있으면 <code class="language-plaintext highlighter-rouge">npm install</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm login</code> 후 배포 <code class="language-plaintext highlighter-rouge">npm publish --access public</code></li>
</ol>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[모듈 (Module) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것]]></summary></entry><entry><title type="html">[JS] 5. 함수 (Function)</title><link href="http://localhost:4000/js5/" rel="alternate" type="text/html" title="[JS] 5. 함수 (Function)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js5</id><content type="html" xml:base="http://localhost:4000/js5/"><![CDATA[<h2 id="함수-function--일련의-과정을-코드-블록으로-감싸-하나의-단위로-정의한-것">함수 (<code class="language-plaintext highlighter-rouge">Function</code>) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c6d16c9b-7b9c-4340-bbab-88b15bfd53db" width="80%" /></p>

<ul>
  <li>자바스크립트의 함수는 객체 타입의 값 → 함수 또한 함수 리터럴 (<code class="language-plaintext highlighter-rouge">functional literal</code>)로 생성할 수 있음</li>
  <li>일반 객체와 달리, 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 가짐</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/05176279-d1d8-4756-8bb3-5186474aa123" width="80%" /></p>

<h3 id="함수-정의-function-definition--함수-호출-이전에-인수를-전달받을-매개변수-문-반환값을-지정">함수 정의 (<code class="language-plaintext highlighter-rouge">Function Definition</code>) : 함수 호출 이전에 인수를 전달받을 매개변수, 문, 반환값을 지정</h3>

<blockquote>
  <p>함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되므로, 함수는 정의된다고 할 수 있다.</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0b6c992d-5608-47a8-b2bc-0af11c3c9b24" width="80%" /></p>

<h4 id="함수-선언문-function-declaration">함수 선언문 (<code class="language-plaintext highlighter-rouge">Function Declaration</code>)</h4>

<ul>
  <li>함수 선언문은 함수 리터럴과 형태가 동일</li>
  <li>함수 리터럴은 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음</li>
</ul>

<h4 id="함수-표현식-function-expression">함수 표현식 (<code class="language-plaintext highlighter-rouge">Function Expression</code>)</h4>

<h4 id="function-생성자-함수"><code class="language-plaintext highlighter-rouge">Function</code> 생성자 함수</h4>

<h4 id="화살표-함수-arrow-function">화살표 함수 (<code class="language-plaintext highlighter-rouge">Arrow Function</code>)</h4>

<h3 id="함수-매개변수-argument--값-parameter--변수">함수 매개변수 (<code class="language-plaintext highlighter-rouge">Argument</code> : 값, <code class="language-plaintext highlighter-rouge">Parameter</code> : 변수)</h3>

<h3 id="즉시-호출-함수-iife">즉시 호출 함수 <code class="language-plaintext highlighter-rouge">IIFE</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function() { ... })();
</code></pre></div></div>

<h3 id="함수의-호출-방식과-this">함수의 호출 방식과 <code class="language-plaintext highlighter-rouge">this</code></h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b706b06f-966b-458a-a6f5-22131c6681ff" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code>를 바인딩하는 방법 : <code class="language-plaintext highlighter-rouge">call</code>, <code class="language-plaintext highlighter-rouge">apply</code>, <code class="language-plaintext highlighter-rouge">bind</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(id) {
  console.log(this, id, this.name);
}

const obj = { name: 'Kim' };

// bind
const bf1 = func.bind(obj);
bf1(1, '서울');

// apply
func.apply(obj, [ 2, '부산' ]);

// call
func.call(obj, 3, '대구');
</code></pre></div></div>

<h2 id="순수-함수-pure-function--함수로서의-함수">순수 함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>) : 함수로서의 함수</h2>

<ul>
  <li>입력이 같으면 결과도 같다! → <code class="language-plaintext highlighter-rouge">Side Effect</code>가 없다. 즉, 외부의 값을 변경시키지 않아야 한다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const weeks = ['일', '월', '화', '수', '목', '금', '토'];

const getWeekName = function(weekNo) {
  return `${weeks[weekNo]}요일`;
};

const day = new Date().getDay();
console.log(`오늘은 ${getWeekName(day)}입니다!`);
</code></pre></div></div>

<p>→ 외부에 값을 두지 않고 내부에 값을 두는 클로저를 활용해야 한다!</p>

<h2 id="고차-함수-higher-order-function--다른-함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 다른 함수를 인자로 받거나 함수를 반환하는 함수</h2>

<blockquote>
  <p>자바스크립트에서의 함수는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class Citizen</code>)</p>

  <ol>
    <li>변수에 할당 (<code class="language-plaintext highlighter-rouge">Assignment</code>)할 수 있다.</li>
    <li>다른 변수의 인자 (<code class="language-plaintext highlighter-rouge">Argument</code>)로 전달될 수 있다.</li>
    <li>다른 함수의 결과로 반환 (<code class="language-plaintext highlighter-rouge">Return</code>)될 수 있다.</li>
  </ol>

  <p>→ 함수가 일급 객체이므로, 함수를 데이터와 유사하게 다룰 수 있어 ‘고차 함수’로서 활용될 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const double = (n) =&gt; { return n * 2; };
console.log(double(4)); // 4 * 2 = 8
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const adder = added =&gt; num =&gt; num + added;
console.log(adder(5)(3)); // 5 + 3 = 8
</code></pre></div></div>

<ul>
  <li>함수의 형태로 반환되는 함수를 모두 고차 함수라 정의할 수 있다.
    <ul>
      <li>함수는 일급 객체 → 일급 객체로서의 함수는 고차 함수로 활용 가능</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>함수를 리턴하는 함수를 커리 함수 (<code class="language-plaintext highlighter-rouge">Curry Function</code>)라고 부르던데…?</p>

  <ul>
    <li>커리 함수라는 용어로, 고차 함수를 ‘함수를 인자로 받는 함수’에만 한정해 사용할 수 있음
      <ul>
        <li>엄밀히 말하면, 고차 함수가 커리 함수를 포함하는 개념</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Array.map()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 호출한 다음, 그 결과를 새로운 배열로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].map((num) =&gt; { return num * num; })); // [ 1, 4, 9, 16, 25 ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.filter()</code> 함수 : 배열의 요소 중에 주어진 조건을 만족하는 요소만을 추출하여 새로운 배열로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].filter((num) =&gt; { return num % 2 === 0 })); // [ 2, 4 ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.reduce()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 누적하여 하나의 값으로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].reduce((accumulator, currentValue)
  =&gt; { return accumulator + currentValue;}, 0)); // 15
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.forEach()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행 (반환값이 존재하지 않음)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5].forEach((num) =&gt; { console.log(num); }); // 1부터 5까지 순서대로 출력
</code></pre></div></div>

<h2 id="콜백-함수-callback-function--매개변수를-통해-다른-함수의-내부로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) : 매개변수를 통해 다른 함수의 내부로 전달되는 함수</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; { console.log(`출력`); }, 1);
</code></pre></div></div>

<ul>
  <li>고차 함수의 인자로 전달되어, 특정 동작을 수행하거나 완료 시에 호출
    <ul>
      <li>콜백 함수를 전달받은 고차 함수는 함수 내부에서 이 콜백 함수르 호출 (<code class="language-plaintext highlighter-rouge">Invoke</code>)할 수 잇음</li>
      <li>부르는 조건에 따라서 콜백 함수의 실행 조건을 결정할 수 있음</li>
    </ul>
  </li>
  <li>콜백 함수를 언제 호출하는지에 따라, 자바스크립트 엔진이 콜백 함수의 호출 시점을 결정
    <ul>
      <li>함수가 실행되면 콜 스택에 함수를 넣었다가, 함수에서 반환이 일어날 때 가장 위쪽에서 해당 함수를 꺼냄</li>
      <li>이벤트 루프는 콜 스택과 테스크 큐를 주시하고 있다가, 스택이 비어 있으면 큐의 첫번째 콜백을 스택에 쌓아 실행</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>매개변수를 통해 다른 함수로 전달되는 함수는 콜백 함수, 매개변수를 통해 콜백 함수를 전달받는 함수는 고차 함수!</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// printString : 두개의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const printString = (callbackHof, callback_only, str) =&gt; {
    str +=' 반이고';
    callbackHof( callback_only, str ); 
}

// concatFirst : printString의 매개변수로 활용되는 콜백함수이면서,
// 하나의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const concatFirst = (callback_only, str) =&gt; {
  callback_only(str);
}

// concatAgain : concatFirst의 매개변수로 활용되는 콜백함수
const concatAgain = (str) =&gt; {
  str += ' 가만히 있으면 반이라도 간다';
  console.log(str);
}

printString(concatFirst, concatAgain, '시작은'); // 시작은 반이고 가만히 있으면 반이라도 간다
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[함수 (Function) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것]]></summary></entry><entry><title type="html">[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)</title><link href="http://localhost:4000/js4/" rel="alternate" type="text/html" title="[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js4</id><content type="html" xml:base="http://localhost:4000/js4/"><![CDATA[<h2 id="스코프-scope--변수에-접근할-수-있는-범위">스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수에 접근할 수 있는 범위</h2>

<ul>
  <li>변수가 선언되었을 때, 선언 위치에 의해 해당 변수에 접근할 수 있는 코드의 영역이 결정
    <ul>
      <li>자바스크립트 엔진은 스코프를 통해 참조 대상 식별자를 찾아 변수를 식별</li>
    </ul>
  </li>
</ul>

<h3 id="전역-스코프-global-level-scope--코드-어디에서나-참조-가능">전역 스코프 (<code class="language-plaintext highlighter-rouge">Global-level Scope</code>) → 코드 어디에서나 참조 가능</h3>

<ul>
  <li>전역에 선언된 전역 변수 (<code class="language-plaintext highlighter-rouge">Global variable</code>) 는 전역 객체 (<code class="language-plaintext highlighter-rouge">Global Object</code>)의 프로퍼티</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var global = 'global';

function main() {
  var local = 'local';
  console.log(global);
  console.log(local);
}

console.log(global);
console.log(local); // Uncaught ReferenceError: local is not defined
</code></pre></div></div>

<h3 id="함수-스코프-function-level-scope--함수-자신과-하위-함수에서만-참조-가능">함수 스코프 (<code class="language-plaintext highlighter-rouge">Function-level Scope</code>) → 함수 자신과 하위 함수에서만 참조 가능</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function () {
  var local = 'local';
  console.log(local);
})();
</code></pre></div></div>

<h3 id="블록-스코프-block-level-scope--블록-내에서만-참조-가능">블록 스코프 (<code class="language-plaintext highlighter-rouge">Block-level Scope</code>) → 블록 내에서만 참조 가능</h3>

<h3 id="모듈-스코프-module-level-scope-">모듈 스코프 (<code class="language-plaintext highlighter-rouge">Module-level Scope</code>) →</h3>

<h3 id="렉시컬-스코프-lexical-level-scope">렉시컬 스코프 (<code class="language-plaintext highlighter-rouge">Lexical-level Scope</code>)</h3>

<h3 id="암묵적-전역-implicit-global">암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)</h3>

<h2 id="실행-컨텍스트-execution-context--실행할-코드에-제공할-환경-정보들을-모아놓은-객체">실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;

function f1(x, y) {
  var gg = 11;   let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('first');
  { 
    const xx = 99;
    let lll = 0;
    f2('nest-first');
    var zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  function f2(t, u) { console.log(t, 'inner', xx, zz); }
  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); }
  var zz = 800;
  f2('second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f1(1,2);   console.log(kk, yy);

f2('third');
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/40dca0b0-9e4b-44d6-a36c-83aee24fc2e3" /></p>

<p><code class="language-plaintext highlighter-rouge">(1)</code> 전역 코드 평가 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg;  let bb;
function f1(x, y) { ... } // Function Object
function f2(g) { ... }    // Function Object
let xx;
var kk;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(2)</code> 전역 코드 실행 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;
let xx = 9;
if (gg &gt; 0) { ... }
f1(1,2);   console.log(kk, yy);
f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(3)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">if</code>문 코드 블록 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (gg &gt; 0) { // var gg = 1;
  var kk = 33; var yy = 9;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(4)</code> 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  var gg;   let bb;
  { ... }
  // function f2(t, u) { ... } // Function Object
  function f2(t, u, v) { ... } // Function Object
  var zz;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(5)</code> 함수 코드 평가 단계 내부의 블록 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">{ ... }</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  { 
    const xx;
    let lll;
    var zz;
    function f2(t) { ... } // Function Object
  }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(6)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length); // f1&gt; 11, 22, undefined, f2, 3
  f2('first');
  { ... }
  zz = 800;
  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(7)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  f2('first');

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(8)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  f2('first'); // first inner2 9 undefined

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(9)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  { 
    xx = 99;
    lll = 0;
    f2('nest-first');
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(10)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;

  { 
    xx = 99;
    lll = 0;
    f2('nest-first'); // nest-first nested 99 undefined 0
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(11)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }

  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(12)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  f2('second'); // second nested 99 800 0
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(13)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">console.log</code> 문 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1;  bb = 2;

console.log(kk, yy); // 33 9
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(14)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 평가</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(15)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third'); // third global f2&gt; 1 2 9 33
</code></pre></div></div>

<blockquote>
  <p><b>블록 코드 평가 및 실행</b></p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">Global</code>/<code class="language-plaintext highlighter-rouge">Function</code> 평가할 때 <code class="language-plaintext highlighter-rouge">Block scope</code>를 만나면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 생성한다.<br />(별도의 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>를 생성하지 않고 독립적인 <code class="language-plaintext highlighter-rouge">Lexical Environment</code>만을 생성한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block code</code>를 평가하여 이 <code class="language-plaintext highlighter-rouge">Block</code>에 대한 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>를 생성한다.</li>
    <li><code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">let</code>은 <code class="language-plaintext highlighter-rouge">notInitializedYet</code> 상태로 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 등록되고, <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code> 선언식 등은 부모 <code class="language-plaintext highlighter-rouge">Function scope</code>의 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>에 <code class="language-plaintext highlighter-rouge">hoisting</code>한다.<br />(이때 <code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>가 아니라 <code class="language-plaintext highlighter-rouge">var</code>와 같이 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 끝나면, 평가 종료 후 상위 <code class="language-plaintext highlighter-rouge">scope code</code>를 계속 평가한다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 실행되면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 만들고, 부모 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 가져온다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code> 내의 <code class="language-plaintext highlighter-rouge">Function</code> 선언식은 무조건 <code class="language-plaintext highlighter-rouge">Block</code> 최상단에 <code class="language-plaintext highlighter-rouge">hoisting</code>되어 있으므로 먼저 실행한다.<br />(이 시점에 상위 <code class="language-plaintext highlighter-rouge">function-scope</code>에 함수를 정의해, <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>으로 인정된다!)</li>
    <li>그 외의 코드 (할당문 및 다른 함수 호출)를 한 줄씩 실행된다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>의 실행이 끝나면, <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 다시 부모로 돌려준다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>은 조건에 따라 실행 여부가 결정된다. 평가 시 블럭 내의 <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">undefined</code>로 <code class="language-plaintext highlighter-rouge">hoisting</code>되고, 조건이 만족하여 호출 및 실행될 때에만 <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>와 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>를 만들고 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>로 정의된다.</li>
  </ol>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a69498fb-6f39-413d-8a75-ef547e4ba4b5" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1271743-b805-4040-9743-39e7b2cd5bda" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5272ac93-d18b-4112-a45f-46d657839a3d" /></p>

<h2 id="엄격-모드-strict-mode--자바스크립트가-묵인한-에러를-발생시켜-엄격한-오류-검사를-적용">엄격 모드 (<code class="language-plaintext highlighter-rouge">Strict Mode</code>) : 자바스크립트가 묵인한 에러를 발생시켜 엄격한 오류 검사를 적용</h2>

<ul>
  <li>선언하지 않은 식별자는 접근할 수 없음</li>
  <li>암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)은 허용하지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">Delete</code>로 선언된 변수, 함수, 매개변수를 삭제할 수 없음</li>
  <li>블록 내에서의 함수는 블록 스코프 (블록 내 함수는 볼록의 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 존재)</li>
  <li>함수 내에서 매개변수의 이름이 동일해선 안됨</li>
  <li><code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">Infinite</code> 등의 전역 프로퍼티에 값을 할당해선 안됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'use strict';


var gg = 1;
let bb = 2;

function f1(x, y) {
  var gg = 11;
  let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('* first');
  {
    const xx = 99;
    f2('* nest-first');
    var zz = 88;
    function f2(t) {
      console.log(t, '`nested`', xx, zz);
    }
  }
  function f2(t, u) {
    console.log(t, '`inner`', xx, zz);
  }
  function f2(t, u, v) {
    console.log(t, '`inner2`', xx, zz);
  }
  var zz = 800;
  console.log('gg:', gg);
  f2('* second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}
let xx = 9;
if (gg &gt; 0) {
  var kk = 33;
  const yy = 9;
}
f1(1, 2); 
console.log('kkkkk&gt;&gt;', kk);
f2('* third');
</code></pre></div></div>

<h2 id="클로저-closure--함수가-특정-스코프에-접근할-수-있도록-의도적으로-그-스코프에서-정의한-것">클로저 (<code class="language-plaintext highlighter-rouge">Closure</code>) : 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의한 것</h2>

<ul>
  <li>상위 스코프의 식별자를 참조하는 하위 스코프 (함수, 메소드)가 외부에서 참조되어 상위 스코프보다 오래 살아있는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let user;
{
  const private = {
    id: 1,
    name: 'John'
  }
  user = private;
}

user.age = 30;

console.log(user); // { id: 1, name: 'John', age: 30 }
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(x) {
  let clo = function (y) {
    console.log(y);
  }

  return clo(x);
}

func('a'); // a
</code></pre></div></div>

<blockquote>
  <p>클로저를 활용하여 외부변수로 인해 오염될 수 있는 비순수함수 (<code class="language-plaintext highlighter-rouge">Impure Function</code>)를, 함수 내부로 전달된 인수에게만 의존하여 반환값을 만드는 순수함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>)로 바꿀 수 있다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 비순수함수
let cnt1 = 0;

function func1(x) {
  cnt1 += 1;
  return cnt1;
}

console.log(func1()); // 1
console.log(func1()); // 2
console.log(func1()); // 3

// → 순수함수
function func2() {
  let cnt2 = 0;
  return function temp() {
    cnt2 += 1;
    return cnt2;
  };
}

const counter1 = func2();
const counter2 = func2();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[스코프 (Scope) : 변수에 접근할 수 있는 범위]]></summary></entry><entry><title type="html">고차 함수, 콜백 함수 (2024.01.31)</title><link href="http://localhost:4000/digital_hanaro_5.md/" rel="alternate" type="text/html" title="고차 함수, 콜백 함수 (2024.01.31)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_5.md</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_5.md/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 5일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부한-내용">공부한 내용</h2>

<p>고차함수, 콜백함수의 개념을 정리해보고 이 둘의 차이점에 대해 짚어보고자 하였다.</p>

<h3 id="고차-함수-higher-order-function--다른-함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 다른 함수를 인자로 받거나 함수를 반환하는 함수</h3>

<blockquote>
  <p>자바스크립트에서의 함수는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class Citizen</code>)</p>

  <ol>
    <li>변수에 할당 (<code class="language-plaintext highlighter-rouge">Assignment</code>)할 수 있다.</li>
    <li>다른 변수의 인자 (<code class="language-plaintext highlighter-rouge">Argument</code>)로 전달될 수 있다.</li>
    <li>다른 함수의 결과로 반환 (<code class="language-plaintext highlighter-rouge">Return</code>)될 수 있다.</li>
  </ol>

  <p>→ 함수가 일급 객체이므로, 함수를 데이터와 유사하게 다룰 수 있어 ‘고차 함수’로서 활용될 수 있다.</p>
</blockquote>

<ul>
  <li>함수의 형태로 반환되는 함수를 모두 고차 함수라 정의
    <ul>
      <li>함수는 일급 객체 → 일급 객체로서의 함수는 고차 함수로 활용 가능</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const double = (n) =&gt; { return n * 2; };
console.log(double(4)); // 4 * 2 = 8
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const adder = added =&gt; num =&gt; num + added;
console.log(adder(5)(3)); // 5 + 3 = 8
</code></pre></div></div>

<blockquote>
  <p>함수를 리턴하는 함수를 커리 함수 (<code class="language-plaintext highlighter-rouge">Curry Function</code>)라고 부르던데…?</p>

  <ul>
    <li>커리 함수라는 용어로, 고차 함수를 ‘함수를 인자로 받는 함수’에만 한정해 사용할 수 있음
      <ul>
        <li>엄밀히 말하면, 고차 함수가 커리 함수를 포함하는 개념</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="arraymap-함수--배열의-각-요소에-대해-주어진-함수를-호출한-다음-그-결과를-새로운-배열로-반환"><code class="language-plaintext highlighter-rouge">Array.map()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 호출한 다음, 그 결과를 새로운 배열로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].map((num) =&gt; { return num * num; })); // [ 1, 4, 9, 16, 25 ]
</code></pre></div></div>

<h4 id="arrayfilter-함수--배열의-요소-중에-주어진-조건을-만족하는-요소만을-추출하여-새로운-배열로-반환"><code class="language-plaintext highlighter-rouge">Array.filter()</code> 함수 : 배열의 요소 중에 주어진 조건을 만족하는 요소만을 추출하여 새로운 배열로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].filter((num) =&gt; { return num % 2 === 0 })); // [ 2, 4 ]
</code></pre></div></div>

<h4 id="arrayreduce-함수--배열의-각-요소에-대해-주어진-함수를-실행하고-그-결과를-누적하여-하나의-값으로-반환"><code class="language-plaintext highlighter-rouge">Array.reduce()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 누적하여 하나의 값으로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].reduce((accumulator, currentValue) =&gt; { return accumulator + currentValue;}, 0)); // 15
</code></pre></div></div>

<h4 id="arrayforeach-함수--배열의-각-요소에-대해-주어진-함수를-실행-반환값이-존재하지-않음"><code class="language-plaintext highlighter-rouge">Array.forEach()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행 (반환값이 존재하지 않음)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5].forEach((num) =&gt; { console.log(num); }); // 1부터 5까지 순서대로 출력
</code></pre></div></div>

<h3 id="콜백-함수-callback-function--매개변수를-통해-다른-함수의-내부로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) : 매개변수를 통해 다른 함수의 내부로 전달되는 함수</h3>

<ul>
  <li>고차 함수의 인자로 전달되어, 특정 동작을 수행하거나 완료 시에 호출
    <ul>
      <li>콜백 함수를 전달받은 고차 함수는 함수 내부에서 이 콜백 함수르 호출 (<code class="language-plaintext highlighter-rouge">Invoke</code>)할 수 잇음</li>
      <li>부르는 조건에 따라서 콜백 함수의 실행 조건을 결정할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; { console.log(`출력`); }, 1);
</code></pre></div></div>

<ul>
  <li>매개변수를 통해 다른 함수의 내부로 전달되는 함수는 콜백 함수, 매개변수를 통해 콜백 함수를 전달받는 함수는 고차 함수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// printString : 두개의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const printString = (callbackHof, callback_only, str) =&gt; {
    str +=' 반이고';
    callbackHof( callback_only, str );
}

// concatFirst : printString의 매개변수로 활용되는 콜백함수이면서, 하나의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const concatFirst = (callback_only, str) =&gt; {
  callback_only(str);
}

// concatAgain : concatFirst의 매개변수로 활용되는 콜백함수
const concatAgain = (str) =&gt; {
  str += ' 가만히 있으면 반이라도 간다';
  console.log(str);
}

printString(concatFirst, concatAgain, '시작은'); // 시작은 반이고 가만히 있으면 반이라도 간다
</code></pre></div></div>

<blockquote>
  <p>콜백 함수를 언제 호출하는지에 따라, 자바스크립트 엔진이 콜백 함수의 호출 시점을 결정할 수 있다!</p>

  <ul>
    <li>함수가 실행되면, 콜 스택 (<code class="language-plaintext highlighter-rouge">Call Stack</code>)에 함수를 넣었다가 함수에서 반환이 일어날 때 가장 위쪽에서 해당 함수를 꺼낸다.</li>
    <li>이벤트 루프 (<code class="language-plaintext highlighter-rouge">Event Loop</code>)는 콜 스택과 테스크 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>)를 주시하고 있다가, 스택이 비어 있으면 큐의 첫번째 콜백을 스택에 쌓아 실행한다.</li>
  </ul>
</blockquote>

<blockquote>
  <p>참고</p>

  <ul>
    <li><a href="https://www.datoybi.com/callback-promise-async-await/">Steady-Dev, ‘Callback &amp; Promise &amp; async/await 톺아보기’</a></li>
    <li><a href="https://soldonii.tistory.com/119">soldonii, ‘200106(월) : 비동기, 고차함수, 일급객체, V8 엔진 등’</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 5일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[TIL] 2024년 02월 TIL</title><link href="http://localhost:4000/til2/" rel="alternate" type="text/html" title="[TIL] 2024년 02월 TIL" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til2</id><content type="html" xml:base="http://localhost:4000/til2/"><![CDATA[<h2 id="february-2024--시간-관리의-중요성"><code class="language-plaintext highlighter-rouge">February, 2024</code> : 시간 관리의 중요성!</h2>

<p>앞서 2023년이 다사다난한 해라고 말하였는데, 2024년 01월은 그것보다 더 폭풍 같은 한달이었던 것 같다. 다른 것보다도 디지털하나路 2기에 합격하여 9시부터 6시까지 수업을 듣고, 또 6시부터 8시까지 자습하는 생활을 2주간 하다보니 이전보다 내 실력이 증진되는 것 같다는 느낌을 많이 받고 있다. 그렇지만 한달을 회고해보면 아쉬운 점 또한 있다. 1월 1일에 신년을 맞이하면서 내가 해야할 일을 크게 7개의 항목으로 정리하였던 적이 있는데, 어떤 항목은 잘 진행되고 있는데 또다른 어떤 항목은 아직 손도 못댄 부분도 있기 때문이다. 지속적으로 개발 관련 도서를 챕터를 나누어 공부하거나 협업 프로젝트를 진행하고자 기획서를 작성하려고 노력하고 있는데, 아무래도 주중에 수업 및 스터디가 있어서 주말에 한정된 시간을 쓰다보니 생각만큼 진행이 되지 않는 부분이 있다. 그래서 결국 내게 지금 필요한 것은 <b>시간을 효율적으로 관리하여 이를 성과로 이끌어내는 것</b>이라고 생각이 든다. 당장 다음달 초에 정보처리기사와 <code class="language-plaintext highlighter-rouge">SQLD</code> 필기가 예정되어 있는 만큼, 이번 한 달 역시 모든 것에 열심히 임하고자 한다.</p>

<h3 id="2024년-02월-01일-목">2024년 02월 01일 (목)</h3>

<ul>
  <li>디지털하나路 및 모던 자바스크립트 <code class="language-plaintext highlighter-rouge">Deep Dive</code>에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>오늘은 자바스크립트의 객체지향 프로그래밍에 대해 공부하는 시간을 가졌다. 흔히 자바스크립트는 프로토타입 기반 객체지향 언어로 정의하는데, 각각의 프로퍼티들은 프로토타입 체인을 통해 내부 참조를 따라 상위 프로토타입을 순차적으로 검색하는 구조를 갖는다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-02일-금">2024년 02월 02일 (금)</h3>

<ul>
  <li>디지털하나路 및 모던 자바스크립트 <code class="language-plaintext highlighter-rouge">Deep Dive</code>에서 배운 내용을 정리한 게시글을 작성하고 있다.</li>
</ul>

<h3 id="2024년-02월-03일-토">2024년 02월 03일 (토)</h3>

<ul>
  <li>어제에 이어, <code class="language-plaintext highlighter-rouge">vocawik</code> 기획서의 기능 명세서를 작성하고 있다. 그리고 그동안 작업한 내용을 바탕으로 <code class="language-plaintext highlighter-rouge">vocawik</code> <a href="https://pocj8ur4in.github.io/vocawik1/">프로젝트 소개</a> 및 <a href="https://pocj8ur4in.github.io/vocawik2/">프로젝트 설계</a>에 대한 포스트를 작성하였다.</li>
</ul>

<h3 id="2024년-02월-04일-일">2024년 02월 04일 (일)</h3>

<ul>
  <li></li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TIL" /><summary type="html"><![CDATA[February, 2024 : 시간 관리의 중요성!]]></summary></entry><entry><title type="html">[JS] 7. 객체지향 프로그래밍 (OOP)</title><link href="http://localhost:4000/js7/" rel="alternate" type="text/html" title="[JS] 7. 객체지향 프로그래밍 (OOP)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js7</id><content type="html" xml:base="http://localhost:4000/js7/"><![CDATA[<h2 id="객체지향-프로그래밍-object-oriented-programming--원시-타입을-제외한-모든-것이-객체">객체지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">Object-Oriented Programming</code>) : 원시 타입을 제외한 모든 것이 객체</h2>

<blockquote>
  <p>자바스크립트는 프로토타입 (<code class="language-plaintext highlighter-rouge">Prototype</code>) 기반 객체지향 프로그래밍 언어 (<code class="language-plaintext highlighter-rouge">Lisp</code>  → <code class="language-plaintext highlighter-rouge">Scheme</code> → <code class="language-plaintext highlighter-rouge">JavaScript</code>)</p>
</blockquote>

<ul>
  <li>객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>)과 클래스 (<code class="language-plaintext highlighter-rouge">Class</code>)를 통해 생성된 인스턴스 타입 (<code class="language-plaintext highlighter-rouge">Instance Type</code>) → <code class="language-plaintext highlighter-rouge">this</code></li>
  <li>프로퍼티는 각 인스턴스의 <code class="language-plaintext highlighter-rouge">EnvRec</code>에 생성되고, 메소드는 프로토타입에 할당되어 모든 인스턴스가 동일
    <ul>
      <li>특정 인스턴스에 종속되지 않는 함수는 정적인 클래스 메소드 (<code class="language-plaintext highlighter-rouge">Class Method</code>)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Animal {}
class Dog extends Animal {}
const lucy = new Dog();

console.log(lucy instanceof Dog); // true
console.log(lucy instanceof Animal); // true
console.log(lucy instanceof Object); // true

console.log(Object.getPrototypeOf(lucy)); // Animal {}
console.log(Object.getPrototypeOf(Dog)); // [class Animal]
console.log(Object.getPrototypeOf(Animal)); // {}
</code></pre></div></div>

<ul>
  <li>프로토타입은 단방향 <code class="language-plaintext highlighter-rouge">LinkedList</code>으로 연결된 구조 → 프로토타입 체인 (<code class="language-plaintext highlighter-rouge">Prototype Chain</code>)
    <ul>
      <li>특정 프로퍼티에 접근할 때 해당 객체에 프로퍼티가 없으면, 내부 참조를 따라 상위 프로토타입을 순차적으로 검색</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/eabe913e-8056-4309-bd18-ea12d555dfc5" width="50%" /></p>

<h3 id="정적-필드--메소드-static-field--method--특정-인스턴스와-무관하게-클래스에-존재하는-메소드">정적 필드 &amp; 메소드 (<code class="language-plaintext highlighter-rouge">Static Field &amp; Method</code>) : 특정 인스턴스와 무관하게 클래스에 존재하는 메소드</h3>

<ul>
  <li>인스턴스 프로퍼티를 참조할 수 없음 → <code class="language-plaintext highlighter-rouge">Static</code>  영역에 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Animal {
  static ID = 1;
  static isDog(ani) {
    return ani.name === 'Dog';
  }
} 
const dog = new Animal('Dog');
dog.isDog(dog); // TypeError: dog.isDog is not a function
Animal.isDog(dog); // OK
</code></pre></div></div>

<blockquote>
  <p>싱글톤 패턴 (<code class="language-plaintext highlighter-rouge">Singleton Pattern</code>) : 어떤 클래스가 한 번만 인스턴스화되어, 그 인스턴스에 대한 전역 접근 제공</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Singleton {
  static #_instance; // 관례상 protected
  constructor() {
    if (Singleton.#_instance) return Singleton;
    this.name = 'Singleton';
    Singleton.#_instance = this;
  }

  static getInstance() {
    return this.#_instance || new this();
  }
}

const s1 = new Singleton();
const s2 = new Singleton();
</code></pre></div>  </div>
</blockquote>

<h3 id="접근자-accessor-프로퍼티--특정-인스턴스와-무관하게-클래스에-존재하는-메소드">접근자 (<code class="language-plaintext highlighter-rouge">Accessor</code>) 프로퍼티 : 특정 인스턴스와 무관하게 클래스에 존재하는 메소드</h3>

<ul>
  <li>접근자 프로퍼티을 통해 함수를 프로퍼티처럼 활용할 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Emp1 {
  set fullName(name) { // set을 프로퍼티처럼 활용할 수 있음 → accessor
    [this.firstName, this.lastName] = name.split(' ');
  }
  
  get fullName() {  // get을 프로퍼티처럼 활용할 수 있음 → accessor
    return `${this.firstName} ${this.lastName}`;
  }
}

class Emp2 { // stackOverflow 발생!
  set name(nm) { this.name = nm; }
  get name() { return this.name; }
}

class Emp3 {
  #name;

  set name(#name) { this.#name = name; }
  get name() { return this.name; }
}

const hong1 = new Emp1();
hong1.fullName = 'Gil-Dong Hong';
console.log(hong1.fullName);

const hong2 = new Emp2();
hong2.fullName = 'Gil-Dong Hong';
console.log(hong2.fullName);

const hong3 = new Emp3();
hong3.fullName = 'Gil-Dong Hong';
console.log(hong3.fullName);
</code></pre></div></div>

<h3 id="프록시-proxy-객체--객체의-특정-동작을-가로채서-hooking해서-추가-동작-수행">프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>) 객체 : 객체의 특정 동작을 가로채서 (<code class="language-plaintext highlighter-rouge">Hooking</code>)해서 추가 동작 수행</h3>

<ul>
  <li>객체의 작업에 대한 기록 → 로깅 (<code class="language-plaintext highlighter-rouge">Logging</code>)</li>
  <li>잘못된 접근에 대한 오류 (<code class="language-plaintext highlighter-rouge">Validation Check</code>)</li>
  <li>기능 제어 (읽기 전용 등) 및 객체 정보 숨기기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const obj = {
  id: 1,
  name: 'Hong',
  f() {
    console.log('fffff')
  },
};

export const objProxy = new Proxy(obj, {
  set(target, prop, value){
    console.log('proxy.set&gt;&gt;', prop, value);
    target[prop] = value;
  },
  get(target, prop){
    console.log('proxy.get &gt;&gt; ', prop);
    return target[prop];
  },
});

objProxy.id = 100;
console.log('obj.id&gt;&gt;', objProxy.id, obj['id']);
</code></pre></div></div>

<h3 id="상속-inheritance--subclass가-프로토타입-체인으로-superclass의-모든-데이터와-기능을-상속">상속 (<code class="language-plaintext highlighter-rouge">Inheritance</code>) : <code class="language-plaintext highlighter-rouge">SubClass</code>가 프로토타입 체인으로 <code class="language-plaintext highlighter-rouge">Superclass</code>의 모든 데이터와 기능을 상속</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Dog extends Animal {
  constructor(name) {
    super(name); // 필수(for chaining) + 중복(overload) 불가!
  }

  bark() {
    console.log('bowwow!');
  }
}
</code></pre></div></div>

<ul>
  <li>모든 객체는 프로토타입 체인 (<code class="language-plaintext highlighter-rouge">__proto__</code>) 이라는 내부 속성을 가짐
    <ul>
      <li>객체를 생성하는 생성자 함수는 <code class="language-plaintext highlighter-rouge">prototype</code> 속성을 가짐 → 해당 프로토타입이 객체의 프로토타입가 됨</li>
      <li>하위 객체는 상위 객체의 프로토타입을 따라 상위 객체의 속성 및 메소드를 탐색</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>스택 (<code class="language-plaintext highlighter-rouge">Stack</code>) &amp; 큐 (<code class="language-plaintext highlighter-rouge">Queue</code>) : 데이터를 저장하고 관리하기 위한 자료구조</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Stack { // 스택 자료구조
    collection = [];

    push(value) {
        this.collection.push(value);
    }
    pop() {
        return this.collection.pop();
    }
}

const stack = new Stack();
stack.push(1); // 추가하기
stack.push(2); // 추가하기
stack.push(3); // 추가하기
console.log(stack.pop()) // 마지막으로 추가된 하나 꺼내기

class Queue { // 큐 자료구조
    collection = [];

    enqueue(value) {
        this.collection.push(value);
    }

    dequeue() {
        return this.collection.shift();
    }
}

const queue = new Queue();
queue.enqueue(1); // 추가하기
queue.enqueue(2); // 추가하기
queue.enqueue(3); // 추가하기
console.log(queue.dequeue()) // 마지막으로 추가된 하나 꺼내기


</code></pre></div>  </div>
</blockquote>

<h4 id="메소드-오버라이딩-method-overriding--자식-클래스가-부모-클래스의-메소드를-재정의">메소드 오버라이딩 (<code class="language-plaintext highlighter-rouge">Method Overriding</code>) : 자식 클래스가 부모 클래스의 메소드를 재정의</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Animal {
  ...
  id = 1;       // 멤버 프로퍼티
  #age = 10;    // 멤버 프로퍼티 (protected)
  
  toString() {  // 객체의 toString() 오버라이딩 ([메소드] 다형성!)
    return `This animal's name is ${this.name}.`;
  }
} 
</code></pre></div></div>

<h4 id="다중-상속-multiple-inheritance--한-클래스가-여러-클래스들을-상속">다중 상속 (<code class="language-plaintext highlighter-rouge">Multiple Inheritance</code>) : 한 클래스가 여러 클래스들을 상속</h4>

<ul>
  <li>자바스크립트는 단일 상속 언어 → <code class="language-plaintext highlighter-rouge">Mixin</code>을 통해 제한적으로 구현할 수 있음 (타입스크립트 : <code class="language-plaintext highlighter-rouge">Interface</code>)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Mixin 정의
const myMixin = {
  sayHello() {
    console.log("Hello!");
  },
  sayGoodbye() {
    console.log("Goodbye!");
  },
};

function MyClass() {
  ... // 클래스의 생성자 로직
}

Object.assign(MyClass.prototype, myMixin); // Mixin 적용

const obj = new MyClass(); // 객체 생성 및 Mixin 메서드 호출
obj.sayHello();    // 출력: Hello!
obj.sayGoodbye();  // 출력: Goodbye!
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[객체지향 프로그래밍 (Object-Oriented Programming) : 원시 타입을 제외한 모든 것이 객체]]></summary></entry><entry><title type="html">[JS] 6. 배열 (Array) &amp;amp; 이터레이터 (Iterator)</title><link href="http://localhost:4000/js6/" rel="alternate" type="text/html" title="[JS] 6. 배열 (Array) &amp;amp; 이터레이터 (Iterator)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js6</id><content type="html" xml:base="http://localhost:4000/js6/"><![CDATA[<h2 id="배열-array--순서가-있는-데이터-집합">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 순서가 있는 데이터 집합</h2>

<ul>
  <li>배열의 각 요소 (<code class="language-plaintext highlighter-rouge">element</code>)인 프로퍼티 리터럴을 인덱스 (프로퍼티 키)로 접근</li>
  <li><code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가지며, 배열의 길이보다 큰 접근은 <code class="language-plaintext highlighter-rouge">undefined</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 조정해 배열 길이를 조절할 수 있음 (<code class="language-plaintext highlighter-rouge">-1 &lt; length &lt; 2^32</code>)</li>
    </ul>
  </li>
  <li>자바스크립트에서 배열은 비균질적 (<code class="language-plaintext highlighter-rouge">Nonhomogeneous</code>) : 고정 위치 및 크기를 가지지 않음
    <ul>
      <li>희소 배열 (<code class="language-plaintext highlighter-rouge">sparse array</code>) 자료 구조 : 검색에는 약하지만, 조작에는 우수!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // 3의 크기를 갖는 배열 생성
const arr1 = Array(3); // [ &lt;3 empty items&gt; ]
const arr2 = new Array(3); // [ &lt;3 empty items&gt; ]
const arr3 = [,,,]; // [ &lt;3 empty items&gt; ]

// 3의 크기를 갖고 1로 채워진 배열 생성
const arr4 = Array(3).fill(1); // [ 1,1,1 ]

// 3의 크기를 갖고 인덱스 1부터 1이 존재하는 배열 생성
const arr5 = Array(3).fill(1, 1); // [ &lt;1 empty item&gt;, 1, 1 ]

// 3의 크기를 갖고 인덱스 1 이상 2 미만에 1이 존재하는 배열 생성
const arr6 = Array(3).fill(1, 0, 2); // [ &lt;1 empty item&gt;, 1, &lt;1 empty item&gt; ]

// arr2를 복제한 유사 배열 객체 생성
const arr7 = Array.from(arr2); // [ undefined, undefined, undefined ]

// 3의 크기를 갖는 유사 배열 객체 생성
const arr8 = Array.from(Array(3)); // [ undefined, undefined, undefined ]

// 3의 크기를 갖고 1,2,3이 존재하는 유사 배열 객체 생성
const arr9 = Array.from(Array(3), (_, i)  =&gt; i + 1); // [ 1, 2, 3 ]

// 3의 크기를 갖고 1,2,3이 존재하는 유사 배열 객체 생성
const arr10 = Array.from(Array(3).keys()); // [ 1, 2, 3 ]

// 3의 크기를 갖고 1로 채워진 배열 생성
const arr11 = [];
arr11.push(1); // [ 1 ]
arr11.push(1); // [ 1, 1 ]
arr11.push(1); // [ 1, 1, 1 ]

// 스택 배열
const stack = [];
stack.push(1);
stack.push(2);
stack.push(3);
stack.pop();

// 큐 배열
const queue = [];
queue.push(1);
queue.push(2);
queue.push(3);
queue.shift();

// 스택 배열, 큐 배열 초기화
stack.length = 0;
queue.length = 0;

// 배열 검색
const arr12 = [ 3, 7, 3, 9, 2];
arr12.indexOf(3);  // 0
arr.lastIndexOf(3); // 2
arr.includes(3); // true

const arr13 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 2 } ];
const idx = arr13.findIndex(item =&gt; item.id === 2); // 1

// 배열 루프
arr13.forEach(( arr, idx ) =&gt; console.log(arr.id));

// 배열 요소 합치기
const arr14 = arr1.concat(arr2);
const arr15 = [...arr1, ...arr2];

// 배열 평탄화
const arr16 = [ 1, 2, [3] ].flat();
console.log(arr16); // 1, 2, 3

const arr17 = [ 1, 2, [[3]] ].flat();
console.log(arr17); // 1, 2, [3]

const arr18 = [ 1, 2, [[3]] ].flat(2);
console.log(arr18); // 1, 2, 3
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = [1, 2, 3, 4, 5];

// ex1) [2,3]을 추출
const ex1 = arr.slice(1,3);

console.log(`\n#1`);
console.log(ex1);

// ex2) [3]부터 모두 다 추출
const ex2 = arr.slice(arr.indexOf(3));

console.log(`\n#2`);
console.log(ex2);

// ex3) [2,3,4] 제거하기
arr.splice(1, 3)

console.log(`\n#3`);
console.log(arr);

// ex4) 복원하기
arr.splice(1, 0, 2,3,4)

console.log(`\n#4`);
console.log(arr);

// ex5) [3] 부터 끝까지 제거하기
arr.splice(arr.indexOf(3))

console.log(`\n#5`);
console.log(arr);

// ex6) 복원하기
arr.splice(2, 0, 3,4,5)

console.log(`\n#6`);
console.log(arr);

// ex7) [1,2, 'X', 'Y', 'Z', 4, 5] 만들기
arr.splice(2, 1)
arr.splice(2, 0, 'X', 'Y', 'Z')

console.log(`\n#7`);
console.log(arr);

// ex8) 위 7번 문제를 splice를 사용하지 말고 작성하시오.
arr.splice(2, 3)
const ex8 = [...arr.slice(0, 2), 'X', 'Y', 'Z' , ...arr.slice(2)]

console.log(`\n#8`);
console.log(ex8);
</code></pre></div></div>

<blockquote>
  <p>리스트 (<code class="language-plaintext highlighter-rouge">List</code>) : 중첩 참조 <code class="language-plaintext highlighter-rouge">link</code>를 가진 객체</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const array = [1, 2, 3, …]; // 배열

const list = { // 리스트
    value: 1,
    rest: {   // 메모리 주소 (link)
        value: 2,
        rest: {
            value: 3,
            rest: {...}
        }
    }
}
</code></pre></div>  </div>

  <p>→ 자비스크립트의 <code class="language-plaintext highlighter-rouge">Array</code>는 <code class="language-plaintext highlighter-rouge">List</code> : <code class="language-plaintext highlighter-rouge">List</code>는 검색은 느리지만, 조작하는 것은 쉽다!</p>
</blockquote>

<h3 id="유사-배열-객체-array-like-object--배열과-유사한-형태를-갖지만-배열은-아닌-객체">유사 배열 객체 (<code class="language-plaintext highlighter-rouge">Array-like Object</code>) : 배열과 유사한 형태를 갖지만, 배열은 아닌 객체</h3>

<ul>
  <li>문자열, <code class="language-plaintext highlighter-rouge">Object</code>, <code class="language-plaintext highlighter-rouge">arguments</code>, <code class="language-plaintext highlighter-rouge">NodeList</code>, <code class="language-plaintext highlighter-rouge">JQuery</code> 객체 등 컬렉션 (<code class="language-plaintext highlighter-rouge">Collection</code>) 형태의 객체 데이터</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array.isArray(x) || x instanceof Array : false
</code></pre></div></div>

<ul>
  <li>인덱스는 <code class="language-plaintext highlighter-rouge">0</code>부터 시작해야 하며, 반드시 <code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가짐</li>
  <li><code class="language-plaintext highlighter-rouge">for ~ of</code> 등을 통해 순회 가능한 <code class="language-plaintext highlighter-rouge">iterable</code>한 객체 (<code class="language-plaintext highlighter-rouge">cf</code>. <code class="language-plaintext highlighter-rouge">iterator</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">forEach</code>를 제외한 나머지 유사 배열 객체는 <code class="language-plaintext highlighter-rouge">Array</code> 메소드를 사용할 수 없음</li>
  <li><code class="language-plaintext highlighter-rouge">Array.from()</code>으로 배열로 만들 수 있음</li>
</ul>

<h2 id="이터레이터-iterator--next-함수-호출-시-계속-그-다음-값을-반환하는-객체">이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>) : <code class="language-plaintext highlighter-rouge">next()</code> 함수 호출 시 계속 그 다음 값을 반환하는 객체</h2>

<ul>
  <li>현재 어디에 있고, 다음엔 어디로 가는지 아는 포인터 (<code class="language-plaintext highlighter-rouge">Pointer</code>)
    <ul>
      <li>이터러블 (<code class="language-plaintext highlighter-rouge">Iterable</code>) 프로토콜 : <code class="language-plaintext highlighter-rouge">Symbol.iterator</code>를 구현 및 상속한 메소드를 호출하면, 이터레이터 반환</li>
      <li>이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>) 프로토콜 : <code class="language-plaintext highlighter-rouge">next()</code>를 호출하면, <code class="language-plaintext highlighter-rouge">value()</code>, <code class="language-plaintext highlighter-rouge">done()</code>을 가진 이터레이터 리터럴 반환</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ItDog1 extends Dog {
  [Symbol.iterator]() {
    return this.name.split(', ').values();
  }
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const itDog1 = new ItDog1('Toby, Max, Sam');
console.log([...itDog1]);

class ItDog2 extends Dog {
  [Symbol.iterator]() {
    let idx = 0;
    const names = this.name.split(/,\s?/);
    return {
      next() {
        return { value: names[idx++],
                 done: idx &gt; names.length };
      }
    };
  }
} 
const itDog2 = new ItDog2('Toby, Max, Sam');
for (const d of itDog2) console.log(d);
const iter = itDog2[Symbol.iterator]();
console.log(iter.next());  // 4회 반복
</code></pre></div></div>

<h3 id="제너레이터-generator--제너레이터-함수-function의-실행을-제어하는-함수">제너레이터 (<code class="language-plaintext highlighter-rouge">Generator</code>) : 제너레이터 함수 <code class="language-plaintext highlighter-rouge">function*()</code>의 실행을 제어하는 함수</h3>

<ul>
  <li>실행 과정에서 <code class="language-plaintext highlighter-rouge">yield</code>를 만나면, 호출자 (<code class="language-plaintext highlighter-rouge">caller</code>)에게 정보 반환과 제어권을 넘김
    <ul>
      <li>제너레이터를 호출하면 이터레이터를 얻음 → 실행이 한번에 끝나지 않는다!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function* route() { // function* ~ yield → iterator를 return하고, 일시정지(pause)한 상태로 시작!
  const start = yield "출발 역은?";  // yield가 있으므로 caller에게 제어권을 넘긴다.
  const end = yield "도착 역은?";

  return `${start}역에서 출발하여 ${end}역에 도착합니다.`;
}

const caller = route();
caller.next();
caller.next('을지로입구');
caller.next('강남');
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[배열 (Array) : 순서가 있는 데이터 집합]]></summary></entry></feed>