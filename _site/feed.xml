<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-21T13:49:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[SpringBoot] 3. Spring Data</title><link href="http://localhost:4000/springboot3/" rel="alternate" type="text/html" title="[SpringBoot] 3. Spring Data" /><published>2024-03-26T00:00:00+09:00</published><updated>2024-03-30T00:00:00+09:00</updated><id>http://localhost:4000/springboot3</id><content type="html" xml:base="http://localhost:4000/springboot3/"><![CDATA[<h2 id="스프링-데이터-spring-data--다양한-데이터-소스에-접근해-데이터를-활용">스프링 데이터 (<code class="language-plaintext highlighter-rouge">Spring Data</code>) : 다양한 데이터 소스에 접근해 데이터를 활용</h2>

<ul>
  <li>스프링 데이터는 여러 데이터 스토어를 지원하는 개별 프로젝트를 포함하는 상위 프로젝트
    <ul>
      <li>여러 데이터 소스의 데이터를 다룰 때 일관성 있는 프로그래밍 모델 제공</li>
      <li>비즈니스 도메인 객체를 특정 데이터 스토어에 저장 가능</li>
      <li>관계형 데이터베이스와 스프링 데이터 <code class="language-plaintext highlighter-rouge">JPA</code>를 사용해서 비즈니스 객체 관리 가능</li>
    </ul>
  </li>
  <li>스프링 템플릿 (<code class="language-plaintext highlighter-rouge">Spring Template</code>) : 특정 데이터베이스의 다양한 연산을 수행 가능한 클래스
    <ul>
      <li>템플릿 클래스에서 저장소별 특화된 자원을 관리하고 예외를 변환할 수 있게 해주는 헬퍼 메서드가 포함</li>
    </ul>
  </li>
</ul>

<h3 id="스프링-데이터-모듈-spring-data-module">스프링 데이터 모듈 (<code class="language-plaintext highlighter-rouge">Spring Data Module</code>)</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4fce3081-c961-42e5-b1ba-b07b8d7cb31d" width="80%" /></p>

<ul>
  <li>스프링 데이터 커먼즈 : 데이터 스토어의 독립적인 기초 컴포넌트로 구성
    <ul>
      <li>스프링 데이터 <code class="language-plaintext highlighter-rouge">JPA</code>의 <code class="language-plaintext highlighter-rouge">JpaRepository</code> 인터페이스는 스프링 데이터 커먼즈 내 <code class="language-plaintext highlighter-rouge">PagingAndSortingRepository</code>의 <code class="language-plaintext highlighter-rouge">CRUD</code>, 페이징, 정렬 기능을 상속<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/666ac803-a66b-4d03-b3ba-64d8caf9117f" width="80%" /></li>
    </ul>
  </li>
  <li>스프링 데이터 서브 모듈 : 특정 데이터베이스에 특화된 기능을 포함</li>
</ul>

<h3 id="스프링부트-어플리케이션-데이터베이스-연동-설정">스프링부트 어플리케이션 데이터베이스 연동 설정</h3>

<blockquote>
  <p>요구사항 : 스프링부트에 관계형 데이터베이스를 연동하기 위해선, 어플리케이션에 관련 설정 작업을 해야 한다.</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/2fe98ffc-7530-4a29-8c15-5b386a9cc01c" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application.properties</code>에 데이터베이스 연결 정보를 작성할 수 있음</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/125bd13f-b45c-45e7-8363-4936c6ae6b33" width="80%" /></p>

<blockquote>
  <p>요구사항 : 어플리케이션을 시작할 때, 데이터베이스 내 스키마를 적절히 초기화해야 한다.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/main/resources/</code> 폴더의 <code class="language-plaintext highlighter-rouge">.sql</code> 파일을 통해 스키마 정의 및 스크립트 실행이 가능</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ed4f1d35-6e23-4695-8691-83b53e0d73cc" width="80%" /></p>

<h3 id="crudrepository-pagingandsortingrepository-인터페이스-이해"><code class="language-plaintext highlighter-rouge">CrudRepository</code>, <code class="language-plaintext highlighter-rouge">PagingAndSortingRepository</code> 인터페이스 이해</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Repository</code> : 비즈니스 도메인 클래스와 그 식별자로 데이터 소스 접근을 추상화하는 인터페이스
    <ul>
      <li>객체의 런타임 타입 정보만을 알려주는 마커 (<code class="language-plaintext highlighter-rouge">marker</code>) 인터페이스</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/21d76eb4-360c-4728-970e-8e89a694ec35" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CrudRepository</code> : <code class="language-plaintext highlighter-rouge">Repository</code>를 상속받아 <code class="language-plaintext highlighter-rouge">CRUD</code> 연산을 포함하는 하위 인터페이스</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/e9253a24-e0b4-41fa-bd24-ed593e818519" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PagingAndSortingRepository</code> : 페이징 (<code class="language-plaintext highlighter-rouge">pagination</code>)과 정렬 (<code class="language-plaintext highlighter-rouge">sort</code>) 기능을 포함</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/974dcccb-9eec-4414-a7e7-e151658f5a3d" width="80%" /></p>

<blockquote>
  <p>요구사항 : 스프링 데이터 <code class="language-plaintext highlighter-rouge">JPA</code>를 사용해 도메인 객체를 관계형 데이터베이스에 저장하고 관리한다.</p>
</blockquote>

<ul>
  <li>엔티티에 <code class="language-plaintext highlighter-rouge">@Id</code>, <code class="language-plaintext highlighter-rouge">@Column</code>, <code class="language-plaintext highlighter-rouge">GeneratedValue</code> 어노테이션 추가
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Transactional</code> : 메소드 실행 중 발생하는 데이터 작업을 하나의 트랙잭션으로 처리</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/46bfc342-f746-46f2-932d-c54da6119e1c" width="80%" /></p>

<ul>
  <li>엔티티를 관리하기 위한 레포지토리 인터페이스 작성</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/466f2dd2-eb57-4794-b63b-35018944d03e" width="80%" /></p>

<h3 id="쿼리-메소드-namedquery를-통한-스프링-데이터를-사용한-데이터-조회">쿼리 메소드, <code class="language-plaintext highlighter-rouge">@NamedQuery</code>를 통한 스프링 데이터를 사용한 데이터 조회</h3>

<ul>
  <li>쿼리 메소드 : 리포지토리 인터페이스에 정의하는 메소드 이름을 패턴에 맞춰 작성하면 이름을 파싱해 쿼리 생성</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b7a77f68-f866-4070-9107-1861e56843c5" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@NamedQuery</code> : 직접 쿼리문을 지정해 데이터를 조회 (2개 이상의 테이블을 조인해 데이터를 조회)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@@Modifying</code> : <code class="language-plaintext highlighter-rouge">@Query</code> 에 정의된 쿼리가 조회가 아닌 수정 작업을 수행한다는 것을 명시</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c3772e60-0728-4f77-90c9-5cc44552742a" width="80%" /></p>

<h3 id="타입-검사-쿼리-정적-검사를-위한-criteria-api-사용">타입 검사, 쿼리 정적 검사를 위한 <code class="language-plaintext highlighter-rouge">Criteria API</code> 사용</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Criteria API</code> : 쿼리를 단순 문자열이 아닌 프로그램 코드로 작성해 타입 안정성 보장 가능</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/496e64e0-1202-45c5-94fa-bc15d25758cf" width="80%" /></p>

<h3 id="스프링-데이터-jpa와-querydsl">스프링 데이터 <code class="language-plaintext highlighter-rouge">JPA</code>와 <code class="language-plaintext highlighter-rouge">QueryDSL</code></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">QueryDSL</code> : <code class="language-plaintext highlighter-rouge">Criteria API</code>처럼 타입 안정성을 보장하고, 평문형 <code class="language-plaintext highlighter-rouge">API</code>로 코드 작성량 을 줄임
    <ul>
      <li>쿼리에 포함된 엔티티 타입이 실제로 존재하고, 해당 엔티티를 데이터베이스에 저장 가능</li>
      <li>쿼리에 포함된 모든 프로퍼티가 엔티티에 실제로 조직하고, 해당 프로퍼티를 데이터베이스에 저장 가능</li>
      <li>모든 <code class="language-plaintext highlighter-rouge">SQL</code> 연산자에는 적합한 타입이 사용되며, 최종 쿼리가 문법적으로 올바름</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/6e06e455-8a6a-4851-a84d-50e3490cea87" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">querydsl-apt</code> : 소스 파일의 어노테이션을 컴파일 단계 이전에 먼저 처리하는 어노테이션 처리 도구
    <ul>
      <li>어플리케이션에 포함된 엔티티 클래스를 바탕으로 <code class="language-plaintext highlighter-rouge">Q</code>-타입 클래스 생성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">querydsl-jpa</code> : <code class="language-plaintext highlighter-rouge">JPA</code>를 사용하는 어플리케이션에서 <code class="language-plaintext highlighter-rouge">QueryDSL</code>을 사용할 수 있게 함</li>
  <li><code class="language-plaintext highlighter-rouge">apt-maven-gradle</code> : 메이븐의 프로세스 골에서 <code class="language-plaintext highlighter-rouge">Q</code>-타입 클래스가 생성되는 것을 보장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">outputDirectory</code> 프로퍼티로 <code class="language-plaintext highlighter-rouge">Q</code>-타입 클래스 파일이 저장될 위치 지정</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/fb3eebf7-6845-4cbf-aafa-d43c23fb7867" width="80%" /></p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SpringBoot" /><summary type="html"><![CDATA[스프링 데이터 (Spring Data) : 다양한 데이터 소스에 접근해 데이터를 활용]]></summary></entry><entry><title type="html">[SQLD] 3. SQL 활용</title><link href="http://localhost:4000/sqld3/" rel="alternate" type="text/html" title="[SQLD] 3. SQL 활용" /><published>2024-03-08T00:00:00+09:00</published><updated>2024-03-08T00:00:00+09:00</updated><id>http://localhost:4000/sqld3</id><content type="html" xml:base="http://localhost:4000/sqld3/"><![CDATA[<blockquote>
  <p>SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘SQL 활용’ 관련 정리이다.</p>
</blockquote>

<h2 id="서브-쿼리-subquery--하나의-쿼리-내에-존재하는-또다른-쿼리">서브 쿼리 (<code class="language-plaintext highlighter-rouge">SubQuery</code>) : 하나의 쿼리 내에 존재하는 또다른 쿼리</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1760ee26-6607-4398-8329-cc136d3c3017" width="80%" /></p>

<h3 id="스칼라-서브-쿼리-scalar-subquery--주로-select에-위치하는-서브-쿼리">스칼라 서브 쿼리 (<code class="language-plaintext highlighter-rouge">Scalar SubQuery</code>) : 주로 <code class="language-plaintext highlighter-rouge">SELECT</code>에 위치하는 서브 쿼리</h3>

<ul>
  <li>컬럼 대신 사용되므로 하나의 값만을 반환, 그렇지 않으면 에러 발생</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT M.PRODUCT_CODE,
    (SELECT S.PRODUCT_NAME
        FROM PRODUCT S
        WHERE S.PRODUCT_CODE = M.PRODUCT_CODE) AS PRODUCT_NAME,
    M.MEMBER_ID,
    M.CONTENT
FROM PRODUCT_REVIEW M;
</code></pre></div></div>

<h3 id="인라인-뷰-inline-view--from처럼-테이블명이-오는-위치에-위치하는-서브-쿼리">인라인 뷰 (<code class="language-plaintext highlighter-rouge">Inline View</code>) : <code class="language-plaintext highlighter-rouge">FROM</code>처럼 테이블명이 오는 위치에 위치하는 서브 쿼리</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT M.PRODUCT_CODE, S.PRODUCT_NAME, S.PRICE, M.MEMBER_ID, M.CONTENT
FROM PRODUCT_REVIEW M,
    (SELECT PRODUCT_CODE, PRODUCT_NAME, PRICE FROM PRODUCT) S
WHERE M.PRODUCT_CODE = S.PRODUCT_CODE;
</code></pre></div></div>

<h3 id="중첩-서브쿼리-nested-subquery--where과-having에-위치하는-쿼리">중첩 서브쿼리 (<code class="language-plaintext highlighter-rouge">Nested SubQuery</code>) : <code class="language-plaintext highlighter-rouge">WHERE</code>과 <code class="language-plaintext highlighter-rouge">HAVING</code>에 위치하는 쿼리</h3>

<h4 id="비연관-서브쿼리-un-correlated-subquery--서브쿼리-내에-메인-쿼리의-컬럼이-존재하지-않음">비연관 서브쿼리 (<code class="language-plaintext highlighter-rouge">Un-Correlated SubQuery</code>) : 서브쿼리 내에 메인 쿼리의 컬럼이 존재하지 않음</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT NAME, AGE, BIRTHDAY
    FROM STUDENT
    WHERE CODE = (SELECT CODE
        FROM SCHOOL
        WHERE SCHOOL_NAME = 'EIA');
</code></pre></div></div>

<h4 id="연관-서브쿼리-correlated-subquery--서브쿼리-내에-메인-쿼리의-컬럼이-존재함">연관 서브쿼리 (<code class="language-plaintext highlighter-rouge">Correlated SubQuery</code>) : 서브쿼리 내에 메인 쿼리의 컬럼이 존재함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_NO, DRINK_CODE, ORDER_CNT
    FROM CAFE_ORDER A
    WHERE ORDER_CNT = (SELECT MAX(ORDER_CNT)
        FROM CAFE_ORDER B
        WHERE B.DRINK_CODE = A.DRINK_CODE);
</code></pre></div></div>

<h5 id="단일-행-서브쿼리-single-row-subquery--서브쿼리가-1건-이하의-데이터-반환">단일 행 서브쿼리 (<code class="language-plaintext highlighter-rouge">Single Row SubQuery</code>) : 서브쿼리가 1건 이하의 데이터 반환</h5>

<ul>
  <li>단일 행 연산자와 함께 사용 : <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;&gt;</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FORM PRODUCT
    WHERE PRICE = (SELECT MAX(PRICE) FROM PRODUCT);
</code></pre></div></div>

<h5 id="다중-행-서브쿼리-multi-row-subquery--서브쿼리가-여러-건의-데이터-반환">다중 행 서브쿼리 (<code class="language-plaintext highlighter-rouge">Multi Row SubQuery</code>) : 서브쿼리가 여러 건의 데이터 반환</h5>

<ul>
  <li>다중 행 연산자와 함께 사용 : <code class="language-plaintext highlighter-rouge">IN</code>, <code class="language-plaintext highlighter-rouge">ALL</code>, <code class="language-plaintext highlighter-rouge">ANY</code>, <code class="language-plaintext highlighter-rouge">SOME</code>, <code class="language-plaintext highlighter-rouge">EXISTS</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM PRODUCT
    WHERE PRODUCT_ID IN (SELECT PRODUCT_CODE FROM PRODUCT_REVIEW);
</code></pre></div></div>

<h5 id="다중-칼럼-서브쿼리-multi-col-subquery--서브쿼리가-여러-칼럼의-데이터-반환">다중 칼럼 서브쿼리 (<code class="language-plaintext highlighter-rouge">Multi Col SubQuery</code>) : 서브쿼리가 여러 칼럼의 데이터 반환</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM EMPLOYEES
    WHERE (JOB_ID, SALARY) IN (SELECT JOB_ID, MAX_SALARY
    FROM JOBS
    WHERE MAX_SALARY = 10000);
</code></pre></div></div>

<h2 id="뷰-view--특정-select에-이름을-붙어-재사용-가능하도록-저장한-오브젝트">뷰 (<code class="language-plaintext highlighter-rouge">View</code>) : 특정 <code class="language-plaintext highlighter-rouge">SELECT</code>에 이름을 붙어 재사용 가능하도록 저장한 오브젝트</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SQL</code>에서 테이블처럼 사용 가능한 가상의 테이블 : 실제 데이터 대신 <code class="language-plaintext highlighter-rouge">SELECT</code>만 가짐</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE OR REPLACE VIEW DEPT_MEMBERS AS
    SELECT A.DEPARTMENT_ID, A.DEPARTMENT_NAME, B.FULL_NAME
        FROM DEPARTMENT A
        LEFT OUTER JOIN EMPLOYEE B
            ON A.DEPARTMENT_ID = B.DEPARTMENT_ID; // 뷰 생성
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP VIEW DEPT_TABLE; // 뷰 삭제
</code></pre></div></div>

<h2 id="집합-연산자--각-쿼리의-결과-집합을-가지고-연산하는-명령어">집합 연산자 : 각 쿼리의 결과 집합을 가지고 연산하는 명령어</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4feed2f3-d35c-4ccf-b322-0456236667a0" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM STUDENT UNION ALL SELECT * FROM TEACHER; // 쿼리1, 쿼리2 결과의 합집합 (중복 포함)
SELECT * FROM STUDENT UNION SELECT * FROM TEACHER; // 쿼리1, 쿼리2 결과의 합집합 (중복 제거)
SELECT * FROM STUDENT INTERSECT SELECT * FROM TEACHER; // 쿼리1, 쿼리2 결과의 교집합 (중복 제거)
SELECT * FROM STUDENT MINUS SELECT * FROM TEACHER; // 쿼리1에서 쿼리2 결과 제거해 출력
</code></pre></div></div>

<h2 id="그룹-함수--데이터를-group-by하여-나타낼-수-있는-데이터를-구하는-함수">그룹 함수 : 데이터를 <code class="language-plaintext highlighter-rouge">GROUP BY</code>하여 나타낼 수 있는 데이터를 구하는 함수</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5d6edb1a-9724-458f-aba9-41c94e88b012" width="80%" /></p>

<h3 id="rollup--소그룹-간의-소계-및-총계를-계산하는-함수"><code class="language-plaintext highlighter-rouge">ROLLUP</code> : 소그룹 간의 소계 및 총계를 계산하는 함수</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5d943091-01f0-411d-9a43-908e516ced2c" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, COUNT(*)
    FROM MY_ORDER
    GROUP BY ROLLUP(ORDER_DT, (ORDER_ITEM, ORDER_ITEM_NAME))
    ORDER BY ORDER_DT;
</code></pre></div></div>

<h3 id="cube--소그룹-간의-소계-및-총계를-다차원적으로-계산하는-함수"><code class="language-plaintext highlighter-rouge">CUBE</code> : 소그룹 간의 소계 및 총계를 다차원적으로 계산하는 함수</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ae2850c7-250d-48b6-85dd-a896628496e3" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, COUNT(*)
    FROM MY_ORDER
    GROUP BY ORDER_DT
    ORDER BY ORDER_DT;
</code></pre></div></div>

<h3 id="grouping-sets--특정-항목에-대한-소계를-계산하는-함수"><code class="language-plaintext highlighter-rouge">GROUPING SETS</code> : 특정 항목에 대한 소계를 계산하는 함수</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/fc039246-e84d-44ba-96e1-d484aa109901" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, COUNT(*)
    FROM MY_ORDER
    GROUP BY GROUPING SETS(ORDER_DT, ORDER_ITEM)
    ORDER BY ORDER_DT;
</code></pre></div></div>

<h3 id="grouping--소계를-나타내는-row를-구분하는-기준"><code class="language-plaintext highlighter-rouge">GROUPING</code> : 소계를 나타내는 <code class="language-plaintext highlighter-rouge">ROW</code>를 구분하는 기준</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, GROUPING(ORDER_DT), COUNT(*)
    FROM MY_ORDER
    GROUP BY ROLLUP(ORDER_DT)
    ORDER BY ORDER_DT;
</code></pre></div></div>

<h2 id="윈도우-함수--over-키워드와-함께-사용되는-함수">윈도우 함수 : <code class="language-plaintext highlighter-rouge">OVER</code> 키워드와 함께 사용되는 함수</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/26594129-2933-4c9e-9412-a9e8a937517f" width="80%" /></p>

<h3 id="순위-함수--윈도우-함수-중-순위를-매기는-함수">순위 함수 : 윈도우 함수 중 순위를 매기는 함수</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1300c402-ee17-414c-9726-1cab28b97c1b" width="80%" /></p>

<h4 id="rank--순위를-매길-때-같은-순위가-존재하면-존재하는-수만큼-건너뜀"><code class="language-plaintext highlighter-rouge">RANK</code> : 순위를 매길 때 같은 순위가 존재하면 존재하는 수만큼 건너뜀</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, COUNT(*) RANK() OVER(ORDER BY COUNT(*) DESC) AS RANK
    FROM MY_ORDER
    GROUP BY ORDER_DT;
</code></pre></div></div>

<h4 id="dense_rank--순위를-매길-때-같은-순위가-존재하더라도-건너뛰지-않고-이어서-매김"><code class="language-plaintext highlighter-rouge">DENSE_RANK</code> : 순위를 매길 때 같은 순위가 존재하더라도 건너뛰지 않고 이어서 매김</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, COUNT(*) DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) AS RANK
    FROM MY_ORDER
    GROUP BY ORDER_DT;
</code></pre></div></div>

<h4 id="row_number--순위를-매길-때-동일한-값이알도-각기-다른-순위를-부여"><code class="language-plaintext highlighter-rouge">ROW_NUMBER</code> : 순위를 매길 때 동일한 값이알도 각기 다른 순위를 부여</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ORDER_DT, COUNT(*) ROW_NUMBER() OVER(ORDER BY COUNT(*) DESC) AS RANK
    FROM MY_ORDER
    GROUP BY ORDER_DT;
</code></pre></div></div>

<h3 id="집계-함수--윈도우-함수-중-값을-집계하는-함수">집계 함수 : 윈도우 함수 중 값을 집계하는 함수</h3>

<h4 id="sum--데이터의-합계를-구하는-함수"><code class="language-plaintext highlighter-rouge">SUM</code> : 데이터의 합계를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT SUM(SCORE) AS TOTAL_SCORE FROM SQLD;
</code></pre></div></div>

<h4 id="max--데이터의-최댓값를-구하는-함수"><code class="language-plaintext highlighter-rouge">MAX</code> : 데이터의 최댓값를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MAX(SCORE) AS TOTAL_SCORE FROM SQLD;
</code></pre></div></div>

<h4 id="min--데이터의-최솟값을-구하는-함수"><code class="language-plaintext highlighter-rouge">MIN</code> : 데이터의 최솟값을 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MIN(SCORE) AS TOTAL_SCORE FROM SQLD;
</code></pre></div></div>

<h4 id="avg--데이터의-평균값을-구하는-함수"><code class="language-plaintext highlighter-rouge">AVG</code> : 데이터의 평균값을 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT AVG(SCORE) AS TOTAL_SCORE FROM SQLD;
</code></pre></div></div>

<h4 id="count--데이터의-건수를-구하는-함수"><code class="language-plaintext highlighter-rouge">COUNT</code> : 데이터의 건수를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT COUNT(*) OVER(
    PARTITION BY SUBJECT,
    ORDER BY SCORE DESC
    RANGE UNBOUNDED PRECEDING) AS HIGHER_COUNT
</code></pre></div></div>

<h3 id="행-순서-함수">행 순서 함수</h3>

<h4 id="first_value--파티션별-가장-선두에-위치한-데이터를-구하는-함수"><code class="language-plaintext highlighter-rouge">FIRST_VALUE</code> : 파티션별 가장 선두에 위치한 데이터를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE,
    FIRST_VALUE(SCORE) OVER (ORDER BY SCORE) AS FIRST_VALUE
FROM SQLD;
</code></pre></div></div>

<h4 id="last_value--파티션별-가장-끝에-위치한-데이터를-구하는-함수"><code class="language-plaintext highlighter-rouge">LAST_VALUE</code> : 파티션별 가장 끝에 위치한 데이터를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE,
    LAST_VALUE(SCORE) OVER (ORDER BY SCORE) AS LAST_VALUE
FROM SQLD;
</code></pre></div></div>

<h4 id="lag--파티션별로-특정-수만큼-앞선-데이터를-구하는-함수"><code class="language-plaintext highlighter-rouge">LAG</code> : 파티션별로 특정 수만큼 앞선 데이터를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE,
    LAG(SCORE, 3) OVER (ORDER BY SCORE) AS LAG
FROM SQLD;
</code></pre></div></div>

<h4 id="lead--파티션별로-특정-수만큼-뒤에-있는-데이터를-구하는-함수"><code class="language-plaintext highlighter-rouge">LEAD</code> : 파티션별로 특정 수만큼 뒤에 있는 데이터를 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE,
    LEAD(SCORE, 3) OVER (ORDER BY SCORE) AS LAG
FROM SQLD;
</code></pre></div></div>

<h3 id="비율-함수">비율 함수</h3>

<h4 id="ratio_to_report--파티션별-합계에서-차지하는-비율을-구하는-함수"><code class="language-plaintext highlighter-rouge">RATIO_TO_REPORT</code> : 파티션별 합계에서 차지하는 비율을 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE, SUM(SCORE) AS SUM, 
    RATIO_TO_REPORT(SCORE) OVER() AS RATIO_TO_REPORT
FROM SQLD;
</code></pre></div></div>

<h4 id="percent_rank--해당-파티션의-맨-위-끝-행을-0-맨-아래-끝-행을-1로-놓고-현재-행이-위치하는-백-분위-순위-값을-구하는-함수"><code class="language-plaintext highlighter-rouge">PERCENT_RANK</code> : 해당 파티션의 맨 위 끝 행을 0, 맨 아래 끝 행을 1로 놓고 현재 행이 위치하는 백 분위 순위 값을 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE, SUM(SCORE) AS SUM, 
    PERCENT_RANK OVER(ORDER BY SCORE) AS PERCENT_RANK
FROM SQLD;
</code></pre></div></div>

<h4 id="cume_dist--해당-파티션에서의-누적-백분율을-구하는-함수-결과값--01"><code class="language-plaintext highlighter-rouge">CUME_DIST</code> : 해당 파티션에서의 누적 백분율을 구하는 함수 (결과값 : <code class="language-plaintext highlighter-rouge">0~1</code>)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE, SUM(SCORE) AS SUM, 
    CUME_DIST OVER(ORDER BY SCORE)/COUNT(*) OVER() AS CUME_DIST
FROM SQLD;
</code></pre></div></div>

<h4 id="nitile--주어진-수만큼-행들을-n등분한-후-현재-행에-해당하는-등급을-구하는-함수"><code class="language-plaintext highlighter-rouge">NITILE</code> : 주어진 수만큼 행들을 <code class="language-plaintext highlighter-rouge">N</code>등분한 후 현재 행에 해당하는 등급을 구하는 함수</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT STUDENT_NAME, SUBJECT, SCORE, SUM(SCORE) AS SUM, 
    NITILE(1) OVER(ORDER BY SCORE DESC) AS NITILE
FROM SQLD;
</code></pre></div></div>

<h2 id="top-n-쿼리--시작-지점부터-n까지의-범위를-추출하는-쿼리"><code class="language-plaintext highlighter-rouge">Top-N</code> 쿼리 : 시작 지점부터 <code class="language-plaintext highlighter-rouge">N</code>까지의 범위를 추출하는 쿼리</h2>

<h3 id="rownum--실제론-존재하지-않는-수도-컮럼-pseudo-column-행이-반환될-때마다-순번이-1씩-증가"><code class="language-plaintext highlighter-rouge">ROWNUM</code> : 실제론 존재하지 않는 수도 컮럼 (<code class="language-plaintext highlighter-rouge">Pseudo Column</code>), 행이 반환될 때마다 순번이 1씩 증가</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ROWNUM,
    NAME,
    SCORE
    FROM EXAM;
</code></pre></div></div>

<h2 id="셀프-조인-self-join--나-자신과의-join-alias를-통한-별칭-부여는-필수">셀프 조인 (<code class="language-plaintext highlighter-rouge">Self Join</code>) : 나 자신과의 <code class="language-plaintext highlighter-rouge">Join</code> (<code class="language-plaintext highlighter-rouge">ALIAS</code>를 통한 별칭 부여는 필수!)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.TYPE, A.NAME, B.TYPE, B.NAME
    FROM CATEGORY A, CATEGORY B
    WHERE A.CATEGORY_NAME = B.PARENT_CATEGORY;
</code></pre></div></div>

<h2 id="계층-쿼리--테이블에-계층-구조를-이루는-컬럼이-존재할-때-데이터-출력">계층 쿼리 : 테이블에 계층 구조를 이루는 컬럼이 존재할 때 데이터 출력</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LEVEL</code> : 현재의 <code class="language-plaintext highlighter-rouge">DEPTH</code> 반환, 루트 노드는 1</li>
  <li><code class="language-plaintext highlighter-rouge">SYS_CONNECT_BY_PATH (컬럼,구분자)</code> : 루트 노드부터 현재 노드까지의 경로 출력</li>
  <li><code class="language-plaintext highlighter-rouge">START WITH</code> : 경로가 시작되는 루트 노드 생성</li>
  <li><code class="language-plaintext highlighter-rouge">CONNECT BY</code> : 조건을 만족하는 데이터가 없을 때까지 루트로부터 자식 노드 생성</li>
  <li><code class="language-plaintext highlighter-rouge">PRIOR</code> : 바로 앞에 있는 부모 노드의 값 반환</li>
  <li><code class="language-plaintext highlighter-rouge">CONNECTED_BY_ROOT (컬럼)</code> : 루트 노드의 주어진 컬럼 값 반환</li>
  <li><code class="language-plaintext highlighter-rouge">CONNECT_BY_ISLEAF</code>  : 가장 하위 노드인 경우 1을 반환, 그 외에는 0 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT LEVEL, SYS_CONNECT_BY_PATH('['||TYPE||']' || TYPE, '-') AS PATH FROM CATEGORY
START WITH PARENT_CATEGORY IS NULL
CONNECT BY PRIOR NAME = PARENT_CATEGORY;
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SQLD" /><summary type="html"><![CDATA[SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘SQL 활용’ 관련 정리이다.]]></summary></entry><entry><title type="html">[SQLD] 4. 관리 구문</title><link href="http://localhost:4000/sqld4/" rel="alternate" type="text/html" title="[SQLD] 4. 관리 구문" /><published>2024-03-08T00:00:00+09:00</published><updated>2024-03-08T00:00:00+09:00</updated><id>http://localhost:4000/sqld4</id><content type="html" xml:base="http://localhost:4000/sqld4/"><![CDATA[<blockquote>
  <p>SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘관리 구문’ 관련 정리이다.</p>
</blockquote>

<h2 id="dml-data-manipulation-language--데이터를-입력수정삭제조회하는-명령어"><code class="language-plaintext highlighter-rouge">DML</code> (<code class="language-plaintext highlighter-rouge">Data Manipulation Language</code>) : 데이터를 입력·수정·삭제·조회하는 명령어</h2>

<h3 id="insert--테이블에-데이터를-입력하는-명령어"><code class="language-plaintext highlighter-rouge">INSERT</code> : 테이블에 데이터를 입력하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ...) VALUES (데이터1, 데이터2, ...);
INSERT INTO 테이블명 VALUES (전체 컬럼에 입력될 데이터 리스트);
</code></pre></div></div>

<h3 id="update--테이블에-이미-저장된-데이터를-수정하는-명령어"><code class="language-plaintext highlighter-rouge">UPDATE</code> : 테이블에 이미 저장된 데이터를 수정하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UPDATE 테이블명 SET 컬럼명 = 새로운 데이터 (WHERE 수정할 데이터에 대한 조건);
</code></pre></div></div>

<h3 id="delete--테이블에-이미-저장된-데이터를-삭제하는-명령어"><code class="language-plaintext highlighter-rouge">DELETE</code> : 테이블에 이미 저장된 데이터를 삭제하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELETE FROM 테이블명 (WHERE 삭제할 데이터에 대한 조건);
</code></pre></div></div>

<h3 id="merge--테이블에-새로운-데이터를-입력하거나-이미-저장된-데이터에-대한-변경-작업을-한번에-처리하는-명령어"><code class="language-plaintext highlighter-rouge">MERGE</code> : 테이블에 새로운 데이터를 입력하거나, 이미 저장된 데이터에 대한 변경 작업을 한번에 처리하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MERGE
    INTO 타겟테이블명
    USING 비교테이블명
    ON 조건
    WHEN MATCHED THEN
        UPDATE
            SET 컬럼명 = 새로운 데이터 [, 컬럼명 = 새로운 데이터...]
    WHEN NOT MATCHED THEN
        INSERT [(컬럼명1, 컬럼명2...)]
        VALUES [(데이터1, 데이터2...)]
</code></pre></div></div>

<h2 id="tcl-transaction-control-language--트랜잭션을-제어하는-명령어"><code class="language-plaintext highlighter-rouge">TCL</code> (<code class="language-plaintext highlighter-rouge">Transaction Control Language</code>) : 트랜잭션을 제어하는 명령어</h2>

<h3 id="트랜잭션-transaction--쪼개질-수-없는-업무-처리의-논리적인-단위">트랜잭션 (<code class="language-plaintext highlighter-rouge">Transaction</code>) : 쪼개질 수 없는 업무 처리의 논리적인 단위</h3>

<ul>
  <li>원자성 (<code class="language-plaintext highlighter-rouge">Atomicity</code>) : 트랜잭션으로 묶인 일련의 동작들은 모두 성공하거나 모두 실패해야 한다.</li>
  <li>일관성 (<code class="language-plaintext highlighter-rouge">Consistency</code>) : 트랜잭션이 완료된 후에도 데이터베이스가 가진 데이터에 일관성이 있어야 한다.</li>
  <li>고립성 (<code class="language-plaintext highlighter-rouge">Isolation</code>) : 하나의 트랜잭션은 고립된어 수행되어야 한다.</li>
  <li>지속성 (<code class="language-plaintext highlighter-rouge">Durability</code>) : 트랜잭션이 성공적일때 트랜잭션이 변경한 데이터가 영구적으로 저장되어야 함을 의미한다.</li>
</ul>

<h3 id="commit--insert-delete-update-후-변경된-내용을-확정반영하는-명령어"><code class="language-plaintext highlighter-rouge">COMMIT</code> : <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code> 후 변경된 내용을 확정·반영하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COMMIT;
</code></pre></div></div>

<h3 id="rollback--insert-delete-update-후-변경된-내용을-취소하는-명령어"><code class="language-plaintext highlighter-rouge">ROLLBACK</code> : <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code> 후 변경된 내용을 취소하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ROLLBACK TO A;
</code></pre></div></div>

<h3 id="savepoint--rollback을-수행할-때-전체-작업을-되돌리는-대신-일부만-되돌리는-명령어"><code class="language-plaintext highlighter-rouge">SAVEPOINT</code> : <code class="language-plaintext highlighter-rouge">ROLLBACK</code>을 수행할 때 전체 작업을 되돌리는 대신 일부만 되돌리는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SAVEPOINT A;
</code></pre></div></div>

<h2 id="ddl-data-definition-language--데이터를-정의하는-명령어"><code class="language-plaintext highlighter-rouge">DDL</code> (<code class="language-plaintext highlighter-rouge">Data Definition Language</code>) : 데이터를 정의하는 명령어</h2>

<ul>
  <li>문자 : <code class="language-plaintext highlighter-rouge">CHAR</code>, <code class="language-plaintext highlighter-rouge">VARCHAR</code>, <code class="language-plaintext highlighter-rouge">CLOB</code></li>
  <li>숫자 : <code class="language-plaintext highlighter-rouge">NUMBER</code></li>
  <li>날짜 : <code class="language-plaintext highlighter-rouge">DATE</code></li>
</ul>

<h3 id="create--테이블을-생성하는-명령어"><code class="language-plaintext highlighter-rouge">CREATE</code> : 테이블을 생성하는 명령어</h3>

<ul>
  <li>테이블 생성 시 반드시 지켜야 하는 규칙 : 지키지 않으면, 에러 발생!
    <ul>
      <li>테이블명은 고유해야 함</li>
      <li>한 테이블 내에서 컬럼명은 고유해야 함</li>
      <li>컬럼명 뒤에 데이터 유형과 데이터 크기가 명시되어야 함</li>
      <li>컬럼에 대한 정의는 괄호 <code class="language-plaintext highlighter-rouge">()</code> 안에 기술되어야 함</li>
      <li>각 컬럼들은 콤마 <code class="language-plaintext highlighter-rouge">,</code>로 구분됨</li>
      <li>테이블명과 컬럼명은 숫자로 시작될 수 없음</li>
      <li>마지막은 세미콜론 <code class="language-plaintext highlighter-rouge">;</code>으로 끝남</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE 테이블명 (
    컬럼1 데이터타입 (NULL|DEFAULT 옵션)
    ...
)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE 테이블명 AS SELECT * FROM 복사대상테이블명;
</code></pre></div></div>

<h3 id="제약조건-constraint--테이블에-저장될-데이터의-무결성-정확성일관성을-유지하고-데이터의-결함이-없음을-보증">제약조건 (<code class="language-plaintext highlighter-rouge">CONSTRAINT</code>) : 테이블에 저장될 데이터의 무결성 (정확성·일관성)을 유지하고, 데이터의 결함이 없음을 보증</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CREATE</code>로 테이블을 생성할 때, 향후 테이블에 저장될 데이터에 대해 일정 제한을 걸 수 있음</li>
</ul>

<h4 id="기본-키-primary-key--테이블에-저장된-각각의-row에-대한-고유성-보장-null-값-불가">기본 키 (<code class="language-plaintext highlighter-rouge">PRIMARY KEY</code>) : 테이블에 저장된 각각의 <code class="language-plaintext highlighter-rouge">ROW</code>에 대한 고유성 보장 (<code class="language-plaintext highlighter-rouge">NULL</code> 값 불가)</h4>

<h4 id="고유-키-unique-key--테이블에-저장된-각각의-row에-대한-고유성-보장-null-값-허용">고유 키 (<code class="language-plaintext highlighter-rouge">UNIQUE KEY</code>) : 테이블에 저장된 각각의 <code class="language-plaintext highlighter-rouge">ROW</code>에 대한 고유성 보장 (<code class="language-plaintext highlighter-rouge">NULL</code> 값 허용)</h4>

<h4 id="not-null--해당-컬럼에-null-값이-입력되는-것을-금지"><code class="language-plaintext highlighter-rouge">NOT NULL</code> : 해당 컬럼에 <code class="language-plaintext highlighter-rouge">NULL</code> 값이 입력되는 것을 금지</h4>

<h4 id="check--컬럼에-저장될-수-있는-값의-범위를-제한"><code class="language-plaintext highlighter-rouge">CHECK</code> : 컬럼에 저장될 수 있는 값의 범위를 제한</h4>

<h4 id="외래-키-foreign-key--하나의-테이블이-다른-테이블ㅇ르-참조할-때-정의">외래 키 (<code class="language-plaintext highlighter-rouge">FOREIGN KEY</code>) : 하나의 테이블이 다른 테이블ㅇ르 참조할 때 정의</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CASCADE</code> : 부모 값을 삭제할 때, 자식 값도 같이 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">SET NULL</code> : 부모 값을 삭제할 때, 자식의 컬럼을 <code class="language-plaintext highlighter-rouge">NULL</code>로 처리</li>
  <li><code class="language-plaintext highlighter-rouge">SET DEFAULT</code> : 부모 값을 삭제할 때, 자식의 해당 컬럼을 <code class="language-plaintext highlighter-rouge">DEFAULT</code> 값으로 변경</li>
  <li><code class="language-plaintext highlighter-rouge">RESTRICT</code> : 자식 테이블에 해당 데이터가 <code class="language-plaintext highlighter-rouge">PK</code>로 존재하지 않는 경우에만 부모 값 삭제·수정 가능</li>
  <li><code class="language-plaintext highlighter-rouge">NO ACTION</code> : 참조 무결성 제악이 걸린 경우 삭제·수정 불가</li>
</ul>

<h3 id="alter--테이블의-구조를-변경하는-명령어"><code class="language-plaintext highlighter-rouge">ALTER</code> : 테이블의 구조를 변경하는 명령어</h3>

<h4 id="add-column--새로운-컬럼을-추가하는-명령어"><code class="language-plaintext highlighter-rouge">ADD COLUMN</code> : 새로운 컬럼을 추가하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE 테이블명 ADD 컬럼명 데이터유형;
</code></pre></div></div>

<h4 id="drop-column--기존에-있는-컬럼을-삭제하는-명령어"><code class="language-plaintext highlighter-rouge">DROP COLUMN</code> : 기존에 있는 컬럼을 삭제하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE 테이블명 DROP COLUMN 컬럼명;
</code></pre></div></div>

<h4 id="modify-column--기존에-있는-컬럼을-변경하는-명령어"><code class="language-plaintext highlighter-rouge">MODIFY COLUMN</code> : 기존에 있는 컬럼을 변경하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE 테이블명 MODIFY (컬럼명1 데이터유형 [DEFAULT 옵션] [NOT NULL 옵션]...);
</code></pre></div></div>

<h4 id="rename-column--기존에-있는-컬럼의-이름을-변경하는-명령어"><code class="language-plaintext highlighter-rouge">RENAME COLUMN</code> : 기존에 있는 컬럼의 이름을 변경하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE 테이블명 RENAME COLUMN 기존컬럼명 TO 변경컬럼명;
</code></pre></div></div>

<h4 id="add-constraint--제약조건을-추가하는-명령어"><code class="language-plaintext highlighter-rouge">ADD CONSTRAINT</code> : 제약조건을 추가하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADD TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건 (컬럼명); 
</code></pre></div></div>

<h3 id="drop-table--테이블을-삭제하는-명령어"><code class="language-plaintext highlighter-rouge">DROP TABLE</code> : 테이블을 삭제하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP TABLE 테이블명 [CASCADE CONSTRAINT];
</code></pre></div></div>

<h3 id="rename-table--테이블을-변경하는-명령어"><code class="language-plaintext highlighter-rouge">RENAME TABLE</code> : 테이블을 변경하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RENAME 기존테이블명 TO 변경테이블명;
</code></pre></div></div>

<h3 id="truncate-table--테이블에-저장된-데이터를-모두-제거하는-명령어"><code class="language-plaintext highlighter-rouge">TRUNCATE TABLE</code> : 테이블에 저장된 데이터를 모두 제거하는 명령어</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TRUNCATE TABLE 테이블명;
</code></pre></div></div>

<h2 id="dcl-data-control-language--사용자-user를-생성하고-권한-및-역할을-부여하는-명령어"><code class="language-plaintext highlighter-rouge">DCL</code> (<code class="language-plaintext highlighter-rouge">Data Control Language</code>) : 사용자 (<code class="language-plaintext highlighter-rouge">USER</code>)를 생성하고 권한 및 역할을 부여하는 명령어</h2>

<ul>
  <li>하나의 데이터베이스는 여러 사용자들을 가질 수 있음</li>
</ul>

<h3 id="사용자-관련-명령어">사용자 관련 명령어</h3>

<h4 id="create-user--사용자를-생성하는-명령어"><code class="language-plaintext highlighter-rouge">CREATE USER</code> : 사용자를 생성하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE USER 사용자명 IDENTIFIED BY 패스워드;
</code></pre></div></div>

<h4 id="alter-user--사용자를-변경하는-명령어"><code class="language-plaintext highlighter-rouge">ALTER USER</code> : 사용자를 변경하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER USER 사용자명 IDENTIFIED BY 패스워드;
</code></pre></div></div>

<h4 id="drop-user--사용자를-삭제하는-명령어"><code class="language-plaintext highlighter-rouge">DROP USER</code> : 사용자를 삭제하는 명령어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP USER 사용자명;
</code></pre></div></div>

<h3 id="권한-관련-명령어">권한 관련 명령어</h3>

<h4 id="grant--사용자에-권한을-부여하는-명렁어"><code class="language-plaintext highlighter-rouge">GRANT</code> : 사용자에 권한을 부여하는 명렁어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRANT 권한 TO 사용자명;
</code></pre></div></div>

<h4 id="revoke--사용자에-권한을-회수하는-명렁어"><code class="language-plaintext highlighter-rouge">REVOKE</code> : 사용자에 권한을 회수하는 명렁어</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REVOKE 권한 FROM 사용자명;
</code></pre></div></div>

<h3 id="역할-관련-명령어">역할 관련 명령어</h3>

<h4 id="role을-이용한-권한-부여"><code class="language-plaintext highlighter-rouge">ROLE</code>을 이용한 권한 부여</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE ROLE 역할명;
GRANT 권한 TO 역할명;
GRANT 역할명 TO 사용자명;
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SQLD" /><summary type="html"><![CDATA[SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘관리 구문’ 관련 정리이다.]]></summary></entry><entry><title type="html">[SQLD] 2. SQL 기본</title><link href="http://localhost:4000/sqld2/" rel="alternate" type="text/html" title="[SQLD] 2. SQL 기본" /><published>2024-03-07T00:00:00+09:00</published><updated>2024-03-08T00:00:00+09:00</updated><id>http://localhost:4000/sqld2</id><content type="html" xml:base="http://localhost:4000/sqld2/"><![CDATA[<blockquote>
  <p>SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘SQL 기본’ 관련 정리이다.</p>
</blockquote>

<h2 id="select문--저장된-데이터-조회"><code class="language-plaintext highlighter-rouge">SELECT</code>문 : 저장된 데이터 조회</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT  PRODUCT_CODE,
        COUNT (ORDER_CNT) AS ORDER_CNT
FROM ORDER_PRODUCT
WHERE ORDER_DATE BETWEEN '20240308' AND '20240309'
GROUP BY PRODUCT_CODE
HAVING COUNT(ORDER_CNT) &gt;= 1000;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT 컬럼1, 컬럼2, ... FROM 테이블 WHERE 컬럼1 = '컬럼1';
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*</code> : 컬럼을 명시하지 않고 <code class="language-plaintext highlighter-rouge">*</code>`를 쓰면, 테이블 내 전체 컬럼 조회</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM 테이블;
</code></pre></div></div>

<ul>
  <li>산술 연산자 : <code class="language-plaintext highlighter-rouge">NUMBER DATA</code> 유형의 데이터와 함꼐 사용하는 연산자</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1b2fdf5c-c60d-479d-86ba-3c57f0e15ee0" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT 10+5, 10-5, 10*5, 10/5, 10%5 FROM DUAL; // 15, 5, 2, 0
</code></pre></div></div>

<ul>
  <li>합성 연산자 <code class="language-plaintext highlighter-rouge">||</code> : 문자와 문자를 연결할 때 사용하는 연산자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT '1'||'0'||'+'||'5' AS RESULT FROM DUAL; // 10+5
</code></pre></div></div>

<h3 id="문자-함수">문자 함수</h3>

<h4 id="chr아스키-코드--입력된-아스키-코드에-매핑되는-문자-변환"><code class="language-plaintext highlighter-rouge">CHR(아스키 코드)</code> : 입력된 아스키 코드에 매핑되는 문자 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT CHR(65) FROM DUAL; // A
</code></pre></div></div>

<h4 id="lower문자열--입력된-문자열을-대문자로-변환"><code class="language-plaintext highlighter-rouge">LOWER(문자열)</code> : 입력된 문자열을 대문자로 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT LOWER('SQLD') FROM DUAL; // sqld
</code></pre></div></div>

<h4 id="upper문자열---입력된-문자열을-소문자로-변환"><code class="language-plaintext highlighter-rouge">UPPER(문자열)</code> :  입력된 문자열을 소문자로 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT LOWER('sqld') FROM DUAL; // SQLD
</code></pre></div></div>

<h4 id="ltrim문자열특정문자열--문자열-왼쪽부터-비교하여-공백-혹은-명시된-특정-문자-제거"><code class="language-plaintext highlighter-rouge">LTRIM(문자열[,{특정문자(열)}])</code> : 문자열 왼쪽부터 비교하여 공백 혹은 명시된 특정 문자 제거</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT LTRIM('      SQLD') FROM DUAL; // SQLD
</code></pre></div></div>

<h4 id="rtrim문자열특정문자열--문자열-오른쪽부터-비교하여-공백-혹은-명시된-특정-문자-제거"><code class="language-plaintext highlighter-rouge">RTRIM(문자열[,{특정문자(열)}])</code> : 문자열 오른쪽부터 비교하여 공백 혹은 명시된 특정 문자 제거</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT RTRIM('SQLD      ') FROM DUAL; // SQLD
</code></pre></div></div>

<h4 id="trim위치특정문자from문자열--문자열-왼쪽오른쪽-공백-혹은-옵션-지정-장소부터-제거"><code class="language-plaintext highlighter-rouge">TRIM([{위치}{특정문자}FROM]문자열)</code> : 문자열 왼쪽·오른쪽 공백 혹은 옵션 지정 장소부터 제거</h4>

<ul>
  <li>옵션 : <code class="language-plaintext highlighter-rouge">LEADING</code>, <code class="language-plaintext highlighter-rouge">TRAILING</code>, <code class="language-plaintext highlighter-rouge">BOTH</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT TRIM('      SQLD      ') FROM DUAL; // SQLD
SELECT TRIM(LEADING 'S' FROM 'SQLD') FROM DUAL; // QLD
SELECT TRIM(TRAILING 'Q' FROM 'SQLD') FROM DUAL; // SQL
</code></pre></div></div>

<h4 id="substr문자열시작점길이--문자열의-원하는-부분만-잘라-반환"><code class="language-plaintext highlighter-rouge">SUBSTR(문자열,시작점[,{길이}])</code> : 문자열의 원하는 부분만 잘라 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT SUBSTR('SQLD', 1, 2) FROM DUAL; // QL
</code></pre></div></div>

<h4 id="length문자열--문자열의-길이-반환"><code class="language-plaintext highlighter-rouge">LENGTH(문자열)</code> : 문자열의 길이 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT LENGTH('SQLD') FROM DUAL; // 4
</code></pre></div></div>

<h4 id="replace문자열변경전-문자열변경-후-문자열--문자열에서-변경-전-문자열을-찾아-변경-후-문자열로-변환"><code class="language-plaintext highlighter-rouge">REPLACE(문자열,변경전 문자열,[{변경 후 문자열}])</code> : 문자열에서 변경 전 문자열을 찾아 변경 후 문자열로 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT REPLACE('SQLD', 'D', 'P') FROM DUAL; // SQLP
</code></pre></div></div>

<h3 id="숫자-함수">숫자 함수</h3>

<h4 id="abs수--수의-절댓값-반환"><code class="language-plaintext highlighter-rouge">ABS({수})</code> : 수의 절댓값 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ABS(-1) FROM DUAL; // 1
</code></pre></div></div>

<h4 id="sign수--수의-부호-반환-1-0--1"><code class="language-plaintext highlighter-rouge">SIGN({수})</code> : 수의 부호 반환 (1, 0, -1)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT SIGN(5) FROM DUAL; // 1
SELECT SIGN(0) FROM DUAL; // 0
SELECT SIGN(-4) FROM DUAL; // -1
</code></pre></div></div>

<h4 id="round수-자릿수--수를-지정된-소수점-자릿수까지-반올림해-반환"><code class="language-plaintext highlighter-rouge">ROUND({수} [,{자릿수}])</code> : 수를 지정된 소수점 자릿수까지 반올림해 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ROUND(127.000000001, 0) FROM DUAL; // 127
</code></pre></div></div>

<h4 id="trunc수-자릿수--수를-지정된-소수점-자릿수까지-버림해-반환"><code class="language-plaintext highlighter-rouge">TRUNC({수}, [,{자릿수}])</code> : 수를 지정된 소수점 자릿수까지 버림해 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ROUND(127.000000001, 9) FROM DUAL; // 127
</code></pre></div></div>

<h4 id="ceil수--소수점-이하의-수를-올림한-정수로-반환"><code class="language-plaintext highlighter-rouge">CEIL({수})</code> : 소수점 이하의 수를 올림한 정수로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT CEIL(127.000000001) FROM DUAL; // 128
</code></pre></div></div>

<h4 id="floor수--소수점-이하의-수를-버림한-정수로-반환"><code class="language-plaintext highlighter-rouge">FLOOR({수})</code> : 소수점 이하의 수를 버림한 정수로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT FLOOR(127.000000001) FROM DUAL; // 127
</code></pre></div></div>

<h4 id="mod수1-수2--수1을-수2로-나눈-나머지를-반환"><code class="language-plaintext highlighter-rouge">MOD({수1}, {수2})</code> : 수1을 수2로 나눈 나머지를 반환</h4>

<ul>
  <li>수2가 0이면 수1 그대로 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MOD(15, 4) FROM DUAL; // 3
SELECT MOD(15, 0) FROM DUAL; // 15
</code></pre></div></div>

<h3 id="날짜-함수">날짜 함수</h3>

<h4 id="sysdate--현재의-연월일시분초-반환"><code class="language-plaintext highlighter-rouge">SYSDATE</code> : 현재의 연,월,일,시,분,초 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT SYSDATE FROM DUAL;
</code></pre></div></div>

<h4 id="extract특정-단위-from-데이터--날짜-데이터에서-연월일시분초-등-단위-지정해-출력"><code class="language-plaintext highlighter-rouge">EXTRACT({특정 단위} FROM {데이터})</code> : 날짜 데이터에서 연,월,일,시,분,초 등 단위 지정해 출력</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT EXTRACT(YEAR FROM SYSDATE) AS YEAR FROM DUAL; // 2024
</code></pre></div></div>

<h4 id="add_mount날짜-데이터-특정-개월-수--날짜-데이터에-특정-개월-수를-더한-날짜-반환"><code class="language-plaintext highlighter-rouge">ADD_MOUNT({날짜 데이터}, {특정 개월 수})</code> : 날짜 데이터에 특정 개월 수를 더한 날짜 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ADD_MOUNT('2024-03-07', 'YYYY-MM-DD', 2) // 2024-03-09
</code></pre></div></div>

<h3 id="변환-함수">변환 함수</h3>

<ul>
  <li>명시적 형변환 : 변환 함수로 데이터 유형 변환을 명시적으로 나타냄</li>
  <li>암시적 형변환 : 데이터베이스에서 내부적으로 데이터 유형을 변환함</li>
</ul>

<h4 id="to_number문자열--문자열을-숫자형으로-변환"><code class="language-plaintext highlighter-rouge">TO_NUMBER({문자열})</code> : 문자열을 숫자형으로 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT TO_NUMBER('123') FROM DUAL; // 123
</code></pre></div></div>

<h4 id="to_char수날짜포맷--수나-날짜를-포맷-형식의-문자형으로-변환"><code class="language-plaintext highlighter-rouge">TO_CHAR({수|날짜[,{포맷}]})</code> : 수나 날짜를 (포맷 형식의) 문자형으로 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT TO_CHAR(123) FROM DUAL; // '123'
</code></pre></div></div>

<h4 id="to_date문자열포맷--포맷-형식의-문자형-데이터를-날짜형으로-변환"><code class="language-plaintext highlighter-rouge">TO_DATE({문자열},{포맷})</code> : 포맷 형식의 문자형 데이터를 날짜형으로 변환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT TO_DATE('2024-03-07', 'YYYYMMDD') FROM DUAL; // '2024-03-07'
</code></pre></div></div>

<h3 id="null-관련-함수"><code class="language-plaintext highlighter-rouge">NULL</code> 관련 함수</h3>

<h4 id="nvl인수1-인수2--인수1의-값이-null이면-인수2-아니면-인수1-반환"><code class="language-plaintext highlighter-rouge">NVL({인수1}, {인수2})</code> : 인수1의 값이 <code class="language-plaintext highlighter-rouge">NULL</code>이면 인수2, 아니면 인수1 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER, NVL(SCORE, 0) AS MEMBER_SCORE FROM REVIEW;
</code></pre></div></div>

<h4 id="nullif인수1-인수2--인수1의-값이-같으면-null-아니면-인수1-반환"><code class="language-plaintext highlighter-rouge">NULLIF({인수1}, {인수2})</code> : 인수1의 값이 같으면 <code class="language-plaintext highlighter-rouge">NULL</code>, 아니면 인수1 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER, NULLIF(SCORE, 0) AS MEMBER_SCORE FROM REVIEW;
</code></pre></div></div>

<h4 id="coalesce인수1-인수2---null이-아닌-최초의-인수-반환"><code class="language-plaintext highlighter-rouge">COALESCE({인수1}, {인수2}, ...)</code> : <code class="language-plaintext highlighter-rouge">NULL</code>이 아닌 최초의 인수 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER, COALESCE(PHONE, EMAIL, FAX) AS  CONTACT FROM REVIEW;
</code></pre></div></div>

<h4 id="nvl인수1-인수2-인수3--인수1의-값이-null이-아니면-인수2-null이면-인수3-반환"><code class="language-plaintext highlighter-rouge">NVL({인수1}, {인수2}, {인수3})</code> : 인수1의 값이 <code class="language-plaintext highlighter-rouge">NULL</code>이 아니면 인수2, <code class="language-plaintext highlighter-rouge">NULL</code>이면 인수3 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER, NVL(SCORE, '리뷰 O', '리뷰 X') AS MEMBER_SCORE FROM REVIEW;
</code></pre></div></div>

<h4 id="case--이면-이고-이면-이다-식으로-표현되는-구문"><code class="language-plaintext highlighter-rouge">CASE</code> : ‘~이면 ~이고, ~이면 ~이다’ 식으로 표현되는 구문</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER,
    CASE WHEN SCORE = '5' THEN '만점'
    END AS REVIEW_DATA
FROM REVIEW;
</code></pre></div></div>

<h3 id="where절--dml문을-수행할-때-원하는-데이터만-선택"><code class="language-plaintext highlighter-rouge">WHERE</code>절 : <code class="language-plaintext highlighter-rouge">DML</code>문을 수행할 때 원하는 데이터만 선택</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT 컬럼1, 컬럼2, ... FROM 테이블 WHERE (조건절);
</code></pre></div></div>

<h4 id="비교-연산자--조건절-내에서-비교하기-위해-사용되는-연산자">비교 연산자 : 조건절 내에서 비교하기 위해 사용되는 연산자</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/e770be4a-d9a5-425d-8d01-d9106d794854" width="80%" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8ae99f0d-ea21-4e0c-b2cf-f5b886993c8d" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER FROM REVIEW WHERE MEMBER &lt; 10; // 10보다 작은 값 출력
SELECT MEMBER FROM REVIEW WHERE MEMBER = 10; // 10인 값 출력
SELECT MEMBER FROM REVIEW WHERE MEMBER &lt;= 10; // 10보다 작거나 같은 값 출력
SELECT MEMBER FROM REVIEW WHERE MEMBER &lt;&gt; 0; // 10과 같지 않은 값 출력
SELECT MEMBER FROM REVIEW WHERE MEMBER not col = 10; // 칼럼이 1이 아닌 값 출력
</code></pre></div></div>

<h4 id="sql-연산자--조건절-내에서-sql이-지원하는-연산자"><code class="language-plaintext highlighter-rouge">SQL</code> 연산자 : 조건절 내에서 <code class="language-plaintext highlighter-rouge">SQL</code>이 지원하는 연산자</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1567d7de-05b2-43f3-947f-53bfaaafe555" width="80%" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5895f223-e540-4d49-bba6-abdb7938b900" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MEMBER FROM REVIEW WHERE MEMBER BETWEEN 1 AND 10; // 1 ~ 10인 값 출력
</code></pre></div></div>

<h4 id="논리-연산자--조건절-내에서-논리-연산을-위해-사용되는-연산자">논리 연산자 : 조건절 내에서 논리 연산을 위해 사용되는 연산자</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/950b6035-99b0-4654-af32-ad33db4eddaf" width="80%" /></p>

<h3 id="group-by절--데이터를-그룹별로-묶음"><code class="language-plaintext highlighter-rouge">GROUP BY</code>절 : 데이터를 그룹별로 묶음</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BY</code> 뒤에 그룹핑의 기준이 되는 하나 이상의 컬럼이 위치</li>
</ul>

<h4 id="집계-함수--데이터를-그룹핑한-뒤에-그룹별로-집계-데이터를-도출">집계 함수 : 데이터를 그룹핑한 뒤에 그룹별로 집계 데이터를 도출</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0b0bfff1-003b-493e-bf4d-afed82b901fa" width="80%" /></p>

<h3 id="having--group-by절을-수행할-때-원하는-데이터만-선택-데이터-그룹핑에-사용"><code class="language-plaintext highlighter-rouge">HAVING</code> : <code class="language-plaintext highlighter-rouge">GROUP BY</code>절을 수행할 때 원하는 데이터만 선택 (데이터 그룹핑에 사용)</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b60b2263-1015-4c38-a5c0-4b0961836f30" width="80%" /></p>

<h3 id="order-by절--select한-데이터-정렬"><code class="language-plaintext highlighter-rouge">ORDER BY</code>절 : <code class="language-plaintext highlighter-rouge">SELECT</code>한 데이터 정렬</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/6d2c9476-fb99-4797-862a-32bf2f57ff56" width="80%" /></p>

<blockquote>
  <p>정렬의 기준이 되는 컬럼이 <code class="language-plaintext highlighter-rouge">NULL</code>이 포함되는 경우 : 오라클은 <code class="language-plaintext highlighter-rouge">NULL</code>을 최대로 보아 맨 뒤에 위치</p>
</blockquote>

<h3 id="join--다른-테이블을-한번에-결합하여-표현"><code class="language-plaintext highlighter-rouge">JOIN</code> : 다른 테이블을 한번에 결합하여 표현</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8cccf773-6e26-445f-b8c6-98baedfac236" width="80%" /></p>

<h4 id="equi-join---조건으로-join"><code class="language-plaintext highlighter-rouge">EQUI JOIN</code> : <code class="language-plaintext highlighter-rouge">=</code> 조건으로 <code class="language-plaintext highlighter-rouge">JOIN</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.CODE, A.NAME, B.ID, B.CONTENT
FROM PRODUCT A, PRODUCT_REVIEW B
WHERE A.PRODUCT_CODE = B.PRODUCT_CODE;
</code></pre></div></div>

<h4 id="non-equi-join--이-아닌-between-----조건으로-join"><code class="language-plaintext highlighter-rouge">Non EQUI JOIN</code> : <code class="language-plaintext highlighter-rouge">=</code>이 아닌 <code class="language-plaintext highlighter-rouge">BETWEEN</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code> 조건으로 <code class="language-plaintext highlighter-rouge">JOIN</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.CODE, A.NAME, B.ID, B.CONTENT
FROM PRODUCT A, PRODUCT_REVIEW B
WHERE B.DATE BETWEEN A.START_DATE AND A.END_DATE;
</code></pre></div></div>

<h4 id="outer-join--테이블-옆에-을-붙어-join-조건에-만족하지-않는-행들도-출력"><code class="language-plaintext highlighter-rouge">OUTER JOIN</code> : 테이블 옆에 <code class="language-plaintext highlighter-rouge">(+)</code>을 붙어 <code class="language-plaintext highlighter-rouge">JOIN</code> 조건에 만족하지 않는 행들도 출력</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7e5708df-e66c-4f8e-ad9a-84e931a86af6" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.CODE, A.NAME, B.ID, B.CONTENT
FROM PRODUCT A, PRODUCT_REVIEW B
WHERE A.PRODUCT_CODE = B.PRODUCT_CODE(+);
</code></pre></div></div>

<h3 id="standard-join--여러-데이터베이스에서-표준으로-활용되는-join"><code class="language-plaintext highlighter-rouge">STANDARD JOIN</code> : 여러 데이터베이스에서 표준으로 활용되는 <code class="language-plaintext highlighter-rouge">JOIN</code></h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DB</code> 벤더마다 <code class="language-plaintext highlighter-rouge">SQL</code> 문법 차이가 너무 크면 호환성·효율성에 문제가 발생하므로 <code class="language-plaintext highlighter-rouge">ANSI SQL</code> 지정</p>
</blockquote>

<h4 id="inner-standard-join--on으로-작성된-join-조건에-충족하는-데이터만-출력"><code class="language-plaintext highlighter-rouge">INNER STANDARD JOIN</code> : <code class="language-plaintext highlighter-rouge">ON</code>으로 작성된 <code class="language-plaintext highlighter-rouge">JOIN</code> 조건에 충족하는 데이터만 출력</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/53ba83bc-ee24-4fac-a062-5edc69aa838f" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM PRODUCT A INNER JOIN PRODUCT_REVIEW B
    ON A.PRODUCT_ID = B.PRODUCT_ID;
</code></pre></div></div>

<h4 id="outer-standard-join--join-조건에-만족하지-않는-행들도-출력"><code class="language-plaintext highlighter-rouge">OUTER STANDARD JOIN</code> : <code class="language-plaintext highlighter-rouge">JOIN</code> 조건에 만족하지 않는 행들도 출력</h4>

<h5 id="left-outer-join--왼쪽에-표기된-테이블들은-무조건-출력"><code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> : 왼쪽에 표기된 테이블들은 무조건 출력</h5>

<ul>
  <li>오른쪽에 <code class="language-plaintext highlighter-rouge">JOIN</code>되는 데이터가 없는 <code class="language-plaintext highlighter-rouge">ROW</code>는 오른쪽 컬럼의 값이 <code class="language-plaintext highlighter-rouge">NULL</code></li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/fdecf4bf-52de-4f48-a596-2f6543dc62ca" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.CODE, A.NAME, B.ID, B.CONTENT
FROM PRODUCT A LEFT OUTER JOIN PRODUCT_REVIEW B
    ON A.PRODUCT_ID = B.PRODUCT_ID;
</code></pre></div></div>

<h5 id="right-outer-join--오른쪽에-표기된-테이블들은-무조건-출력"><code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code> : 오른쪽에 표기된 테이블들은 무조건 출력</h5>

<ul>
  <li>왼쪽에 <code class="language-plaintext highlighter-rouge">JOIN</code>되는 데이터가 없는 <code class="language-plaintext highlighter-rouge">ROW</code>는 왼쪽 컬럼의 값이 <code class="language-plaintext highlighter-rouge">NULL</code></li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/60319867-65e2-4056-b64d-af3d7e3f5f2e" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.CODE, A.NAME, B.ID, B.CONTENT
FROM PRODUCT A RIGHT OUTER JOIN PRODUCT_REVIEW B
    ON A.PRODUCT_ID = B.PRODUCT_ID;
</code></pre></div></div>

<h5 id="full-outer-join--왼쪽-오른쪽에-표기된-테이블을-모두-출력"><code class="language-plaintext highlighter-rouge">FULL OUTER JOIN</code> : 왼쪽, 오른쪽에 표기된 테이블을 모두 출력</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code>와 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code>의 합집합 (단, 중복값은 제거)</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b2467251-eacb-426c-b4b7-1168e0ba19b2" width="80%" /></p>

<h5 id="nature-join--테이블에-같은-이름을-가진-컬럼들이-모두-동일한-데이터를-가지면-join"><code class="language-plaintext highlighter-rouge">NATURE JOIN</code> : 테이블에 같은 이름을 가진 컬럼들이 모두 동일한 데이터를 가지면 <code class="language-plaintext highlighter-rouge">JOIN</code></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT *
FROM RUNNING_MAN A NATURAL JOIN INFINITE_CHALLENGE B;
</code></pre></div></div>

<h5 id="cross-join--테이블-사이에-join이-없으면-조합할-수-있는-모든-경우-출력"><code class="language-plaintext highlighter-rouge">CROSS JOIN</code> : 테이블 사이에 <code class="language-plaintext highlighter-rouge">JOIN</code>이 없으면, 조합할 수 있는 모든 경우 출력</h5>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/34eb0299-568e-4a6e-8737-00ce194ae55c" width="80%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT A.CODE, A.NAME, B.ID, B.CONTENT
FROM ENTERTAINER A CROSS JOIN DRINK B;
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SQLD" /><summary type="html"><![CDATA[SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘SQL 기본’ 관련 정리이다.]]></summary></entry><entry><title type="html">[SQLD] 1. 데이터 모델링의 이해</title><link href="http://localhost:4000/sqld1/" rel="alternate" type="text/html" title="[SQLD] 1. 데이터 모델링의 이해" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-08T00:00:00+09:00</updated><id>http://localhost:4000/sqld1</id><content type="html" xml:base="http://localhost:4000/sqld1/"><![CDATA[<blockquote>
  <p>SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘데이터 모델링의 이해’ 관련 정리이다.</p>
</blockquote>

<h2 id="데이터-모델링의-이해">데이터 모델링의 이해</h2>

<h3 id="데이터-모델의-이해">데이터 모델의 이해</h3>

<ul>
  <li>모델링 (<code class="language-plaintext highlighter-rouge">Modeling</code>) : 현실에서 반영할 데이터를 저장할 데이터베이스를 구축하기 위한 분석·설계의 과정
    <ul>
      <li>모델링 조건 : 현실 세계를 반영해야 함, 단순화하여 표현해야 함, 관리하고자 하는 데이터를 모델로 설계</li>
    </ul>
  </li>
  <li>모델링 특징 : ‘현실 세계를 추상화, 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법’
    <ul>
      <li>추상화 (<code class="language-plaintext highlighter-rouge">Abstraction</code>) : 현실 세계의 아이디어나 개념을 일정한 형식으로 간략하게 표현하는 것</li>
      <li>단순화 (<code class="language-plaintext highlighter-rouge">Simplification</code>) : 복잡한 현실 세계를 정해진 표기법으로 단순하고 쉽게 표현하는 것</li>
      <li>명확화 (<code class="language-plaintext highlighter-rouge">Clarify</code>) : 불분명함을 제거하고 명확하게 해석할 수 있도록 기술하는 것</li>
    </ul>
  </li>
  <li>모델링의 3가지 관점 : 데이터 관점 , 프로세스 관점, 데이터·프로세스의 상관 관점</li>
  <li>데이터 모델링 유의점 : 중복 (같은 데이터가 여러 엔티티에 중복으로 저장되는 것은 지양되어야), 비유연성 (데이터 모델은 수시로 변경되므로, 데이터 모델과 프로세스를 분리해야), 비일관성 (데이터 간 연관 관계에 대해 명확히 정의해야)</li>
  <li>모델링 3단계 : 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링</li>
  <li>데이터 독립성 : 데이터베이스에 대한 사용자들의 관점과 실제 표현되는 물리적인 방식 분리</li>
  <li>3단계 스키마 구조 : 논리적 독립성, 개념적 독립성이 보장
    <ul>
      <li>외부 스키마 (<code class="language-plaintext highlighter-rouge">External Schema</code>) : 각 사용자가 보는 데이터베이스의 스키마 정의 → 사용자 관점</li>
      <li>개념 스키마 (<code class="language-plaintext highlighter-rouge">Conceptual Schema</code>) : 모든 사용자가 보는 데이터베이스의 스키마 통합 → 통합 관점</li>
      <li>내부 스키마 (<code class="language-plaintext highlighter-rouge">Internal Schema</code>) : 물리적 저장 구조를 표현 → 물리적 관점</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ERD</code> (<code class="language-plaintext highlighter-rouge">Entity Relation Diagram</code>) : 시스템에 어떤 엔티티가 존재하고, 그들 간 어떤 관계를 표현하는 다이어그램<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4824dc44-0a8e-46ad-bb7f-e3ab51287b3b" width="80%" /><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/2e42ecb5-6caa-4870-92c1-c71b13af3799" width="80%" /></li>
</ul>

<h3 id="엔티티">엔티티</h3>

<ul>
  <li>엔티티 (<code class="language-plaintext highlighter-rouge">Entity</code>) : 데이터베이스에서 식별 가능한 객체
    <ul>
      <li>엔티티 특징 : 업무에서 쓰이는 정보이면서 업무 프로세스에 의해 이용되어야 함, 유니크함을 보장할 수 있는 식별자가 있어야 함, 영속적으로 존재하는 2개 이상의 인스턴스의 집합이여야 함, 반드시 속성을 가져야 함, 다른 엔티티와 1개 이상의 관계를 가지고 있어야 함</li>
    </ul>
  </li>
  <li>엔티티 분류 : 유형 엔티티 (물리적 형태 존재, 안정적, 지속적), 개념 엔티티 (물리적 형태 없음, 개념적), 사건 엔티티 (행위를 함으로 발생, 빈번함, 통계 자료로 이용 가능)</li>
  <li>엔티티 발생 시점 : 기본 엔티티 (업무에 원래 존재하는 정보), 중심 엔티티 (기본 엔티티에서 파새오디어 행위 엔티티 생성), 행위 엔티티 (2개 이상의 엔티티로부터 파생)</li>
</ul>

<h3 id="속성">속성</h3>

<ul>
  <li>속성 (<code class="language-plaintext highlighter-rouge">Attribute</code>) : 사람·사물을 정의할 때 사물이나 개념의 특징을 설명해줄 수 있는 항목
    <ul>
      <li>속성 특징 : 더 이상 쪼개지지 않는 레벨, 프로세스에 필요한 항목이여야 함</li>
      <li>속성값 : 엔티티에 속한 하나의 인스턴스를 구체적으로 나타내주는 데이터</li>
    </ul>
  </li>
  <li>엔티티, 인스턴스, 속성, 속성값의 관계 : 속성 ⊂ 인스턴스 ⊂ 엔티티
    <ol>
      <li>1개의 엔티티는 2개 이상의 인스턴스를 갖는다.</li>
      <li>1개의 인스턴스는 2개 이상의 속성을 갖는다.</li>
      <li>1개의 속성은 1개의 속성값을 갖는다.</li>
    </ol>
  </li>
  <li>특성에 따른 속성 분류 : 기본 속성 (업무 프로세스 분석을 통해 바로 정의 가능한 속성), 설계 속성 (업무에 존재하지 않지만 설계할 때 도출된 속성), 파생 속성 (다른 속성의 속성값을 계산하거나 특정 규칙으로 변환되어 생성한 속성)</li>
  <li>구성 방식에 따른 속성 분류 : <code class="language-plaintext highlighter-rouge">PK</code> (엔티티의 인스턴스를 식별할 수 있는 속성), <code class="language-plaintext highlighter-rouge">FK</code> (다른 엔티티의 속성에서 가져온 속성), 일반 속성 (<code class="language-plaintext highlighter-rouge">PK</code>, <code class="language-plaintext highlighter-rouge">FK</code>를 제외한 나머지 속성)</li>
  <li>도메인 (<code class="language-plaintext highlighter-rouge">Domain</code>) : 속성이 가질 수 있는 속성값의 범위</li>
  <li>용어사전 : 속성의 이름을 직관적으로 부여하기 위한 업무사전</li>
  <li>시스템 카탈로그 : 시스템 자체에 관련이 있는 데이터를 담고 있는 데이터베이스 (읽기 연산만 가능)</li>
</ul>

<h3 id="관계">관계</h3>

<ul>
  <li>관계 (<code class="language-plaintext highlighter-rouge">Relation</code>) : 엔티티와 엔티티와의 관계
    <ul>
      <li>존재 관계 : 존재 자체로 연관성이 있는 관계</li>
      <li>행위 관계 : 특정한 행위를 함으로써 연관성이 생기는 관계</li>
    </ul>
  </li>
  <li>관계 표기법 : 관계명 (엔티티와 엔티티가 어떤 관계를 맺고 있는지 나타내는 문장),  관계차수 (<code class="language-plaintext highlighter-rouge">1:1</code>, <code class="language-plaintext highlighter-rouge">1:N</code>, <code class="language-plaintext highlighter-rouge">N:N</code>와 같이 각 엔티티에서 관계에 참여하는 수), 관계선택사양 (이 관계가 필수요소인지 선택사항인지 나타내는 말)</li>
</ul>

<h3 id="식별자">식별자</h3>

<ul>
  <li>식별자 (<code class="language-plaintext highlighter-rouge">Identifier</code>) : 속성 중에 각각의 인스턴스를 구분 가능하게 하는 속성</li>
  <li>
    <p>식별자 분류 : 대표성 여부 (주식별자<code class="language-plaintext highlighter-rouge">vs</code>보조 식별자), 소스로 생성되었는지 여부 (내부식별자<code class="language-plaintext highlighter-rouge">vs</code>외부식별자), 단일 속성 여부 (단일식별자<code class="language-plaintext highlighter-rouge">vs</code>복합식별자), 대체 여부 (원조식별자<code class="language-plaintext highlighter-rouge">vs</code>대리식별자)</p>
  </li>
  <li>주식별자 : <code class="language-plaintext highlighter-rouge">PK</code> → 하나의 속성이 주식별자가 될 수 있고, 여러 개의 속성이 주식별자가 될 수 있음</li>
  <li>주식별자 특징 : 유일성 (각 인스턴스에 유니크함을 부여하여 식별이 가능하도록 함), 최소성 (유일성을 보장하는 최소 개수의 속성이여아 함),  불변성 (속성값이 되도록 변하지 않아아 함), 존재성 (속성값이 <code class="language-plaintext highlighter-rouge">NULL</code>일 수 없음)</li>
</ul>

<h2 id="데이터-모델과-sql">데이터 모델과 <code class="language-plaintext highlighter-rouge">SQL</code></h2>

<h3 id="정규화">정규화</h3>

<ul>
  <li>정규화 (<code class="language-plaintext highlighter-rouge">Normalization</code>) : 데이터 정합성을 위해 엔티티를 작은 단위로 분리하는 과정
    <ul>
      <li>제1정규형 : 모든 속성은 반드시 하나의 값만 가져야 함</li>
      <li>제2정규형 : 엔티티의 모든 일반속성은 반드시 모든 주식별자에 종속되어야 함</li>
      <li>제3졍규형 : 주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없음</li>
    </ul>
  </li>
</ul>

<h3 id="반정규화">반정규화</h3>

<ul>
  <li>반정규화 (<code class="language-plaintext highlighter-rouge">De-Normalization</code>) : 데이터의 조회 성능 향상을 위해 데이터 중복을 허용하거나 데이터를 그룹핑
    <ul>
      <li>테이블 반졍규화 : 테이블 병합 (<code class="language-plaintext highlighter-rouge">JOIN</code>이 많아 테이블 통합, <code class="language-plaintext highlighter-rouge">1:M</code>은 지양해야), 테이블 분할 (엔티티 일부 속성을 <code class="language-plaintext highlighter-rouge">1:1</code>의 엔티티로 만드는 테이블 수직 분할, 엔티티 인스턴스를 특정 기준으로 파티셔닝하는 테이블 수평 분할), 테이블 추가 (별도의 중복된 엔티티를 추가하는 중복 테이블 추가, 통계 테이블·이력 테이블·부분 테이블 추가)</li>
      <li>컬럼 반정규화 : 중복 칼럼 추가 (<code class="language-plaintext highlighter-rouge">JOIN</code>이 많아 컬럼 통합), 파생 칼럼 추가 (계산값을 미리 컬럼으로 보관), 이력 테이블 컬럼 추가 (조회 기준이 될 컬럼을 미리 추가)</li>
      <li>관계 반정규화 : <code class="language-plaintext highlighter-rouge">JOIN</code>이 많아 중복 관계 추가</li>
    </ul>
  </li>
</ul>

<h3 id="트랜잭션">트랜잭션</h3>

<ul>
  <li>트랜잭션 (<code class="language-plaintext highlighter-rouge">Transaction</code>) : 데이터를 조작하기 위한 하나의 논리 작업 다위</li>
  <li>널 (<code class="language-plaintext highlighter-rouge">NULL</code>) : 존재하지 않음, 값이 없음</li>
</ul>

<h2 id="데이터베이스">데이터베이스</h2>

<h3 id="관계형-테이터베이스">관계형 테이터베이스</h3>

<ul>
  <li>데이터베이스 (<code class="language-plaintext highlighter-rouge">Database</code>) : 데이터를 저장하는 공간
    <ul>
      <li>관계형 데이터베이스 (<code class="language-plaintext highlighter-rouge">RDB; Relational Database</code>) : 관계형 데이터 모델에 기초한 데이터베이스 (모든 데이터를 2차원 테이블 형태로 표현한 뒤 각 테이블 간의 관계를 정의)</li>
      <li>테이블 (<code class="language-plaintext highlighter-rouge">Table</code>) : 세로 열인 컬럼 (<code class="language-plaintext highlighter-rouge">Column</code>)과 가로 행인 로우 (<code class="language-plaintext highlighter-rouge">Row</code>)로 구성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SQL</code> : 관계형 데이터베이스에서 데이터를 다루기 위해 사용하는 언어</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SQLD" /><summary type="html"><![CDATA[SQLD를 취득하기 위해 공부하는 과정에 작성한 ‘데이터 모델링의 이해’ 관련 정리이다.]]></summary></entry><entry><title type="html">[React] 3. 함수 컴포넌트 (Functional Component)</title><link href="http://localhost:4000/react3/" rel="alternate" type="text/html" title="[React] 3. 함수 컴포넌트 (Functional Component)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react3</id><content type="html" xml:base="http://localhost:4000/react3/"><![CDATA[<h2 id="함수-컴포넌트-functional-component--리액트-훅을-통한-상태와-생명주기-관리">함수 컴포넌트 (<code class="language-plaintext highlighter-rouge">Functional Component</code>) : 리액트 훅을 통한 상태와 생명주기 관리</h2>

<blockquote>
  <p>클래스 컴포넌트의 한계?</p>

  <ul>
    <li>데이터의 흐름을 추적하기 어려움 : 서로 다른 여러 메소드에서, 작성 순서에 상관없이 상태의 업데이트 발생 가능</li>
    <li>어플리케이션 내부 로직의 재사용이 어려움 : 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트나 <code class="language-plaintext highlighter-rouge">props</code>이 많아짐</li>
    <li>기능이 많아질수록 컴포넌트의 크기가 커짐 : 내부에서 처리하는 데이터 흐름이 복잡해짐</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState, useEffect } from 'react';

const MyFunctionalComponent = () =&gt; {
  // useState 훅을 사용하여 상태 정의
  const [count, setCount] = useState(0);

  // useEffect 훅을 사용하여 부수 효과(라이프사이클 작업 등) 처리
  useEffect(() =&gt; {
    console.log('Component mounted or count updated:', count);
    // componentWillUnmount 역할을 하는 함수 (클린업 함수)
    return () =&gt; {
      console.log('Component will unmount');
    };
  }, [count]); // count가 업데이트될 때만 실행

  const handleIncrement = () =&gt; {
    // setCount를 사용하여 상태 업데이트
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default MyFunctionalComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useContext</code>와 같은 리액트 훅을 사용하여 상태를 관리</li>
  <li><code class="language-plaintext highlighter-rouge">useEffect</code> 훅을 통해 라이프사이클 메소드와 유사한 동작을 수행 가능</li>
  <li><code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용하지 않고, 클래스 컴포넌트보다 간결하고 명료하게 작성 가능</li>
</ul>

<h3 id="리액트-훅-react-hook--함수형-컴포넌트에서-상태와-생명주기-메서드를-사용할-때-사용">리액트 훅 (<code class="language-plaintext highlighter-rouge">React Hook</code>) : 함수형 컴포넌트에서 상태와 생명주기 메서드를 사용할 때 사용</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c4f6fd02-e4fd-4f86-bd52-e4eed847cc3c" width="50%" /></p>

<ul>
  <li>상태 관리 훅 : <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">userContext</code>, <code class="language-plaintext highlighter-rouge">useReducer</code></li>
  <li>시점 훅 : <code class="language-plaintext highlighter-rouge">useLayoutEffect</code>, <code class="language-plaintext highlighter-rouge">useEffect</code></li>
  <li>메모이제이션 (<code class="language-plaintext highlighter-rouge">Memo</code>) 훅 : <code class="language-plaintext highlighter-rouge">useMemo</code>, <code class="language-plaintext highlighter-rouge">useCallback</code>, <code class="language-plaintext highlighter-rouge">memo</code></li>
</ul>

<blockquote>
  <p>훅의 규칙 (<code class="language-plaintext highlighter-rouge">Rules-of-Hooks</code>) : 관련 <code class="language-plaintext highlighter-rouge">ESLint</code> 규칙으로 <code class="language-plaintext highlighter-rouge">react-hooks/rules-of-hooks</code> 또한 존재</p>

  <p><code class="language-plaintext highlighter-rouge">(1)</code> 최상위에서만 훅을 호출해야 한다. (반복문, 조건문, 중첩 함수 내에서 훅을 실행할 수 없다.)<br />→ 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.<br />
<code class="language-plaintext highlighter-rouge">(2)</code> 훅을 호출할 수 있는 것은 함수 컴포넌트, 혹은 커스텀 훅만 가능하다.</p>
</blockquote>

<h4 id="usestate--함수형-컴포넌트-내부에서-상태를-정의하고-관리할-때-사용"><code class="language-plaintext highlighter-rouge">useState</code> : 함수형 컴포넌트 내부에서 상태를 정의하고 관리할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react'
const [state, setState] = useState(initState)
</code></pre></div></div>

<ul>
  <li>인수로 사용할 상태의 초기값을 받음</li>
  <li>첫번째 값에 현재 상태의 값, 두번째 값에 상태를 업데이트하는 함수가 담긴 배열을 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const [state, setState] = useState(() =&gt; Number.praseInt(window.localStorage.getItem(cacheKey)));
</code></pre></div></div>

<ul>
  <li>게으른 초기화 (<code class="language-plaintext highlighter-rouge">Lazy Initialization</code>) : <code class="language-plaintext highlighter-rouge">useState</code> 등 리액트 훅의 인자에 변수 대신 함수 자체를 넘기는 것
    <ul>
      <li><code class="language-plaintext highlighter-rouge">useState</code>의 초기값이 복잡하거나 무거운 연산을 포함하는 경우에 사용</li>
      <li>오직 상태가 처음 만들어질 때만 사용 → 리렌더링이 발생하면 이 함수의 실행은 무시</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react';

const Component = () =&gt; {
  // useState를 사용하여 counter라는 상태를 정의하고 초기값을 0으로 설정
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1)
  }

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<h4 id="useeffect--어플리케이션-내-컴포넌트의-여러-값들을-통해-부수-효과를-만들-때-사용"><code class="language-plaintext highlighter-rouge">useEffect</code> : 어플리케이션 내 컴포넌트의 여러 값들을 통해 부수 효과를 만들 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Component = () =&gt; {
  useEffect(
    () =&gt; {},
    [props, state]
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 콜백 함수, 두번째 인수로 의존성 배열을 받음 : 의존성 배열의 값이 변경되면 콜백 실행
    <ul>
      <li><code class="language-plaintext highlighter-rouge">componentDidMount</code> 시점에 비동기로 실행 → <code class="language-plaintext highlighter-rouge">rendering</code> 이후, <code class="language-plaintext highlighter-rouge">mount</code> 이후</li>
    </ul>
  </li>
  <li>클래스 컴포넌트의 생명주기와 비슷한 동작을 구현 가능 : 의존성 배열에 빈 배열을 넣으면 컴포넌트가 마운트될 때만 실행</li>
  <li>렌더링이 실행될 때마다 의존성에 있는 값을 보면서 값 (<code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">props</code>)이 변경되면 부수 효과를 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Component = () =&gt; {
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1)
  }

  const counter = 1

  useEffect(
    () =&gt; {
      console.log(count) // 1, 2, 3, 4...
    }
  )

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>클린업 함수를 반환 가능 : 컴포넌트가 언마운트될 때 실행 (<code class="language-plaintext highlighter-rouge">componentWillUnMount</code>)
    <ul>
      <li>함수 컴포넌트가 리렌더링되었을 때 의존성 변화가 있었을 당시의 값 기준으로 실행되어 이전 상태를 청소</li>
      <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useEffect</code>는 콜백이 실행될 때마다 이전 클린업 함수가 존재하면 그 클린업 함수를 실행한 뒤 콜백 실행
        <ul>
          <li>특정 이벤트 핸돌러가 무한히 생성되는 것을 방지</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState, useEffect } from 'react'

export default function App() {
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  }

  useEffect(() =&gt; {
    const addMouseEffect = () =&gt; {
      console.log(counter)
    }

    window.addEventListener('click', addMouseEffect);

    return () =&gt; {
      console.log('클린업 함수', counter);
      window.removeEventListener('click', addMouseEffect);
    }
  }, [counter]);

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onclick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}

// 클린업 함수 0
// 1
// 클린업 함수 1
// 2
// ...
</code></pre></div></div>

<ul>
  <li>의존성 배열 (<code class="language-plaintext highlighter-rouge">dependency arra</code>) : 내부의 특정 값이 변경될 때에만 <code class="language-plaintext highlighter-rouge">useEffect</code> 콜백이 실행되도록 제어
    <ul>
      <li>의존성 배열에 사용자가 원하는 값을 넣는 경우 : 해당 값이 변경될 따마다 실행</li>
      <li>의존성 배열에 빈 배열을 두는 경우 : 최초 렌더링 직후에 한번 실행하고 더 이상 실행하지 않음</li>
      <li>의존성 배열에 아무런 값을 두지 않는 경우 : 렌더링이 발생할 때마다 매번 실행
        <ul>
          <li><code class="language-plaintext highlighter-rouge">vs</code> 직접 실행? : 클라이언트 사이드에서 실행 보장, 컴포넌트 렌더링 완료 이후에 실행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useEffect(() =&gt; {
  // 실행될 코드
}, [dependency1, dependency2, ...]); // 의존성 배열
</code></pre></div></div>

<h4 id="usememo--큰-연산에-대한-결과를-메모이제이션-memoization할-때-사용"><code class="language-plaintext highlighter-rouge">useMemo</code> : 큰 연산에 대한 결과를 메모이제이션 (<code class="language-plaintext highlighter-rouge">Memoization</code>)할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useMemo, useState } from 'react'

const ExpensiveComponent = ({ value }) =&gt; {
  useEffect(() =&gt; {
    console.log('rendering')
  })

  return &lt;span{value + 10000}&gt;&lt;/span&gt;
}

const App = () =&gt; {
  const [value, setValue] = useState(10);
  const [, triggerRendering] = useState(false);

  const MemoizedComponent = useMemo(
    () =&gt; &lt;ExpensiveComponent value={value}&gt;, [value]
  )

  const handleChange = (e) =&gt; {
    setValue(Number(e.target.value))
  }

  const handleClick = () =&gt; {
    setValue(Number(e.target.value))
  }

  return (
    &lt;&gt;
      &lt;input value={value} onChange={handleChange}&gt;&lt;/input&gt;
      &lt;button = onClick={handleClick}&gt;렌더링 발생&lt;/button&gt;
      {MemoizedComponent}
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 생성 함수, 두번째 인수로 해당 함수가 의존하는 값의 배열을 전달
    <ul>
      <li>렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면, 함수를 재실행하지 않고 이전의 값을 반환</li>
      <li>렌더링 발생 시 의존성 배열의 값이 변경되었으면, 첫번째 인수의 함수를 실행한 후에 그 값을 반환 및 메모이제이션</li>
    </ul>
  </li>
</ul>

<h4 id="reactmemo--외부-상태나-컨텍스트에-의존하지-않고-순수-함수형-컴포넌트를-메모이제이션할-때-사용"><code class="language-plaintext highlighter-rouge">React.Memo</code> : 외부 상태나 컨텍스트에 의존하지 않고 순수 함수형 컴포넌트를 메모이제이션할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const CreateUser = React.memo(({ username, email, onChange, onCreate }) =&gt; {
  return (
    &lt;div&gt;
      &lt;input
        name="username"
        placeholder="계정명"
        onChange={onChange}
        value={username}
      /&gt;
      &lt;input
        name="email"
        placeholder="이메일"
        onChange={onChange}
        value={email}
      /&gt;
      &lt;button onClick={onCreate}&gt;등록&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre></div></div>

<ul>
  <li>컴포넌트의 <code class="language-plaintext highlighter-rouge">props</code>이 바뀔 때에만 리렌더링을 수행</li>
</ul>

<h4 id="usecallback--인수로-넘겨받은-콜백-자체를-저장해-재성성-대신-재사용할-때-사용"><code class="language-plaintext highlighter-rouge">useCallback</code> : 인수로 넘겨받은 콜백 자체를 저장해, 재성성 대신 재사용할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const ChildComponent = memo(({name, value, onChange}) =&gt; {
  useEffect(
    () =&gt; {
      console.log('rendering', name)
    }
  )

  return(
    &lt;&gt;
      &lt;h1&gt;{name} (value ? '켜짐' : '꺼짐')&lt;/h1&gt;
      &lt;button onClick={onChange}&gt;toggle&lt;/button&gt;
    &lt;/&gt;
  )
})

const App = () =&gt; {
  const [status1, setStatus1] = useState(false)
  const [status2, setStatus2] = useState(false)

  const toggle1 = useCallback(
    function toggle1() {
      setStatus(!status1)
    }, [status1],
  )

  const toggle2 = useCallback(
    function toggle2() {
      setStatus(!status2)
    }, [status2],
  )

  return (
    &lt;&gt;
      &lt;ChildComponent name="1" value={status1} onChange={toggle1}&gt;&lt;/ChildComponent&gt;
      &lt;ChildComponent name="2" value={status2} onChange={toggle2}&gt;&lt;/ChildComponent&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 함수, 두번째 인수로 해당 함수가 의존하는 값의 배열을 전달</li>
  <li>값의 메모이제이션을 위해 <code class="language-plaintext highlighter-rouge">useMemo</code>를 사용했다면, 함수의 메모이제이션을 위해 사용하는 것이 <code class="language-plaintext highlighter-rouge">useCallback</code>!
    <ul>
      <li>해당 의존성이 변경되었을 때만 함수가 재생성 : 불필요한 리소스 및 리렌더링 방지 가능</li>
      <li><code class="language-plaintext highlighter-rouge">useMemo</code>을 통해 <code class="language-plaintext highlighter-rouge">useCallback</code>를 구현할 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="useref--함수형-컴포넌트-내에서-참조를-생성하고-관리할-때-사용"><code class="language-plaintext highlighter-rouge">useRef</code> : 함수형 컴포넌트 내에서 참조를 생성하고 관리할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, useEffect } from 'react';

function MyComponent() {
  const myInputRef = useRef(null);

  useEffect(() =&gt; {
    // 컴포넌트가 마운트된 후, input 요소에 포커스를 줌
    myInputRef.current.focus();
  }, []);

  return &lt;input ref={myInputRef} /&gt;;
}
</code></pre></div></div>

<ul>
  <li>반환값인 객체 내부에 있는 <code class="language-plaintext highlighter-rouge">.current</code>로 값에 접근 혹은 변경이 가능</li>
  <li>컴포넌트의 렌더링과 관계없이 변수를 저장 가능 → <code class="language-plaintext highlighter-rouge">useState</code>와 달리, 매번 리렌더링이 일어나지 않음</li>
  <li>주로 <code class="language-plaintext highlighter-rouge">DOM</code> 요소에 접근하거나 컴포넌트의 생명주기와 독립적으로 값을 유지하는 상황에서 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, useState, useEffect } from 'react';

function MyComponent() {
  const countRef = useRef(0);
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    // countRef는 렌더링과 무관하게 유지되는 변수
    countRef.current = count;
  }, [count]);

  const handleClick = () =&gt; {
    setCount(count + 1);
    console.log(countRef.current); // 항상 가장 최근 값 출력
  };

  return &lt;button onClick={handleClick}&gt;증가&lt;/button&gt;;
}
</code></pre></div></div>

<h4 id="usecontext--react-context를-통해-전역으로-상태를-공유하거나-전달할-때-사용"><code class="language-plaintext highlighter-rouge">useContext</code> : <code class="language-plaintext highlighter-rouge">React Context</code>를 통해 전역으로 상태를 공유하거나 전달할 때 사용</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prop</code> 내려주기 : <code class="language-plaintext highlighter-rouge">A</code> 컴포넌트가 제공하는 데이터를 <code class="language-plaintext highlighter-rouge">D</code> 컴포넌트에서 사용하려면, …
    <ul>
      <li>하위 컴포넌트로 필요한 위치까지 계속해서 넘겨주어야 함 → 제공하는 쪽, 제공받는 쪽 모두 번거로운 작업!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;A props={props}&gt;
  &lt;B props={props}&gt;
    &lt;C props={props}&gt;
      &lt;D props={props}&gt;
        ...
      &lt;/D&gt;
    &lt;/C&gt;
  &lt;/B&gt;
&lt;/A&gt;
</code></pre></div></div>

<ul>
  <li>리액트 컨텍스트 (<code class="language-plaintext highlighter-rouge">React Context</code>) : 컴포넌트 트리 안에서 전역적으로 데이터를 공유
    <ul>
      <li>중첩 컴포넌트 간에 데이터를 명시적으로 전달하지 않아도 되므로, <code class="language-plaintext highlighter-rouge">Props</code>를 여러 단계에 걸쳐 전달하지 않아도 됨</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1. Context 객체 생성
const MyContext = React.createContext(defaultValue);

// 2. Context를 제공하는 컴포넌트 작성
const MyContextProvider = ({ children }) =&gt; {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
};

// 3. useContext를 사용하여 값에 접근
import { useContext } from 'react';

const MyComponent = () =&gt; {
  const contextValue = useContext(MyContext); // 이때, 리액트가 아닌 자비스크립트가 반환된다.

  // contextValue를 사용하여 렌더링 또는 다른 로직 수행
};
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Context.Provider</code> : 컨텍스트 값을 하위 컴포넌트에 제공
    <ul>
      <li><code class="language-plaintext highlighter-rouge">value</code> 속성을 통해 전달할 값을 설정</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const MyContextProvider = ({ children }) =&gt; {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
};
</code></pre></div></div>

<h4 id="usereducer--복잡한-상태-로직을-다룰-때-사용"><code class="language-plaintext highlighter-rouge">useReducer</code> : 복잡한 상태 로직을 다룰 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// useReducer가 사용할 State 정의
type State = {
  count: number
}

// State의 변화를 발생시킬 Action의 타입과 넘겨줄 payload 정의
type Action = {
  type: 'up' | 'down' | 'reset';
  payload?: State;
}

// 무거운 연산이 포함된 게으른 초기화 함수 init 정의
const init = (count: State) =&gt; {
  return count
}

const initState: State = { count: 0 }

const reducer = ((state: State, action: Action): State) =&gt; {
  switch (action.type) {
    case 'up':
      return { count: state.count + 1 }
    case 'down':
      return { count: state.count - 1 &gt; 0 ? state.count - 1 : 0 }
    case 'down':
      return init(action.payload || { count: 0 })
    default:
      throw new Error(`Unexpected Action type: ${action.type}`)
  }
}

const export default App = () =&gt; {
  const [state, dispatcher] = useReducer(reducer, initialState, init)

  const handleUpButtonClick = () =&gt; {
    dispatcher({ type: 'up' })
  }

  const handleDownButtonClick = () =&gt; {
    dispatcher({ type: 'down' })
  }

  const handleResetButtonClick = () =&gt; {
    dispatcher({ type: 'reset', payload: { count: 1 } })
  }

  return {
    &lt;div className="App"&gt;
      &lt;button onclick={handleUpButtonClick}&gt;+&lt;/button&gt;
      &lt;button onclick={handleDownButtonClick}&gt;-&lt;/button&gt;
      &lt;button onclick={handleResetButtonClick}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre></div></div>

<ul>
  <li>반환값은 <code class="language-plaintext highlighter-rouge">useState</code>와 동일하게 길이가 <code class="language-plaintext highlighter-rouge">2</code>인 배열
    <ul>
      <li><code class="language-plaintext highlighter-rouge">state</code> : 현재 <code class="language-plaintext highlighter-rouge">useReducer</code>가 갖고 있는 값</li>
      <li><code class="language-plaintext highlighter-rouge">dispatcher</code> : <code class="language-plaintext highlighter-rouge">state</code>를 업데이트하는 함수<br />(값만 넘겨주는 <code class="language-plaintext highlighter-rouge">setState</code>와 달리, <code class="language-plaintext highlighter-rouge">state</code>를 변경할 수 있는 <code class="language-plaintext highlighter-rouge">action</code> 반환)</li>
    </ul>
  </li>
  <li>인수는 <code class="language-plaintext highlighter-rouge">useState</code>와 달리 2~3개의 인수를 필요로 함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">reducer</code> : 첫번째 인수 → <code class="language-plaintext highlighter-rouge">useReducer</code>의 기본 <code class="language-plaintext highlighter-rouge">action</code>을 정의하는 함수</li>
      <li><code class="language-plaintext highlighter-rouge">initialState</code> : 두번째 인수 → <code class="language-plaintext highlighter-rouge">useReducer</code>의 초깃값</li>
      <li><code class="language-plaintext highlighter-rouge">init</code> : (선택) 세번째 인수 → 초깃값을 지연해서 생성 (게으른 초기화)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">useReducer</code>의 목적?</p>

  <p><code class="language-plaintext highlighter-rouge">(1)</code> 복잡한 형태의 <code class="language-plaintext highlighter-rouge">state</code>를 사전에 정의된 <code class="language-plaintext highlighter-rouge">dispatcher</code>로만 수정할 수 있게 하여,<br /><code class="language-plaintext highlighter-rouge">(2)</code> <code class="language-plaintext highlighter-rouge">state</code> 값에 대한 접근은 컴포넌트에서만 가능하게 하고,<br /><code class="language-plaintext highlighter-rouge">(3)</code> 이를 업데이트하하는 방법에 대한 상세 정의 컴포넌트 밖에 둔 다음,<br /><code class="language-plaintext highlighter-rouge">(4)</code> <code class="language-plaintext highlighter-rouge">state</code>의 업데이트를 <code class="language-plaintext highlighter-rouge">dispatcher</code>로 제한한다!</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">state</code> 하나가 가질 값이 복잡하고 이를 수정하는 경우의 수가 많아지면 <code class="language-plaintext highlighter-rouge">state</code>를 관리하는 것이 어려워짐</li>
    <li>여러 <code class="language-plaintext highlighter-rouge">state</code>를 관리하는 것보다 성격이 비슷한 것들을 묶어 <code class="language-plaintext highlighter-rouge">useReducer</code>로 관리하는 것이 효율적</li>
    <li>게으른 초기화 함수를 인자로 사용하여 <code class="language-plaintext highlighter-rouge">useState</code>에 함수를 넣은 것과 같은 이점을 누릴 수 있음</li>
    <li>추가로 <code class="language-plaintext highlighter-rouge">state</code>에 대한 초기화가 필요할 때 <code class="language-plaintext highlighter-rouge">reducer</code>에서 재사용할 수 있음</li>
  </ul>
</blockquote>

<h4 id="forwardref--부모-컴포넌트에서-자식-컴포넌트로-ref를-전달할-수-있게-함"><code class="language-plaintext highlighter-rouge">forwardRef</code> : 부모 컴포넌트에서 자식 컴포넌트로 <code class="language-plaintext highlighter-rouge">ref</code>를 전달할 수 있게 함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, forwardRef } from 'react';

// 자식 컴포넌트
const ChildComponent = forwardRef((props, ref) =&gt; {
  const internalState = useRef(null);

  // 부모 컴포넌트에서 전달한 ref에 직접 접근
  // ref.current를 통해 부모 컴포넌트의 ref를 참조할 수 있음
  const handleButtonClick = () =&gt; {
    console.log('자식 컴포넌트에서 버튼 클릭');
    console.log('내부 상태:', internalState.current);
  };

  return (
    // 여기에 컴포넌트 JSX를 작성
    &lt;div&gt;
      &lt;button onClick={handleButtonClick}&gt;자식 컴포넌트에서 클릭&lt;/button&gt;
    &lt;/div&gt;
  );
});

// 부모 컴포넌트
const ParentComponent = () =&gt; {
  // ref를 생성하여 자식 컴포넌트에 전달
  const childRef = useRef();

  // 부모 컴포넌트에서 ref를 자식 컴포넌트에 전달
  return (
    &lt;div&gt;
      {/* forwardRef를 사용하여 자식 컴포넌트에 ref 전달 */}
      &lt;ChildComponent ref={childRef} /&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ref</code>를 받고자 하는 컴포넌트를 <code class="language-plaintext highlighter-rouge">forwards</code>로 감싸고, 두번째 인수로 <code class="language-plaintext highlighter-rouge">ref</code> 전달
    <ul>
      <li>부모 컴포넌트에서 <code class="language-plaintext highlighter-rouge">props.ref</code>를 통해 <code class="language-plaintext highlighter-rouge">ref</code>를 전달</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">useRef</code>에서 반환된 <code class="language-plaintext highlighter-rouge">ref</code> 객체를 상위에서 하위 컴포넌트로 전달할 때, 직접 <code class="language-plaintext highlighter-rouge">props</code>를 넣을 수 없을 때 사용
    <ul>
      <li>컴포넌트 외부의 <code class="language-plaintext highlighter-rouge">DOM</code>에 접근 : 부모에서 선언 → 자식에 전달 → 자식에 참조 걸기 → 부모에서 컨트롤</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">But</code>, 외부 <code class="language-plaintext highlighter-rouge">DOM</code>을 참조하는 <code class="language-plaintext highlighter-rouge">ref</code>를 갖는 것은 <code class="language-plaintext highlighter-rouge">Coupling</code>이 강해지므로 좋지 않다!</p>
</blockquote>

<h4 id="useimperativehandle-with-forwardref--부모-컴포넌트가-자식-컴포넌트를-컨트롤할-수-있게-함"><code class="language-plaintext highlighter-rouge">useImperativeHandle (with forwardRef)</code> : 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있게 함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { forwardRef, useRef, useImperativeHandle } from 'react';

const ChildComponent = forwardRef((props, ref) =&gt; {
  // useImperativeHandle을 사용하여 부모 컴포넌트에 특정 함수나 값들을 노출
  useImperativeHandle(ref, () =&gt; ({
    // 부모 컴포넌트에서 입력 엘리먼트에 포커스를 맞추기 위해 함수를 노출
    focusInput: () =&gt; {
      inputRef.current.focus();
    }
  }));

  const inputRef = useRef(null);

  return &lt;input ref={inputRef} /&gt;;
});

const ParentComponent = () =&gt; {
  const childRef = useRef(null);

  const handleClick = () =&gt; {
    // 자식 컴포넌트에서 노출한 함수를 호출하여 입력 엘리먼트에 포커스를 맞춤
    childRef.current.focusInput();
  };

  return (
    &lt;div&gt;
      &lt;ChildComponent ref={childRef} /&gt;
      &lt;button onClick={handleClick}&gt;입력에 포커스 맞추기&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useImperativeHandle</code>을 통해 부모 컴포넌트에 함수 및 기능을 노출시킴
    <ul>
      <li>부모에게 참조값을 전달 → 자식은 객체를 반환</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">HTMLElement</code>만 주입 가능한 <code class="language-plaintext highlighter-rouge">ref</code>에, 자식 컴포넌트에 새로 설정한 객체의 키·값에 대해서도 접근 가능</li>
</ul>

<h4 id="uselayouteffect--시그니처가-useeffect와-동일하나-모든-dom-변경-후의-콜백-실행이-동기적으로-발생"><code class="language-plaintext highlighter-rouge">useLayoutEffect</code> : 시그니처가 <code class="language-plaintext highlighter-rouge">useEffect</code>와 동일하나, 모든 <code class="language-plaintext highlighter-rouge">DOM</code> 변경 후의 콜백 실행이 동기적으로 발생</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React, { useLayoutEffect, useState } from 'react';

const MyComponent = () =&gt; {
  const [width, setWidth] = useState(0);

  useLayoutEffect(() =&gt; {
    // DOM 요소의 너비 측정
    const element = document.getElementById('myElement');
    if (element) {
      const elementWidth = element.clientWidth;
      setWidth(elementWidth);
    }
  }, []); // 빈 의존성 배열은 이 효과가 초기 렌더 이후에 한 번만 실행되도록 함

  return (
    &lt;div&gt;
      &lt;p&gt;내 요소의 너비는: {width}px&lt;/p&gt;
      &lt;div id="myElement"&gt;이것은 내 요소입니다&lt;/div&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre></div></div>

<ul>
  <li>‘시그니처가 <code class="language-plaintext highlighter-rouge">useEffect</code>와 동일하나,’ : 두 훅의 형태나 사용 예제가 동일함</li>
  <li>‘모든 <code class="language-plaintext highlighter-rouge">DOM</code> 변경 후의 콜백 실행이 동기적으로 발생’ :<br /><code class="language-plaintext highlighter-rouge">(1)</code> 리액트가 <code class="language-plaintext highlighter-rouge">DOM</code>을 업데이트 → <code class="language-plaintext highlighter-rouge">(2)</code><code class="language-plaintext highlighter-rouge">useLayoutEffect</code> 실행 → <code class="language-plaintext highlighter-rouge">(3)</code><code class="language-plaintext highlighter-rouge">useEffect</code> 실행<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/db687861-6983-4eac-8615-a144ef0efb3c" width="90%" /></li>
  <li><code class="language-plaintext highlighter-rouge">DOM</code>은 계산되었지만, 이것이 화면에 반영되기 전에 하고 싶은 작업을 처리할 때 사용</li>
</ul>

<h3 id="사용자-정의-훅-custom-hook--서로-다른-컴포넌트-내부에서-같은-로직을-공유할-때-사용">사용자 정의 훅 (<code class="language-plaintext highlighter-rouge">Custom Hook</code>) : 서로 다른 컴포넌트 내부에서 같은 로직을 공유할 때 사용</h3>

<ul>
  <li>기존에 존재하는 훅을 기반으로 필요한 훅을 개발 (함수 이름이 반드시 <code class="language-plaintext highlighter-rouge">use</code>로 시작)
    <ul>
      <li>사용자 정의 훅의 동작, 매개변수, 반환값을 사전에  정의한 상태에서 구현하여 다른 컴포넌트에서 활용</li>
    </ul>
  </li>
</ul>

<h4 id="usefetch--http-요청을-fetch하여-데이터를-가져오는-작업을-추상화"><code class="language-plaintext highlighter-rouge">useFetch</code> : <code class="language-plaintext highlighter-rouge">HTTP</code> 요청을 <code class="language-plaintext highlighter-rouge">fetch</code>하여 데이터를 가져오는 작업을 추상화</h4>

<h4 id="usetimeout--일정-시간이-지난-후에-콜백-함수를-실행하는-작업을-추상화"><code class="language-plaintext highlighter-rouge">useTimeout</code> : 일정 시간이 지난 후에 콜백 함수를 실행하는 작업을 추상화</h4>

<h4 id="usetoggle--불리언-상태를-토글하는-작업을-추상화"><code class="language-plaintext highlighter-rouge">useToggle</code> : 불리언 상태를 토글하는 작업을 추상화</h4>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[함수 컴포넌트 (Functional Component) : 리액트 훅을 통한 상태와 생명주기 관리]]></summary></entry><entry><title type="html">[React] 2. 클래스 컴포넌트 (Class Component)</title><link href="http://localhost:4000/react2/" rel="alternate" type="text/html" title="[React] 2. 클래스 컴포넌트 (Class Component)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react2</id><content type="html" xml:base="http://localhost:4000/react2/"><![CDATA[<h2 id="클래스-컴포넌트-class-component--생성자와-생명주기-메소드를-통한-상태와-생명주기-관리">클래스 컴포넌트 (<code class="language-plaintext highlighter-rouge">Class Component</code>) : 생성자와 생명주기 메소드를 통한 상태와 생명주기 관리</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { Component } from 'react';

class MyClassComponent extends Component {
  constructor(props) {
    super(props);
    // 초기 상태 설정
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    // 컴포넌트가 마운트된 후 실행되는 코드
    console.log('Component mounted');
  }

  componentDidUpdate(prevProps, prevState) {
    // 상태 또는 속성이 업데이트된 후 실행되는 코드
    console.log('Component updated', prevState.count, '-&gt;', this.state.count);
  }

  componentWillUnmount() {
    // 컴포넌트가 언마운트되기 전 실행되는 코드
    console.log('Component will unmount');
  }

  handleIncrement = () =&gt; {
    // 상태 업데이트 예시
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={this.handleIncrement}&gt;Increment&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default MyClassComponent;
</code></pre></div></div>

<h3 id="생성자-constructor--메소드-내에서-컴포넌트-자체를-참조--this">생성자 (<code class="language-plaintext highlighter-rouge">Constructor</code>) : 메소드 내에서 컴포넌트 자체를 참조 → <code class="language-plaintext highlighter-rouge">this</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constructor(props) {
  super(props);
  console.log("constructor");
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this.state</code> : 컴포넌트의 상태를 저장 (<code class="language-plaintext highlighter-rouge">setState</code> 메소드를 사용하여 업데이트)</li>
  <li><code class="language-plaintext highlighter-rouge">this.props</code> : 컴포넌트에서 사용되는 속성에 접근</li>
</ul>

<h3 id="생명주기-메소드-lifecycle-methods--클래스-컴포넌트의-생명주기에-따라-메소드를-실행">생명주기 메소드 (<code class="language-plaintext highlighter-rouge">Lifecycle Methods</code>) : 클래스 컴포넌트의 생명주기에 따라 메소드를 실행</h3>

<blockquote>
  <p>클래스 컴포넌트의 생명주기 메소드가 실행되는 시점?</p>

  <ul>
    <li>마운트 (<code class="language-plaintext highlighter-rouge">Mount</code>) : 컴포넌트가 생성되는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Constructor</code>, <code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code>, <code class="language-plaintext highlighter-rouge">render</code>, <code class="language-plaintext highlighter-rouge">componentDidMount</code></li>
      </ul>
    </li>
    <li>업데이트 (<code class="language-plaintext highlighter-rouge">Update</code>) : 이미 생성된 컴포넌트의 내용이 변경되는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code>, <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code>, <code class="language-plaintext highlighter-rouge">render</code>, <code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code>, <code class="language-plaintext highlighter-rouge">componentDidUpdate</code></li>
      </ul>
    </li>
    <li>언마운트 (<code class="language-plaintext highlighter-rouge">Unmount</code>) : 컴포넌트가 더 이상 존재하지 않는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">componentWillUnmount</code></li>
      </ul>
    </li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/aec795ea-ff51-4f9d-ada3-ebca3616178f" width="80%" /></p>
</blockquote>

<h4 id="render"><code class="language-plaintext highlighter-rouge">render()</code></h4>

<ul>
  <li>컴포넌트가 <code class="language-plaintext highlighter-rouge">UI</code>를 렌더링하기 위해 사용 (마운트, 업데이트 과정에서 실행)</li>
  <li>리액트 클래스 컴포넌트의 유일한 필수 값으로 사용</li>
  <li>항상 순수해야 하며 부수 효과가 없어야 함 → <code class="language-plaintext highlighter-rouge">render</code> 내에서 <code class="language-plaintext highlighter-rouge">this.setState</code>를 호출하면 안됨</li>
</ul>

<h4 id="static-getderivedstatefrompropsprops-state"><code class="language-plaintext highlighter-rouge">static getDerivedStateFromProps(props, state)</code></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props</code>에 가져온 값을 상태에 넣을 때, 상태나 <code class="language-plaintext highlighter-rouge">props</code>이 변화했을 때 실행</li>
  <li>정적 (<code class="language-plaintext highlighter-rouge">static</code>) 메서드이므로 this에 접근할 수 없음</li>
  <li>상태를 업데이트하기 위해 객체를 반환하거나, 아무것도 업데이트하지 않을 경우 <code class="language-plaintext highlighter-rouge">null</code> 반환</li>
  <li><code class="language-plaintext highlighter-rouge">props</code>와 <code class="language-plaintext highlighter-rouge">state</code>를 동기화할 때 주로 사용</li>
</ul>

<h4 id="componentdidmount"><code class="language-plaintext highlighter-rouge">componentDidMount()</code></h4>

<ul>
  <li>클래스 컴포넌트가 마운트된 이후, 즉 트리에 삽입된 후에 실행</li>
  <li>데이터 가져오기, 구독 설정, DOM 조작 등의 부수 효과를 초기화할 때 적합</li>
  <li><code class="language-plaintext highlighter-rouge">API</code>를 호출하고, 가져온 데이터로 ```state``를 업데이트할 때 주로 사용</li>
</ul>

<h4 id="shouldcomponentupdatenextprops-nextstate"><code class="language-plaintext highlighter-rouge">shouldComponentUpdate(nextProps, nextState)</code></h4>

<ul>
  <li>클래스 컴포넌트가 리렌더링을 할지 안할지 결정</li>
  <li>불리언 값 반환 (기본값은 <code class="language-plaintext highlighter-rouge">true</code>)</li>
  <li>불필요한 렌더링을 방지하여 성능 최적화에 사용</li>
</ul>

<h4 id="getsnapshotbeforeupdateprevprops-prevstate"><code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate(prevProps, prevState)</code></h4>

<ul>
  <li>클래스 컴포넌트 엄데이트 직전의 <code class="language-plaintext highlighter-rouge">DOM</code> 내의 특정 값을 반환하면, 그 다음의 <code class="language-plaintext highlighter-rouge">componentDidUpdate</code> 반환</li>
  <li>컴포넌트가 업데이트되기 직전에 DOM에서 특정 값을 캡처</li>
  <li>값을 반환하거나 <code class="language-plaintext highlighter-rouge">null</code> 반환 → 반환된 값은 <code class="language-plaintext highlighter-rouge">componentDidUpdate</code>에 매개변수로 전달</li>
  <li>업데이트가 적용되기 전에 <code class="language-plaintext highlighter-rouge">DOM</code>의 이전 상태를 알아야 할 때 유용</li>
</ul>

<h4 id="componentdidupdateprevprops-prevstate-snapshot"><code class="language-plaintext highlighter-rouge">componentDidUpdate(prevProps, prevState, snapshot)</code></h4>

<ul>
  <li>컴포넌트 업데이트가 일어난 이후에 실행 (초기 렌더링에는 호출되지 않음)</li>
  <li>컴포넌트가 업데이트된 후에 DOM을 조작하는 데 사용될 수 있음</li>
  <li>이전 <code class="language-plaintext highlighter-rouge">props</code>, 이전 <code class="language-plaintext highlighter-rouge">state</code> 및 <code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code>에서 반환된 스냅샷을 매개변수로 받음</li>
  <li><code class="language-plaintext highlighter-rouge">props</code> 변경에 따라 네트워크 요청을 수행하거나, <code class="language-plaintext highlighter-rouge">state</code> 변경에 따라 <code class="language-plaintext highlighter-rouge">DOM</code>을 업데이트할 때 자주 사용</li>
</ul>

<h4 id="componentwillunmount"><code class="language-plaintext highlighter-rouge">componentWillUnmount()</code></h4>

<ul>
  <li>컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 실행</li>
  <li>타이머 무효화, 네트워크 요청 취소, 구독 해제 등의 정리 작업 수행에 적합</li>
  <li>메모리 누수를 방지하기 위해 컴포넌트가 더이상 필요하지 않은 리소스 정리</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[클래스 컴포넌트 (Class Component) : 생성자와 생명주기 메소드를 통한 상태와 생명주기 관리]]></summary></entry><entry><title type="html">[Engineer Information Processing] 5. 정보 시스템 구축 관리</title><link href="http://localhost:4000/engineer_information_processing5/" rel="alternate" type="text/html" title="[Engineer Information Processing] 5. 정보 시스템 구축 관리" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing5</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing5/"><![CDATA[<blockquote>
  <p>정보처리기사를 취득하기 위해 공부하는 과정에 작성한 ‘정보 시스템 구축 관리’ 관련 정리이다.</p>
</blockquote>

<h2 id="소프트웨어-개발-생명-주기">소프트웨어 개발 생명 주기</h2>

<h3 id="프로젝트-관리-도구">프로젝트 관리 도구</h3>

<ul>
  <li><b><code>CPM</code> (임계 경로법) : 프로젝트 완성에 필요한 작업을 나열해 작업 소요 기간 예측</b>
    <ul>
      <li>작업을 표시하는 노드와 전후 의존 관계를 표시하는 간선으로 구성</li>
      <li>프로젝트 중간 점검을 뜻하는 박스 노드에 예상 완료 시간 표시</li>
      <li>박스 노드 도달 이전 작업이 완료되야 다음 작업 진행</li>
    </ul>
  </li>
  <li><b>간트 차트 : 각 작업들의 일정을 막대로 표시하는 시간선 차트</b></li>
  <li><b><code>WBS</code> (작업 분해) : 프로젝트 작업을 계층적으로 분해 및 구조화</b></li>
</ul>

<h3 id="소프트웨어-개발-방법론">소프트웨어 개발 방법론</h3>

<ul>
  <li>소프트웨어 개발 방법론 : 소프트웨어 개발 생명주기에 소프트웨어 공학 원리를 적용
    <ul>
      <li><b>구조적 방법론 : 정형화된 분석 절차에 따라 구조적으로 사용자 요구 파악</b></li>
      <li><b>정보 공학 방법론 : 정보 시스템 개발의 관리 절차 체계화 (구조적 방법론의 거시적 관점 부재에 등장)</b></li>
      <li><b>컴포넌트 기반 개발 방법론 (<code>CBD</code>) : 재사용 가능한 컴포넌트를 조합해 어플리케이션을 개발</b>
        <ul>
          <li><b><code>CBD</code> 특징 : 점진적 개발, 컴포넌트 설계서 사용, 재사용 가능, 높은 확장성</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b>소프트웨어 재사용 : 소프트웨어의 전체 혹은 일부분을 다른 소프트웨어 개발 및 유지에 사용</b>
    <ul>
      <li>소프트웨어 재사용 접근 : <b>합성 중심 (블록 구성)</b>, 생성 중심 (템플릿·프레임워크 등 패턴 사용)</li>
    </ul>
  </li>
</ul>

<h3 id="비용-산정-모델">비용 산정 모델</h3>

<ul>
  <li><b>비용 산정 모델 : 프로젝트 특성 및 요구사항을 고려해 소프트웨어 개발 비용 산정</b>
    <ul>
      <li><b>델파이 기법 : 산정 요원 및 조정에 의해 단계별로 전문가들의 견해를 조정자가 조정해 최종 결정</b></li>
      <li><b><code>LOC</code> 기법 : 소프트웨어 각 기능 구현 시 작성될 원시 코드 라인 수로 예측치 추정</b></li>
      <li><b><code>COCOMO</code> 기법 : 소스 코드 규모에 따른 비용을 예측해 <code>Man-Month</code>로 나타냄</b>
        <ul>
          <li><b><code>COCOMO</code> 모형 종류 : <code>Basic COCOMO</code> (프로젝트 크기를 코드 라인 수로 측정), <code>Intermediate COCOMO</code> (개발자 경험 수준, 신뢰성 요구사항을 고려해 보정 계수 적용), <code>Detailed COCOMO</code> </b></li>
          <li><b><code>COCOMO</code> 개발 유형 : 단순형 (5만 라인 이하), 중간형 (30만 라인 이하), 임배디드형 (30만 라인 이상)</b></li>
        </ul>
      </li>
      <li><b><code>Putnam</code> 모델 : 소프트웨어 개발 생명 주기 내 노력 분포 예측 (크기, 생산성, 기술 요소)</b></li>
      <li><b>기능 점수 : 시스템 구현 기술에 의존적이고 개발자에 식별된 기능 기반해 시스템 크기 측정</b>
        <ul>
          <li><b>기능 점수 비용 산정 요소 : 코드 라인 수, 데이터 파일 수, 문서 수, 입력 유형 수, 보고서 수</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어-개발-표준">소프트웨어 개발 표준</h3>

<ul>
  <li><b><code>ISO/IEC 25000</code> : 소프트웨어 품질 평가 및 절차 모델</b>
    <ul>
      <li><code>ISO/IEC 9126</code>과 <code>ISO/IEC 14598</code> 통합</li>
      <li><code>2501n</code> : 품질 모형, <code>2503n</code> : 품질 측정</li>
    </ul>
  </li>
  <li><b><code>SPICE</code>, <code>ISO/IEC 15504</code> : 소프트웨어 프로세스 평가 및 개선</b>
    <ul>
      <li><code>ISO/IEC 12207</code> 개선</li>
      <li><code>SPICE</code> 모델 범주 : 고객-공급자 프로세스, 공학 프로세스, 지원 프로세스, 관리 프로세스, 조직 프로세스</li>
      <li><b><code>SPICE</code> 모델 레벨 : 레벨5, 최적 / 레벨4, 예측 / 레벨3, 확립 / 레벨2, 관리 / 레벨1, 수행 / 레벨0, 불완전</b></li>
    </ul>
  </li>
  <li><b><code>CMM</code> : 조직 업무 능력 평가 기준을 세우기 위한 능력 성숙도 모델</b>
    <ul>
      <li><b><code>CMM</code> 모델 레벨 : 레벨5, 최적 / 레벨4, 관리 / 레벨3, 정의 / 레벨2, 반복 / 레벨1, 초보</b></li>
    </ul>
  </li>
</ul>

<h3 id="테일러링과-프레임워크">테일러링과 프레임워크</h3>

<ul>
  <li><b>테일러링 : 기존 개발 방법론을 프로젝트 상황 (요구사항 및 조건)에 맞게 수정해 개발 프로세스 최적화</b>
    <ul>
      <li>테일러링 절차 : 프로젝트 특정 정의 → 표준 프로세스 선정·검증 → 상위 레벨 커스터마이징 → 세부 커스터마이징 → 문서화</li>
    </ul>
  </li>
  <li><b>소프트웨어 프레임워크 : 비슷한 유형의 응용 프로그램을 위해 아키턱처, 산출물의 통합된 집합</b></li>
  <li>라이브러리 : 단순 활용될 수 있는 도구들의 집합 (<b>차이점? : 프레임워크는 전체적인 흐름을 자체적으로 가짐</b>)</li>
  <li><b>소프트웨어 개발 프레임워크 : 소프트웨어 개발을 돕는 재사용 가능한 클래스·패턴의 집합</b>
    <ul>
      <li><b>소프트웨어 개발 프레임워크 장점 : 개발 용이, 시스템 복잡도의 감소, 이식성, 품질 보증, 운영 용이, 개발 코드 간소화, 변경 용이성, 설계 및 코드의 재사용성 증가</b></li>
    </ul>
  </li>
</ul>

<h2 id="신기술-용어">신기술 용어</h2>

<h3 id="네트워크-소프트웨어-하드웨어-관련-신기술">네트워크, 소프트웨어, 하드웨어 관련 신기술</h3>

<blockquote>
  <p>중복 출제된 내용만 정리</p>
</blockquote>

<ul>
  <li>프로토콜 관련
    <ul>
      <li><b><code>RIP</code> : 최단 경로 탐색, <code>Bellman-Ford</code>, 벡터 라우팅 프로토콜</b></li>
      <li><b><code>MQTT</code> : <code>IBM</code>, 대역폭 제한, <code>TCP/IP</code>, <code>IoT</code></b></li>
    </ul>
  </li>
  <li>모바일 관련
    <ul>
      <li><b><code>Mesh</code> : 무선 랜 한계, 대규모 디바이스 네트워크 생성 최적화, 차세대 이동 통신</b></li>
    </ul>
  </li>
  <li>하드웨어 관련
    <ul>
      <li><b>고가용성 솔루션 (<code>HACMP</code>) : 공유 디스크, 클러스터링</b></li>
      <li><b>직접 연결 저장 장치 (<code>DAS</code>) : 호스트 버스 어댑터, 네트워크 디바이스 없이 직접 연결 </b></li>
    </ul>
  </li>
</ul>

<h2 id="소프트웨어-개발-보안">소프트웨어 개발 보안</h2>

<h3 id="소프트웨어-개발-보안-개요">소프트웨어 개발 보안 개요</h3>

<ul>
  <li><b>시큐어 <code>OS</code> : 컴퓨터 운영체제에 보안 기능을 추가</b>
    <ul>
      <li><b>시큐어 <code>OS</code> 접근 통제 종류 : 강제적, 임의적, 역할 기반</b></li>
    </ul>
  </li>
  <li><b>스택 가드 : 메모리 상에 프로그램 복귀 주소와 변수 사이에 특정 값 (카나리)를 저장했다가, 그 값이 변경되면 오버플로우 상태로 가정해 프로그램 실행 중단</b></li>
</ul>

<h3 id="소프트웨어-개발-보안-구축-및-방법론">소프트웨어 개발 보안 구축 및 방법론</h3>

<ul>
  <li><b>정보 보안 3대 요소 : 기밀성 (인가 사용자만 접근), 무결성 (인가 방법으로만 수정), 기용성 (인가 사용자 업무 수행 유지)</b></li>
</ul>

<h3 id="시큐어-코딩-가이드">시큐어 코딩 가이드</h3>

<ul>
  <li><b>입력 데이터 검증 및 표현의 보안 약점 종류 : <code>SQL Injection</code>, 자원 삽입, 크로스 사이트 스크립트 (<code>XSS</code>)</b></li>
  <li><b>보안 기능의 보안 약점 종류 : 하드 코드된 비밀번호</b></li>
</ul>

<h3 id="암호화-알고리즘">암호화 알고리즘</h3>

<ul>
  <li><b>암호 알고리즘 : 평문을 암호문으로 (암호화), 암호문을 평문으로 (복호화) 바꿀 때 암호 키를 통해 사용되는 알고리즘</b></li>
  <li><b>공개 키 : 암호 키와 해독 키가 다름 (비대칭 키 암호화), 쉬운 키 분배, 느린 속도, 복잡한 알고리즘, <code>RSA</code></b></li>
  <li><b>비밀 키 : 암호 키와 해독 키가 같음 (대칭 키 암호화), 어려운 키 분배, 빠른 속도, 쉬운 알고리즘, <code>DES/AES</code></b></li>
  <li><b>해시 암호화 : 임의 길이의 메시지를 입력하면 고정 길이의 출력값으로 변환 (디지털 서명에 활용 → 데이터 무결성 제공)</b>
    <ul>
      <li>해시 3저항성 : 역상 저항성, 제2 역상 저항성, 충돌 저항성</li>
    </ul>
  </li>
</ul>

<h2 id="서버-인증과-접근-통제">서버 인증과 접근 통제</h2>

<h3 id="서버-인증-및-서버-통제-개요">서버 인증 및 서버 통제 개요</h3>

<ul>
  <li><b>사용자 인증 : 지식 기반 인증 (<code>ID/PW</code>), 소유 기반 인증 (토큰), 생체 기반 인증, 다중 인증</b></li>
  <li><b>접근 통제 : 시스템 자원 이용에 대한 불법적인 접근 방지</b>
    <ul>
      <li>접근 통제 요소 → <b><code>AAA</code> (인증 권한 검증 계정 관리)</b></li>
      <li><b>강제적 접근 통제 : 중앙에서 정보 수집 및 분류하여 보안 레벨 결정</b></li>
      <li><b>임의적 접근 통제 : 정보 소유자가 보안 레벨 및 접근 제어 설정</b></li>
      <li><b>역할 기반 접근 통제 : 사람이 아닌 직책에 대해 권한을 부여</b></li>
    </ul>
  </li>
  <li><b>벨 라파둘라 모델 (<code>BLP</code>) : 정보의 기밀성에 따라 상하 관계가 구분된 정보의 보호를 위해 자신의 권한보다 낮은 수분의 문서만을 읽을 수 있게 함 (다중 마스터 복제 방식 기반, 데이터 복제·분산 처리에 효과적)</b></li>
</ul>

<h3 id="보안-솔루션과-보안-아키텍처">보안 솔루션과 보안 아키텍처</h3>

<ul>
  <li><b><code>IDS</code> (침입 탐지 시스템) : 외부 침입 공격에 대해 탐지하는 네트워크 보안 시스템</b>
    <ul>
      <li><b>침입 탐지 기법 : 오용 탐지, 이상 탐지, </b></li>
    </ul>
  </li>
  <li><b><code>IPSec</code> (<code>IP Security</code>) : 통신 세션의 각 <code>IP</code> 패킷을 암호화하고 인증하는 인터넷 프로토콜</b></li>
  <li><b>가상 사설망 : 이용자가 공중망에 사설망을 구축해 전용망을 사용하는 듯한 효과를 가짐</b></li>
</ul>

<h2 id="공격-유형">공격 유형</h2>

<h3 id="서비스-공격-유형">서비스 공격 유형</h3>

<ul>
  <li><b>스머프 공격 : 공격 대상 주소에 근원지로 대량의 <code>ICMP</code> 응답 패킷을 전송해 서비스 거부 유발</b></li>
  <li><b><code>Ping of Death</code> : 비정상적인 <code>ICMP</code> 패킷으로 시스템 성능 저하</b></li>
  <li><b><code>Ping</code> 플러딩 : <code>Ping</code> 테스트로 공격자가 공격 대상 컴퓨터 확인</b></li>
  <li><b><code>DDos</code> : 여러 대의 공격자를 분산 배치 및 동시에 서비스 거부 공격</b></li>
  <li><b><code>TCP</code> 세션 하이재킹 : 서버와 클라이언트가 <code>TCP</code>로 통신할 때, <code>RST</code> 패킷을 보내 세션을 끊고 세션을 탈취</b></li>
  <li><b>피싱 : 가짜 웹사이트로 개인 정보를 탈취</b></li>
  <li><b>랜섬웨어 : 시스템을 잠그거나 데이터를 암호화해 이를 인질로 금전 요구</b></li>
  <li><b>키 로거 : 키보드 움직임을 탐지해 개인정보 탈취</b></li>
  <li><b><code>APT</code> (지능적 지속 위협) : 다양한 보안 위협을 만드렁 정보 유츌</b></li>
  <li><b>백도어 : 프로그램이나 손상된 시스템에 허가되지 않은 접근을 가능하게 정상적인 보안 절차를 우회</b>
    <ul>
      <li><b><code>Tripwire</code> : 크래커가 백도어를 만들거나, 설정 파일을 변경했을 때 분석하는 도구</b></li>
    </ul>
  </li>
  <li><b><code>Switch Jamming</code>  스위치 허브의 기능을 방해해 스위치를 더미 허브처럼 작동시킴</b></li>
</ul>

<h3 id="공격-탐지-및-방지">공격 탐지 및 방지</h3>

<ul>
  <li><b><code>Honeypot</code> : 침입자를 속여 실제 공격당하는 것처럼 보여주어 크래커 추적 및 공격 기법 정보 수집</b></li>
  <li><b><code>DPI</code> : 전 계층 프로토콜과 패킷 내부 컨텐츠를 파악하는 패킷 분석 기술</b></li>
  <li><b><code>HSM</code> : 암호화 키를 생성 및 저장하는 전용 하드웨어 장치</b></li>
  <li><b><code>TCP Wrapper</code> : 외부 컴퓨터가 접속되면 접속 인가 여불를 점검해 접속 허용</b></li>
  <li><b><code>HSM</code> : 네트워크를 제어부, 데이터 전달부로 분리해 네트워크를 제어 및 관리</b></li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[정보처리기사를 취득하기 위해 공부하는 과정에 작성한 ‘정보 시스템 구축 관리’ 관련 정리이다.]]></summary></entry><entry><title type="html">[Engineer Information Processing] 3. 데이터베이스 구축</title><link href="http://localhost:4000/engineer_information_processing3/" rel="alternate" type="text/html" title="[Engineer Information Processing] 3. 데이터베이스 구축" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing3</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing3/"><![CDATA[<blockquote>
  <p>정보처리기사를 취득하기 위해 공부하는 과정에 작성한 ‘데이터베이스 구축’ 관련 정리이다.</p>
</blockquote>

<h2 id="데이터베이스의-개념">데이터베이스의 개념</h2>

<h3 id="데이터베이스--dbms">데이터베이스 : <code>DBMS</code></h3>

<ul>
  <li>지료 : 단순한 데이터, 정보 : 의미 있는 데이터, 지식 : 가공되어 의미 있는 데이터</li>
  <li>정보 시스템 : 조직체의 데이터를 바탕으로 정보를 추출 및 생성하는 시스템
    <ul>
      <li>정보 시스템 종류 : 일괄 처리 시스템, 온라인 실시간 처리 시스템, 분산 처리 시스템</li>
    </ul>
  </li>
  <li><code>DB</code>정의 : <b>통합 데이터</b>, 저장 데이터, 운영 데이터, 공용 데이터</li>
  <li><code>DB</code> 특성 : 실시간 접근성, 내용에 의한 참조, 동시 공유, 계속적 변화</li>
  <li><code>DB</code> 시스템 구성 : <code>DB</code>, <code>DBMS</code>, <code>DB</code> 관리자, <code>DB</code> 언어</li>
</ul>

<h3 id="데이터-관리--빅데이터-관리">데이터 관리 / 빅데이터 관리</h3>

<ul>
  <li><b>데이터 마이닝 : 데이터 웨어하우징에서 수집·분석된 자료를 사용자에 제공하기 위해 분류·가공하는 요소 기술</b>
    <ul>
      <li>분류 : 데이터를 여러 그룹으로 분류</li>
      <li>연관 규칙 분석 : 특정 규칙 탐색</li>
      <li>연속 : 순서 정보를 갖는 데이터에서 순서 관련 패턴 탐색</li>
      <li>군집화 : 데이터를 비슷한 특성의 그룹으로 나눔</li>
      <li>예측 : 과거 데이터를 분석해 미래 예측</li>
      <li>이상 탐지 : 데이터에섯 비정상적인 패턴 탐색</li>
      <li>회귀 분석 : 데이터 간의 관계를 분석</li>
      <li>차원 축소 : 데이터 차원을 줄여서 분석</li>
    </ul>
  </li>
  <li><b>하둡 : 빅데이터 세트를 병렬로 처리하기 위한 데이터 분산 처리를 돕는 자바 기반 소프트웨어 오픈소스 프레임워크</b>
    <ul>
      <li>맴리듀스 : 대용량 데이터를 분산 처리하기 위한 프로그래밍 모델 (<code>Map</code>, <code>Reduce</code> 함수로 구성)</li>
      <li><code>Sqoop</code> : <code>RDBMS</code>과 하둡 간의 데이터 전송을 지원하는 도구</li>
    </ul>
  </li>
</ul>

<h3 id="데이터베이스-스키마와-언어">데이터베이스 스키마와 언어</h3>

<ul>
  <li>스키마 : 데이터베이스 구조 (개체, 속성, 관계) 정의 (데이터베이스의 논리적 구조를 기술해 데이터 일관성·무결성 보장)
    <ul>
      <li>외부 스키마 : 데이터베이스 사용자, 응용 프로그램의 관점에서 데이터베이스 정의</li>
      <li><b>개념 스키마 : 데이터베이스 전체를 정의한 것으로, 데이터 개체·관계·제약 조건·접근 권한·무결성 규칙을 명세</b></li>
      <li><b>내부 스키마 : 내부 물리적 저장 구조를 정의해 데이터의 실제 저장 방법을 기술</b></li>
    </ul>
  </li>
  <li>스키마 간 독립성 : 논리적 독립성, 물리적 독립성</li>
  <li>데이터베이스 언어 : 데이터베이스 내에서 활용되는 언어
    <ul>
      <li><b><code>SQL</code> : 관계형 데이터베이스의 표준 질의어</b></li>
    </ul>
  </li>
</ul>

<h2 id="데이터베이스-설계와-관계형-모델">데이터베이스 설계와 관계형 모델</h2>

<h3 id="데이터베이스-설계">데이터베이스 설계</h3>

<ul>
  <li>데이터베이스 설계 단계 : 요구사항 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0afa4247-f3c7-4848-b2c0-09820caddc61" width="80%" />
    <ul>
      <li><b>개념적 설계 : 목표 <code>DBMS</code>에 독립적인 개념 스키마 설계 (기념 스키마 모델링, 트랜잭션 모델링)</b></li>
      <li><b>논리적 설계 : 목표 <code>DBMS</code>에 종속적인 논리 스키마 설계 (스키마 평가 및 정제, 트랜잭션 인터페이스 설계)</b></li>
      <li><b>물리적 설계 : 목표 <code>DBMS</code>에 종속적인 물리적 구조 설계 (저장 레코드 양식 설계, 레코드 클러스터링)</b>
        <ul>
          <li><b>물리적 설계 고려사항 : 인덱스 구조, 레코드 크기·개수, 트랜잭션 갱신·참조 성향, 개념 스키마 변경 여부</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="데이터-모델--관계형-데이터베이스-모델">데이터 모델 / 관계형 데이터베이스 모델</h3>

<ul>
  <li>데이터 모델 : 데이터베이스 설계 과정에서 데이터 구조를 표현하기 위해 사용되는 도구
    <ul>
      <li>데이텉 모델 구성 요소 : 데이터 구조, 연산, 제약 조건</li>
    </ul>
  </li>
  <li>개념 데이터 모델 : 속성들로 기술된 개체 타입과 개체 타입 간의 관계를 이용해 현실 세계를 표현
    <ul>
      <li><b>개체-관계 모델 (<code>E-R</code> 모델): 개체 타입과 이들 간 관계 타입을 이용해 개념적 표현<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d4eb5c97-8ac9-4e94-ac67-49d51725340f" width="80%" /></b></li>
      <li>논리 데이터 모델 : 엔티티와 속성들의 관계를 구조적으로 정의
        <ul>
          <li><b>논리 데이터 모델 종류 : 계층적 데이터 모델, 네트워크형 데이터 모델, 관계형 데이터 모델</b>
            <ul>
              <li>논리 데이터 모델 구성 요소 : 개체, 속성, 관계</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>관계형 데이터베이스 모델 : 관계형 데이터베이스를 구성하는 개체나 관계를 릴레이션으로 표현
    <ul>
      <li>릴레이션 스키마 : 개념 모델에 도출된 개체를 컴퓨터로 처리 가능한 단위로 매핑한 모델<b>(릴레이션 이름과 속성의 집합)</b></li>
      <li>릴레이션 인스턴스 : 릴레이션 스키마에 따라 저장된 튜플 (테이블의 각 행)</li>
      <li>릴레이션 속성 : 순서가 없는 데이터베이스의 가장 작은 논리적 단위로서의 릴레이션의 열</li>
      <li><b>디그리 : 릴레이션이 가지는 속성의 개수 (디그리 값이 클수록 복잡한 구조 → 정규화 필요)</b></li>
      <li><b>도메인 : 하나의 속성이 가질 수 있는 원자값들의 집합 (데이터 무결성·일관성 유지에 활용)</b></li>
      <li><b>튜플 : 순서가 없는 릴레이션의 행 (카디널리티 : 튜픙의 수)</b></li>
    </ul>
  </li>
  <li><b>릴레이션의 특징 : 튜플의 유일성, 튜플의 무순서성, 속성의 원자성, 속성의 무순서성</b></li>
  <li><b><code>CRUD</code> 매트릭스 : 데이터베이스에 영향 주는 <code>CRUD</code> 연산으로 프로세스·테이블 간 메트릭스를 만들어 트랜잭션 분석</b></li>
</ul>

<h3 id="키와-무결성">키와 무결성</h3>

<ul>
  <li><b>슈퍼 키 : 튜플을 고유하게 식별하는 하나 이상의 속성 집합 (유일성<code>O</code>, 최소성<code>X</code>)</b></li>
  <li><b>후보 키 : 튜플을 고유하게 식별하는 하나 이상의 속성 집합 (유일성<code>O</code>, 최소성<code>O</code>)</b></li>
  <li><b>기본 키 : 후보 키 중 대표인 키 (<code>Null</code><code>X</code>, 중복<code>X</code>, 유일성<code>O</code>, 최소성<code>O</code>)</b></li>
  <li><b>대체 키 : 후보 키 중 기본 키 외의 나머지 키</b></li>
  <li><b>외래 키 : 릴레이션 간 연결을 위해 다른 테이블의 기본 키로 사용되는 키</b></li>
  <li><b>무결성 : 데이터에 적용되는 연산에 제한을 두어 데이터의 정확성·일관성·유효성 유지</b>
    <ul>
      <li>개체 무결성 : 기본 키는 <code>Null</code><code>X</code>, 중복<code>X</code></li>
      <li>참조 무결성 : 외래 키를 변경하려면, 외래 키가 참조하는 대상의 기본 키도 변경해야 함</li>
      <li>도메인 무결성 : 각 속성은 해당 속성 도메인에 지정된 값이어야 함</li>
    </ul>
  </li>
</ul>

<h2 id="데이터베이스-정규화">데이터베이스 정규화</h2>

<h3 id="이상-현상과-함수적-종속">이상 현상과 함수적 종속</h3>

<ul>
  <li><b>이상 현상 : 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 현상</b>
    <ul>
      <li>삽입 이상 : 데이터를 삽입할 때 불필요한 데이터가 함께 삽입되는 현상</li>
      <li>삭제 이상 : 릴레이션의 한 튜플을 삭제할 때 연쇄적으로 삭제되는 현상</li>
      <li>갱신 이상 : 튜플 중에 일부 속성을 갱신해 정보의 모순성이 발생하는 현상</li>
    </ul>
  </li>
  <li>함수적 종속 : 개체 내에 존재하는 속성 간의 관계를 종속적인 관계로 정리하는 방법
    <ul>
      <li><b>부분적 함수 종속 : 혼한 속상 기본키 <code>{A, B}</code>에 대해 <code>A → C</code>가 성립</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/72649301-5d4f-4bf0-97bc-788761c7d3ef" width="70%" /></li>
      <li><b>이행 함수적 종속 : 속성 <code>X, Y, Z</code>가 주어졌을 때, <code>X → Y</code>, <code>Y → Z</code>하면 <code>X → Z</code></b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4105e4d9-df0e-46fc-af34-e8b77a2f2952" width="70%" /></li>
    </ul>
  </li>
</ul>

<h3 id="데이터베이스-정규화--반정규화">데이터베이스 정규화 / 반정규화</h3>

<ul>
  <li><b>정규화 : 논리적 설계 단계에서 발생할 수 있는 종속으로 인한 이상 현상의 문제를 해결하기 위해 여러 테이블로 분해</b>
    <ul>
      <li><b>정규화 목적 : 데이터 구조 안정성 확보, 중복 데이터·수정 및 삭제 시 이상·테이블 불일치 최소화</b></li>
      <li><b>정규화 과정 : 비정규 릴레이션 → <code>1NF</code> → <code>2NF</code> → <code>3NF</code> → <code>BCNF</code> → <code>4NF</code> → <code>5NF</code></b></li>
    </ul>
  </li>
  <li><b>1정규형 : 어떤 테이블에 속한 모든 도메인이 원자값만으로 되어 있는 테이블</b></li>
  <li><b>2정규형 : 1정규형을 만족하면서, 테이블의 부분 함수적 종속을 제거해 완전 함수적 종속이 되도록 분해된 테이블</b></li>
  <li><b>3정규형 : 1,2정규형을 만족하면서, 속성 간 이행 함수 종속을 만족하는 테이블</b></li>
  <li><b><code>BCNF</code>정규형 : 1,2,3정규형을 만족하면서, 결정자가 후보키가 아닌 함수 종속이 제거된 테이블</b></li>
  <li><b>4정규형 : 1,2,3정규형을 만족하면서, 다치 종속이 제거된 테이블</b></li>
  <li><b>5정규형 : 1,2,3,4정규형을 만족하면서, 조인 종속이 제거된 테이블</b></li>
  <li><b>반정규화 : 정규화된 결과를 시스템 성능 향상 및 개발·운영 단순화를 위해 중복·통합·분리를 수행</b>
    <ul>
      <li>반정규화 기법 : 테이블 반정규화 (테이블 병합, 테이블 분할, <b>테이블 추가</b>), 컬럼 반정규화, 관계 반정규화</li>
      <li><b>파티셔닝 : 데이터베이스의 테이블을 분할하는 것</b>
        <ul>
          <li><b>파티셔닝 키 기준 유형 : 범위 분할, 목록 분할, 해시 분할, 합성 분할, 라운드로빈 분할</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="sql"><code class="language-plaintext highlighter-rouge">SQL</code></h2>

<h3 id="관계-대수와-연산자">관계 대수와 연산자</h3>

<ul>
  <li><b>관계 대수 : 원하는 정보 및 정보를 어떻게 유도하는지 기술하는 절차적 방법 (일반 집합 연산, 순수 관계 연산)</b></li>
  <li><b>관계 해석 : 원하는 정보가 무엇이라는 것만 정의하는 비절차적인 방법 (도메인 관계 해석, 튜플 관계 해석)</b>
    <ul>
      <li>관계 해석 자유 변수 : 전칭 정량자 <code>∀</code> (<code>For All</code>), 존재 정량자 <code>∃</code>(<code>For Some</code>)</li>
    </ul>
  </li>
  <li><b>순수 관계 연산자 : <code>Select</code> (튜플 집합 검색), <code>Project</code> (속성 집합 추출), <code>Join</code> (두 릴레이션 공통 속성 결합), <code>Division</code> (두 릴레이션에서 특정 속성를 제외한 속성으로 나눔)</b></li>
  <li>집합 산자 : <b>합집합 (<code>Union</code>), 교집합 (<code>Intersection</code>), 차집합 (<code>Difference</code>), 교차곱 (<code>Cartesian Product</code>)</b></li>
</ul>

<h3 id="뷰-시스템-카탈로그">뷰, 시스템 카탈로그</h3>

<ul>
  <li>뷰 : 사용자에 접근 허용된 자료만을 제한적으로 보여주기 위해 기본 테이블에서 유도되는 가상 테이블
    <ul>
      <li><b>뷰 생성 시 <code>CREATE</code>, 검색 시 <code>SELECT</code> 사용</b></li>
      <li><b>뷰 정의 변경 시 <code>ALTER</code> 대신 <code>DROP</code> 사용</b></li>
      <li><b>뷰를 이용한 또다른 뷰의 생성이 가능 (하나의 뷰 제거 시 기반한 뷰들도 함꼐 삭제)</b></li>
      <li><b>뷰에 대한 조작에서 삽입·갱신·삭제는 제약</b></li>
      <li><b>뷰가 정의된 기본 테이블이 제거되면 뷰도 자동 제거</b></li>
    </ul>
  </li>
  <li><b>시스템 카탈로그 (데이터 사전) : 시스템 자신이 필요하는 여러 객체들에 대한 정보를 가진 시스템 데이터베이스</b>
    <ul>
      <li>메타 데이터 : 시스템 카탈로그에 저장되는 내용</li>
      <li>시스템 카탈로그 기능 : 테이블·뷰·인덱스·사용자 계정 정보 조회</li>
    </ul>
  </li>
  <li><b>인덱스 : 원하는 자료를 검색하기 위해, 인덱스 파일 및 인덱스 파일 (키, 주소)로 구성된, 독립적인 저장 공간</b></li>
</ul>

<h3 id="ddl"><code class="language-plaintext highlighter-rouge">DDL</code></h3>

<ul>
  <li><b>데이터 정의어 (<code>DDL</code>) : 스키마 정의·변경·삭제 (논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의)</b>
    <ul>
      <li><b><code>CREATE</code> : 스키마·도메인·테이블·뷰 정의</b>
        <ul>
          <li><b><code>CREATE TABLE</code> : 테이블 생성 </b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/11c90a08-572b-4ef0-ac4d-6752f5702308" width="80%" /></li>
        </ul>
      </li>
      <li><b><code>ALTER</code> : 테이블 정의 변경 (필드 추가·삭제·갱신)</b>
        <ul>
          <li><b><code>ALTER TABLE</code> : 테이블 구조 변경</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4b8fde9c-c9da-4232-bc19-79c19a66af46" width="80%" /></li>
        </ul>
      </li>
      <li><b><code>DROP</code> : 스키마·도메인·테이블·뷰 삭제</b></li>
    </ul>
  </li>
</ul>

<h3 id="dcl"><code class="language-plaintext highlighter-rouge">DCL</code></h3>

<ul>
  <li><b>데이터 제어어 (<code>DCL</code>) : 데이터 무결성·제어</b>
    <ul>
      <li><b><code>COMMIT</code></b> : 명령어로 수행된 실제 물리적 디스크에 저장한 뒤에 결과 반환</li>
      <li><b><code>ROLLBACK</code> : 명령어로 수행에 실패했음을 알리고, 수행된 결과를 원상 복귀</b></li>
      <li><b><code>GRANT</code> : 관리자가 사용자에 데이터베이스에 대한 권한을 부여</b></li>
      <li><b><code>REVOKE</code> : 관리자가 사용자에 데이터베이스에 대한 권한을 취소</b></li>
    </ul>
  </li>
</ul>

<h3 id="dml"><code class="language-plaintext highlighter-rouge">DML</code></h3>

<ul>
  <li><b>데이터 조작어 (<code>DML</code>) : 데이터 검색·삽입·삭제·변경</b>
    <ul>
      <li><b><code>SELECT</code> : 튜플 검색</b>
        <ul>
          <li><b><code>BETWEEN ~ AND ~</code> : 튜플 검색 시 구간 값 조건식</b></li>
          <li><b>그룹 함수 (<code>GROUP BY~</code>) : <code>COUNT</code> (행의 수), <code>SUM</code> (하나 이상의 열 합게),<br /><code>AVG</code> (하나 이상의 열 평균), <code>MAX</code> (열의 최댓값), <code>MIN</code> (열의 최솟값)&lt;/br&gt;
</b>            <ul>
              <li><b><code>HAVING</code> : 튜플 검색 시 그룹 함수와 결합해 탐색 조건을 지정하는 조건식</b></li>
            </ul>
          </li>
          <li><b><code>ORDER BY~</code> : 특정 항목 기준으로 검색 테이블의 행들을 오름차순·내림차순으로 정렬</b></li>
          <li>하위 질의 = 서브 퀴리 : 하위 질의를 1차 수행한 다음, 반환값을 상위 릴레이션의 <code>WHERE</code>에서 사용</li>
        </ul>
      </li>
      <li><b><code>INSERT</code> : 튜플 삽입</b></li>
      <li><b><code>UPDATE</code> : 튜플 내용 변경</b></li>
      <li><b><code>DELETE</code> : 튜플 삭제</b></li>
    </ul>
  </li>
</ul>

<h3 id="nosql-절차형-sql"><code class="language-plaintext highlighter-rouge">NoSQL</code>, 절차형 <code class="language-plaintext highlighter-rouge">SQL</code></h3>

<ul>
  <li><b><code>NoSQL</code> : 스키마가 고정되지 않은 비관계형 데이터 모델로 데이터를 저장·검색하는 데이터베이스</b></li>
  <li>절차형 <code>SQL</code> : <code>SQL</code>의 연속 실행, 조건에 따른 반복, 분기 등의 제어 가능
    <ul>
      <li>저장 프로시저 : 사용자가 자주 사용하는 명령문을 작성해 데이터베이스에 저장한 <code>PL/SQL</code> 명령문
        <ul>
          <li><b>트리거 : 데이터베이스에 특정 사건이 발생할 때마다 자동으로 수행되는 저장 프로시저</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="데이터베이스-병행-제어와-보안">데이터베이스 병행 제어와 보안</h2>

<h3 id="트랜잭션">트랜잭션</h3>

<ul>
  <li><b>트랜잭션 : 하나의 논리적 기능을 수행하기 위한 작업 단위</b>
    <ul>
      <li><b>트랜잭션의 특징 : 원자성 (완전 수행 안되면 수행 <code>X</code>), 일관성 (트랜잭션 실행 전후 상태가 일관성 유지)<br />고립성 (트랜잭션 실행 시 다른 트랜잭션에 독립적), 영속성 (트랜잭션 결과가 데이터베이스에 저장)</b></li>
      <li><b>트랜잭션 상태 : 활동, 부분 완료 (실행 마치고 저장 직전), 완료, 실패, 철회</b></li>
      <li><b>리커버리 연산 : 트랜잭션 수행 중에 장애로 손상된 데이터베이스를 정상 상태로 복구 (<code>Redo</code>, <code>Undo</code>)</b></li>
      <li><b>즉각 갱신 : 데이터를 갱신하면 트랜잭션 완료 전에 실제 데이터베이스에 반영</b></li>
    </ul>
  </li>
</ul>

<h3 id="병행-제어-회복">병행 제어, 회복</h3>

<ul>
  <li><b>병행 제어 : 동시에 수행되는 트랜잭션을 일관성 있게 처리하기 위해 제어</b>
    <ul>
      <li><b>병행 제어 목적 : 데이터베이스 공유·일관성·시스템 활용도 최대화, 사용자 응답 시간 최소화</b></li>
      <li><b>병행 제어 종류 : 로킹, 타임스탬프, 최적 병행 수행, 다중 버전 기법</b></li>
    </ul>
  </li>
  <li><b>로킹 : 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스 불가하게 함</b>
    <ul>
      <li><b>2단계 로킹 : 트랜잭션의 로크·해제 요청을 2단계로 실시 (직렬성은 보장하지만, 교착상태 예방은 불가능)</b>
        <ul>
          <li>2단계 로킹 단계 : 확장 단계 (트랜잭션 시작 시 모든 잠금 확보), 축소 단계 (트랜잭션 완료 시 잠금 해제)</li>
          <li>2단계 로킹 잠금 상태 : 공유 잠금 (타 트랜잭션 읽기 가능), 배타적 잠금 (타 트랜잭션 읽기 불가능)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>타임스탬프 : 시간 허가 인증 도장을 부여받아 트랜잭션 간 순서를 미리 정함</li>
  <li>회복 : 데이터 손실 및 손상이 발생했을 때 이를 복구
    <ul>
      <li><b>회복 기법 종류 : 즉시 갱신, 지연 갱신, <code>Redo</code>, <code>Undo</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="데이터베이스-보안과-권한-설정">데이터베이스 보안과 권한 설정</h3>

<ul>
  <li><b>암호화 : 네트워를 통하거나 컴퓨터 내부에 자료를 저장할 때 권한을 가진 사람 외엔 데이터를 보지 못하도록 함</b>
    <ul>
      <li><b>암호화 기법 : 비밀 키 (대칭 키), 공개 키 (비대칭 키)</b></li>
    </ul>
  </li>
  <li><b>데이터베이스 보안 적용 주의사항 : 접근 제어, 데이터 암호화, 취약점 관리, 백업과 복원, 감시와 모니터링</b></li>
</ul>

<h3 id="분산-데이터베이스">분산 데이터베이스</h3>

<ul>
  <li>분산 데이터베이스 : 네트워크를 통해 연결된 여러 컴퓨터에 데이터가 분산된 데이터베이스 → 분산 데이터베이스 투명성
    <ul>
      <li><b>위치 투명성 : 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요가 없다.</b></li>
      <li><b>중복 투명성 : 사용자에 통지할 필요 없이 시스템 안에 자원들의 부가적인 복사를 자유롭게 할 수 있다.</b></li>
      <li><b>병행 투명성 : 다중 사용자들이 자원을 자동으로 공유할 수 있다.</b></li>
      <li><b>장애 투명성 : 사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없다.</b></li>
    </ul>
  </li>
  <li>분산 데이터베이스 구성 요소 : 분산 처리기, 분산 데이터베이스, 틍신 네트워크</li>
  <li>분산 데이터베이스 연결 모델 : 클라이언트·서버 모델, <code>Peer-to-Peer</code> 모델, 클러스터 모델</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[정보처리기사를 취득하기 위해 공부하는 과정에 작성한 ‘데이터베이스 구축’ 관련 정리이다.]]></summary></entry><entry><title type="html">[Engineer Information Processing] 2. 소프트웨어 개발</title><link href="http://localhost:4000/engineer_information_processing2/" rel="alternate" type="text/html" title="[Engineer Information Processing] 2. 소프트웨어 개발" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing2</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing2/"><![CDATA[<blockquote>
  <p>정보처리기사를 취득하기 위해 공부하는 과정에 작성한 ‘소프트웨어 개발’ 관련 정리이다.</p>
</blockquote>

<h2 id="통합-구현">통합 구현</h2>

<h3 id="통합-구현-1">통합 구현</h3>

<ul>
  <li>단위 모듈 : 소프트웨어 구현에 필요한 다양한 동작 중에 하나의 동작을 수행하는 기능을 모듈료 구현
    <ul>
      <li>단위 기능 명세서 : 큰 규모의 시스템을 분해아여 단위 기능별로 계층적 구조화·단순화하여 추상화한 문서</li>
    </ul>
  </li>
  <li><b>모듈화 : 소프트웨어 개발에 있어 기능을 나누고 추상화하여, 소프트웨어 성능을 향상 및 효과적인 유지보수 구현</b>
    <ul>
      <li>분할 정복법 : 복잡한 문제를 분해하여, 모듈 단위로 문제 해결</li>
      <li>정보 은닉 : 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐</li>
      <li>자료 추상화 : 함수 내에 자료 구조의 표현 명세를 은폐하고, 자료 및 오퍼레이션을 함께 정의</li>
      <li>모듈 독립성 : 낮은 결합도, 높은 응집도를 갖도록 함</li>
      <li>단위 모듈 테스트 : 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증
        <ul>
          <li>단위 모듈 테스트 기법 : 화이트박스 테스트, 블랙박스 테스트</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b>구현 단계의 작업 절차 : 코딩 계획 → 코딩 → 컴파일 → 코드 테스트</b></li>
  <li><b><code>IDE</code> : 소프트웨어 개발 단계에서 필요한 도구들을 하나의 인터페이스로 통합 제공</b>
    <ul>
      <li><code>IDE</code> 종류 : 이클립스, 비주얼 스튜디오, <code>Xcode</code>, 안드로이드 스튜디오, <code>IntelliJ</code>, <code>PyCharm</code></li>
      <li><b><code>IDE</code> 구성 요소 : 소스 코드 편집기, 컴파일러, 디버거</b></li>
      <li><b><code>IDB</code> 기능 : 개발 환경 지원, 컴파일, 디버깅, 외부 연계, <code>DB</code> 연동, 배포</b></li>
    </ul>
  </li>
  <li><b>빌드 자동화 도구 : 소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만듬 (<code>Gradle</code>)</b>
    <ul>
      <li>빌드 자동화 도구 기능 : 컴파일, 컴포넌트 패키징, 파일 조작, 버전 관리 도구 통합, 문서 생성, 테스트, 품질 분석, 배포</li>
      <li>빌드 자동화 도구 프로세스 : 컴파일 → 패키징 → 단위 테스트 → 정적 분석 → 리포팅 → 배포 → 최종 빌드</li>
      <li><b><code>Ant</code>, <code>Maven</code>, <code>Gradle</code>, <code>Jenkins</code>, <code>Makefile</code>, <code>Travis CI</code>, <code>TeamCity</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="형상-관리">형상 관리</h3>

<ul>
  <li><b>형상 관리 : 개발 단계에 생성되는 모든 문서·코드 등 소프트웨어 변경 사항을 체계젹으로 관리하기 위해 추적·통제</b>
    <ul>
      <li><b>형상 관리 항목 : 프로젝트 요구 분석서, 운영·설치 지침, 요구사항 명세서, 설계·인터페이스 명세서, 테스트 설계서, 소프트웨어 품질보증, 형상관리 계획서, 코드 모듈, 소스·테스트 코드</b></li>
      <li><b>형상 관리 도구 : 소프트웨어 개발 생명주기 전반에 걸쳐 산출물의 종합 및 변경 과정을 체계적으로 관리</b></li>
      <li><b>형상 관리 절차 : 형상 식별 → 형상 식별자 선정 → 형상 통제 → 형상 기록·보고 → 형상 검사</b></li>
    </ul>
  </li>
</ul>

<h3 id="버전-관리">버전 관리</h3>

<ul>
  <li>버전 관리 : 요구사항 변화에 따른 다양한 형상 항목에 버전을 부여해 이력을 관리
    <ul>
      <li>변경 관리 : 변경된 요구사항에 대해, 비용·기간을 고려해 타당성 평가 (변경 관리 ⊂ 버전 관리 ⊂ 형상 관리)</li>
      <li>버전 관리 도구 구분 : 공유 폴더 방식, 클라이언트·서버 방식, <b>분산 저장소 방식</b></li>
      <li><b>버전 관리 도구 종류 : <code>CVS</code>, <code>RCS</code>, <code>SVN</code>, <code>BitKeeper</code>, <code>Git</code>, <code>Clear Case</code></b></li>
    </ul>
  </li>
</ul>

<h2 id="시스템-인터페이스-구현">시스템 인터페이스 구현</h2>

<h3 id="모듈-연계">모듈 연계</h3>

<ul>
  <li>모듈 연계 : 시스템 인터페이스를 목적으로 내부-외부 혹은 내부-내부 모듈 간 인터페이스를 설정하는 것
    <ul>
      <li><b><code>EAI</code> : 기업 내부에서 운영되는 각종 플랫폼 및 어플리케이션 간의 정보 전달·연계·통합 솔루션</b>
        <ul>
          <li><b><code>Point-to-Point</code> : 어플리케이션을 미들웨어 없이 점 대 점을 연결하는 방식</b></li>
        </ul>
      </li>
      <li><b><code>Hun &amp; Spoke</code> : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식</b></li>
      <li><b><code>Message Bus</code> : 어플리케이션 간에 미들웨어를 배치해 처리하는 방식</b></li>
      <li><b><code>Hybrid</code> : <code>Hun &amp; Spoke</code>와 <code>Message Bus</code>를 혼합</b></li>
      <li><code>EAI</code> 구성 요소 : <code>EAI</code> 플랫폼, 어댑터, 브로커, 메시지 큐, 비즈니스 워크플로우</li>
    </ul>
  </li>
  <li><code>ESB</code> : 어플리케이션 간의 데이터 변환 및 연계 지원을 제공하는 인터페이스 제공 솔루션</li>
  <li><code>Web Service</code> : 네트워크 정보를 표준화된 서비스의 형태로 만들어 공유하는 기술 (<code>SOA</code> 실천)</li>
  <li><code>IPC</code> : <code>OS</code>에서 프로세스 간 데이터에 대한 통신 기술
    <ul>
      <li><code>IPC</code> 기술 : 파이프, 소켓, 메시지 큐, 공유 메모리</li>
    </ul>
  </li>
</ul>

<h3 id="인터페이스-구현">인터페이스 구현</h3>

<ul>
  <li>인터페이스 기능 정의 : 인터페이스를 실제 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술하는 과정
    <ul>
      <li>인터페이스 기능 정의 순서 : 컴포넌트 명세서 확인 → 인터페이스 명세서 확인 → 인터페이스 기능 구현 정의서 → 인터페이스 기능 구현 정형화</li>
    </ul>
  </li>
  <li>모듈 세부 설계서 : 컴포넌트 설계서, 인터페이스 명세서</li>
  <li><b>인터페이스 구현 : 송·수신 시스템 간의 데이터 교환 및 처리를 실현하는 작업</b>
    <ul>
      <li><b><code>AJAX</code> : <code>JS</code> 기반의 비동기 통신 기술 (클라이언트·서버 간 <code>XML</code>으로 통신)</b></li>
      <li><b><code>JSON</code> : <code>JS</code> 기반의 데이터 통신을 이용한 인터페이스 구현</b></li>
    </ul>
  </li>
  <li>인터페이스 구현 검증 : 구현된 인터페이스의 동작 상태 검증·감시 (<code>Watir</code>, <code>FitNesse</code>, <code>NTAF Naver</code>, <code>Selenum</code>, <code>Appium</code>)
    <ul>
      <li><b><code>xUnit</code> : <code>Assertion</code>, <code>Fixture</code>, <code>Test Runner</code>를 지원하는 단위 테스트 프레임워크</b></li>
      <li><b><code>STAF</code> : 서비스 호출, 컴포넌트 재사용을 데몬 기반 테스트 분산 환경에서 테스트 수행</b></li>
    </ul>
  </li>
  <li>인터페이스 구현 감시 도구 : <code>APM</code>을 통한 동작 상태 감시 (트랜잭션·변수값·호출 함수·로그·시스템 부하 조회·분석)</li>
</ul>

<h3 id="인터페이스-보안">인터페이스 보안</h3>

<ul>
  <li>인터페이스 보안 : 모듈 컴포넌트 간 데이터 교환 시 데이터 변조·탈취 및 인터페이스 모듈 자체의 보안 취약점
    <ul>
      <li><b>데이터 통신 시 데이터 탈취 위협 : 스니핑 (네트워크 패킷을 엿봐 계정·비밀번호 탈취), 스푸핑 (사용자가 크래커의 사이트로 통신해 비밀번호 탈취)</b></li>
    </ul>
  </li>
  <li>네트워크 보안 적용 : 송·수신 중간자의 데이터 탈취·위변조를 방지하기 위한 네트워크 트래픽 암호화
    <ul>
      <li>네트워크 구간 보안 기능 적용 시 고려사항 : 상대방 인증 적용, 데이터 기밀성의 보장, <code>End-to-End</code> 보안의 적용, 인증 키를 통한 통신, 연결 단위 외에 메시지 단위 인증 및 암호화</li>
      <li><code>SSL</code> : 웹 브라우저·서버 간 통신에서 데이터 암호화 및 인증</li>
      <li><code>S-HTTP</code> : 웹 서버·클라이언트 간 통신에서 전송 데이터 암호화</li>
    </ul>
  </li>
  <li>데이터베이스 보안 적용 : 데이터베이스의 기밀성 유지를 위해 중요하고 민감한 데이터는 암호화
    <ul>
      <li>데이터베이스 암호화 기법 : <code>API</code>, <code>Filter (Plug-in)</code>, <code>Hybrid</code></li>
      <li>데이터베이스 암호화 알고리즘 : 대칭키 알고리즘 (<code>ARIA 256</code>), 해시 알고리즘 (<code>SHA-512</code>), 비대칭키 알고리즘 (<code>RSA</code>)</li>
    </ul>
  </li>
  <li>인터페이스 연계 테스트 : 송·수신 시스템 간 구성 요소가 정상적으로 동작하는지 테스트
    <ul>
      <li>인터페이스 연계 태스트 순서 : 테스트 케이스 작성 → 테스트 환경 구축 → 테스트 수행 → 테스트 수행 결과 검증</li>
    </ul>
  </li>
</ul>

<h2 id="제품-소프트웨어-패키징">제품 소프트웨어 패키징</h2>

<h3 id="제품-소프트웨어-패키징-1">제품 소프트웨어 패키징</h3>

<ul>
  <li><b>제품 소프트웨어 패키징 : 개발 완료된 소프트웨어를 고객에 인도하기 위해 패키징하고, 배포 설치 파일을 만드는 작업</b>
    <ul>
      <li>제품 소프트웨어 패키징 프로세스 : 기능 식별 → 모듈화 → 빌드 → 사용자 환경 분석 → 적용 시험 → 변경 개선</li>
    </ul>
  </li>
  <li>제품 소프트웨어 패키징 도구 : 소프트웨어 배포 목적으로 패키징 시에 지식재산권 보호·관리 기능을 제공하는 도구
    <ul>
      <li><b>제품 소프트웨어 패키징 도구 고려 사항 : 내부의 컨텐츠 암호화·보안, 암호화 알고리즘 적합한지, 이기종 컨텐츠 및 단말기 간 <code>DRM</code> 연동 고려, 사용자 편의성을 위한 복잡성·비효율성 문제 고려</b></li>
      <li><code>REL</code> : <code>XML</code> 기반 디지털 컨텐츠의 권한 관리를 위한 언어</li>
      <li><code>ODRL</code> : <code>XML</code> 기반 디지털 컨텐츠의 저작권 관리 위한 권한 표현 언어</li>
      <li><code>SSO</code> : 사용자가 하나의 로그인으로 여러 시스템에 접근할 수 있는 인증 방식</li>
      <li>디지털 인증서 : 디지털 컨텐츠나 서비스의 보안을 강화하기 위한 전자 문서</li>
    </ul>
  </li>
  <li>어플리케이션 모니터링 도구 (<code>APM</code>) : 응용 소프트웨어 성능 및 서비스 이용성을 감시하고 관리하는 도구
    <ul>
      <li><code>APM</code> 제공 기능 : 어플리케이션 모니터링, 사용자 모니터링, 성능 최적화, 장애 대응</li>
    </ul>
  </li>
  <li>협업 도구 : 소프트웨어 개발 과정에서 이해관계자 간 이견 조율을 수행하기 위한 도구
    <ul>
      <li>협업 도구 종류 : 버전 관리 시스템, 이슈 트래커, 채팅 도구, 코드 리뷰 도구, <code>CI·CD</code> 도구</li>
    </ul>
  </li>
</ul>

<h3 id="제품-소프트웨어-저작권">제품 소프트웨어 저작권</h3>

<ul>
  <li><b><code>DRM</code> : 디지털 컨텐츠의 유통 과정에서 컨텐츠를 안전한 관리·보호를 위해 허가된 사용자만 접근 제한</b>
    <ul>
      <li><code>DRM</code> 기술적 요구사항 : 지속적 보호, 이용 편리성, 유연성, 통합 용이성</li>
      <li><b><code>DRM</code> 기술 요소</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ea806705-3295-4cf9-b929-44b93563fb58" width="80%" /></li>
      <li><b><code>DRM</code> 유통 과정</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c363604b-b7e3-4113-97c9-66c239d10d27" width="80%" /></li>
      <li><b><code>DRM</code> 유통 구성</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/81ec6d7b-97b2-4e67-9496-e9e7290456c6" width="80%" /></li>
      <li><code>DRM</code> 정책 : <code>Render Permission</code>, <code>Transport Permission</code>, <code>Derivative Permission</code></li>
      <li><code>DRM</code> 사용 조건 : <code>Period</code>, <code>Count</code>, <code>Domain</code></li>
    </ul>
  </li>
</ul>

<h3 id="제품-소프트웨어-메뉴얼-작성">제품 소프트웨어 메뉴얼 작성</h3>

<ul>
  <li>소프트웨어 메뉴얼 : 제품 소프트웨어 개발 단계부터 적용된 기준, 패키징 이후 설치 및 사용자 측면의 내용을 기록
    <ul>
      <li><b>소프트웨어 설치 메뉴얼 : 소프트웨어 실사용자가 제품을 최초 설치 시 참조하는 메뉴얼</b>
        <ul>
          <li><b>소프트웨어 설치 메뉴얼 기본 사항 : 개요, 관련 파일, 아이콘, 설치 환경 체크 항목</b></li>
        </ul>
      </li>
      <li>소프트웨어 사용자 메뉴얼 : 소프트웨어 설치와 사용에 필요한 제반 절차·환경을 포함하는 메뉴얼
        <ul>
          <li><b>사용자 메뉴얼 작성 순서 : 작성 지침 정의 → 사용 설명서 구성 요소 정의 → 구성 요소별 내용 작성 → 사용자 메뉴얼 검토 → 메뉴얼 배포</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>릴리즈 노트 : 어플리케이션 최종 사용자인 고객에 제공하는 배포 정보 문서
    <ul>
      <li><b>릴리즈 노트 항목 : 헤더, 개요, 목적, 이슈 요약, 재현 항목, 수정·개선 내용, 최종 사용자 영향도, 노트, 면책 조항, 연락 정보</b></li>
    </ul>
  </li>
</ul>

<h3 id="제품-소프트웨어-품질-관리">제품 소프트웨어 품질 관리</h3>

<ul>
  <li>소프트웨어 품질 관리 : 소프트웨어 개발 과정에서 발생할 수 있는 다양한 문제점들을 사전에 파악해 품질 향상
    <ul>
      <li>소프트웨어 품질 국제 표준 : <code><b>ISO/IEC 9126</b></code>, <code><b>ISO/IEC 12119</b></code>, <code><b>ISO/IEC 25000</b></code>, <code><b>ISO/IEC 15504 (SPICE)</b></code></li>
      <li><b>소프트웨어 품질 목표 : <code>Software Quality and Goals</code></b>
        <ul>
          <li><b>운영 측면 : 정확성, 신뢰성, 사용 용이성, 효율성, 무결성</b></li>
          <li><b>변경 수용 특성 : 이식성, 상호운용성, 재사용성, 유지보수성, 유연성, 시험 역량</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="어플리케이션-테스트">어플리케이션 테스트</h2>

<h3 id="테스트-관리">테스트 관리</h3>

<ul>
  <li><b>소프트웨어 테스트 : 소프트웨어 개발 단계에서 소프트웨어 결함을 찾아내는 활동</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/cab6acf2-9601-452f-9219-f03c397435ce" width="80%" />
    <ul>
      <li>소프트웨어 테스트 프로세스 : 계획·제어 → 분석·설계 → 구현·실행 → 평가·보고</li>
      <li>소프트웨어 테스트 원리 : 결함 존재 증명, <b>완벽한 테스트는 불가능</b>, 개발 초기에 수행되어야 함, <b>특정 모듈에 결함 대부분이 존재</b>, 테스트는 컨텍스트에 의존
        <ul>
          <li><b>파레토의 법칙 : 전체 결과의 <code>80%</code>가 전체 원인의 <code>20%</code></b></li>
          <li><b>살충제 패러독스 : 동일한 테스트 케이스로 테스트하면 어느 시점부터 결함 발견 불가능</b></li>
          <li>오류-부재의 궤변 : 요구사항을 만족하지 못하는 오류를 발견해 제거해도, 해당 어플리케이션 품질이 높다고 할 수 없음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="테스트-케이스와-테스트-오라클">테스트 케이스와 테스트 오라클</h3>

<ul>
  <li><b>테스트 케이스 : 구현된 소프트웨어가 사용자 요구사항을 준수하는지 확인하기 위한 테스트 항목에 대한 명세서</b>
    <ul>
      <li><b>표준 테스트 케이스 형식 : <code>ID</code>, 시나리오, 단계, 데이터, 예상 결과, 실제 결과, 통과 실패</b></li>
      <li><b>테스트 케이스 자동 생성 : 자료 흐름도 → 테스트 경로 관리·입력 도메인 분석 → 테스트 데이터 산출·랜덤 테스트 → 무작위 값 입력·신뢰성 검사</b></li>
      <li>테스트 케이스 구성 요소 (<code>ISO/IEC/IEEE 29119-3</code>)<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1d53b65b-aeef-4253-8748-60accb3d844a" width="80%" /></li>
    </ul>
  </li>
  <li><b>테스트 오라클 : 테스트 결과가 참인지 거짓인지 판단하기 위해 사전에 정의된 <code>True</code>를 입력해 비교</b>
    <ul>
      <li>테스트 오라클 종류 : 참 오라클, 일관성 검사 오라클, 샘플링 오라클, 휴리스틱 오라클</li>
    </ul>
  </li>
</ul>

<h3 id="v-모델과-테스트-레벨"><code class="language-plaintext highlighter-rouge">V</code>-모델과 테스트 레벨</h3>

<ul>
  <li><b>시각에 따른 테스트 : 검증 (<code>Verification</code>)<code>vs</code>확인 (<code>Validation</code>)</b></li>
  <li><code>Test Bases</code> 테스트 : 소프트웨 내부 구조에 따른 테스트 케이스 작성 및 확인
    <ul>
      <li><code>Test Bases</code> 종류 : 구문 기반, 결정 기반, 조건 기반, 데이트 흐름 기반, 명세 기반, 경험 기반</li>
    </ul>
  </li>
  <li>동적 테스트 : 어플리케이션을 직접 실행 (<code>vs</code>정적 테스트)<br />→ <b>블랙박스 테스팅 (명세 기반), 화이트박스 테스팅 (구조 기반)</b></li>
  <li>알파 테스트 (개발자 관점에서 사용자가 테스트)<code>vs</code>베타 테스트 (사용자 관점에서 사용자가 테스트)</li>
  <li>테스트 분류 : 회복 테스트, 안전 테스트, 성능 테스트, 구조 테스트, <b>회귀 테스트</b>, 병행 테스트</li>
  <li>성능 테스트 유형 : 부하 테스트, 강도 테스트, 스파이크 테스트, 내구성 테스트</li>
  <li><code class="language-plaintext highlighter-rouge">V</code>-모델 : 어플리케이션 개발 단계에 따라 어플리케이션르 총체적을 관리하기 위한 테스트 활동의 묶음<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0d419760-7be8-40fc-b4df-d40adc5a5fa8" width="80%" />
    <ul>
      <li><b>단위 테스트 : 개발자가 원시 코드를 대상으로 각 단위를 다른 부분과 연계되는 부분을 고려치 않고 테스트</b></li>
      <li>통합 테스트 : 단위 테스트를 통과한 개발 소프트웨어·하드웨어 컴포넌트 간 인터페이스 및 연동 기능을 테스트</li>
      <li>시스템 테스트 : 단위·통합 테스트 이후 실제 환경과 유사한 환경에서 시스템 성능과 관련된 요구사항을 테스트</li>
      <li><b>인수 테스트 : 소프트웨어 제품에 대한 요구사항을 제대로 이행되었는지 확인</b></li>
    </ul>
  </li>
</ul>

<h3 id="테스트-시나리오와-테스트-기법">테스트 시나리오와 테스트 기법</h3>

<ul>
  <li>테스트 시나리오 : 테스트를 위한 테스트 케이스의 집합 (테스트 케이스의 동작 순서 기술)</li>
  <li>테스트 환경 구축 : 실제 운영 시스템에 정상적으로 작동하는지 테스트하기 위한 실제 운영 환경과 동일한 시설 구축</li>
  <li><b>화이트박스 테스트 : 모듈의 원시 코드를 오픈한 상태에서 코드의 모든 논리적 경로 테스트</b>
    <ul>
      <li><b>화이트박스 테스트 종류 : 기초 경로 검사, 제어 구조 검사 (조건 검사, 루프 검사, 데이터 흐름 검사)</b></li>
    </ul>
  </li>
  <li><b>블랙박스 테스트 : 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 정상 작동되는지 입증 (기능 테스트)</b>
    <ul>
      <li><b>블랙박스 테스트 종류 : 동치 분할 검사, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사, 경계값 분석</b>
<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f06ef31a-a382-4d07-bee6-cf9db10df171" width="70%" /></li>
    </ul>
  </li>
</ul>

<h3 id="테스트-커버리지">테스트 커버리지</h3>

<ul>
  <li><b>테스트 커버리지 : 주어진 테스트 케이스에 의해 수해오디는 소프트웨어 테스트 범위를 측정하는 테스트 품질 측정 기준</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/042d81b0-8871-4949-af3c-c18e59e0fe13" width="50%" /></li>
</ul>

<h3 id="통합-테스트">통합 테스트</h3>

<ul>
  <li><b>단위 테스트 : 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트</b>
    <ul>
      <li><b>단위 테스트 지원 도구 (<code>xUnit</code>) : <code>JUnit</code>, <code>Mocha</code>, <code>Mockito</code>, <code>Karma</code>, <code>Selenium</code><b></b></b></li>
    </ul>
  </li>
  <li>통합 테스트 : 각 모듈을 결합해 시스템을 완성할 때, 모듈 간 인터페이스나 통합 컴포넌트 간 오류 탐색<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5463b8f8-85ba-4a02-9e24-ece7cdd50502" width="80%" />
    <ul>
      <li>비 점진적 통합 방식 (빅뱅 통합) : 모든 모듈이 결합된 프로그램 전체 대상으로 테스트</li>
      <li>점진적 통합 방식 (상향식·하향식) : 단계적으로 통합하면서 테스트</li>
    </ul>
  </li>
  <li><b>하향식 통합 테스트 : 상위 컴포넌트 → 하위 컴포넌트</b>
    <ul>
      <li>시스템 테스트 기능, 개발 일정 예측 가능, 통합 오류 발견 어려움, 테스트 스텁 사용 가능, 협력 필요</li>
    </ul>
  </li>
  <li><b>상향식 통합 테스트 : 하위 컴포넌트 → 상위 컴포넌트</b>
    <ul>
      <li>하위 모듈 결함 전파 방지, 드라이버 통한 테스트 가능, 개바 속도 빠름, 조기 결함 발견 가능</li>
    </ul>
  </li>
  <li>테스트 자동화 도구 : 어플리케이션 개발 중에 반복되는 테스트 과정을 자동화하는 도구
    <ul>
      <li><b>테스트 자동화 도구 유형 : 정적 분석 도구, 테스트 실행 도구, 성능 테스트 도구, 테스트 통제 도구</b>
        <ul>
          <li>테스트 하네스 도구 : 소프트웨어 컴포넌트 테스트, 프로그램 입력, 결과 비교, 컴포넌트 기능 대행 목적
            <ul>
              <li><b>테스트 드라이버 : 상향식 테스트에서 테스트 대상을 제어·동작하기 위한 도구</b></li>
              <li><b>테스트 스탑 : 하향식 테스트에서 시스템 컴포넌트가 개발되지 않은 상황의 가상 더미 컴포넌트</b></li>
              <li>테스트 슈트 : 일정 순서에 의해 수행될 계별 테스트 집합 및 패키지</li>
              <li>테스트 케이스 : 요구사항에 맞게 개발되었는지 확인할 테스트 입력 및 예상 결과</li>
              <li>테스트 스크립트 : 테스트 케이스르 수행해 결과를 보고할 목적으로 작성된 명령어·이벤트 중심 파일</li>
              <li>목 오브젝트 : 사용자 행위를 미리 조건부로 입력해 그 상황에 맞는 행위를 수행하는 객체</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="어플리케이션-성능-개선">어플리케이션 성능 개선</h2>

<h3 id="결함-관리">결함 관리</h3>

<ul>
  <li>결함 : 소프트웨어의 에러, 결함, 결점, 버그, 실패
    <ul>
      <li>결함 심각도별 분류 : 치명적, 주요, 보통, 경미한 단순</li>
      <li>결함 우선순위 : 결정적, 높음, 보통, 낮거나 즉시 해결, 주의 요망, 대기, 개선 권고</li>
      <li>결함 위치별 분류 : 시스템 결함, 기능 결함, <code class="language-plaintext highlighter-rouge">GUI</code> 결함, 문서 결함</li>
      <li>결함 관리 프로세스 : 결합 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 → 보고서 작성</li>
    </ul>
  </li>
  <li>에러 : 소프트웨어 개발 또는 유지보수 수행 중에 발생한 부정확한 결과</li>
  <li><b>오류 : 소프트웨어 구현이나 설계상의 오류로 인해 시스템의 고장을 일으킴</b></li>
  <li>고장 : 정상적인 프로그램과 비정상적인 프로그램의 실행 결과 차이</li>
  <li>결함 : 버그, 에러, 오류, 실패를 모두 포괄</li>
</ul>

<h3 id="어플리케이션-성능-개선-1">어플리케이션 성능 개선</h3>

<ul>
  <li>성능 처리 지표 : 처리량, 응답 시간, 경과 시간, 갸용성, 확장성, 안정성</li>
  <li>성능 분석 도구 : 성능·부하·스트레스 점검 도구, 머니터링 도구</li>
  <li><b>위험 감시 : 위험 요수 징후들에 대해 계속해서 인지하는 것</b>
    <ul>
      <li>위험 감시 절차 : 위험 식별 → 위험 평가 → 위험 대응 계획 수립 → 위험 모니터링</li>
    </ul>
  </li>
  <li>어플리케이션 성능 저하 원인 : <code>DB Lock</code>, 불필요한 <code>DB Fetch</code>, 연결 누수, 부적절한 <code>Connection Pool Size</code></li>
  <li>알고리즘 : 주어진 과제를 해결하는 방법 및 절차 (자연여, 의사코드, 순서도, 프로그래밍 언어로 표현)
    <ul>
      <li>분할 정복법 : 제시된 문제를 분할이 불가능할 때까지 나누고, 각 과제를 해결하면서 다시 결합 (<code>Top-Down</code>)
        <ul>
          <li>분할 정복법 예시 : 퀵 정렬, 병합 정렬</li>
        </ul>
      </li>
      <li>동적 계획법 : 주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용 (<code>Bottom-Up</code>)
        <ul>
          <li>동적 계획법 예시 : 플로이드 알고리즘, 피보니치 수열 알고리즘 → 최적 부분 구조, 중복 부분 문제에 적합</li>
        </ul>
      </li>
      <li>탐욕법 : 각 부분에 대한 최적해를 구해 이를 결합하여, 국소적인 관점에서 최적의 해결 방법을 구함
        <ul>
          <li>탐욕법 예시 : 크루스칼 알고리즘, 다익스트라 알고리즘</li>
        </ul>
      </li>
      <li>퇴각 검색법 : 어떤 문제의 최적해를 구하기 위해 모든 가능성을 탐색
        <ul>
          <li>퇴각 검색법 예시 : <code>N-Queen</code></li>
        </ul>
      </li>
      <li>분기 한정법 : 정해진 범위를 벗어나는 값들은 가지치기하면서 결과값을 추적
        <ul>
          <li>분기 한정법 예시 : 최적 우선 탐색 알고리즘, <code>A*</code> 알고리즘</li>
        </ul>
      </li>
      <li>근사 해법 : 복잡도가 매우 높은 문제에 대해 가장 근사치의 값을 구하는 결정성 구현
        <ul>
          <li>근사 해법 예시 : 근사 알고리즘</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>알고리즘 시간 복잡도 : 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것
    <ul>
      <li><b>빅오 표기법 : 알고리즘 실행 시간이 최악일 때를 표기하는 방법</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3b1bdb74-3483-4178-b2c8-c7f5cb09a42b" width="80%" /></li>
    </ul>
  </li>
  <li><b>순환 복잡도 : 프로그램의 이해 난이도는 제어 흐름 그래프의 복잡도에 따라 결정 → 복잡도를 싸이클로메틱 개수로 산정</b>
    <ul>
      <li>최대 10이 넘지 않도록 하며, 넘으면 이를 분해하도록 함</li>
      <li>복잡도 = 화살표 수 - 노드 수 + 2 = 영역 수 + 1 = 의사 결정 수 + 조건 수 + 1<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7c67d819-c188-4cee-9528-332bdfc2c6ed" width="90%" /></li>
    </ul>
  </li>
</ul>

<h3 id="소스-코드-최적화">소스 코드 최적화</h3>

<ul>
  <li>소스 코드 최적화 : 읽기 쉽고 변경·추가가 쉬운 클린 코드를 위해 기본적으로 지킬 윈칙 및 기준 정의
    <ul>
      <li>스파게티 코드 : 처리 로직의 제어가 체계화되어 있지 않고 서로 얽혀있는 코드</li>
      <li>외계인 코드 : 오래되거나 참고 문서·개발자가 없어 유지보수가 어려운 프로그램</li>
      <li><b>클린 코드 : 깔끔하게 잘 정리된 코드 (중복 코드 제거, 높은 가독성·프로그래밍 속도·버그 탐색 속도)</b>
        <ul>
          <li><b>클린 코드 작성 원칙 : 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화</b></li>
          <li><b>클린 코드 유형 : 좋은 배치, 작은 함수, 분석 가능한 제어 흐름, 간결한 주석, 의미 있는 이름</b></li>
        </ul>
      </li>
      <li><b>코드 간결성 유지 지침 : 공백으로 실행문·주석 구분, 복잡한 논리식·산술식 들여쓰기, 빈 줄로 선언부·구현부 구별, 한줄에 적은 문장</b></li>
      <li>소스 코드 최적화 유형 : 클래스 분할 배치, 좋은 이름 사용, 코딩 형식 준수, 느슨한 결합, 적절한 주석</li>
    </ul>
  </li>
  <li><b>소스 코드 품질 분석 도구 : 코딩 스타일, 코드 표준, 코드 복잡도, 메모리 누수, 스레드 결함을 발견하기 위해 사용</b>
    <ul>
      <li><b>정적 분석 도구 : 소스 코드 검증, 코드 리뷰, 정적 리버스 엔지니어링</b>
        <ul>
          <li><b>정적 분석 도구 종류 : <code>PMD</code>, <code>CPPCheck</code>, <code>SonarQube</code>, <code>CheckStyle</code>, <code>CCM</code>, <code>Coberfura</code></b></li>
        </ul>
      </li>
      <li>동적 분석 도구 : 디버깅, 스트레스 테스트, 모의 해킹, 동적 리버스 엔지니어링<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/17507c69-6c8a-4049-b5ee-f7d5a064f820" width="80%" /></li>
    </ul>
  </li>
</ul>

<h2 id="데이터-입출력-구현">데이터 입출력 구현</h2>

<h3 id="자료-구조">자료 구조</h3>

<ul>
  <li>자료 구조의 분류 : 선형 구조, 비선형 구조, 파일 구조로 대분류<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/27fa958b-8c44-4516-ac0d-cfe496f748fa" width="80%" />
    <ul>
      <li>자료구조의 활용 : 정렬, 검색, <b>인덱스</b>, 레코드</li>
    </ul>
  </li>
  <li>선형 자료 구조 : 데이터를 일렬로 늘어놓은 자료 구조, 데이터를 순서대로 저장하고 순차적으로 처리
    <ul>
      <li><b>스택 : 후입선출 (<code>LIFO</code>), 큐 : 선입선출 (<code>FIFO</code>), 데크 : 리스트 양끝에 포인터 2개 사용</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1d7edc16-6e1e-4887-a157-e7d8b9fb4172" width="80%" /></li>
    </ul>
  </li>
  <li>비선형 구조 : 데이터를 한줄로 연결하지 않는 구조, 자료 간 선후관계가 <code>1:N</code>, <code>N:1</code>으로 표현
    <ul>
      <li><b>트리 : 노드와 브랜치로 사이클을 이루지 않는 그래프</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5c562017-31a9-41c5-b4d8-d120f5d5022d" width="70%" /></li>
      <li>이진 트리 : 차수가 2 이하인 노드들로 구성된 트리 (이진 트리 레벨 <code>K</code>의 최대 노드 수는 <code>2^K-1</code>)<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c4de5709-b5a5-49f0-815a-0cc54e547092" width="80%" />
        <ul>
          <li><b>이진 트리의 운행법 : 전위 운행 (<code>Root → Left → Right</code>), 중위 운행 (<code>Left → Root → Right</code>), 후위 운행 (<code>Left → Right → Root</code>)</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7d5170ec-dcac-45af-970f-40b809c469b1" width="80%" /></li>
          <li><b>이진 트리의 수식 표기법 : 전위 표기법 (연산자 → 피연산자 → 피연산자), 중위 표기법 (피연산자 → 연산자 → 피연산자), 후위 표기법 (피연산자 → 피연산자 → 연산자)</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/eb9e452d-3156-4e9e-baeb-b310b52eaf71" width="80%" /></li>
        </ul>
      </li>
      <li><b>그래프 : 정점과 간선의 집합으로 이루어진 자료 구조 (인접 행렬로 표현)</b>
        <ul>
          <li>그래프 종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프</li>
          <li><code>N</code>개의 노드로 구성된 무방향 그래프의 최대 간선 수 : <code>N(N-1)/2</code></li>
          <li><b>제어 흐름 그래프의 순환 복잡도 : <code>V(G) = (화살표 수) - (노드 수) + 2</code></b></li>
        </ul>
      </li>
      <li><b>인접 행렬 : 방향 그래프에서 정점 <code>Vi</code>과 <code>Vj</code>의 관계를 나타내는 행렬의 원소를 <code>Aij</code>라 할 때,<br />정점 <code>Vi</code>에서 <code>Vj</code>로 향하는 방향 간선이 있으면 행렬의 <code>Aij = 1</code>,<br />방향 간선이 없으면 행렬의 <code>Aij = 0</code>,<br />정점 <code>Vi</code>와 <code>Vj</code>가 서로 인접하면 <code>Aij = 1</code><br />정점 <code>Vi</code>와 <code>Vj</code>가 서로 인접하지 않으면 <code>Aij = 0</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="정렬">정렬</h3>

<ul>
  <li>정렬 : 자료를 특정 기준에 따라 다시 나열 하는 것<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/dd0af678-cbe9-467b-8075-70adbdf6ca1c" width="80%" />
    <ul>
      <li><b>삽입 정렬 : 정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입해 정렬</b></li>
      <li><b>버블 정렬 : 인접한 데이터와 비교하면서 그 크기에 따라 데이터 위치를 바꾸어 정렬</b></li>
      <li><b>선택 정렬 :<code>N</code>개의 레코드 중 최소값(최대값)을 찾아 배열의 <code>N</code>번째로 놓는 것을 반복해 정렬</b></li>
      <li><b>병합 정렬 : 배열을 최대로 나눈 뒤, 나뉜 각 키 한 쌍을 순서를 정하며 병합해 정렬</b></li>
      <li><b>퀵 정렬 : 피벗을 기분으로 작은 값은 왼쪽에, 큰 값은 오른쪽에 모이도록 서로 교환해 정렬</b></li>
    </ul>
  </li>
</ul>

<h3 id="검색-해싱">검색, 해싱</h3>

<ul>
  <li>검색 : 기억 공간 내에서 주어진 조건 을만족하는 자료 탐색
    <ul>
      <li>이분 검색 : 정렬된 배열의 가운데 인덱스 값을 선택 → 크면 작은 값 쪽으로, 작으면 큰 값 쪽으로 이동 반복</li>
      <li><b>선형 검색 : 주어진 자료에서 원소를 첫번째 레코드부터 순차 비교해 탐색</b></li>
      <li>이진 트리 검색 : 전체 레코드를 이진 트리로 구성해 검색</li>
      <li>블록 검색 : 전체 레코드를 블록으로 분리해 순서대로 비교해 검색</li>
    </ul>
  </li>
  <li>해싱 함수 : 레코드 키에 대한 해시 테이블 내의 홈 주소를 계산해 주어진 레코드에 접근할 때 활용되는 함수
    <ul>
      <li><b>해싱 함수 종류 : 제산 방법, 중간 제곱 방법, 중첩 방법, 기수 변환 방법</b></li>
      <li>해싱 오버플로우 해결 : 선형 개방 주소법, 폐쇄 주소 방법, 재해싱</li>
      <li>해싱 관련 용어 : 동의어, 슬롯, 충돌</li>
    </ul>
  </li>
</ul>

<h3 id="인덱스-구조와-파일-편성">인덱스 구조와 파일 편성</h3>

<ul>
  <li>인덱스 : <code>DB</code> 테이블 내의 원하는 레코드를 빠르게 탐색하는 데이터 구조
    <ul>
      <li>인덱스 구성 방법 : <code>B</code> 트리, <code>B+</code> 트리, 트라이 색인</li>
      <li>정적 인덱싱 (색인 순차 파일 방식)<code>vs</code>동적 인덱싱 (가상 기억 접근 방식)</li>
    </ul>
  </li>
  <li><b>파일 편성 기법 : 순차 파일, 색인 순차 파일, <code>VSAM</code> 파일, 직접 파일, 역파일</b></li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[정보처리기사를 취득하기 위해 공부하는 과정에 작성한 ‘소프트웨어 개발’ 관련 정리이다.]]></summary></entry></feed>