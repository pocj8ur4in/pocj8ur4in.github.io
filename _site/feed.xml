<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-22T13:16:26+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[B/E] API</title><link href="http://localhost:4000/backend/api1/" rel="alternate" type="text/html" title="[B/E] API" /><published>2022-11-21T00:00:00+09:00</published><updated>2022-11-21T00:00:00+09:00</updated><id>http://localhost:4000/backend/api1</id><content type="html" xml:base="http://localhost:4000/backend/api1/"><![CDATA[<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br />&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="api-application-programming-interface--어플리케이션-프로그래밍-인터페이스"><code class="language-plaintext highlighter-rouge">API</code> (<code class="language-plaintext highlighter-rouge">Application Programming Interface</code>) : 어플리케이션 프로그래밍 인터페이스</h2>
<ul>
  <li>응용 프로그램에게 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
    <ul>
      <li>주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스 제공</li>
      <li>컴퓨터 프로그램 간 정보를 교환 가능하도록 함</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">JSON</code>,  <code class="language-plaintext highlighter-rouge">XML</code>, <code class="language-plaintext highlighter-rouge">OAuth</code>, <code class="language-plaintext highlighter-rouge">Open API</code>, <code class="language-plaintext highlighter-rouge">Web Socket API</code>, <code class="language-plaintext highlighter-rouge">RPC</code></li>
</ul>

<h3 id="라이브러리-library--플랫폼에서-바로-실행될-수-있도록-api를-바탕으로-구현된-모듈화된-프로그램의-집합">라이브러리 (<code class="language-plaintext highlighter-rouge">Library</code>) : 플랫폼에서 바로 실행될 수 있도록 <code class="language-plaintext highlighter-rouge">API</code>를 바탕으로 구현된 모듈화된 프로그램의 집합</h3>
<ul>
  <li>프로그래밍에서 라이브러리를 사용할 때 메소드가 어떻게 구현되었는지 알 수 없으나, 인터페이스만 알면 사용할 수 있음</li>
</ul>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">API</code>와 라이브러리의 차이? : 실제로 구현되었는가?
      <ul>
        <li><code class="language-plaintext highlighter-rouge">API</code> : 응용 프로그램을 개발하는 데 있어 호환성을 위해 지켜야 하는 <u>추상적인 원칙</u></li>
        <li>라이브러리 : <code class="language-plaintext highlighter-rouge">API</code>를 기반으로 개발자에게 기능을 제공하기 위해 구현된 <u>구현체</u></li>
        <li><code class="language-plaintext highlighter-rouge">SDK</code> (<code class="language-plaintext highlighter-rouge">Software Development Kit</code>) : <code class="language-plaintext highlighter-rouge">API</code>가 라이브러리와 함께 제공</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="rest-api--rest를-기반으로-api를-구현한-것"><code class="language-plaintext highlighter-rouge">REST API</code> : <code class="language-plaintext highlighter-rouge">REST</code>를 기반으로 <code class="language-plaintext highlighter-rouge">API</code>를 구현한 것</h2>

<h3 id="rest--자원을-이름으로-구분하고-해당-자원의-상태를-교환하는-모든-것"><code class="language-plaintext highlighter-rouge">REST</code> : 자원을 이름으로 구분하고, 해당 자원의 상태를 교환하는 모든 것</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP URI</code>를 통해 자원의 표현 명시</li>
  <li><code class="language-plaintext highlighter-rouge">HTTP Method</code>를 통해 해당 자원의 <code class="language-plaintext highlighter-rouge">HTTP URI</code>에 대한 <code class="language-plaintext highlighter-rouge">CRUD Operation</code> (<code class="language-plaintext highlighter-rouge">Create</code>, <code class="language-plaintext highlighter-rouge">Read</code>, <code class="language-plaintext highlighter-rouge">Update</code>, <code class="language-plaintext highlighter-rouge">Delete</code>) 적용</li>
</ul>

<p><img src="https://velog.velcdn.com/images/yhko1992/post/f9311e90-0043-46a9-a935-9bfe85b985c4/image.png" /></p>

<ul>
  <li>자원 : <code class="language-plaintext highlighter-rouge">HTTP URL</code></li>
  <li>자원에 대한 동작 : <code class="language-plaintext highlighter-rouge">HTTP Method</code></li>
  <li>자원에 대한 동작의 내용 : <code class="language-plaintext highlighter-rouge">HTTP Message Pay Load</code></li>
</ul>

<h4 id="서버-클라이언트-구조-server-client">서버-클라이언트 구조 (<code class="language-plaintext highlighter-rouge">Server-Client</code>)</h4>
<ul>
  <li>클라이언트 (<code class="language-plaintext highlighter-rouge">Client</code>) : 자원을 요청하는 쪽
    <ul>
      <li>사용자 인증이나 세션이나 로그인 정보 등을 직접 관리</li>
    </ul>
  </li>
  <li>서버 (<code class="language-plaintext highlighter-rouge">Server</code>) : 자원을 응답하는 쪽
    <ul>
      <li><code class="language-plaintext highlighter-rouge">API</code>를 제공하고 비즈니스 로직을 처리하고 저장</li>
    </ul>
  </li>
</ul>

<h4 id="무상태-stateless--서버가-클라이언트의-세션-상태-및-쿠키를-저장하지-않는-네트워크-프로토콜">무상태 (<code class="language-plaintext highlighter-rouge">Stateless</code>) : 서버가 클라이언트의 세션 상태 및 쿠키를 저장하지 않는 네트워크 프로토콜</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜은 <code class="language-plaintext highlighter-rouge">Stateless Protocol</code>이므로 <code class="language-plaintext highlighter-rouge">REST</code> 역시 무상태
    <ul>
      <li>서버가 클라이언트의 요청에 대한 응답만 처리하고, 세션 상태나 쿠키를 저장하지 않아 구현이 단순해짐</li>
      <li>서버는 클라이언트가 보낸 이전의 요청과 이후의 요청을 완전히 별개의 것으로 인식하고 처리
        <ul>
          <li>이전 요청이 다음 요청의 처리에 연관되어서는 안됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Backend" /><summary type="html"><![CDATA[이 항목은 현재 작성중입니다.&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[B/E] 스프링 (spring)</title><link href="http://localhost:4000/backend/spring1/" rel="alternate" type="text/html" title="[B/E] 스프링 (spring)" /><published>2022-11-11T00:00:00+09:00</published><updated>2022-11-15T00:00:00+09:00</updated><id>http://localhost:4000/backend/spring1</id><content type="html" xml:base="http://localhost:4000/backend/spring1/"><![CDATA[<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br />&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--info"><strong>이 항목은 macOS 기반으로 작성되었습니다.</strong><br />&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="스프링-spring--자바-java-기반의-웹-프레임워크-web-framework">스프링 (<code class="language-plaintext highlighter-rouge">spring</code>) : 자바 (<code class="language-plaintext highlighter-rouge">JAVA</code>) 기반의 웹 프레임워크 (<code class="language-plaintext highlighter-rouge">Web Framework</code>)</h2>
<ul>
  <li>순수 자바 객체 (<code class="language-plaintext highlighter-rouge">Plain Old Java Object</code>) 방식 : <code class="language-plaintext highlighter-rouge">POLO</code>
    <ul>
      <li>특정 인터페이스를 직접 구현하거나 상속받지 않아 기존 라이브러리 지원에 용이하고, 코드가 간결하고 객체가 가벼움</li>
    </ul>
  </li>
  <li>관점 지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">Aspect Oriented Programming</code>) : <code class="language-plaintext highlighter-rouge">AOP</code>
    <ul>
      <li>로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리할 수 있음</li>
    </ul>
  </li>
  <li>의존성 주입 (<code class="language-plaintext highlighter-rouge">Dependency Injection</code>) : <code class="language-plaintext highlighter-rouge">DI</code>
    <ul>
      <li>프로그래밍 구성 요소 간 의존 관계를 소스코드 밖에서 설정을 통해 정의해 코드 재사용률을 높이고 모듈 간 결합도를 낮춤</li>
    </ul>
  </li>
  <li>제어의 역전 (<code class="language-plaintext highlighter-rouge">Inversion of Control</code>) : <code class="language-plaintext highlighter-rouge">IoC</code>
    <ul>
      <li>객체의 생성부터 소멸까지의 제어권이 개발자가 아닌 프레임워크에게 있어 외부 라아브러리 코드가 개발자의 코드를 호출</li>
    </ul>
  </li>
  <li>모델-뷰-컨트롤러 (<code class="language-plaintext highlighter-rouge">Model-View-Controller</code>) : <code class="language-plaintext highlighter-rouge">MVC</code> 패턴
    <ul>
      <li>사용자 인터페이스, 데이터 및 논리 제어의 구현에 사용되는 소프트웨어 디자인 패턴</li>
    </ul>
  </li>
</ul>

<h3 id="모듈화-디자인-modulation--한-프레임워크을-여러-기능적-구성요소-module로-조합해-완성하게끔-하는-설계">모듈화 디자인 (<code class="language-plaintext highlighter-rouge">Modulation</code>) : 한 프레임워크을 여러 기능적 구성요소 (<code class="language-plaintext highlighter-rouge">Module</code>)로 조합해 완성하게끔 하는 설계</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Core</code> : 제어의 역전 (<code class="language-plaintext highlighter-rouge">IOC</code>)과 의존성 주입 (<code class="language-plaintext highlighter-rouge">DI</code>) 기능 제공</li>
  <li><code class="language-plaintext highlighter-rouge">DAO</code> : 자바 데이터베이스 커넥터 (<code class="language-plaintext highlighter-rouge">JDBC</code>) 추상 계층 제공 (<code class="language-plaintext highlighter-rouge">VO</code> 클래스로 접근)</li>
  <li><code class="language-plaintext highlighter-rouge">ORM</code> : <code class="language-plaintext highlighter-rouge">ORM</code>이나 데이터베이스 <code class="language-plaintext highlighter-rouge">API</code>와의 통합 기능 제공</li>
  <li><code class="language-plaintext highlighter-rouge">Web</code> : 웹 어플리케이션 구현과 관련된 기능 제공</li>
  <li><code class="language-plaintext highlighter-rouge">JEE</code> : 엔터프라이즈 <code class="language-plaintext highlighter-rouge">J2EE</code> 스펙과 관한 기능 제공</li>
</ul>

<h3 id="스프링부트-springboot---스프링에서-초기-환경-설정-시-많은-시간이-할애되는-문제-개선">스프링부트 (<code class="language-plaintext highlighter-rouge">springBoot</code>) :  스프링에서 초기 환경 설정 시 많은 시간이 할애되는 문제 개선</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dependencies</code>에 <code class="language-plaintext highlighter-rouge">starter</code> 라이브러리를 작성해 초기 환경 설정에 필요한 라이브러리 설정 및 버전 관리를 자동화</li>
  <li>톰캣 (<code class="language-plaintext highlighter-rouge">Tomcat</code>)과 같은 내장 서버가 존재해 프로젝트 내의 서버 설치 및 버전 관리를 자동화</li>
  <li><code class="language-plaintext highlighter-rouge">XML</code> 파일을 자체적으로 빌드하여 스프링 프로젝트 내 객체 의존성 관리를 자동화</li>
</ul>

<h4 id="그레이들-gradle--그루비-groovy-기반의-스프링부트-빌드-자동화-도구">그레이들 (<code class="language-plaintext highlighter-rouge">Gradle</code>) : 그루비 (<code class="language-plaintext highlighter-rouge">Groovy</code>) 기반의 스프링부트 빌드 자동화 도구</h4>
<ul>
  <li>기존에 사용되던 메이븐 (<code class="language-plaintext highlighter-rouge">Maven</code>)과 같은 구조화된 빌드 프레임워크
    <ul>
      <li><code class="language-plaintext highlighter-rouge">build.gradle</code>의 <code class="language-plaintext highlighter-rouge">dependencies</code>에서 스프링과 스프링부트의 프로젝트를 관리</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">JAVA</code>만 사용 가능한 메이븐과 달리 <code class="language-plaintext highlighter-rouge">C/C++</code>, <code class="language-plaintext highlighter-rouge">Python</code> 등의 다양한 언어 지원</li>
  <li><code class="language-plaintext highlighter-rouge">XML</code>의 정적인 설정 정보에서 벗어나 도메인 언어인 그루비를 통해 코드로서의 설정 정보 구성</li>
</ul>

<h2 id="프로젝트-환경설정">프로젝트 환경설정</h2>
<ul>
  <li><a href="https://start.spring.io">spring initializr</a>에서 스프링부트 <code class="language-plaintext highlighter-rouge">View</code> 페이지 제작
    <ul>
      <li>빌드 관리 툴 : <code class="language-plaintext highlighter-rouge">Gradle</code></li>
      <li>언어 : <code class="language-plaintext highlighter-rouge">JAVA</code></li>
      <li>스프링부트 버전 : <code class="language-plaintext highlighter-rouge">2.7.5</code> (최신 버전)</li>
      <li>라이브러리 선택 : <code class="language-plaintext highlighter-rouge">spring Web</code> (웹), <code class="language-plaintext highlighter-rouge">tymeleaf</code> (<code class="language-plaintext highlighter-rouge">HTML</code>을 만드는 템플릿 엔진)</li>
    </ul>
  </li>
</ul>

<h3 id="라이브러리-library--api를-바탕으로-플랫폼에서-바로-실행될-수-있도록-모듈화된-프로그램의-집합">라이브러리 (<code class="language-plaintext highlighter-rouge">Library</code>) : <code class="language-plaintext highlighter-rouge">API</code>를 바탕으로 플랫폼에서 바로 실행될 수 있도록 모듈화된 프로그램의 집합</h3>
<ul>
  <li>혼자서 완전하게 동작하는 것이 아닌 어느 특정한 부분만을 수행하도록 제작 : 기계어나 바이트 코드로 존재 (비휘발성 자원)
    <ul>
      <li>자바에서는 라이브러리를 <code class="language-plaintext highlighter-rouge">.jar</code> 형태로 배포</li>
    </ul>
  </li>
</ul>

<blockquote>
  <ul>
    <li>프레임워크 (<code class="language-plaintext highlighter-rouge">Framework</code>) : 특정한 문제 해결을 위해 클래스, 라이브러리, 인터페이스를 결합시킨 구조
      <ul>
        <li>모듈화 (<code class="language-plaintext highlighter-rouge">Modulation</code>) : 재사용 가능한 클래스와 라이브러리들을 그룹 단위로 융합시켜 제공</li>
      </ul>
    </li>
    <li>프레임워크와 라이브러리의 차이? : 제어의 역전 (<code class="language-plaintext highlighter-rouge">IOC</code>)이 발생하는가?</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">build.gradle</code>의 <code class="language-plaintext highlighter-rouge">dependencies</code>에서 그레이들을 통해 라이브러리가 관리되는 것을 확인 가능
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Gradle</code>은 기본적으로 하나의 라이브러리에 관련된 모든 의존 라이브러리를 가져옴 (외부 라이브러리로 확인 가능)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// build.gradle

plugins {
	id 'org.springframework.boot' version '2.7.5'
	id 'io.spring.dependency-management' version '1.0.15.RELEASE'
	id 'java'
}

repositories {  // repositories : 그레이들에 의존성 추가된 라이브러리 다운로드
	mavenCentral()
}

dependencies {  // dependencies : 그레이들에 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' 
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    compileOnly("org.springframework.boot:spring-boot-devtools")
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-starter</code> 라이브러리 : <code class="language-plaintext highlighter-rouge">core</code>, <code class="language-plaintext highlighter-rouge">logging</code>, <code class="language-plaintext highlighter-rouge">spring boot</code> 등 필요한 모든 의존관계를 가져옴
    <ul>
      <li><code class="language-plaintext highlighter-rouge">logging</code> : 로깅을 위한 인터페이스로 <code class="language-plaintext highlighter-rouge">log4j</code>와 <code class="language-plaintext highlighter-rouge">logback</code>을 구현체로 가짐</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-starter-web</code> 라이브러리 : <code class="language-plaintext highlighter-rouge">WAS</code>인 톰캣이 내장되어 있음</li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-starter-test</code> 라이브러리 : <code class="language-plaintext highlighter-rouge">JUnit</code>, <code class="language-plaintext highlighter-rouge">mockito</code>, <code class="language-plaintext highlighter-rouge">assertj</code> 등 테스트 코드를 위한 라이브러리를 가져옴
    <ul>
      <li><code class="language-plaintext highlighter-rouge">JUnit</code> : 테스트 프레임워크</li>
      <li><code class="language-plaintext highlighter-rouge">mockito</code> : 목 라이브러리</li>
      <li><code class="language-plaintext highlighter-rouge">assertj</code> : 테스트 코드의 작성을 돕는 라이브러리</li>
      <li><code class="language-plaintext highlighter-rouge">spring-test</code> : 스프링 통합 테스트를 지원</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-devtools</code> 라이브러리 : 어플리케이션 개발 시 유용한 기능을 제공하는 모듈
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Automatic Restart</code> : 브라우저로 전송되는 내용들에 대한 코드가 변경되면, 자동으로 어플리케이션을 재시작
        <ul>
          <li>“고급 설정 &gt; 선택 영역 없이 복사 또는 잘라내기 액션을 호출하면 현재 줄이 복사/잘라내기 되지 않습니다” 체크</li>
          <li>“빌드, 실행, 배포 &gt; 컴파일러 &gt; 프로젝트 자동으로 빌드 (실행/디버그 중이 아닌 경우에만 작동)” 체크</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">Property Defaults</code> : <code class="language-plaintext highlighter-rouge">thymeleaf</code>의 <code class="language-plaintext highlighter-rouge">Application cache</code> 값을 <code class="language-plaintext highlighter-rouge">false</code>로 설정해 개발 환경에서 캐싱 기능 비활성화
        <ul>
          <li><code class="language-plaintext highlighter-rouge">application.properties</code>에서 <code class="language-plaintext highlighter-rouge">spring.thymeleaf.cache</code> 값을 <code class="language-plaintext highlighter-rouge">false</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">test.java.project.AppTests</code>의 <code class="language-plaintext highlighter-rouge">AppTests</code> 클래스를 실행하면, <a href="http://localhost:8080"><code>localhost:8080</code></a>으로 웹 어플리케이션에 접속 가능</p>
</blockquote>

<h3 id="mvc--model-view-controller로-구분"><code class="language-plaintext highlighter-rouge">MVC</code> : <code class="language-plaintext highlighter-rouge">Model</code>, <code class="language-plaintext highlighter-rouge">View</code>, <code class="language-plaintext highlighter-rouge">Controller</code>로 구분</h3>
<ul>
  <li>모델 (<code class="language-plaintext highlighter-rouge">Model</code>) : 컨트롤러에서 데이터를 생성해 이를 뷰에 전달 (<code class="language-plaintext highlighter-rouge">HaspMap</code> 형태 : <code class="language-plaintext highlighter-rouge">key</code>와 <code class="language-plaintext highlighter-rouge">value</code>를 저장)</li>
  <li>뷰 (<code class="language-plaintext highlighter-rouge">View</code>) : 정적 웹 페이지 형식의 <code class="language-plaintext highlighter-rouge">html</code> 파일
    <ul>
      <li>뷰 리졸버 (<code class="language-plaintext highlighter-rouge">View Resolver</code>) : 컨트롤러가 템플릿에 반환한 <code class="language-plaintext highlighter-rouge">html</code> 파일을 찾아 브라우저로 전달</li>
    </ul>
  </li>
  <li>컨트롤러 (<code class="language-plaintext highlighter-rouge">Controller</code>) : 서버에서 온 요청을 받아 서버 로직을 수행한 후 그 결과를 다시 클라이언트에 전달</li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FboF8Pm%2FbtqGbOe7pRd%2FjLnBc46hZG1i9bfZRSSMpK%2Fimg.png" style="width: 80%; height: auto" /></p>

<h4 id="정적-웹-페이지-static-web-page--미리-저장된-파일-그대로-랜더링-과정-없이-전달되는-웹-페이지">정적 웹 페이지 (<code class="language-plaintext highlighter-rouge">Static Web Page</code>) : 미리 저장된 파일 그대로 랜더링 과정 없이 전달되는 웹 페이지</h4>
<ul>
  <li>일반적으로 <code class="language-plaintext highlighter-rouge">.html</code> 형식의 파일들로 저장되었다가 HTTP를 통해 전달
    <ul>
      <li>웹 서버는 사용자의 요쳥에 해당되는 웹 페이지를 보냄</li>
    </ul>
  </li>
  <li>스프링부트에 내장 : <code class="language-plaintext highlighter-rouge">src.resources.static</code> 패키지에 <code class="language-plaintext highlighter-rouge">index.html</code>을 작성하면 첫 화면으로 표현
    <ul>
      <li><code class="language-plaintext highlighter-rouge">templates</code> 패키지에서 접속하려는 파일에 매핑된 컨트롤러가 없으면, <code class="language-plaintext highlighter-rouge">src.resources.static</code> 패키지에서 찾아 반환</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/78904413/161384270-ccdd76ab-6b1f-4af7-bd2e-f94646985dab.png" style="width: 80%; height: auto" /></p>

<h4 id="동적-웹-페이지-dynamic-web-page--스크립트에-의해-처리된-후-생성되어-전달되는-웹-페이지">동적 웹 페이지 (<code class="language-plaintext highlighter-rouge">Dynamic Web Page</code>) : 스크립트에 의해 처리된 후 생성되어 전달되는 웹 페이지</h4>
<ul>
  <li>웹 서버는 사용자의 요청을 해석해 데이터를 가공한 후 생성된 웹 페이지 전달
    <ul>
      <li>클라이언트 사이드 (<code class="language-plaintext highlighter-rouge">Client-side</code>) : 웹 서버가 <code class="language-plaintext highlighter-rouge">JSON</code> 파일을 전달하면, 브라우저에서 자바스크립트로 <code class="language-plaintext highlighter-rouge">HTML</code> 완성
        <ul>
          <li>장점 : 웹 페이지를 처음 로딩할 때 상대적으로 느리지만 유저와의 빠른 인터렉션 가능</li>
          <li>단점 : 봇 크롤러들이 자바 스크립트를 읽지 못해 검색 엔진 최적화 불가능, 쿠키 외 사용자 정보를 담을 수 없음</li>
        </ul>
      </li>
      <li>서버 사이드 (<code class="language-plaintext highlighter-rouge">Server-side</code>) : 클라이언트가 요청할 때마다 웹 서버에서 템플릿에 데이터를 포함한 <code class="language-plaintext highlighter-rouge">HTML</code>를 완성해 전달
        <ul>
          <li>장점 : 웹 페이지를 처음 로딩할 때 상대적으로 빠름</li>
          <li>단점 : 새로운 요청마다 새로고침이 매번 발생해 비효율적임, 사용자에 대한 정보를 서버가 저장</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">Ajax</code> 요청 : 클라이언트가 <code class="language-plaintext highlighter-rouge">Ajax Request</code>을 보내 서버에서 데이터를 받아 <code class="language-plaintext highlighter-rouge">HTML</code> 완성</li>
    </ul>
  </li>
  <li><a href="https://www.thymeleaf.org">타임리프 (<code>thymeleaf</code>) 템플릿 엔진</a> : 정적인 <code class="language-plaintext highlighter-rouge">HTML</code>에 동적인 기능을 부여</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">main.java.group.project</code>에 <code class="language-plaintext highlighter-rouge">Controller</code> 패키지를 생성하고, 그 안에 <code class="language-plaintext highlighter-rouge">helloController</code> 클래스를 작성</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// helloController.java

package group.project.Controller;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller // 컨트롤러 역할을 부여하는 어노테이션

public class helloController {
    @GetMapping("hello")
    public String hello (Model model) {  // Model model : 매개변수로 넣어줄 mvc의 model를 의미
        model.addAttribute("data", "World!");  // 첫번째 패라미터를 두번째 패라미터로 치환
        return "hello";   // 반환값이 들어오면 viewResolver가 resource:templates/ + {ViewName} + .html을 표현
    }
}
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">resources.templates</code>에 <code class="language-plaintext highlighter-rouge">hello.html</code>를 작성하고 <a href="http://localhost:8080/hello"><code>localhost:8080/hello</code></a>에서 템플릿 엔진으로 표현된 페이지 확인</p>
  <blockquote>
    <p>일반 텍스트인 <code class="language-plaintext highlighter-rouge">Let there be light</code> 대신 컨트롤러가 전달한 <code class="language-plaintext highlighter-rouge">attribute</code>의 값인 <code class="language-plaintext highlighter-rouge">hello world!</code>가 출력된다.</p>
  </blockquote>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!--? hello.html --&gt;

&lt;!DOCTYPE HTML&gt;
  &lt;html xmlns:th="http://www.thymeleaf.org"&gt;    &lt;!--? xmlns:th 태그로 타임리프 엔진 선언해 타임리프 문법을 사용 --&gt;
  &lt;head&gt;
    &lt;title&gt;dynamic&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p th:text="'Hello ' + ${data}" &gt;Let there be light&lt;/p&gt; &lt;!--? 컨트롤러롤 통해 받은 첫번째 패라미터를 두번째 패라미터로 치환 --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>

<blockquote>
  <ol>
    <li>웹 브라우저에 주소 (<code class="language-plaintext highlighter-rouge">localhost:8080/hello</code>) 입력</li>
    <li>내장 톰캣 서버가 전달받은 주소를 스프링으로 전송</li>
    <li>스프링이 <code class="language-plaintext highlighter-rouge">helloController</code>에 맵핑된 것을 확인하고 메소드 호출</li>
    <li>스프링이 뷰 리졸버에 반환값과 <code class="language-plaintext highlighter-rouge">model(data:hello!)</code>를 전달</li>
    <li>뷰 리졸버가 템플릿에 반환된 <code class="language-plaintext highlighter-rouge">hello</code>와 동일한 <code class="language-plaintext highlighter-rouge">.html</code> 파일을 찾음</li>
    <li>타임리프 템플릿 엔진이 찾은 <code class="language-plaintext highlighter-rouge">.html</code> 파일을 렌더링</li>
    <li>웹 브라우저가가 변환된 <code class="language-plaintext highlighter-rouge">.html</code> 파일을 화면에 표현</li>
  </ol>
</blockquote>

<p><img src="https://velog.velcdn.com/images%2Fkyukim%2Fpost%2Fab186289-43d1-4d08-8414-f785bc2b23d0%2F2021-02-03_12-52-51.jpg" style="width: 80%; height: auto" /></p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">main.java.group.project.Controller</code>의 <code class="language-plaintext highlighter-rouge">helloController.java</code>와 <code class="language-plaintext highlighter-rouge">resources.templates</code>의 <code class="language-plaintext highlighter-rouge">dynamic.html</code> 수정</p>
  <blockquote>
    <p><a href="localhost:8080/hello-mvc?name=ddd"><code>localhost:8080/hello-mvc?name=ddd</code></a>에서 템플릿 엔진으로 표현된 페이지 확인</p>
  </blockquote>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// helloController.java

package group.project.Controller;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller // 컨트롤러 역할을 부여하는 어노테이션

public class helloController {
    @GetMapping("hello-mvc")  // HTTP GET 요청을 처리하는 메소드를 맵핑해 ".../URL"에 따라 어떤 페이지를 보여줄지 결정하는 어노테이션
    public String helloMvc (@RequestParam("name") String name, Model model) {
    // @requestparam : 패러미터로 값을 전달. 만약 패러미터로 ?name=ddd을 전달받으면 메소드의 name 패러미터의 값은 ddd로 정해짐
        model.addAttribute("name", name);   // 모델의 name attribute의 값을 ddd로 설정
        return "hello-template";    // 반환값이 들어오면 viewResolver가 resource:templates/ + {ViewName} + .html을 표현
    }
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!--? hello-template.html --&gt;

&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;body&gt;
        &lt;p th:text="'hello ' + ${name}"&gt;hello! empty&lt;/p&gt;
        &lt;!--? 일반 텍스트를 컨트롤러가 전달한 attribute의 값으로 치환 --&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>

<blockquote>
  <ol>
    <li>웹 브라우저에 주소 (<code class="language-plaintext highlighter-rouge">localhost:8080/hello-mvc?name=ddd</code>) 입력</li>
    <li>내장 톰캣 서버가 전달받은 주소를 스프링으로 전송</li>
    <li>스프링이 <code class="language-plaintext highlighter-rouge">helloController</code>에 맵핑된 것을 확인하고 메소드 호출</li>
    <li>스프링이 뷰 리졸버에 반환값과 <code class="language-plaintext highlighter-rouge">model(name:ddd)</code>를 전달</li>
    <li>뷰 리졸버가 템플릿에 반환된 <code class="language-plaintext highlighter-rouge">hello-template</code>와 동일한 <code class="language-plaintext highlighter-rouge">.html</code> 파일을 찾음</li>
    <li>타임리프 템플릿 엔진이 찾은 <code class="language-plaintext highlighter-rouge">.html</code> 파일을 렌더링</li>
    <li>웹 브라우저가가 변환된 <code class="language-plaintext highlighter-rouge">.html</code> 파일을 화면에 표현</li>
  </ol>
</blockquote>

<p><img src="https://velog.velcdn.com/images%2Fkyukim%2Fpost%2F2b360d66-22d3-4321-8f06-b0d81c254802%2F2021-02-03_15-22-36.jpg" style="width: 80%; height: auto" /></p>

<h3 id="빌드-build--소스-코드를-브라우저에서-실행할-수-있는-하나의-소프트웨어로-변환하는-작업">빌드 (<code class="language-plaintext highlighter-rouge">Build</code>) : 소스 코드를 브라우저에서 실행할 수 있는 하나의 소프트웨어로 변환하는 작업</h3>

<blockquote>
  <p>어플리케이션 종료 후 콘솔에 다음 명령어를 입력해 빌드</p>
  <blockquote>
    <p>해당 경로의 <code class="language-plaintext highlighter-rouge">lib</code>에 <code class="language-plaintext highlighter-rouge">springmvc-0.0.1-SNAPSHOT.jar</code> 파일이 생성된 것을 확인할 수 있다.</p>
  </blockquote>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./gradlew build   // 프로젝트 빌드
</code></pre></div></div>

<blockquote>
  <p>콘솔에 다음 명령어를 입력해 빌드된 파일로 <code class="language-plaintext highlighter-rouge">IDE</code> 없이 웹 어플리케이션을 동작시킴</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -jar springmvc-0.0.1-SNAPSHOT.jar
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Backend" /><summary type="html"><![CDATA[이 항목은 현재 작성중입니다.&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[D/B] 데이터베이스 (Database)</title><link href="http://localhost:4000/database/database1/" rel="alternate" type="text/html" title="[D/B] 데이터베이스 (Database)" /><published>2022-11-02T00:00:00+09:00</published><updated>2022-11-18T00:00:00+09:00</updated><id>http://localhost:4000/database/database1</id><content type="html" xml:base="http://localhost:4000/database/database1/"><![CDATA[<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br />&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="데이터베이스-database--데이터의-집합">데이터베이스 (<code class="language-plaintext highlighter-rouge">Database</code>) : 데이터의 집합</h2>
<ul>
  <li>데이터 (<code class="language-plaintext highlighter-rouge">Data</code>) : 현실에서 관찰하거나 측정한 사실이나 값
    <ul>
      <li>구조 (<code class="language-plaintext highlighter-rouge">Structure</code>) : 데이터를 저장하기 위해 미리 정한 구조
        <ul>
          <li>정형 데이터 (<code class="language-plaintext highlighter-rouge">Structured Data</code>) : 구조화된 데이터</li>
          <li>반정형 데이터 (<code class="language-plaintext highlighter-rouge">Semi-Structured Data</code>) : 구조화된 데이터이지만, 내용 안에 구조에 대한 설명이 함께 존재
            <ul>
              <li>구조를 파악하는 파싱 (<code class="language-plaintext highlighter-rouge">Parsing</code>) 과정이 필요</li>
            </ul>
          </li>
          <li>비정형 데이터 (<code class="language-plaintext highlighter-rouge">Unstructured Data</code>) : 구조화되지 않은 데이터</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정보 (<code class="language-plaintext highlighter-rouge">information</code>) : 의사 결정에 사용하기 위해 데이터를 가공한 결과물</li>
</ul>

<h3 id="파일-시스템-file-system--컴퓨터에서-데이터를-쉽게-검색하고-접근하기-위해-조직된-체계">파일 시스템 (<code class="language-plaintext highlighter-rouge">File System</code>) : 컴퓨터에서 데이터를 쉽게 검색하고 접근하기 위해 조직된 체계</h3>
<ul>
  <li>데이터 중복성 : 동일한 내용의 데이터가 여러 파일에 중복 저장
    <ul>
      <li>공간 낭비 : 만약 여러 응용 프로그램이 동일한 내용의 데이터를 필요로 한다면, 이를 별도의 파일로 저장</li>
      <li>동기화 문제 : 데이터 일관성과 데이터 무결성을 유지하기 어려움</li>
    </ul>
  </li>
  <li>데이터 종속성 : 응용 프로그램이 데이터 파일에 종속적
    <ul>
      <li>만약 응용 프로그램이 사용하는 파일의 디렉토리를 변경한다면, 응용 프로그램 또한 이에 맞춰 변경해야 함</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>운영체제에 내장된 기존의 파일 시스템으로는 데이터베이스를 효율적으로 관리하는 데에 한계가 있다.</p>
</blockquote>

<h2 id="데이터베이스-구조-database-architecture">데이터베이스 구조 (<code class="language-plaintext highlighter-rouge">Database Architecture</code>)</h2>
<ul>
  <li>데이터 사전 (<code class="language-plaintext highlighter-rouge">Data Dictionary</code>) : 스키마, 매핑 정보, 제약 조건 등을 저장
    <ul>
      <li>스키마 (<code class="language-plaintext highlighter-rouge">Schema</code>) : 데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것
        <ul>
          <li>인스턴스 (<code class="language-plaintext highlighter-rouge">Instance</code>) : 스키마에 따라 데이터베이스에 실제로 저장된 값</li>
        </ul>
      </li>
      <li>매핑 (<code class="language-plaintext highlighter-rouge">Mapping</code>) : 미리 정의된 매핑 정보를 이용해 사용자가 원하는 데이터에 접근
        <ul>
          <li>외부/개념 매핑 : 외부 스키마와 개념 스키마 간의 대응 관계</li>
          <li>개념/내부 매핑 : 개념 스키마와 내부 스키마 간의 대응 관계</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>데이터 디렉터리 (<code class="language-plaintext highlighter-rouge">Data Directory</code>) : 데이터 사전의 데이터에 접근할 때 필요한 위치 정보를 저장하는 시스템 데이터베이스</li>
  <li>사용자 데이터베이스 (<code class="language-plaintext highlighter-rouge">User Database</code>) : 사용자가 실제 사용하는 데이터가 저장되어 있는 데이터베이스</li>
</ul>

<h3 id="3단계-데이터베이스-구조-3-level-database-architecture--하나의-데이터베이스를-3개의-단계로-나눔">3단계 데이터베이스 구조 (<code class="language-plaintext highlighter-rouge">3-Level Database Architecture</code>) : 하나의 데이터베이스를 3개의 단계로 나눔</h3>

<ol>
  <li>외부 단계 (<code class="language-plaintext highlighter-rouge">External Level</code>) : 개별 사용자의 관점 -&gt; 데이터베이스 하나에 외부 스키마가 여러 개 존재할 수 있음</li>
  <li>개념 단계 (<code class="language-plaintext highlighter-rouge">Conceptual Level</code>) : 전체 조직의 관점 -&gt; 데이터베이스 하나에 개념 스키마가 하나만 존재</li>
  <li>내부 단계 (<code class="language-plaintext highlighter-rouge">Internal Level</code>) : 물리적 저장 장치의 관점 -&gt; 데이터베이스 하나에 내부 스키마가 하나만 존재</li>
</ol>

<blockquote>
  <p>외부 단계로 갈수록 더 높은 추상화 레벨 : 사용자에게 데이터베이스 구현과 관련된 내용을 숨기고 단순화된 정보만 제공</p>
</blockquote>

<h4 id="데이터-독립성-data-independency--하위-스키마를-변경하더라도-상위-스키마가-영향을-받지-않음">데이터 독립성 (<code class="language-plaintext highlighter-rouge">Data Independency</code>) : 하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않음</h4>
<ul>
  <li>논리적 데이터 독립성 : 개념 스키마 <code class="language-plaintext highlighter-rouge">-X-&gt;</code> 외부 스키마</li>
  <li>물리적 데이터 독립성 : 내부 스키마 <code class="language-plaintext highlighter-rouge">-X-&gt;</code> 개념 스키마</li>
</ul>

<blockquote>
  <p>데이터베이스를 3단계로 나누고, 단계별로 스카마를 유지하며, 스키마 간 대응 관계를 정의하는 이유 : 데이터 독립성의 실현</p>
</blockquote>

<h3 id="데이터베이스-언어-database-language--사용자와-데이터베이스-관리-시스템-간의-통신-수단">데이터베이스 언어 (<code class="language-plaintext highlighter-rouge">Database Language</code>) : 사용자와 데이터베이스 관리 시스템 간의 통신 수단</h3>
<ul>
  <li>데이터 정의어 (<code class="language-plaintext highlighter-rouge">DDL</code>) : 스키마를 정의, 수정, 삭제하기 위해 사용</li>
  <li>데이터 조작어 (<code class="language-plaintext highlighter-rouge">DML</code>) : 데이터의 삽입, 삭제, 수정, 검색 처리를 요구하기 위해 사용</li>
  <li>데이터 제어어 (<code class="language-plaintext highlighter-rouge">DCL</code>) : 내부적으로 필요한 규칙 및 기법을 정의하기 위해 사용</li>
</ul>

<h3 id="데이터베이스-관리-시스템-database-management-system--데이터를-데이터베이스에-통합해-관리">데이터베이스 관리 시스템 (<code class="language-plaintext highlighter-rouge">Database Management System</code>) : 데이터를 데이터베이스에 통합해 관리</h3>
<blockquote>
  <ul>
    <li>정의 기능 : 데이터베이스의 구조를 정의하거나 수정</li>
    <li>조직 기능 : 데이터를 삽입, 삭제, 수정, 검색하는 연산을 수행</li>
    <li>제어 기능 : 데이터를 항상 정확하고 안전하게 유지</li>
  </ul>
</blockquote>

<ul>
  <li>질의 처리기 (<code class="language-plaintext highlighter-rouge">Query Processor</code>) : 사용자의 데이터 처리 요구를 해석해 처리</li>
  <li>저장 데이터 관리자 (<code class="language-plaintext highlighter-rouge">Stored Data Manager</code>) : 디스크에 저장된 데이터베이스와 데이터 사전을 관리하고 접근</li>
</ul>

<h2 id="데이터-모델-data-model--데이터-모델링의-결과물을-표현하는-도구">데이터 모델 (<code class="language-plaintext highlighter-rouge">Data Model</code>) : 데이터 모델링의 결과물을 표현하는 도구</h2>
<ul>
  <li>데이터 모델링 (<code class="language-plaintext highlighter-rouge">Data Modeling</code>) : 현실 세게의 데이터를 컴퓨터의 데이터베이스로 옮기는 과정
    <ul>
      <li>개념적 데이터 모델링 (<code class="language-plaintext highlighter-rouge">Conceptual Modeling</code>) : 현실 세계의 데이터를 데이터베이스의 개념적 구조로 표현</li>
      <li>논리적 데이터 모델링 (<code class="language-plaintext highlighter-rouge">logical modeling</code>) : 개념 세계의 데이터를 데이터베이스의 논리적 구조로
표현
<br /></li>
    </ul>
  </li>
</ul>

<p><img src="https://mblogthumb-phinf.pstatic.net/20130909_221/james_parku_1378690124507WakE9_JPEG/4.jpg?type=w2" /></p>

<ul>
  <li>데이터 구조 (<code class="language-plaintext highlighter-rouge">Data Structure</code>) : 개체 타입과 이들 간의 관계 명세</li>
  <li>연산 (<code class="language-plaintext highlighter-rouge">Operation</code>) : 개체 인스턴스 처리 작업 명세</li>
  <li>제약 조건 (<code class="language-plaintext highlighter-rouge">Constraint</code>) : 데이터의 논리적 제약 명세</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Database" /><summary type="html"><![CDATA[이 항목은 현재 작성중입니다.&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[B/E] 도커 (Docker)</title><link href="http://localhost:4000/backend/docker1/" rel="alternate" type="text/html" title="[B/E] 도커 (Docker)" /><published>2022-11-02T00:00:00+09:00</published><updated>2022-11-11T00:00:00+09:00</updated><id>http://localhost:4000/backend/docker1</id><content type="html" xml:base="http://localhost:4000/backend/docker1/"><![CDATA[<p class="notice--info"><strong>이 항목은 macOS 기반으로 작성되었습니다.</strong><br />&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="가상화-virtualization--컴퓨터-자원-computer-resource의-추상화">가상화 (<code class="language-plaintext highlighter-rouge">Virtualization</code>) : 컴퓨터 자원 (<code class="language-plaintext highlighter-rouge">Computer Resource</code>)의 추상화</h2>
<ul>
  <li>하드웨어 종속성 배제 : 물리적인 하드웨어 자원을 논리적인 단위로 나누고 이를 통합해 가상의 자원을 활용</li>
</ul>

<h3 id="리소스-가상화-resource-virtualization--컴퓨터-내-특정-자원만을-추상화">리소스 가상화 (<code class="language-plaintext highlighter-rouge">Resource Virtualization</code>) : 컴퓨터 내 특정 자원만을 추상화</h3>
<ul>
  <li>(가상의) 메인 메모리 : 가상 메모리 (<code class="language-plaintext highlighter-rouge">Virtual Memory</code>)</li>
  <li>(가상의) 저장 장치 : 클라우드 (<code class="language-plaintext highlighter-rouge">Cloud</code>)</li>
  <li>(가상의) 그래픽 카드 : <code class="language-plaintext highlighter-rouge">vGPU</code></li>
  <li>(가상의) 네트워크 : 가상 사설 네트워크 (<code class="language-plaintext highlighter-rouge">Virtual Personal Network</code>)</li>
</ul>

<h3 id="플랫폼-가상화-platform-virtualization--여러-개의-프로세스을-구동할-수-있는-플랫폼을-추상화">플랫폼 가상화 (<code class="language-plaintext highlighter-rouge">Platform Virtualization</code>) : 여러 개의 프로세스을 구동할 수 있는 플랫폼을 추상화</h3>
<ul>
  <li>에뮬레이션 (<code class="language-plaintext highlighter-rouge">Emulation</code>) : 다른 컴퓨터 프로세서를 위해 쓰인 운영체제와 응용 프로그램을 실행</li>
  <li>하드웨어 수준 가상화 (<code class="language-plaintext highlighter-rouge">H/W-level Virtualization</code>) : 하드웨어 플랫폼 위의 하이퍼바이저를 통해 가상 머신을 관리함</li>
  <li>
    <p>운영체제 수준 가상화 (<code class="language-plaintext highlighter-rouge">O/S-level Virtualization</code>) : 운영체제의 커널이 각각의 격리된 프로세스를 동작시킴</p>
  </li>
  <li>
    <h4 id="에뮬레이터-emulator--모든-하드웨어-자원의-동작을-소프트웨어로-대체">에뮬레이터 (<code class="language-plaintext highlighter-rouge">Emulator</code>) : 모든 하드웨어 자원의 동작을 소프트웨어로 대체</h4>
    <ul>
      <li>애뮬레이터 안의 응용 프로그램은 물리 하드웨어가 아닌 인터프리터 프로그램을 통해 실행 (<code class="language-plaintext highlighter-rouge">Java Virtual Machine</code>)
        <ul>
          <li>인터프리터 프로그램은 가상 머신에서 명령을 수행할 때마다 물리 CPU가 처리할 바이너리 코드 갱신</li>
          <li>물리 CPU는 에뮬레이터를 실행하기 위한 바이너리 코드를 해석해 이를 대신 실행</li>
        </ul>
      </li>
      <li>장점 : 아키텍쳐가 전혀 다른 하드웨어 역시 가상화할 수 있음 (vs 하이퍼바이저 : 가상화할 수 없음)</li>
      <li>단점 : 물리 CPU 내에서 직접 실행할 때보다 비효율적임</li>
    </ul>
  </li>
  <li>
    <h4 id="하이퍼바이저-hypervisor--다수의-가상-머신을-생성-실행-제어하는-논리적-플랫폼으로써의-프로세스">하이퍼바이저 (<code class="language-plaintext highlighter-rouge">Hypervisor</code>) : 다수의 가상 머신을 생성, 실행, 제어하는 논리적 플랫폼으로써의 프로세스</h4>
    <ul>
      <li>하이퍼바이저 안의 응용 프로그램은 물리 하드웨어를 하이퍼바이저에 의해 제한적으로 사용</li>
      <li>
        <p>하드웨어 가상 머신 (<code class="language-plaintext highlighter-rouge">H/W Virtual Machine</code>) : 하이퍼바이저에 의해 생성된 가상 환경</p>
      </li>
      <li>
        <h5 id="type-1-호스팅-hosting--하이퍼바이저가-일반-프로그램과-같이-운영체제의-소프트웨어-계층에서-실행">Type 1. 호스팅 (<code class="language-plaintext highlighter-rouge">Hosting</code>) : 하이퍼바이저가 일반 프로그램과 같이 운영체제의 소프트웨어 계층에서 실행</h5>
        <ul>
          <li>장점 : 가상의 하드웨어를 구동하기에 호스트 운영 체제에 큰 제약이 없음</li>
          <li>단점 : 호스트 운영 체제 위에서 게스트 운영체제를 구동해 비교적 큰 오버헤드 가짐 / <code class="language-plaintext highlighter-rouge">GPU Passthrough</code> 미지원</li>
        </ul>
      </li>
      <li>
        <h5 id="type-2-네이티브-native--하이퍼바이저를-하드웨어에-직접-임베디드되어-실행">Type 2. 네이티브 (<code class="language-plaintext highlighter-rouge">Native</code>) : 하이퍼바이저를 하드웨어에 직접 임베디드되어 실행</h5>
        <ul>
          <li>장점 : 별도의 호스트 운영체제가 없어 오버헤드가 적음 / 하드웨어를 직접 제어하기에 효율적인 자원 사용 가능</li>
          <li>단점 : 자체적인 가상 머신에 대한 관리 기능이 없기에, 이를 위한 별도의 컴퓨터나 콘솔이 필요</li>
          <li>
            <h6 id="전가상화-full-virtualization--하이퍼바이저에서-명령을-번역">전가상화 (<code class="language-plaintext highlighter-rouge">Full-Virtualization</code>) : 하이퍼바이저에서 명령을 번역</h6>
            <ul>
              <li>게스트 가상 머신이 요청한 명령은 하이퍼바이저가 실행한 관리용 가상 머신 <code class="language-plaintext highlighter-rouge">DOM</code>을 통해 하드웨어에 접근</li>
              <li>하이퍼바이저가 각 가상 머신들의 모든 명령을 번역하여 실행하고, 이에 맞게 자원을 할당해야 함</li>
            </ul>
          </li>
          <li>
            <h6 id="반가상화-para-virtualization--게스트-가상-머신에서-명령을-번역">반가상화 (<code class="language-plaintext highlighter-rouge">Para-Virtualization</code>) : 게스트 가상 머신에서 명령을 번역</h6>
            <ul>
              <li>게스트 가상 머신이 하이퍼 콜 (<code class="language-plaintext highlighter-rouge">Hyper Call</code>)을 통해 하이퍼바이저에 명령을 직접 요청</li>
              <li>게스트 가상 머신의 운영 체제가 하이퍼 콜을 요청할 수 있게 커널을 수정해야 함</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="컨테이너-container--소프트웨어-패키지의-추상화">컨테이너 (<code class="language-plaintext highlighter-rouge">Container</code>) : 소프트웨어 패키지의 추상화</h4>
    <ul>
      <li>컨테이너는 프로세스가 동작하는 격리된 사용자 공간 인스턴스
        <ul>
          <li>하나의 응용 프로그램과 그 응용 프로그램의 동작을 위한 라이브러리로 구성</li>
        </ul>
      </li>
      <li>
        <p>운영체제의 커널은 여러 개의 격리된 컨테이너를 갖추어 각각의 개별적인 서버처럼 동작시킴</p>
      </li>
      <li>
        <h5 id="리눅스-컨테이너-linux-container--리눅스에서-제공하는-운영체제-레벨의-가상화">리눅스 컨테이너 (<code class="language-plaintext highlighter-rouge">Linux Container</code>) : 리눅스에서 제공하는 운영체제 레벨의 가상화</h5>
        <ul>
          <li>커널 레벨의 격리된 (<code class="language-plaintext highlighter-rouge">isolated</code>) 공간만 제공할 뿐, 개발 및 서버 운영에 필요한 부가 기능 부족</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div style="color: white; padding: 3% 2% 2% 2%; background-color: black;">
사용자가 운영체제 A에서만 가능한 a, 운영체제 B에서만 가능한 b, 운영체제 C에서만 가능한 c을 동시에 실행한다고 가정한다면,
<ul>
  <li>에뮬레이션 : 응용 프로그램 ×3 ⊂ 에뮬레이트 운영체제 ×3 ⊂ 에뮬레이터 ×3 ⊂ 호스트 운영체제 ⊂ 하드웨어</li>
  <li>Type 1. 호스팅 : 응용 프로그램 ×3 ⊂ 게스트 운영체제 ×3 ⊂ 하이퍼바이저 ⊂ 호스트 운영체제 ⊂ 하드웨어</li>
  <li>Type 2. 네이티브 &gt; 전가상화 : 응용 프로그램 ×3 ⊂ 게스트 운영체제 ×3 ⊂ DOM ⊂ 하이퍼바이저 ⊂ 하드웨어</li>
  <li>Type 2. 네이티브 &gt; 반가상화 : 응용 프로그램 ×3 ⊂ 수정된 게스트 운영체제 ×3 ⊂ 하이퍼바이저 ⊂ 하드웨어</li>
  <li>운영체제 수준 가상화 : 컨테이너 프로세스 ×3 ⊂ 컨테이너 관리 소프트웨어 ⊂ 운영체제 ⊂ 하드웨어 </li>
</ul>
</div>

<ul>
  <li>Q. <code class="language-plaintext highlighter-rouge">MacOS</code>에서 도커로 윈도우 컨테이너를 실행하는 경우라면? : 응용 프로그램을 실행할 때 (O) 운영 체제를 실행할 때 (X)
    <ul>
      <li>윈도우 컨테이너 ⊂ 가상 머신 (호스팅) ⊂ 컨테이너 관리 소프트웨어 ⊂ 운영체제 ⊂ 하드웨어</li>
    </ul>
  </li>
</ul>

<h2 id="도커-docker--컨테이너-기반-가상화-플랫폼-container-based-virtualization-platform">도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 컨테이너 기반 가상화 플랫폼 (<code class="language-plaintext highlighter-rouge">Container-based Virtualization Platform</code>)</h2>

<p><img src="https://pyrasis.com/assets/images/Docker-HOWTO/docker-containerized-appliction-blue-border_2.png.webp" width="50%" /></p>

<ul>
  <li><a href="https://www.docker.com">공식 홈페이지</a>에서 <code class="language-plaintext highlighter-rouge">.dmg</code> 파일을 다운로드 후 설치</li>
  <li>터미널 창에 다음 명령어를 입력해 도커가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker version // 현재 도커의 버전 확인

Client:
 Cloud integration: ~
 Version:           ~
 API version:       ~
 Go version:        ~

Server: ~
 Engine:
  Version:          ~
  API version:      ~
  Go version:       ~
</code></pre></div></div>
<blockquote>
  <p>Q. 클라이언트와 서버의 버전 정보가 따로 구성되어 있는 이유?</p>
  <ul>
    <li>도커가 클라이언트와 서버의 역할을 각각 수행할 수 있음
      <ul>
        <li>리눅스 터미널에 도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 이를 터미널에 출력</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="q-도커를-쓰는-이유--비교적-효율적인-가상화-방식--통일된-개발-환경--배포의-동시성">Q. 도커를 쓰는 이유? : 비교적 효율적인 가상화 방식 + 통일된 개발 환경 + 배포의 동시성</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Virtualization</code> : 응용 프로그램 실행 시 운영체제 수준 가상화 방식이 성능 손실이 더 적고 빠르게 동작한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Development</code> : 운영체제에 상관없이 같은 환경에서 개발할 수 있게 해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">Deployment</code> : 서비스 환경과 응용 프로그램을 같이 배포할 수 있게 한다.</li>
</ol>

<h3 id="도커-파일-dockerfile--서버-운영-기록을-코드화해-저장한-파일---해당-시점의-도커-이미지-빌드">도커 파일 (<code class="language-plaintext highlighter-rouge">Dockerfile</code>) : 서버 운영 기록을 코드화해 저장한 파일 -&gt; 해당 시점의 도커 이미지 빌드</h3>

<blockquote>
  <p>눈송이 서버 (<code class="language-plaintext highlighter-rouge">Snowflakes Server</code>) : 각각의 서버마다 운영 기록이 다르기에 서로 모양이 다른 서버들이 공존하는 상황</p>
  <ul>
    <li>서버 간의 운영체제, 컴파일러, 설치된 패키지 등의 차이로 발생하는 문제 개선을 위해 서버 운영 기록 저장</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DSL</code> (<code class="language-plaintext highlighter-rouge">Domain-Specific Language</code>) : 도커 파일을 작성할 때 쓰는 언어 (도커 이미지의 생성 과정 표현)</li>
</ul>

<h3 id="q-도커-파일을-쓰는-이유--테스트-주도-개발의-순환에-부합한다">Q. 도커 파일을 쓰는 이유? : 테스트 주도 개발의 순환에 부합한다.</h3>
<ul>
  <li>테스트 주도 개발 (<code class="language-plaintext highlighter-rouge">Test Driven Development</code>) : 선 테스트 후 개발 사이클을 반복하는 개발 방법론</li>
</ul>

<div style="color: white; padding: 2% 1% 1% 1%; background-color: black;">
<ol>
  <li>테스트를 작성한다. : 도커 파일을 만든다.</li>
  <li>테스트에 실패하고 코드를 수정한다. : 도커 이미지의 빌드에 실패하고 도커 파일을 수정한다.</li>
  <li>테스트에 성공한다면, 중복된 코드 등을 리펙터링한다. : 도커 이미지의 빌드에 성공한다면, 도커 파일의 내용을 리펙터링하다.</li>
  <li>처음으로 되돌아간다.</li>
</ol>
</div>

<h3 id="도커-이미지-docker-image--컨테이너의-실행에-필요한-모든-파일과-설정값-정보을-포함">도커 이미지 (<code class="language-plaintext highlighter-rouge">Docker Image</code>) : 컨테이너의 실행에 필요한 모든 파일과 설정값 정보을 포함</h3>
<ul>
  <li>상태값을 가지지 않음 (변하지 않는 값들을 저장) &lt;-&gt; 컨테이너 : 이미지가 실행된 살태 (변하는 값들을 저장)</li>
  <li>이미지 레이어 : 도커 이미지는 여러 개의 읽기 전용 (<code class="language-plaintext highlighter-rouge">Read-Only</code>) 레이어로 구성되고, 파일 추가/생성 시 새로운 레이어를 생성
    <ul>
      <li>유니온 파일 시스템 (<code class="language-plaintext highlighter-rouge">Union File Systems</code>)읕 통해 여러 개의 레이어를 하나의 파일 시스템으로 활용</li>
    </ul>
  </li>
  <li>컨테이너 레이어 : 컨테이너가 실행되면 이미지 레이어 위에 읽기/쓰기 (<code class="language-plaintext highlighter-rouge">Read-Write</code>) 레이어를 추가
    <ul>
      <li>컨테이너를 실행하면서 생성되거나 변경된 내용을 저장</li>
    </ul>
  </li>
  <li>이미지 경로 : <code class="language-plaintext highlighter-rouge">URL</code> 방식으로 관리 -&gt; 뒤에 태그 (<code class="language-plaintext highlighter-rouge">/tag</code>)를 붙임</li>
  <li><a href="https://hub.docker.com"> 도커 허브</a> (<code class="language-plaintext highlighter-rouge">Docker Hub</code>) : 도커 이미지를 서버에 무료로 공개하고 관리</li>
</ul>

<h3 id="q-도커-이미지를-쓰는-이유--도커-이미지와-도커-컨테이너들을-클래스나-인스턴스처럼-활용한다">Q. 도커 이미지를 쓰는 이유? : 도커 이미지와 도커 컨테이너들을 클래스나 인스턴스처럼 활용한다.</h3>
<ul>
  <li>도커는 해시 값 (= 컨테이너 ID)과 임의의 이름 (= 컨테이너 이름)를 통해 컨테이너를 구분하고 이들을 환경변수로 관리</li>
</ul>

<div style="color: white; padding: 3% 2% 2% 2%; background-color: black;">
운영자가 지금까지 운영한 서버를 도커 이미지로 배포하고 도커 컨테이너에 설치한다면,
<ul>
  <li>도커 파일 : 지금까지 서버를 운영한 기록</li>
  <li>도커 이미지 (도커 파일 + 실행 시점) : 지금부터 설치된 서버가 가질 초기값</li>
  <li>도커 컨테이너 (도커 파일 + 환경 변수) : 지금부터 설치된 서버가 운영될 장소</li>
</ul>
</div>
<ul>
  <li>도커 안에서는 서버 역시 하나의 소프트웨어처럼 사용할 수 있고, 생성할 수 있는 컨테이너의 개수에도 제한이 없다.</li>
</ul>

<h2 id="도커-명령어-docker-command--docker-command-형식으로-구성">도커 명령어 (<code class="language-plaintext highlighter-rouge">Docker Command</code>) : <code class="language-plaintext highlighter-rouge">docker &lt;command&gt;</code> 형식으로 구성</h2>
<ul>
  <li>리눅스 터미널에 도커 명령어를 입력하면 도커 서버에서 이에 해당되는 작업 수행</li>
  <li>항상 <code class="language-plaintext highlighter-rouge">root</code> 권한으로 실행되기에 <code class="language-plaintext highlighter-rouge">$ sudo</code>를 앞에 붙어야 함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo usermod -aG docker $USER # 현재 사용자를 docker 그룹에 추가
</code></pre></div></div>

<div style="text-align: center;">
    <table>
        <thead>
            <tr>
                <td>docker 명령어</td>
                <td>명령어 형식</td>
                <td>명령어 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>docker search</td>
                <td>$ docker search [이미지]</td>
                <td>도커 허브에서 이미지 검색</td>
            </tr>
            <tr>
                <td>docker pull</td>
                <td>$ docker pull [사용자명/] 이미지 [:태그]</td>
                <td>도커 허브에서 이미지 다운로드<br />사용자명을 지정해 도커 허브에서 해당 사용자가 올린 이미지을 다운로드<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker image</td>
                <td>$ docker images</td>
                <td>사용 가능한 모든 이미지 목록 확인</td>
            </tr>
            <tr>
                <td>docker rmi</td>
                <td>$ docker rmi 이미지 [:태그]</td>
                <td>다운로드한 이미지 삭제<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker run</td>
                <td>$ docker run [옵션] [실행할 이미지]</td>
                <td>이미지를 컨테이너로 생성한 뒤 컨테이너 실행<br />입력받은 이미지가 현재 없다면, 해당 이미지를 도커 허브에서 다운로드<br />실행할 파일을 지정해 직접 실행 가능 (여기서 빠져나오면 컨테이너가 정지)<br /><div style="text-align: center; font-size: 120%; padding: 2% 0% 0% 0%">
    <table>
        <thead>
            <tr>
                <td>docker run 옵션</td>
                <td>옵션 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>-d</td>
                <td>백그라운드 모드 (detached mode)</td>
            </tr>
            <tr>
                <td>-p [호스트 포트:컨테이너 포트]</td>
                <td>호스트와 컨테이너의 포트를 연결 (port forwarding)<br />http://호스트 IP:호스트 포트로 컨테이너의 포트 접속</td>
            </tr>
            <tr>
                <td>-v [호스트의 디렉터리]</td>
                <td>호스트의 디렉터리를 컨테이너의 디렉터리에 연결 (mount)</td>
            </tr>
            <tr>
                <td>-e [환경변수]</td>
                <td>컨테이너 내에서 사용할 환경변수 설정 (environment variable)</td>
            </tr>
            <tr>
                <td>-name [컨테이너 이름]</td>
                <td>컨테이너 이름 설정 (container name)</td>
            </tr>
            <tr>
                <td>-rm</td>
                <td>프로세스 종료 시 컨테이너 자동으로 제거 (remove container)</td>
            </tr>
            <tr>
                <td>-link [컨테이너 이름:주소]</td>
                <td>컨테이너와 컨테이너 연결 (link container)<br />[주소:포트번호]로 컨테이너에 접속</td>
            </tr>
            <tr>
                <td>-it</td>
                <td>리눅스 터미널 입력을 위한 옵션 (interactive / Pseudo-tty)</td>
            </tr>
         </tbody>
    </table>
</div></td>
            </tr>
            <tr>
              <td>docker ps</td>
              <td>$ docker ps [옵션]</td>
              <td>실행중인 모든 컨테이너 목록 확인<br />-a 옵션으로 정지된 컨테이너까지 모두 검색</td>
            </tr>
            <tr>
              <td>docker start</td>
              <td>$ docker start [컨테이너 이름 | 컨테이너 ID]</td>
              <td>정지된 컨테이너 재시작</td>
            </tr>
            <tr>
              <td>docker stop</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너 정지</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker exec</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]<br />[명령] [매개 변수]</td>
              <td>컨테이너 외부에서 컨테이너 내의 명령 실행</td>
            </tr>
            <tr>
              <td>docker diff</td>
              <td>$ docker diff [컨테이너 이름 | 컨테이너 ID]</td>
              <td>컨테이너가 실행되면서 변경된 파일 목록 확인<br />A : 추가된 파일<br />C : 변경된 파일<br />D : 삭제된 파일</td>
            </tr>
            <tr>
              <td>docker cp</td>
              <td>$ docker cp [컨테이너 이름 | 컨테이너 ID]<br />[:컨테이너 경로] [호스트 경로]</td>
              <td>컨테이너의 파일을 호스트의 디렉토리로 복사</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker rm</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>생성된 컨테이너 삭제</td>
            </tr>
            <tr>
              <td>docker commit</td>
              <td>$ docker commit [옵션] [컨테이너 이름 | 컨테이너 ID]<br />[이미지 이름] [:태그]</td>
              <td>컨테이너를 이미지 파일로 생성</td>
            </tr>
            <tr>
              <td>docker build</td>
              <td>$ docker build [옵션] [도커 파일 경로]<br />[--tag 이미지 이름 : 이미지 태그] </td>
              <td>도커 파일에 설정된 내용대로 도커 이미지 생성<br />--tag 뒤에 이미지 이름와 이미지 태그를 설정할 수 있음</td>
            </tr>
            <tr>
              <td>docker history</td>
              <td>$ docker history [이미지 이름 | 이미지 ID] [:태그]</td>
              <td>도커 파일에 설정된 내용대로 이미지 히스토리 생성</td>
            </tr>
            <tr>
              <td>docker inspect</td>
              <td>$ docker inspect<br />[이미지나 컨테이너 이름 | 이미지나 컨테이너 ID]</td>
              <td>이미지나 컨테이너의 세부 정보 출력</td>
            </tr>
         </tbody>
    </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Backend" /><summary type="html"><![CDATA[이 항목은 macOS 기반으로 작성되었습니다.&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[F/E] JavaScript</title><link href="http://localhost:4000/frontend/js1/" rel="alternate" type="text/html" title="[F/E] JavaScript" /><published>2022-10-09T00:00:00+09:00</published><updated>2022-10-30T00:00:00+09:00</updated><id>http://localhost:4000/frontend/js1</id><content type="html" xml:base="http://localhost:4000/frontend/js1/"><![CDATA[<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br />&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="자바스크립트-javascript--웹-문서가-동적으로-표현하는-것을-구현하는-객체-기반-스크립트-언어">자바스크립트 (<code class="language-plaintext highlighter-rouge">JavaScript</code>) : 웹 문서가 동적으로 표현하는 것을 구현하는 객체 기반 스크립트 언어</h2>
<ul>
  <li>동적으로 구현되어 타입을 명시할 필요가 없는 인터프리터 언어</li>
  <li>프로토타입 (<code class="language-plaintext highlighter-rouge">prototype</code>) 기반의 객체 지향 언어이나, 함수형 프로그래밍 또한 표현 가능</li>
  <li>대다수 웹 브라우저 내에 인터프리터가 내장되어 사용되나, <code class="language-plaintext highlighter-rouge">Node.js</code>와 같은 프레임워크를 통해 서버 측 프로그래밍에서도 가능
    <ul>
      <li>웹의 내용을 표현하는 <code class="language-plaintext highlighter-rouge">HTML</code>의 내용, 속성, 스타일을 변경할 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="-javascript를-html에-적용시키는-방법"># JavaScript를 HTML에 적용시키는 방법</h3>

<h4 id="--internal-javascript--html-태그의-속성-script에-javascript-코드를-넣는-방법">- <code class="language-plaintext highlighter-rouge">Internal JavaScript</code> : HTML 태그의 속성 <code class="language-plaintext highlighter-rouge">script=""</code>에 JavaScript 코드를 넣는 방법</h4>
<hr />

<p>입력 :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
  alert ("Hello");
&lt;/script&gt;
</code></pre></div></div>

<h4 id="--linking-javascript--별도의-js-파일을-만들고-이를-html-문서와-연결하는-방법">- <code class="language-plaintext highlighter-rouge">Linking JavaScript</code> : 별도의 .js 파일을 만들고 이를 HTML 문서와 연결하는 방법</h4>
<hr />

<p>입력 :</p>
<blockquote>
  <p>→ hello.js</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alert ("Hello");
</code></pre></div>  </div>
</blockquote>

<blockquote>
  <p>→ index.html</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script src="hello.js"&gt;&lt;/script&gt;
</code></pre></div>  </div>
</blockquote>

<h2 id="변수-variable--데이터-data를-저장할-수-있는-메모리-공간">변수 (<code class="language-plaintext highlighter-rouge">variable</code>) : 데이터 (<code class="language-plaintext highlighter-rouge">data</code>)를 저장할 수 있는 메모리 공간</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var x;
</code></pre></div></div>

<h3 id="객체-object--변수를-객체로-선언하고-초기화">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 변수를 객체로 선언하고 초기화</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jb = {'a': 100, 'b': 200, 'c': 300};
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jb = {};
jb['a'] = 100;
jb['b'] = 200;
jb['c'] = 300;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jb = new Object();
jb['a'] = 100;
jb['b'] = 200;
jb['c'] = 300;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jb = new Object();
jb.a = 100;
jb.b = 200;
jb.c = 300;
</code></pre></div></div>

<h3 id="배열-array--변수를-배열로-선언하고-초기화">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 변수를 배열로 선언하고 초기화</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jbAry = new Array();
jbAry[0] = 'a';
jbAry[1] = 'b';
jbAry[2] = 'c';
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jbAry = [ 'a', 'b', 'c' ];
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var jbAry = new Array( 'a', 'b', 'c' );
</code></pre></div></div>

<table style="text-align: center">
    <thead>
        <tr>
            <td>Array 메소드</td>
            <td>Array 메소드에 대한 설명</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>jb.length</td>
            <td>배열의 길이 반환</td>
        </tr>
        <tr>
            <td>var njb = jb.concat( 원소 혹은 배열 )</td>
            <td>기존 배열에 원소 혹은 배열을 추가해 새로운 배열 선언</td>
        </tr>
        <tr>
            <td>jb.every( function( x ) { return 조건 } )</td>
            <td>배열의 원소를 오름차순으로 검사 : 조건을 만족하지 않는 원소가 있으면 false, 없으면 true 반환</td>
        </tr>
        <tr>
            <td>jb.indexOf( 검색할 값, 검색을 시작할 인덱스 값 )</td>
            <td>시작할 인덱스 값부터 검색해 값과 일치하는 원소가 존재하면 해당 인덱스 값 반환, 없으면 -1 반환</td>
        </tr>
        <tr>
            <td>jb.lastIndexOf( 검색할 값, 검색을 시작할 인덱스 값 )</td>
            <td>시작할 인덱스 값부터 역순으로 검색해 값과 일치하는 원소가 존재하면 해당 인덱스 값 반환, 없으면 -1 밥환</td>
        </tr>
        <tr>
            <td>var njb = jb.join( 원소들을 구분할 값 (기본값 : ,) )</td>
            <td>기존 배열에 있는 원소들을 연결해 하나의 문자열로 만듬 (el1,el2,el3)</td>
        </tr>
        <tr>
            <td>jb.push( 추가할 원소 ) / jb.unshift( 추가할 원소 )</td>
            <td>배열의 맨 끝에 / 맨 앞에 원소를 추가</td>
        </tr>
        <tr>
            <td>jb.pop() / jb.shift()</td>
            <td>배열의 맨 끝에 / 맨 앞에 위치한 원소를 제거</td>
        </tr>
        <tr>
            <td>jb.reverse()</td>
            <td>배열의 원소 순서를 역순으로 만듬</td>
        </tr>
        <tr>
            <td>var njb = jb.slice( 시작할 인덱스 값, 끝낼 인덱스 값 )</td>
            <td>기존 배열에서 배열의 인덱스을 선택해 새로운 배열을 만듬</td>
        </tr>
        <tr>
            <td>jb.splice( 시작할 인덱스 값, 추출할 원소의 개수, 넣을 값 )</td>
            <td>기존 배열에서 배열의 범위를 선택해 새로운 배열을 만들고, 추출한 자리에 새로운 값을 넣음</td>
        </tr>
    </tbody>
</table>

<h3 id="문자열-string--변수를-문자열로-선언하고-초기화">문자열 (<code class="language-plaintext highlighter-rouge">string</code>) : 변수를 문자열로 선언하고 초기화</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var x = 'varX'
var y = 'varY'; var z = 'varZ'
</code></pre></div></div>

<table style="text-align: center">
    <thead>
        <tr>
            <td>String 메소드</td>
            <td>String 메소드에 대한 설명</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>str.length</td>
            <td>문자열의 길이 반환</td>
        </tr>
        <tr>
            <td>str.charAt( 반환할 인덱스 값 ) / str.charCodeAt( 반환할 인덱스 값 )</td>
            <td>특정 위치에 있는 문자 반환 / 특정 위치에 있는 문자의 유니코드 값 반환</td>
        </tr>
        <tr>
            <td>str.concat( 문자열1 [, 문자열2 ... [, 문자열N ] ]  )</td>
            <td>문자열에 문자열을 연결 (인수가 문자열이 아닌 경우 : 인수를 문자열로 반환) </td>
        </tr>
        <tr>
            <td>str.startsWith( 확인할 문자열, 확인할 범위 )</td>
            <td>기존 문자열의 (0~범위) 내 문자열이 특정 문자열으로 시작하는지 확인해 맞으면 true, 아니면 false 반환</td>
        </tr>
        <tr>
            <td>str.endsWith( 확인할 문자열, 확인할 범위 )</td>
            <td>기존 문자열의 (0~범위) 내 문자열이 특정 문자열로 끝나는지 확인해 맞으면 true, 아니면 false 반환</td>
        </tr>
        <tr>
            <td>str.includes( 검색할 문자열, 검색을 시작할 인덱스 값 )</td>
            <td>문자열이 검색할 문자열을 포함하는지 탐색할 때 포함하면 true 반환, 포함하지 않으면 false 반환</td>
        </tr>
        <tr>
            <td>str.indexOf( 검색할 문자열, 검색을 시작할 인덱스 값 )</td>
            <td>시작할 인덱스 값부터 검색해 일치하는 문자열이 존재하면 해당 인덱스 값 반환, 없으면 -1 반환</td>
        </tr>
        <tr>
            <td>str.lastIndexOf( 검색할 문자열, 검색을 끝낼 인덱스 값 )</td>
            <td>검색을 끝낼 인덱스 값까지 검색해 일치하는 문자열이 존재하면 해당 인덱스 값 반환, 없으면 -1 반환</td>
        </tr>
        <tr>
            <td>str.repeat ( 반복한 횟수 )</td>
            <td>문자열을 반복한 값 반환</td>
        </tr>
        <tr>
            <td>str.replace ( 찾을 문자열, 바꿀 문자열 )</td>
            <td>기존 문자열 내에서 특정 문자열을 찾아서 다른 문자열로 바꿈</td>
        </tr>
        <tr>
            <td>str.split( 분할할 때의 기준, 최대로 분할할 개수 )</td>
            <td>기존 문자열을 기준에 맞게 분할해 배열의 여러 원소로 만듬</td>
        </tr>
        <tr>
            <td>str.substr( 추출을 시작할 인덱스 값, 추출할 문자열의 길이 )</td>
            <td>기존 문자열에서 문자열의 범위를 지정해 추출한 문자열 반환</td>
        </tr>
        <tr>
            <td>str.substring( 시작할 인덱스 값, 끝낼 인덱스 값 )</td>
            <td>기존 문자열에서 문자열의 인덱스를 선택해 추출한 문자열 반환</td>
        </tr>
         <tr>
            <td>str.fromCharCode( 바꿀 인덱스 값 )</td>
            <td>문자에 해당되는 유니코드 변환</td>
        </tr>
    </tbody>
</table>

<h2 id="연산자-operator">연산자 (<code class="language-plaintext highlighter-rouge">operator</code>)</h2>
<ul>
  <li>단항 연산자 / 이항 연산자 / 다항 연산자 : 필요한 항의 개수가 1개 / 2개 / 3개인 연산자</li>
</ul>

<h3 id="비교-연산자--------">비교 연산자 <code class="language-plaintext highlighter-rouge">==</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">===</code>, <code class="language-plaintext highlighter-rouge">!===</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code></h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7 == 7      // 왼쪽의 변수는 오른쪽의 변수와 같다.
'7' == 7    // 왼쪽의 문자열은 오른쪽의 변수와 같다.
3 != 7      // 왼쪽의 변수는 오른쪽의 변수가 같지 않다.
3 === 3     // 왼쪽의 변수는 오른쪽의 변수와 엄격하게 같다.
3 !=== '3'  // 왼쪽의 변수는 오른쪽의 문자열과 엄격하게 같지 않다.
7 &gt; 3       // 왼쪽의 변수는 오른쪽의 변수보다 크다.
7 &gt;= '3'    // 왼쪽의 변수는 오른쪽의 문자열보다 크거나 같다.
'3' &lt; 7     // 왼쪽의 문자열은 오른쪽의 변수보다 작다.
3 &lt;= 3      // 왼쪽이 변수는 오른쪽의 변수보다 작거나 크다.
</code></pre></div></div>

<h3 id="변수-데이터-타입-반환-연산자-typeof">변수 데이터 타입 반환 연산자 <code class="language-plaintext highlighter-rouge">typeof</code></h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">undefined</code> : 변수가 정의되지 않거나 값이 존재하지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">number</code> : 변수 데이터 타입이 숫자</li>
  <li><code class="language-plaintext highlighter-rouge">string</code> : 변수 데이터 타입이 문자열</li>
  <li><code class="language-plaintext highlighter-rouge">boolean</code> : 변수 데이터 타입이 <code class="language-plaintext highlighter-rouge">bool</code>형</li>
  <li><code class="language-plaintext highlighter-rouge">object</code> : 변수 데이터 타입이 함수, 배열 등 객체</li>
  <li><code class="language-plaintext highlighter-rouge">function</code> : 변수의 값이 함수</li>
  <li><code class="language-plaintext highlighter-rouge">symbol</code> : 변수 데이터 타입이 <code class="language-plaintext highlighter-rouge">symbol</code>형</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var x;
    document.write( "typeof x : " + typeof x + "&lt;br&gt;" );

    var x = 3;
    document.write( "typeof x = 3 : " + typeof x + "&lt;br&gt;" );

    var x = 'varX';
    document.write( "typeof x = 'varX' : " + typeof x + "&lt;br&gt;" );

    var x = true;
    document.write( "typeof x = true : " + typeof x + "&lt;br&gt;" );

    var x = [ 'y', 'z' ];
    document.write( "typeof x = [ 'y', 'z' ] : " + typeof x + "&lt;br&gt;" );

    function x(){};
    document.write( "typeof x(){} : " + typeof x + "&lt;br&gt;" );

    var x = function(){};
    document.write( "typeof x = function(){} : " + typeof x + "&lt;br&gt;" );

    var x = Symbol();
    document.write( "typeof x : " + typeof x = Symbol() + "&lt;br&gt;" );
&lt;/script&gt;
</code></pre></div></div>

<h3 id="조건-연산자-if-else-if-else-switch">조건 연산자 <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else</code>, <code class="language-plaintext highlighter-rouge">switch</code></h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (condition1) {
    statement1
} else if (condition2) {
    statement2
} else {
    statement3
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch ( condition ) {
    case value1:
        statement1;
        break;
    case value2:
        statement2;
        break;
    default:
        statement3;
}
</code></pre></div></div>

<h3 id="반복-연산자-while-dowhile-for">반복 연산자 <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">do~while</code>, <code class="language-plaintext highlighter-rouge">for</code></h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while ( condition ) {
  statement;
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do {
    statement;
} while ( condition )
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( initial; condition; repeat) {
    statement;
}
</code></pre></div></div>

<h2 id="함수-function">함수 (<code class="language-plaintext highlighter-rouge">function</code>)</h2>

<ul>
  <li>함수 선언</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function functionName( argument1, argument2, ... ) {
    statement;
} // 함수 호출은 함수 선언 전후에 가능
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var functionName = function( argument1, argument2, ... ) {
  statement;
}; // 함수 호출은 함수 선언 후에만 가능
</code></pre></div></div>

<ul>
  <li>함수 호출</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>functionName( value1, value2, ... );
</code></pre></div></div>

<ul>
  <li>전역 변수 (<code class="language-plaintext highlighter-rouge">global variable</code>) : 함수 외부에서 선언된 변수
    <ul>
      <li>프로그램 전체에서 접근 가능</li>
    </ul>
  </li>
  <li>지역 변수 (<code class="language-plaintext highlighter-rouge">local variable</code>) : 함수 내부에서 선언된 변수
    <ul>
      <li>함수가 실행되면 만들어지고 함수가 종료되면 소멸</li>
      <li>함수 외부에서는 접근 불가
<br /><br /></li>
    </ul>
  </li>
  <li>내장 함수 (<code class="language-plaintext highlighter-rouge">built-in function</code>)
    <ul>
      <li>사용자의 편의를 위해 다양한 기능의 여러 전역 함수를 미리 정의하여 제공</li>
      <li>자바스크립트의 어떤 타입의 객체에서도 바로 사용 가능</li>
    </ul>
  </li>
</ul>

<h3 id="eval--문자열을-javascript-코드로-인식하게-하는-내장-함수"><code class="language-plaintext highlighter-rouge">eval()</code> : 문자열을 javascript 코드로 인식하게 하는 내장 함수</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var code = '1 + 2';
    document.write( x );                   // 1 + 2
	document.write( eval( code ) );    // 3
&lt;/script&gt;
</code></pre></div></div>

<h3 id="number-string--문자열을-숫자로--숫자를-문자열로-변환하는-내장-함수"><code class="language-plaintext highlighter-rouge">Number()</code>, <code class="language-plaintext highlighter-rouge">String()</code> : 문자열을 숫자로 / 숫자를 문자열로 변환하는 내장 함수</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var a = '2';
    var b = '3';
    var c = a + b;
    var d = Number( a ) + Number( b );
    document.write(c);  //  12
    document.write(d);  //  3
&lt;/script&gt;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var a = 4;
    var b = 5;
    var c = a + b;
    var d = String( a ) + String( b );
    document.write(c);  //  9
    document.write(d);  //  45
&lt;/script&gt;
</code></pre></div></div>

<h3 id="parseint-parsefloat--문자열을-정수형으로--정수형을-문자열로-변환하는-내장-함수"><code class="language-plaintext highlighter-rouge">parseInt()</code>, <code class="language-plaintext highlighter-rouge">parseFloat()</code> : 문자열을 정수형으로 / 정수형을 문자열로 변환하는 내장 함수</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    document.write( parseInt( '17' ) );         // 17
    document.write( parseFloat( '3.14' ) );     // 3.14
&lt;/script&gt;
</code></pre></div></div>

<h3 id="encodeuri-decodeuri-------를-뺀-문자를-인코딩--문자열을-디코딩하는-내장-함수"><code class="language-plaintext highlighter-rouge">encodeURI()</code>, <code class="language-plaintext highlighter-rouge">decodeURI()</code> : <code class="language-plaintext highlighter-rouge">:</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">&amp;</code>를 뺀 문자를 인코딩 / 문자열을 디코딩하는 내장 함수</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var u = 'https://pocj8ur4in.github.io';
    var encU = encodeURI( u );
    document.write( u );                    // https://pocj8ur4in.github.io
	document.write( encU );             // https://pocj8ur4in.github.io를 인코딩한 문자열
	document.write( decodeURI( u ) );   // https://pocj8ur4in.github.io를 인코딩한 문자열을 디코딩한 결과
&lt;/script&gt;
</code></pre></div></div>

<h3 id="encodeuricomponent-decodeuricomponent--모든-문자를-인코딩--문자열을-디코딩하는-내장-함수"><code class="language-plaintext highlighter-rouge">encodeURIComponent()</code>, <code class="language-plaintext highlighter-rouge">decodeURIComponent()</code> : 모든 문자를 인코딩 / 문자열을 디코딩하는 내장 함수</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var u = 'https://pocj8ur4in.github.io';
    var encU = encodeURIComponent( u );
    document.write( u );                            // https://pocj8ur4in.github.io
	document.write( encU );                     // https://pocj8ur4in.github.io를 인코딩한 문자열
	document.write( decodeURIComponent( u ) );  // https://pocj8ur4in.github.io를 인코딩한 문자열을 디코딩한 결과 
&lt;/script&gt;
</code></pre></div></div>

<h3 id="isnan--매개변수가-숫자인지-검사하는-내장-함수-false--숫자-o-true--숫자-x"><code class="language-plaintext highlighter-rouge">isNaN()</code> : 매개변수가 숫자인지 검사하는 내장 함수 (<code class="language-plaintext highlighter-rouge">false</code> : 숫자 O, <code class="language-plaintext highlighter-rouge">true</code> : 숫자 X)</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var a = 11;             
    var b = '11.11';        
    var c = 'NaN';          
    var d = 11 * 11;        
    var e = '11 * 11';
    document.write(isNaN(a));   // false
    document.write(isNaN(b));   // false
    document.write(isNaN(c));   // true (문자이므로 숫자가 아닌 것)
    document.write(isNaN(d));   // false
    document.write(isNaN(e));   // true (따옴표 안에 문자가 있으므로 숫자가 아닌 것)
&lt;/script&gt;
</code></pre></div></div>

<h3 id="isfinite--매개변수가-유한한-수인지-검사하는-내장-함수-false-문자이거나-무한한-수-true--유한한-수"><code class="language-plaintext highlighter-rouge">isFinite()</code> : 매개변수가 유한한 수인지 검사하는 내장 함수 (<code class="language-plaintext highlighter-rouge">false</code>: 문자이거나 무한한 수, <code class="language-plaintext highlighter-rouge">true</code> : 유한한 수)</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    var a = 12;
    var b = Infinity;
    var c = 'NaN';
    document.write(isFinite(a));    // 유한한 숫자이므로 true
    document.write(isFinite(b));    // 무한한 숫자이므로 false
    document.write(isFinite(c));    // 문자이므로 false
&lt;/script&gt;
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Frontend" /><category term="HTML" /><summary type="html"><![CDATA[이 항목은 현재 작성중입니다.&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[B/E] 운영체제 (Operation System)</title><link href="http://localhost:4000/backend/os1/" rel="alternate" type="text/html" title="[B/E] 운영체제 (Operation System)" /><published>2022-10-07T00:00:00+09:00</published><updated>2022-11-01T00:00:00+09:00</updated><id>http://localhost:4000/backend/os1</id><content type="html" xml:base="http://localhost:4000/backend/os1/"><![CDATA[<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br />&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="운영체제-operation-system--사용자가-컴퓨터에서-실행한-프로그램을-관리하고-제어">운영체제 (<code class="language-plaintext highlighter-rouge">Operation System</code>) : 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어</h2>
<ul>
  <li>컴퓨터 시스템 자원의 효율적인 관리 (<code class="language-plaintext highlighter-rouge">Performance</code>) : 하드웨어 자원을 각각의 사용자 응용 프로그램에 적절히 분배
    <ul>
      <li>하드웨어 자원 (<code class="language-plaintext highlighter-rouge">Hardware Resource</code>) : CPU 시간, 기억 장치 및 디스크 영역, I/O 장치</li>
    </ul>
  </li>
  <li>사용자 편의성 제공 (<code class="language-plaintext highlighter-rouge">Convenience</code>) : 사용자가 더 편리하게 사용할 수 있는 환경을 구성</li>
</ul>

<div style="color: white; padding: 2% 0% 2% 0%; background-color: black;">
<ul>
  <li>프로세스 관리 (Process Management)</li>
  <li>메인 메모리 관리 (Main Memory Management)</li>
  <li>파일 관리(File Management)</li>
  <li>저장 장치 관리 (Storage Management)</li>
  <li>I/O 장치 관리 (I/O Device Management)</li>
  <li>시스템 호출 (System call)</li>
</ul>
</div>

<h3 id="부팅-booting--컴퓨터를-시작할-때-자기-자신을-구동시킬-프로그램을-스스로-불러내는-동작">부팅 (<code class="language-plaintext highlighter-rouge">Booting</code>) : 컴퓨터를 시작할 때 자기 자신을 구동시킬 프로그램을 스스로 불러내는 동작</h3>
<ul>
  <li>메인 메모리 (<code class="language-plaintext highlighter-rouge">Main Memory</code>) : 즉시 필요한 데이터를 저장하는 주 기억 장치
    <ul>
      <li><code class="language-plaintext highlighter-rouge">RAM</code> : 휘발성 주 기억 장치 (전원이 꺼지면 모든 내용이 지워짐)
        <ul>
          <li>코드 영역 (<code class="language-plaintext highlighter-rouge">Code Area</code>) : 실행할 프로그램의 코드가 저장되는 영역
            <ul>
              <li>CPU는 이 영역에 저장된 명령어를 하나씩 호출해 수행함</li>
            </ul>
          </li>
          <li>데이터 영역 (<code class="language-plaintext highlighter-rouge">Data Area</code>) : 실행할 프로그램의 전역 변수와 정적 변수가 저장되는 영역
            <ul>
              <li>프로그램 시작 시 할당, 프로그램 종료 시 소멸</li>
            </ul>
          </li>
          <li>스택 영역 (<code class="language-plaintext highlighter-rouge">Stack Area</code>) : 실행할 프로그램의 함수의 호출과 관련된 지역 변수와 매개 변수가 정적으로 저장되는 영역
            <ul>
              <li>후입선출 (<code class="language-plaintext highlighter-rouge">Last-In, First-Out</code>) 방식에 따른 동작 : <code class="language-plaintext highlighter-rouge">PUSH</code>로 데이터를 저장하고, <code class="language-plaintext highlighter-rouge">POP</code>로 데이터를 인출</li>
              <li>메모리의 높은 주소에서 메모리의 낮은 주소의 방향으로 할당</li>
              <li>함수 호출 시 할당, 함수 호출 종료 시 소멸</li>
            </ul>
          </li>
          <li>힙 영역 (<code class="language-plaintext highlighter-rouge">Heap Area</code>) : 사용자에 의해 동적으로 할당되고 해제되는 전역 변수가 저장되는 영역
            <ul>
              <li>할당되는 변수의 크기 제한이 없음 : 크기 제한이 존재하는 스택에 비해 액세스 속도가 상대적으로 느림</li>
              <li>CPU에 의해 효율적으로 관리되는 스택 영역과 달리, 사용자가 힙 영역을 관리해야 함
                <ul>
                  <li>메모리 단편화 (<code class="language-plaintext highlighter-rouge">Memory Fragmentation</code>) : 사용 가능한 메모리가 존재하지만, 할당이 불가능한 상태</li>
                </ul>
              </li>
              <li>메모리의 낮은 주소에서 메모리의 높은 주소의 방향으로 할당</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ROM</code> : 비휘발성 주 기억 장치 (전원이 꺼져도 그 안의 내용이 계속 유지)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">POST</code> (<code class="language-plaintext highlighter-rouge">Power-On Self-Test</code>) : (부팅 시 가장 처음 실행되는 프로그램) 현재 컴퓨터의 상태 검사</li>
          <li>부트 로더 (<code class="language-plaintext highlighter-rouge">Boot Loader</code>) : (<code class="language-plaintext highlighter-rouge">POST</code> 다음에 실행되는 프로그램) 보조 기억 장치의 운영체제를 탐색 후 <code class="language-plaintext highlighter-rouge">RAM</code>에 할당
            <ul>
              <li>보조 기억 장치에서 <code class="language-plaintext highlighter-rouge">RAM</code>으로 할당된 운영체제는 컴퓨터 전원이 꺼질 때까지 상주 (<code class="language-plaintext highlighter-rouge">Resident</code>)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SSD</code>/<code class="language-plaintext highlighter-rouge">HDD</code> : 운영체제가 저장된 보조 기억 장치
    <ul>
      <li>커널 (<code class="language-plaintext highlighter-rouge">Kernel</code>) : 운영체제가 수행하는 모든 작업이 저장</li>
      <li>명령어 해석기 (<code class="language-plaintext highlighter-rouge">Shell</code>) : 사용자가 요청하는 명령어를 해석해 커널에 요청하고 결과를 출력
        <ul>
          <li>응용 프로그램 (<code class="language-plaintext highlighter-rouge">Application</code>) : 운영체제 위에서 수행되며, 운영체제가 지원하는 자원만을 사용 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="일괄-처리-시스템-batch-processing-system--프로그램-수행-과정의-자동화">일괄 처리 시스템 (<code class="language-plaintext highlighter-rouge">Batch Processing System</code>) : 프로그램 수행 과정의 자동화</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Resident Monitor</code> : 프로세서에 할당하기 위해 (컴파일 -&gt; 링크 -&gt; 로딩)의 과정을 하나의 프로그램으로 작성</li>
</ul>

<h3 id="시분할-시스템-time-sharing-system--cpu가-프로그램을-수행하는-시간을-제한">시분할 시스템 (<code class="language-plaintext highlighter-rouge">Time-sharing System</code>) : CPU가 프로그램을 수행하는 시간을 제한</h3>
<ul>
  <li>스위칭 (<code class="language-plaintext highlighter-rouge">Switching</code>) : 프로그램이 일정 시간 실행되면 <code class="language-plaintext highlighter-rouge">Time Out</code>을 발생시켜 다음 프로그램으로 넘어가게 함</li>
  <li>다중 작업 (<code class="language-plaintext highlighter-rouge">Multitasking</code>) : CPU가 짧은 시간 내에 여러 프로그램을 스위칭해 동시에 작업하는 것처럼 보이게 함
    <ul>
      <li>CPU 스케줄링 (<code class="language-plaintext highlighter-rouge">CPU Scheduling</code>) : CPU가 어느 프로그램을 실행할지 선택하는 작업</li>
    </ul>
  </li>
</ul>

<h3 id="다중-프로그래밍-시스템-multiprogramming-system--메모리에-여러-응용-프로그램을-적재시켜-idle-상태-최소화">다중 프로그래밍 시스템 (<code class="language-plaintext highlighter-rouge">Multiprogramming System</code>) : 메모리에 여러 응용 프로그램을 적재시켜 idle 상태 최소화</h3>
<ul>
  <li>프로그램 실행 시에 계산을 담당하는 <code class="language-plaintext highlighter-rouge">CPU</code>와 입출력을 담당하는 <code class="language-plaintext highlighter-rouge">I/O</code> 장치가 교대로 실행
    <ul>
      <li><code class="language-plaintext highlighter-rouge">idle</code>상태 : I/O 장치가 실행되는 동안 CPU가 아무런 작업도 하지 않는 상태</li>
    </ul>
  </li>
</ul>

<h3 id="인터럽트-기반-시스템-interrupt-based-system--인터럽트-발생-시-isr에-맞는-처리-수행">인터럽트 기반 시스템 (<code class="language-plaintext highlighter-rouge">Interrupt-based System</code>) : 인터럽트 발생 시 <code class="language-plaintext highlighter-rouge">ISR</code>에 맞는 처리 수행</h3>
<ul>
  <li>인터럽트 (<code class="language-plaintext highlighter-rouge">Interrupt</code>) : 프로그램 실행 중에 예기치 않은 상황이 발생할 경우 이를 CPU에 알리는 전기 신호
    <ul>
      <li>외부 인터럽트 (<code class="language-plaintext highlighter-rouge">Eternal Interrupt</code>) = 하드웨어 인터럽트 (<code class="language-plaintext highlighter-rouge">Hardware Interrupt</code>)</li>
      <li>내부 인터럽트 (<code class="language-plaintext highlighter-rouge">Internal Interrupt</code>) = 소프트웨어 언터럽트 (<code class="language-plaintext highlighter-rouge">Software Interrupt</code>)
        <ul>
          <li>예외 (<code class="language-plaintext highlighter-rouge">Exception</code>)</li>
          <li>시스템 호출 (<code class="language-plaintext highlighter-rouge">System call</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>인터럽트 서비스 루틴 (<code class="language-plaintext highlighter-rouge">Interrupt Service Routine</code>) : 인터럽트 신호를 처리하기 위한 방법을 내포한 운영체제 내의 코드</li>
</ul>

<h3 id="이중-모드-dual-mode-execution--유저-user-모드와-커널-kernel-모드를-나눔">이중 모드 (<code class="language-plaintext highlighter-rouge">Dual Mode Execution</code>) : 유저 (<code class="language-plaintext highlighter-rouge">User</code>) 모드와 커널 (<code class="language-plaintext highlighter-rouge">Kernel</code>) 모드를 나눔</h3>

<blockquote>
  <p>! 문제 : 어떤 작업이 자원을 계속해서 점유하는 일과 같이 컴퓨터의 작업 효율을 저해하는 행위로부터 보호할 수단을 필요</p>
</blockquote>

<ul>
  <li>CPU 내 레지스터 (<code class="language-plaintext highlighter-rouge">Register</code>)의 <code class="language-plaintext highlighter-rouge">Mode-Bit</code>를 플래그 (<code class="language-plaintext highlighter-rouge">flag</code>)로 활용해 나타냄 (커낼 모드 : <code class="language-plaintext highlighter-rouge">0</code>, 유저 모드 : <code class="language-plaintext highlighter-rouge">1</code>)</li>
  <li>각 명령어에 <code class="language-plaintext highlighter-rouge">Mode-Bit</code>를 넣어 시스템 내의 <code class="language-plaintext highlighter-rouge">Mode-Bit</code>와 같을 시에만 명령어 수행</li>
  <li>특권 명령어 (<code class="language-plaintext highlighter-rouge">Privileged Instruction</code>) : 커널 모드에서만 내릴 수 있는 명령어
    <ul>
      <li><code class="language-plaintext highlighter-rouge">STOP</code>, <code class="language-plaintext highlighter-rouge">HALT</code>, <code class="language-plaintext highlighter-rouge">RESET</code>, <code class="language-plaintext highlighter-rouge">SET_TIMER</code> 등</li>
      <li>유저 모드에서는 특권 명령어를 내릴 수 없음 (내부 인터럽트를 발생해 해당 명령어를 요청한 프로그램을 강제 종료)</li>
    </ul>
  </li>
  <li>시스템 호출 (<code class="language-plaintext highlighter-rouge">System Call</code>) : <code class="language-plaintext highlighter-rouge">Mode-Bit</code>를 바꾸는 행위 (<code class="language-plaintext highlighter-rouge">INT 80</code>)
    <ul>
      <li>사용자가 하드웨어의 자원에 접근할 때, 프로그램에서 시스템 호출을 발생시켜 운영체제에 위임해 커널 모드로 처리</li>
    </ul>
  </li>
</ul>

<blockquote>
  <ul>
    <li>컴퓨터가 부팅되는 과정 : 커널 모드</li>
    <li>응용 프로그램이 실행되는 과정 : 커널 모드</li>
    <li>응용 프로그램이 실행되는 중일 때 : 유저 모드</li>
    <li>인터럽트가 발생한 후 처리하는 과정 : 커널 모드</li>
    <li>인터럽트를 처리한 후 : 유저 모드</li>
  </ul>
</blockquote>

<h4 id="하드웨어-보호-hw-protection--잘못된-명령이나-접근으로부터-보호하기-위해-운영체제에서-내부-인터럽트를-발생">하드웨어 보호 (<code class="language-plaintext highlighter-rouge">H/W Protection</code>) : 잘못된 명령이나 접근으로부터 보호하기 위해 운영체제에서 내부 인터럽트를 발생</h4>

<blockquote>
  <p>! 문제 : 정보들이 여러 I/O 장치를 통해 컴퓨터로 입출력되는 과정에서 장치 간 혹은 데이터 간의 혼선이 발생할 수 있음</p>
</blockquote>

<h5 id="입출력-장치-보호-io-protection--in-out과-같은-입출력-명령을-특권-명령으로-지정해-운영체제를-통해-수행">입출력 장치 보호 (<code class="language-plaintext highlighter-rouge">I/O Protection</code>) : <code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">out</code>과 같은 입출력 명령을 특권 명령으로 지정해 운영체제를 통해 수행</h5>
<ul>
  <li>입출력 수행 시에는 관리자 모드로 전환해 특권 명령을 내림
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Privileged Instruction Violation</code> : 사용자가 입출력 명령을 직접 내린 경우 프로그램을 강제 종료</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>! 문제 : 다른 사용자나 운영체제에 할당된 메모리 영역에 접근해 정보나 프로그램을 해킹할 수 있음</p>
</blockquote>

<h5 id="메모리-보호-memory-protection--cpu와-메인-메모리-간-주소-버스에-mmu-memory-management-unit를-설치">메모리 보호 (<code class="language-plaintext highlighter-rouge">Memory Protection</code>) : CPU와 메인 메모리 간 주소 버스에 <code class="language-plaintext highlighter-rouge">MMU</code> (<code class="language-plaintext highlighter-rouge">Memory Management Unit</code>)를 설치</h5>
<ul>
  <li>두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장</li>
  <li>사용자에 할당된 메모리 영역을 벗어난 주소값을 가져오지 못하게 함</li>
  <li><code class="language-plaintext highlighter-rouge">MMU</code> 설정은 운영체제만 변경 가능
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Segment Violation</code> : 만약 사용자에 할당된 메모리 영역을 벗어난 주소값이 <code class="language-plaintext highlighter-rouge">MMU</code>에 들어오면 내부 인터럽트를 발생시킴</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>! 문제 : 프로그램에서의 무한 루프로 인해 CPU가 독점되어 다른 프로그램이 수행되지 못할 수 있음</p>
</blockquote>

<h5 id="cpu-보호-cpu-protection--타이머-timer를-두어-일정-시간이-지나면-타이머-인터럽트를-발생시킴">CPU 보호 (<code class="language-plaintext highlighter-rouge">CPU Protection</code>) : 타이머 (<code class="language-plaintext highlighter-rouge">Timer</code>)를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킴</h5>
<ul>
  <li>타이머 (<code class="language-plaintext highlighter-rouge">Timer</code>) : 무한 루프나 자원 독점을 막기 위해 특정 시간이 지나면 타이머 인터럽트를 발생시킴
    <ul>
      <li>타이머 인터럽트 (<code class="language-plaintext highlighter-rouge">Timer Interrupt</code>) : 해당 인터럽트의 ISR에서 CPU는 각 프로그램의 CPU 점유 시간을 측정해 분배</li>
      <li>운영체제는 타이머가 끝난 작업을 종료시키고 스케줄링 (<code class="language-plaintext highlighter-rouge">Scheduling</code>) 이전에 타이머 실행</li>
    </ul>
  </li>
</ul>

<h2 id="프로세스-process--실제-메인-메모리에-할당되어-실행-중인-프로그램">프로세스 (<code class="language-plaintext highlighter-rouge">Process</code>) : 실제 메인 메모리에 할당되어 실행 중인 프로그램</h2>
<ul>
  <li>프로그램은 보조 기억 장치에서 아무런 동작을 하지 않은 상태</li>
  <li>어떤 요청에 의해 메인 메모리에 할당되어 CPU를 사용하면서 실행</li>
  <li>각각의 프로세스는 CPU에 의해 샐행된 후 …를 생성 (메인 메모리를 효율적으로 사용해야 함)
    <ul>
      <li>프로세스 테이블 엔트리 = 프로세스 컨트롤 블록 (<code class="language-plaintext highlighter-rouge">Process Control Block</code>)</li>
      <li>주소 공간 (<code class="language-plaintext highlighter-rouge">Address Space</code>)
        <ul>
          <li>코드 세그먼트 (<code class="language-plaintext highlighter-rouge">Code Segment</code>) : 프로그램 소스 코드가 저장</li>
          <li>데이터 세그먼트 (<code class="language-plaintext highlighter-rouge">Data Segment</code>) : 전역 변수가 저장</li>
          <li>스택 세그먼트 (<code class="language-plaintext highlighter-rouge">Stack Segment</code>) : 지역변수와 매개변수가 저장</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>지역변수와 매개 변수가 후입선출의 방식을 따른 스택에 저장되기에, 전역 변수를 먼저 선언해 메인 메모리의 공간 절약 가능</p>
</blockquote>

<h3 id="프로세스의-생성과-종료-creation-and-destruction-of-process">프로세스의 생성과 종료 (<code class="language-plaintext highlighter-rouge">Creation and Destruction of Process</code>)</h3>
<ul>
  <li>최초의 프로세스인 <code class="language-plaintext highlighter-rouge">Init</code>의 생성은 부팅된 운영체제가 처음 수행하는 작업 중 하나</li>
  <li>생성된 프로세스가 다른 프로세스를 생성하는 과정을 반복
    <ul>
      <li>프로세스의 생성을 위한 시스템 호출 : <code class="language-plaintext highlighter-rouge">fork()</code></li>
      <li>프로세스의 종료를 위한 시스템 호출 : <code class="language-plaintext highlighter-rouge">exit()</code></li>
    </ul>
  </li>
  <li>생성된 모든 프로세스는 자신을 식별할 수 있는 고유의 정수값인 <code class="language-plaintext highlighter-rouge">PID</code>을 가짐
    <ul>
      <li>생성된 모든 프로세스는 자신을 생성한 사용자 고유의 <code class="language-plaintext highlighter-rouge">UID</code> 값 또한 가짐 (부모와 자식이 동일한 값)</li>
    </ul>
  </li>
</ul>

<p><img src="https://i.stack.imgur.com/6RGIe.jpg" width="30%" style="margin-left: 2%" /></p>

<ul>
  <li>프로세스 트리 (<code class="language-plaintext highlighter-rouge">Process Tree</code>) : 부모 프로세스인 A에서 자식 프로세스인 B, C, D가 파생되어 생성
    <ul>
      <li>부모 프로세스 : 프로세스를 생성한 프로세스</li>
      <li>자식 프로세스 : 프로세스로부터 생성된 프로세스</li>
      <li>형제 프로세스 : 같은 부모 프로세스에서 파생된 자식 프로세스</li>
    </ul>
  </li>
</ul>

<h3 id="프로세스-컨트롤-블록-process-control-block--프로세스에-대한-모든-정보를-저장하는-곳">프로세스 컨트롤 블록 (<code class="language-plaintext highlighter-rouge">Process Control Block</code>) : 프로세스에 대한 모든 정보를 저장하는 곳</h3>
<ul>
  <li>CPU는 여러 프로세스를 빈번히 전환하면서 수행하기에 각 프로세스의 데이터를 저장해야 작업을 이어서 수행할 수 있음</li>
  <li>운영체제 내에서 프로세스를 관리하는 코드 부분에 저장
    <ul>
      <li>프로세스 컨트롤 블록에 데이터를 저장하고 복원하는 시간 역시 다중 작업을 위해 각 프로세스에 할당되는 시간에 포함</li>
    </ul>
  </li>
  <li>프로세스 상태 (<code class="language-plaintext highlighter-rouge">Process Status</code>), 프로그램 카운터 (<code class="language-plaintext highlighter-rouge">Program Counter</code>), 스택 포인터 (<code class="language-plaintext highlighter-rouge">Stack Pointer</code>), 파일 디스크립터 (<code class="language-plaintext highlighter-rouge">File Descriptors</code>) 등의 정보 포함</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34755287/70577652-12841080-1bef-11ea-8f1c-5c0e0d94c132.png" width="80%" style="margin-left: 2%" /></p>

<h4 id="프로세스-상태-process-status--각-단계들에서-상태-전이가-일어나-다음-단계로-넘어감">프로세스 상태 (<code class="language-plaintext highlighter-rouge">Process Status</code>) : 각 단계들에서 상태 전이가 일어나 다음 단계로 넘어감</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">New</code> : 프로그램이 메인 메모리에 할당된 상태</li>
  <li><code class="language-plaintext highlighter-rouge">Ready</code> : 프로세스가 언제든 실행 가능한 상태; 할당된 프로그램이 실행되기 위한 모든 준비를 마친 상태로 대기된 상태
    <ul>
      <li>n개의 작업이 있을 때, CPU의 프로세서는 스케줄러의 0~(n-1)번, 즉 n개의 작업을 번갈아 처리</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Running</code> : CPU가 해당 프로세스를 실제로 실행중인 상태</li>
  <li><code class="language-plaintext highlighter-rouge">Waiting</code>=<code class="language-plaintext highlighter-rouge">Blocked</code> : <code class="language-plaintext highlighter-rouge">Running</code>이 불가능한 상태
    <ul>
      <li>프로세스가 끝나지 않은 시점에 해당되는 I/O 정보가 없어 작업할 수 없음</li>
      <li><code class="language-plaintext highlighter-rouge">Waiting</code>가 끝나면 다시 CPU에 실행되기 위해 <code class="language-plaintext highlighter-rouge">Ready</code>로 돌아가야 함</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Terminated</code> : 프로세스가 완전히 종료된 상태</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png" width="80%" style="margin-left: 2%" /></p>

<blockquote>
  <ul>
    <li>I/O 작업으로 인한 상태 변화 : <code class="language-plaintext highlighter-rouge">Running</code> -&gt; <code class="language-plaintext highlighter-rouge">Waiting</code> -&gt; <code class="language-plaintext highlighter-rouge">Ready</code> -&gt; <code class="language-plaintext highlighter-rouge">Running</code></li>
    <li>시간 초과로 인터럽트에 의한 상태 변화 : <code class="language-plaintext highlighter-rouge">Running</code> -&gt; <code class="language-plaintext highlighter-rouge">Ready</code> -&gt; <code class="language-plaintext highlighter-rouge">Running</code></li>
  </ul>
</blockquote>

<h3 id="프로세스-큐-process-queue--커널이-프로세스-스케줄링을-위해-데이터-영역에서-관리하는-큐">프로세스 큐 (<code class="language-plaintext highlighter-rouge">Process Queue</code>) : 커널이 프로세스 스케줄링을 위해 데이터 영역에서 관리하는 큐</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Ready Queue</code> : 프로세스 상태가 <code class="language-plaintext highlighter-rouge">Ready</code>인 프로세스들이 CPU 제어를 기다리는 큐
    <ul>
      <li>어떤 CPU 스케줄링 알고리즘을 선택하는지에 따라 CPU 제어 순서가 달라짐</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Job Queue</code> : 보조 기억 장치의 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐
    <ul>
      <li>시스템 내의 모든 프로세스 관리 : <code class="language-plaintext highlighter-rouge">Ready Queue</code>, <code class="language-plaintext highlighter-rouge">Device Queue</code>에 속한 모든 프로세스 포함</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Device Queue</code> : 프로세스 상태가 <code class="language-plaintext highlighter-rouge">Waiting</code>인 프로세스들이 CPU 외의 자원을 기다리는 큐
    <ul>
      <li>기다리는 자원들마다 큐가 할당되며, 해당 자원이 사용되면 인터럽트를 발생시키고 <code class="language-plaintext highlighter-rouge">Ready Queue</code>로 이동</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34755287/53879660-5ccdd500-4052-11e9-972d-11ba3faeb3e3.png" width="80%" style="margin-left: 2%" /></p>

<ul>
  <li>각 큐는 프로세스의 프로세스 컨트롤 블록을 가리키는 포인터 방식으로 연결 리스트를 구현</li>
</ul>

<h4 id="스케줄러-cpu-scheduler--프로세스-순서를-정해-프로세스-큐에-올릴-것을-결정하는-커널의-코드">스케줄러 (<code class="language-plaintext highlighter-rouge">CPU Scheduler</code>) : 프로세스 순서를 정해 프로세스 큐에 올릴 것을 결정하는 커널의 코드</h4>
<ul>
  <li>장기 스케줄러 (<code class="language-plaintext highlighter-rouge">Long-term Scheduler</code>) : 생성된 프로세스 중 어떤 것을 <code class="language-plaintext highlighter-rouge">Job Queue</code>에서 <code class="language-plaintext highlighter-rouge">Ready Queue</code>으로 이동시킬지 선택
    <ul>
      <li>장기 스케줄러는 현재 메모리에 할당된 프로세스의 개수 (<code class="language-plaintext highlighter-rouge">Degree of multiprogramming</code>)를 제어</li>
      <li>장기 스케줄러는 <code class="language-plaintext highlighter-rouge">I/O bound Process</code>,<code class="language-plaintext highlighter-rouge">CPU bound Process</code>를 메인 메모리에 적절히 할당해야 함
        <ul>
          <li><code class="language-plaintext highlighter-rouge">I/O bound Process</code> : I/O 작업 (입출력) 비중이 높은 프로세스</li>
          <li><code class="language-plaintext highlighter-rouge">CPU bound Process</code> : CPU 작업 (계산) 비중이 높은 프로세스</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>중기 스케줄러 (<code class="language-plaintext highlighter-rouge">Medium-term Scheduler</code>) : 실행 중인 프로세스 중 보조 저장 장치로 옮길 것을 주기적으로 검사
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Swapping</code> (<code class="language-plaintext highlighter-rouge">Swap-out</code>↔<code class="language-plaintext highlighter-rouge">Swap-in</code>) : <code class="language-plaintext highlighter-rouge">Swap-in</code>할 때 이전 공간으로 재할당되는 것은 보장되지 않음
        <ul>
          <li><code class="language-plaintext highlighter-rouge">Swap-out</code> : 메인 메모리에서 우선 순위가 은 프로세스를 통째로 보조 기억 장치로 저장</li>
          <li><code class="language-plaintext highlighter-rouge">Swap-in</code> : 나중에 해당 프로세스가 다시 사용되려 할 때 보조 기억 장치에서 메인 메모리에 다시 할당</li>
        </ul>
      </li>
      <li>중기 스케줄러 또한 현재 메모리에 할당된 프로세스의 개수 (<code class="language-plaintext highlighter-rouge">Degree of multiprogramming</code>)를 제어</li>
    </ul>
  </li>
  <li>단기 스케줄러 (<code class="language-plaintext highlighter-rouge">Short-term Scheduler</code>) : <code class="language-plaintext highlighter-rouge">Ready Queue</code> 내에서 프로세스들 중 어떤 것을 다음에 실행시킬지 선택
    <ul>
      <li>CPU 스케줄러 (<code class="language-plaintext highlighter-rouge">CPU Scheduler</code>) 라고도 부르며, 시분할 시스템에서 <code class="language-plaintext highlighter-rouge">Time Out</code>이 발생하면 호출</li>
    </ul>
  </li>
</ul>

<h5 id="문맥-전환-context-switching--cpu가-실행중인-프로세스를-멈추고-다른-프로세스를-실행하는-작업">문맥 전환 (<code class="language-plaintext highlighter-rouge">Context Switching</code>) : CPU가 실행중인 프로세스를 멈추고 다른 프로세스를 실행하는 작업</h5>
<ul>
  <li>문맥 (<code class="language-plaintext highlighter-rouge">Context</code>) : 각 프로세스 컨트롤 블록 내에서 표현
    <ul>
      <li>하드웨어 문맥 : 프로그램 카운터 정보와 레지스터 정보를 저장</li>
      <li>프로세스 주소 공간 : 각 프로세스가 갖고 있는 독자적인 주소 공간에 위치</li>
    </ul>
  </li>
  <li>CPU 스케줄러 : CPU가 어느 프로세스를 다음에 실행할지 지정</li>
  <li>디스패쳐 (<code class="language-plaintext highlighter-rouge">Dispatcher</code>) : 문맥 전환이 발생하면 <code class="language-plaintext highlighter-rouge">Ready</code>에서 <code class="language-plaintext highlighter-rouge">Running</code>으로 상태 전이
    <ul>
      <li>문맥 전환 오버헤드 (<code class="language-plaintext highlighter-rouge">Context Switching Overhead</code>) : 문맥 전환이 발생할 때마다 디스패쳐를 매번 실행시킴<br /><br /></li>
    </ul>
  </li>
</ul>

<ol>
  <li>CPU에서 실행중인 프로세스의 데이터는 해당 프로세스의 프로세스 컨트롤 블록에 갱신</li>
  <li>새로 시작될 프로세스의 프로세스 컨트롤 블록를 CPU로 복원</li>
  <li>캐시와 <code class="language-plaintext highlighter-rouge">Translation Lookup Buffer</code>를 재설정</li>
</ol>

<blockquote>
  <ul>
    <li>시스템 호출로 인한 인터럽트 발생 시 :
      <ul>
        <li>실행 중인 프로세스의 문맥을 프로세스 컨트롤 블록에 갱신하나, 문맥 전환은 이루어지지 않음</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="cpu-스케줄링-cpu-scheduling--cpu-스케줄러에서-어느-프로세스를-다음에-실행할지-지정">CPU 스케줄링 (<code class="language-plaintext highlighter-rouge">CPU Scheduling</code>) : CPU 스케줄러에서 어느 프로세스를 다음에 실행할지 지정</h2>
<ul>
  <li>선점 (<code class="language-plaintext highlighter-rouge">Preemptive</code>) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 강제로 점유할 수 있음</li>
  <li>비선점 (<code class="language-plaintext highlighter-rouge">Non-Preemptive</code>) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 점유할 수 없음 (예외 : <code class="language-plaintext highlighter-rouge">I/O</code> 발생)</li>
</ul>

<h3 id="cpu-스케줄링-척도-cpu-scheduling-criteria--cpu-스케줄링의-효율을-분석하는-기준">CPU 스케줄링 척도 (<code class="language-plaintext highlighter-rouge">CPU Scheduling Criteria</code>) : CPU 스케줄링의 효율을 분석하는 기준</h3>
<ul>
  <li>CPU 점유율 (<code class="language-plaintext highlighter-rouge">CPU Utilization</code>) : 현재 CPU가 작업을 수행하는 비율 -&gt; 높을수록 좋음</li>
  <li>처리율 (<code class="language-plaintext highlighter-rouge">Throughput</code>) : 단위 시간 당 완료되는 프로세스의 개수 -&gt; 많을수록 좋음</li>
  <li>소요 시간 (<code class="language-plaintext highlighter-rouge">Turnaround Time</code>) : 프로세스가 생성된 시간부터 종료되는 데까지 걸린 시간 -&gt; 짧을수록 좋음</li>
  <li>대기 시간 (<code class="language-plaintext highlighter-rouge">Waiting Time</code>) : CPU 제어를 위해 <code class="language-plaintext highlighter-rouge">Ready Queue</code>에서”만” 대기한 시간 -&gt; 짧을수록 좋음
    <ul>
      <li>평균 대기 시간 (<code class="language-plaintext highlighter-rouge">Average Waiting Time</code>) : (각 프로세스들의 대기 시간의 합) / (프로세스들의 개수)</li>
    </ul>
  </li>
  <li>응답 시간 (<code class="language-plaintext highlighter-rouge">Response Time</code>) : <code class="language-plaintext highlighter-rouge">Interactive System</code>에서 입력에 대한 반응 시간 -&gt; 짧을수록 좋음</li>
</ul>

<h3 id="선입선출-first-come-first-served-스케줄링--가장-먼저-작업을-요청한-프로세스를-먼저-수행">선입선출 (<code class="language-plaintext highlighter-rouge">First-Come, First-Served</code>) 스케줄링 : 가장 먼저 작업을 요청한 프로세스를 먼저 수행</h3>
<ul>
  <li>비선점 (<code class="language-plaintext highlighter-rouge">Non-Preemptive</code>)</li>
  <li>들어온 순서대로 작업을 수행한다고 해도 그것이 반드시 효율적이지 않음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Convoy Effect</code> : CPU를 많이 점유하는 프로세스가 먼저 수행되어 나머지 프로세스들이 그만큼 오래 대기하는 것</li>
    </ul>
  </li>
</ul>

<blockquote>
  <table style="text-align: center">
 	<thead>
		<tr>
			<th>Process</th>
			<th>Burst Time (msec)</th>
		</tr>
	</thead>
   	<tbody>
      <tr>
        <td>P1</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>24</td>
      </tr>
    </tbody>
</table>
  <ul>
    <li>FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (0 + 3 + 6) / 3 = 3msec</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <table style="text-align: center">
 	<thead>
		<tr>
			<th>Process</th>
			<th>Burst Time (msec)</th>
		</tr>
	</thead>
   	<tbody>
      <tr>
        <td>P1</td>
        <td>24</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>3</td>
      </tr>
    </tbody>
</table>
  <ul>
    <li>FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (0 + 24 + 27) / 3 = 17msec</li>
      </ul>
    </li>
    <li>CPU를 오래 점유하는 P3로 인해 상대적으로 빠른 처리가 가능한 P1과 2가 오래 대기하는 Convoy Effect이 발생!</li>
  </ul>
</blockquote>

<h3 id="최단작업-shortest-job-first-스케줄링--시간이-가장-짧게-수행되는-프로세스를-먼저-수행">최단작업 (<code class="language-plaintext highlighter-rouge">Shortest-Job-First</code>) 스케줄링 : 시간이 가장 짧게 수행되는 프로세스를 먼저 수행</h3>
<ul>
  <li>비선점 (<code class="language-plaintext highlighter-rouge">Non-Preemptive</code>), 선점 (<code class="language-plaintext highlighter-rouge">Preemptive</code>)</li>
  <li>일반적으로 가장 빠른 평균 대기 시간을 가지나, 현실에서는 각 프로세스의 CPU 점유 시간이 주어져 있지 않기에 비현실적</li>
</ul>

<blockquote>
  <table style="text-align: center">
 	<thead>
		<tr>
			<th>Process</th>
			<th>Burst Time (msec)</th>
		</tr>
	</thead>
   	<tbody>
      <tr>
        <td>P1</td>
        <td>6</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>8</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>7</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>3</td>
      </tr>
    </tbody>
</table>
  <ul>
    <li>FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, P4 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (0 + 6 + 14 + 21) / 4 = 10.25msec</li>
      </ul>
    </li>
    <li>SJF Scheduling : (작업 시간이 짧은 순서대로) P4, P1, P3, P2 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (0 + 3 + 9 + 16) / 4 = 7msec</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="우선순위-priority-스케줄링--우선순위가-가장-높은-프로세스를-먼저-수행">우선순위 (<code class="language-plaintext highlighter-rouge">Priority</code>) 스케줄링 : 우선순위가 가장 높은 프로세스를 먼저 수행</h3>
<ul>
  <li>비선점 (<code class="language-plaintext highlighter-rouge">Non-Preemptive</code>), 선점 (<code class="language-plaintext highlighter-rouge">Preemptive</code>)</li>
  <li>우선순위는 정수값으로 표현되며, 값이 작을수록 우선순위가 높음</li>
</ul>

<blockquote>
  <table style="text-align: center">
 	<thead>
		<tr>
			<th>Process</th>
			<th>Burst Time (msec)</th>
      <th>Priority</th>
		</tr>
	</thead>
   	<tbody>
      <tr>
        <td>P1</td>
        <td>10</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>2</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>1</td>
        <td>5</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>5</td>
        <td>2</td>
      </tr>
    </tbody>
</table>
  <ul>
    <li>Priority Scheduling : (우선순위가 높은 순서대로) P2, P5, P1, P3, P4 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (0 + 1 + 6 + 16 + 18) / 5 = 8.2 msec</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="라운드-로빈-round-robin-스케줄링--원-모양으로-모든-프로세스를-돌아가면서-수행">라운드 로빈 (<code class="language-plaintext highlighter-rouge">Round-Robin</code>) 스케줄링 : 원 모양으로 모든 프로세스를 돌아가면서 수행</h3>
<ul>
  <li>선점 (<code class="language-plaintext highlighter-rouge">Preemptive</code>)</li>
  <li>시분할 시스템에서 CPU가 한 프로세스를 일정 시간 수행한 후, 이를 대기 상태로 보내고 다음 프로세스를 수행하는 것을 반복
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Time Quantum</code> : CPU가 한 프로세스를 수행하는 시간 -&gt; 스케줄리의 효율성이 <code class="language-plaintext highlighter-rouge">Time Quantum</code>의 크기에 의존</li>
    </ul>
  </li>
</ul>

<blockquote>
  <table style="text-align: center">
 	<thead>
		<tr>
			<th>Process</th>
			<th>Burst Time (msec)</th>
      <th>Time Quantum</th>
		</tr>
	</thead>
   	<tbody>
      <tr>
        <td>P1</td>
        <td>7</td>
        <td rowspan="3">4msec</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>4</td>
      </tr>
    </tbody>
</table>
  <ul>
    <li>RP Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, 그리고 (완료하지 못한) P1 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (4 + 8 + 12) / 3 = 8 msec</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <table style="text-align: center">
 	<thead>
		<tr>
			<th>Process</th>
			<th>Burst Time (msec)</th>
      <th>Time Quantum</th>
		</tr>
	</thead>
   	<tbody>
      <tr>
        <td>P1</td>
        <td>7</td>
        <td rowspan="3">3msec</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>4</td>
      </tr>
    </tbody>
</table>
  <ul>
    <li>RP Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, (완료하지 못한) P1, P2, P3, 그리고 P1 순으로 처리한다.
      <ul>
        <li>Average Waiting Time : (12 + 13 + 14) / 3 = 13 msec</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="멀티레벨-큐-multi-level-queue-스케줄링--각-프로세스-그룹에-따른-큐를-두어-수행">멀티레벨 큐 (<code class="language-plaintext highlighter-rouge">Multi-level Queue</code>) 스케줄링 : 각 프로세스 그룹에 따른 큐를 두어 수행</h3>
<ul>
  <li>프로세스 그룹 : 프로세스를 기준에 따라 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Interactive Process</code> : 유저 수준 &gt; 데이터를 바로바로 처리 (<code class="language-plaintext highlighter-rouge">I/O bound Process</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">Batch Process</code> : 유저 수준 &gt; 일정 시간에 데이터를 한번에 처리 (<code class="language-plaintext highlighter-rouge">CPU bound Process</code>)</li>
    </ul>
  </li>
  <li>우선순위에 따라 대기할 큐를 지정할 수 있고, 각 큐마다 서로 다른 스케줄링 방식을 사용 가능</li>
</ul>

<h3 id="멀티레벨-피드백-큐-multi-level-feedback-queue-스케줄링--멀테레벨-큐에-피드백-추가">멀티레벨 피드백 큐 (<code class="language-plaintext highlighter-rouge">Multi-level Feedback Queue</code>) 스케줄링 : 멀테레벨 큐에 피드백 추가</h3>
<ul>
  <li>멀티레벨 큐처럼 프로세스를 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치
    <ul>
      <li>모든 프로세스들은 처음에는 무조건 우선순위가 가장 높은 큐에서 대기 (vs 멀티레벨 큐 : 우선순위에 따른 큐 지정 가능)</li>
    </ul>
  </li>
  <li>피드백 (<code class="language-plaintext highlighter-rouge">Feedback</code>) : <code class="language-plaintext highlighter-rouge">time out</code>이 발생한 프로세스를 보다 낮은 우선순위의 큐로 격하
    <ul>
      <li>우선순위와 <code class="language-plaintext highlighter-rouge">CPU burst</code>가 반비례 : <code class="language-plaintext highlighter-rouge">I/O bound Process</code>는 높은 우선순위, <code class="language-plaintext highlighter-rouge">CPU bound Process</code>는 낮은 우선순위</li>
    </ul>
  </li>
</ul>

<h2 id="프로세스-간-통신-inter-process-communication--프로세스들-간에-서로-데이터를-주고받는-행위">프로세스 간 통신 (<code class="language-plaintext highlighter-rouge">Inter-Process Communication</code>) : 프로세스들 간에 서로 데이터를 주고받는 행위</h2>
<ul>
  <li>독립 프로세스 (<code class="language-plaintext highlighter-rouge">Independent Process</code>) : (단일 처리 시스템에서) 다른 프로세스에 독립적으로 실행되는 동기적 프로세스</li>
  <li>협력 프로세스 (<code class="language-plaintext highlighter-rouge">Cooperating Process</code>) : 실행중인 다른 프로세스와의 상호 작용을 통해 수행되는 비동기적 프로세스</li>
</ul>

<h3 id="공유-메모리-shared-memory--협력-프로세스-간-하나의-공유-메모리-영역을-만들어-상호-통신">공유 메모리 (<code class="language-plaintext highlighter-rouge">Shared Memory</code>) : 협력 프로세스 간 하나의 공유 메모리 영역을 만들어 상호 통신</h3>
<blockquote>
  <p>공유 메모리 세그먼트 : 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치</p>
</blockquote>

<ul>
  <li>장점 : 커널 의존성이 낮아 속도가 빠르고, 유저 레벨에서의 IPC가 가능해 자유로운 통신이 가능</li>
  <li>단점 : 자원과 데이터를 공유하기에 동기화 문제가 발생</li>
</ul>

<h3 id="메시지-패싱-message-passing--협력-프로세스-간-각자의-메시지를-운영-체제에-전달해-통신">메시지 패싱 (<code class="language-plaintext highlighter-rouge">Message Passing</code>) : 협력 프로세스 간 각자의 메시지를 운영 체제에 전달해 통신</h3>
<ul>
  <li>장점 : 별도의 구축 없이 커널만을 이용하기에 비교적 구현이 쉬움</li>
  <li>단점 : 커널을 이용할 때마다, 시스템 호출에 따른 문맥 전환이 매번 발생 (문맥 복사 2번 수행, 문맥 전환 오버헤드 발생)</li>
</ul>

<h2 id="쓰레드-thread--프로세스-내부의-흐름">쓰레드 (<code class="language-plaintext highlighter-rouge">Thread</code>) : 프로세스 내부의 흐름</h2>
<ul>
  <li>CPU를 구성하는 기본 단위로, 일반적으로 하나의 프로세스은 하나의 쓰레드가 존재</li>
  <li>하나의 쓰레드는 고유한 <code class="language-plaintext highlighter-rouge">Thread ID</code>, <code class="language-plaintext highlighter-rouge">Program Counter</code>, <code class="language-plaintext highlighter-rouge">Register Set</code> 및 <code class="language-plaintext highlighter-rouge">Stack</code>을 가짐</li>
</ul>

<h3 id="다중-쓰레드-multi-threads---하나의-프로세스에-쓰레드가-2개-이상-존재">다중 쓰레드 (<code class="language-plaintext highlighter-rouge">Multi-Threads</code>) :  하나의 프로세스에 쓰레드가 2개 이상 존재</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Concurrent</code> : 한 프로세스에서 여러 쓰레드가 빠른 시간 간격으로 스위칭되어 동시에 실행되는 것처럼 보임
    <ul>
      <li>여러 쓰레드들이 하나의 프로세스 안에 속하면서 <code class="language-plaintext highlighter-rouge">code</code>, <code class="language-plaintext highlighter-rouge">data</code> 메모리 공간과 프로세스 자원 <code class="language-plaintext highlighter-rouge">file</code>과 <code class="language-plaintext highlighter-rouge">I/O</code> 공유</li>
      <li>메시지 패싱 X (운영 체제를 거치지 않고도 통신 가능), 공유 메모리 X (공유 메모리를 만들지 않아도 됨)
        <ul>
          <li>멀티 프로세스에 비해 문맥 전환 시간이 짧고, 메모리와 자원의 할당이 더 효율적</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>운영체제가 다중 쓰레드를 지원 : 현대 운영체제에서의 문맥 전환은 프로세스가 아닌 쓰레드 단위로 이루어짐
    <ul>
      <li>하나의 프로세스 안에서 여러 쓰레드가 수행되다가 다른 프로세스로 넘어가 그 프로세스의 쓰레드를 수행함
        <ul>
          <li>웹 브라우저 : 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 따로 수행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="다중-쓰레드-모델-multi-threads-models---2개-이상의-쓰레드로-구성된-모델">다중 쓰레드 모델 (<code class="language-plaintext highlighter-rouge">Multi-Threads Models</code>) :  2개 이상의 쓰레드로 구성된 모델</h3>
<ul>
  <li>유저 쓰레드 (<code class="language-plaintext highlighter-rouge">User Thread</code>) : 유저 레벨의 쓰레드 라이브러리를 통해 관리되는 쓰레드</li>
  <li>
    <p>커널 쓰레드 (<code class="language-plaintext highlighter-rouge">Kernel Thread</code>) :  운영체제가 제공하고 직접 관리하는 쓰레드</p>
  </li>
  <li>
    <h4 id="many-to-one-모델--한-커널-쓰레드가-여러-유저-쓰레드-처리"><code class="language-plaintext highlighter-rouge">Many-to-One</code> 모델 : 한 커널 쓰레드가 여러 유저 쓰레드 처리</h4>
    <ul>
      <li>병목 현상 : 시스템 호출이 발생하면, 모든 유저 쓰레드가 대기해야 함</li>
    </ul>
  </li>
  <li>
    <h4 id="one-to-one-모델--유저-쓰레드-한-개당-커널-쓰레드를-대응시켜-처리"><code class="language-plaintext highlighter-rouge">One-to-One</code> 모델 : 유저 쓰레드 한 개당 커널 쓰레드를 대응시켜 처리</h4>
    <ul>
      <li>커널 쓰레드가 과도하게 생성되어 비효율적임</li>
    </ul>
  </li>
  <li>
    <h4 id="many-to-many-모델--여러-유저-쓰레드가-여러-커널-쓰레드-처리"><code class="language-plaintext highlighter-rouge">Many-to-Many</code> 모델 : 여러 유저 쓰레드가 여러 커널 쓰레드 처리</h4>
    <ul>
      <li>커널 쓰레드의 수는 유저 쓰레드의 수보다 작거나 같게 해야 함</li>
    </ul>
  </li>
  <li>
    <h4 id="two-level-모델--중요한-작업은-one-to-one으로-나머지는-many-to-one으로-처리"><code class="language-plaintext highlighter-rouge">Two-Level</code> 모델 : 중요한 작업은 <code class="language-plaintext highlighter-rouge">One-to-One</code>으로, 나머지는 <code class="language-plaintext highlighter-rouge">Many-to-One</code>으로 처리</h4>
  </li>
</ul>

<h2 id="메인-메모리-관리-main-memory-management">메인 메모리 관리 (<code class="language-plaintext highlighter-rouge">Main Memory Management</code>)</h2>
<ul>
  <li>메모리 공간은 기본적으로 주소 (<code class="language-plaintext highlighter-rouge">address</code>)와 데이터 (<code class="language-plaintext highlighter-rouge">data</code>)로 구성되어 있음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CPU</code>는 주소를 가지고 메인 메모리에 요청을 하거나 해당 주소에 계산 결과를 저장</li>
      <li>메모리는 <code class="language-plaintext highlighter-rouge">CPU</code>가 요구하는 주소에 저장되어 있는 데이터를 <code class="language-plaintext highlighter-rouge">CPU</code>에게 전달</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34755287/54821877-d74f5380-4ce6-11e9-8888-e63816796f65.png" width="80%" style="margin-left: 2%" /></p>

<ul>
  <li>프로그램 빌드는 소스 파일, 목적 파일, 실행 파일 순서로 생성
    <ul>
      <li>소스 파일 (<code class="language-plaintext highlighter-rouge">Source file</code>) : 고수준언어 또는 어셈블리어
        <ul>
          <li>컴파일 단계 : 소스 파일은 컴파일러 또는 어셈블러에 의해 컴파일 또는 어셈블하여 목적 파일 생성</li>
        </ul>
      </li>
      <li>목적 파일 (<code class="language-plaintext highlighter-rouge">Object file</code>) : 컴파일된 결과 또는 어셈블된 결과
        <ul>
          <li>링크 단계 : 목적 파일은 링커 (<code class="language-plaintext highlighter-rouge">Linker</code>)에 의해 하드 디스크의 라이브러리을 찾아 정보를 추가해 실행 파일 생성</li>
        </ul>
      </li>
      <li>실행 파일 (<code class="language-plaintext highlighter-rouge">Executable file</code>) : 링크된 결과
        <ul>
          <li>로드 단계 : 실행 파일은 로더 (<code class="language-plaintext highlighter-rouge">Loader</code>)에 의해 메인 메모리에 할당</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34755287/54821878-d74f5380-4ce6-11e9-98e8-a43b086a4837.png" width="80%" style="margin-left: 2%" /></p>

<ul>
  <li>빌드된 프로그램은 <code class="language-plaintext highlighter-rouge">code</code>, <code class="language-plaintext highlighter-rouge">data</code>, <code class="language-plaintext highlighter-rouge">stack</code> 영역으로 구분됨
    <ul>
      <li>단순히 생성된 프로그램은 <code class="language-plaintext highlighter-rouge">code</code>, <code class="language-plaintext highlighter-rouge">data</code> 영역만 존재</li>
      <li>로드 단계에서 프로그램이 실행을 위해 메모리에 적재되었을 때, 운영체제에 의해 <code class="language-plaintext highlighter-rouge">stack</code> 영역이 추가됨</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34755287/54821879-d7e7ea00-4ce6-11e9-9ad0-ffe02008d6a9.png" width="80%" style="margin-left: 2%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MMU</code>의 재배치 레지스터 (<code class="language-plaintext highlighter-rouge">Relocation register</code>) : 프로그램이 메모리에 할당될 때마다 다른 주소공간을 사용
    <ul>
      <li>프로그램은 메인 메모리에 주소를 사용 가능한지 여부를 생각하지 않고 주소를 사용하려고 함
        <ul>
          <li>메인 메모리에 할당되는 주소는 유동적이기에 프로그램이 사용하려는 주소를 실제 할당된 주소로 변경</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">address translation</code> : 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소를 찾아가도록 함</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>프로그램이 할당된 실제 메모리 주소 공간의 위치는 프로그램을 실행하는 <code class="language-plaintext highlighter-rouge">CPU</code>에 전혀 영향을 미치지 않음</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/34755287/54821880-d7e7ea00-4ce6-11e9-944e-3be89338213f.png" width="80%" style="margin-left: 2%" /></p>

<ul>
  <li>논리 주소 (<code class="language-plaintext highlighter-rouge">logical address</code>) : CPU에서 사용하는 주소</li>
  <li>물리 주소 (<code class="language-plaintext highlighter-rouge">physical address</code>) : 메모리에서 사용하는 주소</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Backend" /><summary type="html"><![CDATA[이 항목은 현재 작성중입니다.&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[Git] 자주 쓰는 linux 기본 명령어</title><link href="http://localhost:4000/git/git3/" rel="alternate" type="text/html" title="[Git] 자주 쓰는 linux 기본 명령어" /><published>2022-10-06T00:00:00+09:00</published><updated>2022-10-08T00:00:00+09:00</updated><id>http://localhost:4000/git/git3</id><content type="html" xml:base="http://localhost:4000/git/git3/"><![CDATA[<p class="notice--info"><strong>이 항목은 macOS 기반으로 작성되었습니다.</strong><br />&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<blockquote>
  <ul>
    <li>폴더 (<code class="language-plaintext highlighter-rouge">Folder</code>) 혹은 디렉터리 (<code class="language-plaintext highlighter-rouge">Directory</code>) : 파일의 분류를 위해 붙이는 이름공간 (<code class="language-plaintext highlighter-rouge">Namespace</code>)</li>
    <li>파일 (<code class="language-plaintext highlighter-rouge">File</code>) : 컴퓨터에 쓰이는 데이터를 모아놓은 것</li>
    <li>경로 (<code class="language-plaintext highlighter-rouge">Path</code>) : 파일 시스템을 통해 특정한 파일까지 찾아갈 수 있는 디렉토리의 구조
      <blockquote>
        <ul>
          <li>절대 경로 (<code class="language-plaintext highlighter-rouge">Absolute Path</code>) : 최상위 디렉터리부터 해당 파일까지 경유한 모든 경로를 작성하는 경로</li>
          <li>상대 경로 (<code class="language-plaintext highlighter-rouge">Relative Path</code>) : 현재 위치한 디렉터리를 기준으로 해당 파일까지의 위치를 작성하는 경로</li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<h3 id="pwd-print-working-directory--현재-작업중인-디렉터리의-경로를-출력"><code class="language-plaintext highlighter-rouge">pwd</code> (<code class="language-plaintext highlighter-rouge">print working directory</code>) : 현재 작업중인 디렉터리의 경로를 출력</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pwd
&gt; /home
</code></pre></div></div>

<h3 id="cd-디렉토리-이름-change-directory--절대--상대-경로로-이롱"><code class="language-plaintext highlighter-rouge">cd</code> [디렉토리 이름] (<code class="language-plaintext highlighter-rouge">change directory</code>) : 절대 / 상대 경로로 이롱</h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">.</code> : 현재 디렉토리</li>
  <li><code class="language-plaintext highlighter-rouge">..</code> : 한 단계 위의 디렉토리</li>
  <li><code class="language-plaintext highlighter-rouge">/</code> : 최상위 디렉토리</li>
  <li><code class="language-plaintext highlighter-rouge">~</code> : Home 디렉토리</li>
  <li><code class="language-plaintext highlighter-rouge">-</code> : 이전 디렉토리</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /folder1/folder2
$ pwd
&gt; /home/folder1/folder2

$ cd ..
$ pwd
&gt; /home/folder1

$ cd -
$ pwd
&gt; /home/folder1/folder2

$ cd .
$ pwd
&gt; /home/folder1/folder2

$ cd ~
$ pwd
&gt; /home
</code></pre></div></div>

<h3 id="ls-옵션-파일-이름-list--현재-작업중인-디렉터리-내의-파일과-디렉토리-정보를-출력"><code class="language-plaintext highlighter-rouge">ls</code> [옵션] [파일 이름] (<code class="language-plaintext highlighter-rouge">list</code>) : 현재 작업중인 디렉터리 내의 파일과 디렉토리 정보를 출력</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls
&gt; home/ folder1     folder3     file1    file2.txt
</code></pre></div></div>

<h3 id="cp-옵션-원본-파일-이름-대상-파일-이름-디렉토리-이름-copy--파일을-복사"><code class="language-plaintext highlighter-rouge">cp</code> [옵션] [원본 파일 이름] [대상 파일 이름/ 디렉토리 이름] (<code class="language-plaintext highlighter-rouge">copy</code>) : 파일을 복사</h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">f</code> : 덮어쓰기 시 물어보지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">-r</code> : 하위 디렉토리를 모두 포함하여 복사</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls
&gt; home/ folder1     folder3     file1    file2.txt

$ cp file1 folder1
$ cp -r folder3 folder1
$ cd folder1
$ ls
&gt; home/ folder1     folder3     file1
</code></pre></div></div>

<h3 id="mv-옵션-원본-파일-이름-대상-파일-이름-move--파일-혹은-디렉터리의-이름이나-위치를-변경"><code class="language-plaintext highlighter-rouge">mv</code> [옵션] [원본 파일 이름] [대상 파일 이름] (<code class="language-plaintext highlighter-rouge">move</code>) : 파일 혹은 디렉터리의 이름이나 위치를 변경</h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">f</code> : 덮어쓰기 시 물어보지 않음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls
&gt; home/ folder1     folder3     file1

$ mv file1 file3
$ ls
&gt; home/ folder1     folder3     file3

$ mv file3 folder3
$ ls
&gt; home/ folder1     folder3

$ cd folder3
$ ls
&gt; folder3/ file3
</code></pre></div></div>

<h3 id="mkdir-옵션-파일-이름-make-directory--새로운-디렉터리를-생성"><code class="language-plaintext highlighter-rouge">mkdir</code> [옵션] [파일 이름] (<code class="language-plaintext highlighter-rouge">make directory</code>) : 새로운 디렉터리를 생성</h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">-p</code> : 하위 디렉터리까지 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls
&gt; folder3/ file3

$ mkdir dir1
$ ls
&gt; folder3/ dir1     file3

$ mkdir dir2/dir3
$ ls
&gt; dir1     dir2       file3

$ cd dir2
$ ls
&gt; folder3/ dir3
</code></pre></div></div>

<h3 id="rm-옵션-파일-이름-remove--파일을-삭제"><code class="language-plaintext highlighter-rouge">rm</code> [옵션] [파일 이름] (<code class="language-plaintext highlighter-rouge">remove</code>) : 파일을 삭제</h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">-r</code> : 디렉터리를 삭제 (하위 디렉터리와 파일도 삭제)</li>
  <li><code class="language-plaintext highlighter-rouge">-f</code> : 사용자에 삭제 여부를 묻지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">-i</code> : 파일이나 디렉토리 삭제할 때마다 확인 (y: 확인, n: 취소)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls
&gt; folder3/ folder1     folder2     file1

$ rm file1
$ ls
&gt; folder3/ folder1     folder2

$ rm -r folder1
$ ls
&gt; folder3/ folder2

$ rm -rf folder2
$ ls
&gt; folder3/
</code></pre></div></div>

<h3 id="find-디렉토리-이름-옵션--특정-파일이나-디렉터리를-검색"><code class="language-plaintext highlighter-rouge">find</code> [디렉토리 이름] [옵션] : 특정 파일이나 디렉터리를 검색</h3>
<hr />

<ul>
  <li><code class="language-plaintext highlighter-rouge">-name</code> : 특정 이름이나 확장자를 가진 파일이나 디렉터리를 검색</li>
  <li><code class="language-plaintext highlighter-rouge">-exec [명령어] {} \;</code> : 검색 이후의 명령어를 처리
    <ul>
      <li><code class="language-plaintext highlighter-rouge">{}</code> : 검색 결과가 해당 구문 안으로 하나씩 처리</li>
      <li><code class="language-plaintext highlighter-rouge">\;</code> : <code class="language-plaintext highlighter-rouge">-exec</code> 다음 부분의 명령어를 실행</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">-type</code> : 디렉터리나 파일을 지정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls
&gt; ./ file1.txt     file2.txt     file3.txt

$ find ./ -name *.txt
&gt; ./ file1.txt     
&gt; ./ file2.txt     
&gt; ./ file3.txt

$ find ./ -name *.txt -exec rm -f {} \;
$ ls
&gt; ./
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Git" /><summary type="html"><![CDATA[이 항목은 macOS 기반으로 작성되었습니다.&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[Git] 깃 (Git)과 깃허브 (GitHub)</title><link href="http://localhost:4000/git/git2/" rel="alternate" type="text/html" title="[Git] 깃 (Git)과 깃허브 (GitHub)" /><published>2022-10-06T00:00:00+09:00</published><updated>2022-11-16T00:00:00+09:00</updated><id>http://localhost:4000/git/git2</id><content type="html" xml:base="http://localhost:4000/git/git2/"><![CDATA[<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br />&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--info"><strong>이 항목은 macOS 기반으로 작성되었습니다.</strong><br />&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="버전-관리-version-control--특정한-시간-기준으로-파일-변화를-저장하고-관리">버전 관리 (<code class="language-plaintext highlighter-rouge">Version Control</code>) : 특정한 시간 기준으로 파일 변화를 저장하고 관리</h2>
<ul>
  <li>버전 (<code class="language-plaintext highlighter-rouge">Version</code>) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용</li>
</ul>

<h3 id="1-로컬-버전-관리-local-version-control">1. 로컬 버전 관리 (<code class="language-plaintext highlighter-rouge">Local Version Control</code>)</h3>
<ul>
  <li>로컬 사용자가 서버 없이 로컬 컴퓨터 내의 데이터베이스를 이용해 파일의 변경 정보 관리
    <ul>
      <li>협업에서 사용하기 어려움, 내부 정보가 손상되면 복구할 방법이 없음</li>
    </ul>
  </li>
</ul>

<h3 id="2-중앙집중식-버전-관리-central-version-control--서브-머신-svn">2. 중앙집중식 버전 관리 (<code class="language-plaintext highlighter-rouge">Central Version Control</code>) : 서브 머신 (<code class="language-plaintext highlighter-rouge">SVN</code>)</h3>
<ul>
  <li>클라이언트가 최종본를 관리하는 데이터베이스 서버로부터 개별 파일을 로컬에 다운로드, 수정본을 서버에 올림
    <ul>
      <li>데이터베이스 서버에 의존적, 협업의 규모가 커지면 수정 충돌 문제 발생 (유사 사례 : <a href="https://namu.wiki/w/편집%20충돌">나무위키 문서의 편집 충돌</a>)</li>
    </ul>
  </li>
</ul>

<h3 id="3-분산형-버전-관리-distributed-version-control--깃-git">3. 분산형 버전 관리 (<code class="language-plaintext highlighter-rouge">Distributed Version Control</code>) : 깃 (<code class="language-plaintext highlighter-rouge">Git</code>)</h3>
<ul>
  <li>클라이언트가 원격 저장소로부터 전체 기록과 각 기록을 추적할 수 있는 정보를 포함한 전체 데이터를 로컬 저장소에 저장
    <ul>
      <li>클라이언트가 자신의 작업을 원격 저장소에 독립적인 로컬 저장소에 버전별로 저장하고 관리</li>
      <li>여러 클라이언트들의 작업을 여러 로컬 저장소로 다원화되어 각각의 클라이언트는 충돌의 염려 없이 작업 가능</li>
      <li>필요한 경우 작업을 마친 클라이언트가 서버의 원격 저장소에 원하는 버전을 통합시켜 서버 단위의 편집 버전을 +1 올림
        <ul>
          <li>클라이언트는 원격 저장소에 자신의 작업을 통합시킬 때만 서버와 통신하면 됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="깃-git--분산형-버전-관리-시스템-distributed-version-control-system"><a href="https://git-scm.com">깃</a> (<code class="language-plaintext highlighter-rouge">Git</code>) : 분산형 버전 관리 시스템 (<code class="language-plaintext highlighter-rouge">Distributed Version Control System</code>)</h2>
<ul>
  <li>터미널 창에 다음 명령어를 입력해 <a href="https://pocj8ur4in.github.io/mac/homebrew1/"><code>homebrew</code></a>를 통해 <code class="language-plaintext highlighter-rouge">git</code> 설치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install git
</code></pre></div></div>

<h3 id="gitignore-디렉터리--버전-관리를-하지-않을-파일이나-디렉터리-혹은-파일-확장자를-설정"><code class="language-plaintext highlighter-rouge">.gitignore</code> 디렉터리 : 버전 관리를 하지 않을 파일이나 디렉터리, 혹은 파일 확장자를 설정</h3>

<ul>
  <li>특정한 이름을 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename.txt
</code></pre></div></div>

<ul>
  <li>특정한 확장자를 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*.txt
</code></pre></div></div>

<ul>
  <li>특정한 경로 아래의 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder/
</code></pre></div></div>

<ul>
  <li>특정한 경로 아래의 특정한 확장자를 가진 파일 제외</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder/filename.txt
</code></pre></div></div>

<ul>
  <li>예외 만들기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!filename.txt
</code></pre></div></div>

<h3 id="readmemd-파일--프로젝트에-대한-설명과-사용-방법-license-등의-내용을-작성"><code class="language-plaintext highlighter-rouge">README.md</code> 파일 : 프로젝트에 대한 설명과 사용 방법, <code class="language-plaintext highlighter-rouge">LICENSE</code> 등의 내용을 작성</h3>
<ul>
  <li>기존의 <code><a href="_posts/2022-10-29-markdown1.md">Markdown</a></code>에 깃허브에서만 사용 가능한 기능을 추가한 <code class="language-plaintext highlighter-rouge">Github Flavored Markdown</code>을 이용</li>
  <li><code class="language-plaintext highlighter-rouge">Github</code> 프로젝트 레포지토리 페이지에서 <code class="language-plaintext highlighter-rouge">README.md</code>가 표현된 것을 확인 가능
    <ul>
      <li>자신의 아이디와 같은 이름의 레포지토리의 <code class="language-plaintext highlighter-rouge">README.md</code>는 해당 사용자의 깃허브 프로필에 표시됨</li>
    </ul>
  </li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb18y0K%2FbtruITygdgC%2FV4XYZs3D0ZMlzqlkHZkH9k%2Fimg.png" /></p>

<ul>
  <li><a href="https://shields.io">뱃지</a> : 해당 사이트에서 뱃지의 구성 요소들을 직접 지정해 생성한 후 <code class="language-plaintext highlighter-rouge">img</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/(아이콘 내용)-(아이콘 색상)?style=flat-square&amp;logo=(로고 이름)&amp;logoColor=(로고 색상)"/&gt;
</code></pre></div></div>

<p><img alt="GitHub followers" src="https://img.shields.io/github/followers/pocj8ur4in?style=social" /></p>

<ul>
  <li><a href="https://hits.seeyoufarm.com">방문자 수</a> : 해당 사이트에서 <code class="language-plaintext highlighter-rouge">Target URL</code>과 로고를 선택한 후 <code class="language-plaintext highlighter-rouge">a</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="https://github.com/pocj8ur4in"&gt; ... &lt;/a&gt;
</code></pre></div></div>

<p><a href="https://github.com/pocj8ur4in"><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2Fseondal&amp;count_bg=%23000000&amp;title_bg=%23000000&amp;icon=github.svg&amp;icon_color=%23E7E7E7&amp;title=GitHub&amp;edge_flat=false)" /></a></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazassumnida"><code>Solved.ac</code> 티어</a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[![Solved.ac 프로필]
(http://mazassumnida.wtf/api/v2/generate_badge?boj={백준ID})]
(https://solved.ac/백준ID)
</code></pre></div></div>

<p><img src="https://camo.githubusercontent.com/82c9b109cd774ae61438576d5cece4102c8844e1bd1db3a3767dca13eaf93fee/687474703a2f2f6d617a617373756d6e6964612e7774662f6170692f76322f67656e65726174655f62616467653f626f6a3d73747261774a49" /></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazandi"><code>Solved.ac</code> 잔디</a> : 해당 사이트에서 <code class="language-plaintext highlighter-rouge">img</code> 태그로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="http://mazandi.herokuapp.com/api?handle={백준ID}&amp;theme=warm"/&gt;
</code></pre></div></div>

<p><img src="http://mazandi.herokuapp.com/api?handle=pocj8ur4in&amp;theme=warm" /></p>

<ul>
  <li><a href="https://github.com/mazassumnida/mazandi">자주 사용한 언어</a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[![Top Langs]
(https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브ID)]
(https://github.com/깃허브ID/github-readme-stats)
</code></pre></div></div>

<p><img src="https://camo.githubusercontent.com/fbf4f4aadb79493225ed43d6daca84015eafa94d496ef07bbf723200e12f923c/68747470733a2f2f6769746875622d726561646d652d73746174732e76657263656c2e6170702f6170692f746f702d6c616e67732f3f757365726e616d653d616e7572616768617a7261" /></p>

<ul>
  <li><a href="https://github.com/kyechan99/capsule-render"><code>Header &amp; Footer</code></a> : 해당 사이트에서 마크다운 언어로 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![header]
(https://capsule-render.vercel.app/api?type=모양&amp;color=auto&amp;height=높이&amp;section=header&amp;text=내용&amp;fontSize=폰트크기)
</code></pre></div></div>
<p><img src="https://camo.githubusercontent.com/0da1f68bf3ed97f972472f31e1dbf68514bc3f72761bf300f8474f53ffab7932/68747470733a2f2f63617073756c652d72656e6465722e76657263656c2e6170702f6170693f747970653d776176696e6726636f6c6f723d6175746f266865696768743d3330302673656374696f6e3d68656164657226746578743d63617073756c6525323072656e64657226666f6e7453697a653d393026616e696d6174696f6e3d66616465496e26666f6e74416c69676e593d333826646573633d4465636f7261746525323047697448756225323050726f66696c652532306f72253230616e792532305265706f2532306c696b652532306d65212664657363416c69676e593d35312664657363416c69676e3d3632" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![Footer]
(https://capsule-render.vercel.app/api?type=모양&amp;color=auto&amp;height=높이&amp;section=header&amp;text=내용&amp;fontSize=폰트크기)
</code></pre></div></div>
<p><img src="https://camo.githubusercontent.com/2d4943deac939925b872b56f5dae84d2f2da502ebabb3da5b51fd6750fef5947/68747470733a2f2f63617073756c652d72656e6465722e76657263656c2e6170702f6170693f747970653d7761766526636f6c6f723d6175746f266865696768743d3230302673656374696f6e3d666f6f74657226746578743d4e6f772532305573652532306d652126666f6e7453697a653d3930" /></p>

<h3 id="git-디렉터리--깃의-버전을-저장할-로컬-저장소"><code class="language-plaintext highlighter-rouge">.git</code> 디렉터리 : 깃의 버전을 저장할 로컬 저장소</h3>
<ul>
  <li>버전 (<code class="language-plaintext highlighter-rouge">Version</code>) : 어떤 파일이 수정된 기록이나 그 파일이 수정된 내용
    <ul>
      <li>작업 트리 (<code class="language-plaintext highlighter-rouge">working tree</code>) : 파일 수정, 저장 등의 작업을 하는 작업 디렉터리
        <ul>
          <li>스테이징 (<code class="language-plaintext highlighter-rouge">Staging</code>) : 작업 트리에서 작업한 파일을 버전으로 만들기 위해 스테이지로 이동</li>
        </ul>
      </li>
      <li>스테이지 (<code class="language-plaintext highlighter-rouge">stage</code>) : 버전으로 만들 파일이 대기하는 스테이징 영역
        <ul>
          <li>커밋 (<code class="language-plaintext highlighter-rouge">Commit</code>) : 스테이지에서 대기중인 파일을 버전으로 만들어 레포지토리에 저장</li>
        </ul>
      </li>
      <li>레포지토리 (<code class="language-plaintext highlighter-rouge">repository</code>) : 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 저장소</li>
    </ul>
  </li>
</ul>

<h2 id="깃-명령어-git-command--git-command-형식으로-구성">깃 명령어 (<code class="language-plaintext highlighter-rouge">Git Command</code>) : <code class="language-plaintext highlighter-rouge">git &lt;command&gt;</code> 형식으로 구성</h2>
<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">git</code> : 깃 명령 다음에 입력할 수 있는 명령어 옵션 확인</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git
...
</code></pre></div>  </div>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git init</code> : 깃 저장소를 만들 디렉터리 초기화 (깃 저장소인 <code class="language-plaintext highlighter-rouge">.git</code> 디렉터리가 생성)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git init
Initialized empty Git repository in ...
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git status</code> :  깃의 현재 상태 확인
    <ul>
      <li><code class="language-plaintext highlighter-rouge">untracked</code> 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하고 있지 않습니다. (파일이 스테이지에서 대기 : <code class="language-plaintext highlighter-rouge">false</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">tracked</code> 상태 : 현재 깃이 해당 파일의 수정 여부를 추적하고 있습니다. (파일이 스테이지에서 대기 : <code class="language-plaintext highlighter-rouge">true</code>)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">unmodified</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되지 않았습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Working tree clean</code></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">modified</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었으나 스테이징되지 않았습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Changes not stage for commit:</code></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">staged</code> 상태 : 깃에 현재 버전이 저장된 이후 파일이 수정되었고 스테이징되었습니다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">Changes to be committed:</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
On branch master  // 현재 master 브랜치에 위치해 있음
No commits yet    // 아직 커밋한 파일이 존재하지 않음
nothing to commit // 현재 커밋한 파일이 존재하지 않음
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
On branch master
No commits yet
untracked files   // untracked 상태 : 아직 버전 관리하지 않은 파일들이 존재함
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git add</code> : 작업 트리에서 스테이지로 스테이징</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add helloWorld.txt
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git commit</code> : 스테이지에 있는 파일을 버전으로 커밋
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-m</code> 옵션을 통해 커밋과 함께 메시지 저장</li>
      <li><code class="language-plaintext highlighter-rouge">-am</code> 옵션을 통해 스테이징과 커밋을 동시에 처리</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git commit -m "message1"
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git log</code> : 레포지토리에 저장된 버전 정보 확인
    <ul>
      <li>커밋 해시 (<code class="language-plaintext highlighter-rouge">commit hash</code>) : 커밋을 구별하는 ID (<code class="language-plaintext highlighter-rouge">HEAD-&gt;master</code> : 해당 버전이 가장 최신임을 표시)</li>
      <li>작성자 (<code class="language-plaintext highlighter-rouge">Author</code>) : <code class="language-plaintext highlighter-rouge">git config --global user</code>를 통해 입력한 사용자 정보 (이름과 이메일)</li>
      <li>작성일 (<code class="language-plaintext highlighter-rouge">Date</code>) : 버전이 작성된 시각</li>
      <li>커밋 메시지 (<code class="language-plaintext highlighter-rouge">commit message</code>) : <code class="language-plaintext highlighter-rouge">git commit -m</code>을 통해 저장된 메시지</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Git" /><summary type="html"><![CDATA[이 항목은 현재 작성중입니다.&gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[macOS] 홈브류 (Homebrew)</title><link href="http://localhost:4000/mac/homebrew1/" rel="alternate" type="text/html" title="[macOS] 홈브류 (Homebrew)" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-09-26T00:00:00+09:00</updated><id>http://localhost:4000/mac/homebrew1</id><content type="html" xml:base="http://localhost:4000/mac/homebrew1/"><![CDATA[<p class="notice--info"><strong>이 항목은 macOS 기반으로 작성되었습니다.</strong><br />&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="homebrew"><a href="https://brew.sh/index_ko">Homebrew</a></h2>

<ul>
  <li>Ruby로 작성된 macOS용 패키지 관리 어플리케이션 (Package Management Application)</li>
  <li>커맨드라인 도구나 시스템 패키지 설치에 사용</li>
  <li>cask Package : GUI 어플리케이션 설치도 가능하게 해주는 Homebrew 확장 패키지</li>
  <li>mas Package : App Store 어플리케이션 설치도 가능하게 해주는 Homebrew 확장 패키지</li>
</ul>

<h3 id="homebrew-설치">Homebrew 설치</h3>
<ul>
  <li>터미널 실행 후 다음 명령어를 입력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 Homebrew가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew --version
// "Homebrew X.X.X" 출력 : 정상 설치
// "zsh: command not found: brew" 출력 : 설치 오류
</code></pre></div></div>

<h3 id="cask-package-설치">cask Package 설치</h3>
<ul>
  <li>터미널 창에 다음 명령어를 입력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install cask
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 cask Package가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew list
</code></pre></div></div>

<h3 id="mas-package-설치">mas Package 설치</h3>
<ul>
  <li>터미널 창에 다음 명령어를 입력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install mas
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 mas Package가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew list
</code></pre></div></div>

<h3 id="homebrew-명령어">Homebrew 명령어</h3>

<table>
    <thead>
        <tr>
            <th>Homebrew 명령어 이름</th>
            <th>Homebrew 명령어 설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>brew --version</th>
            <td>Homebrew의 버전 정보 확인</td>
        </tr>
        <tr>
            <th>brew doctor</th>
            <td>Homebrew 설치 환경을 검사</td>
        </tr>
        <tr>
            <th>brew update</th>
            <td>Homebrew를 최신 버전으로 업데이트</td>
        </tr>
        <tr>
            <th>brew list</th>
            <td>설치된 패키지를 확인</td>
        </tr>
        <tr>
            <th>brew upgrade</th>
            <td>설치된 모든 패키지를 업데이트</td>
        </tr>
        <tr>
            <th>brew search (패키지명)</th>
            <td>해당 패키지가 설치되어 있는지 검색</td>
        </tr>
        <tr>
            <th>brew install (패키지명)</th>
            <td>해당 패키지를 최신 버전으로 설치</td>
        </tr>
        <tr>
            <th>brew info (패키지명)</th>
            <td>해당 패키지의 정보 확인</td>
        </tr>
        <tr>
            <th>brew upgrade (패키지명)</th>
            <td>해당 패키지를 업데이트</td>
        </tr>
        <tr>
            <th>brew uninstall (패키지명)</th>
            <td>해당 패키지를 삭제</td>
        </tr>
        <tr>
            <th>brew outdated</th>
            <td>최신 버전이 존재하는 패키지 확인</td>
        </tr>
        <tr>
            <th>brew cleanup (패키지명)</th>
            <td>해당 패키지의 구버전에 해당하는 파일 삭제</td>
        </tr>
    </tbody>
</table>

<h3 id="cask-명령어">cask 명령어</h3>
<ul>
  <li>기존의 brew 명령어 뒤에 <code class="language-plaintext highlighter-rouge">--cask</code>를 추가</li>
</ul>

<h3 id="mas-명령어">mas 명령어</h3>

<table>
    <thead>
        <tr>
            <th>mas 명령어 이름</th>
            <th>mas 명령어 설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>mas version</th>
            <td>mas의 버전 정보 확인</td>
        </tr>
        <tr>
            <th>mas list</th>
            <td>mas로 설치된 패키지 확인</td>
        </tr>
        <tr>
            <th>mas upgrade</th>
            <td>mas로 설치된 모든 패키지를 최신 버전으로 업데이트</td>
        </tr>
        <tr>
            <th>mas search (검색어)</th>
            <td>앱스토어에서 해당 검색어와 일치하는 패키지 검색</td>
        </tr>
        <tr>
            <th>mas install (패키지 ID)</th>
            <td>해당되는 ID를 가진 패키지를 최신 버전으로 설치</td>
        </tr>
        <tr>
            <th>mas upgrade (패키지 ID)</th>
            <td>해당되는 ID를 가진 패키지를 최신 버전으로 업데이트</td>
        </tr>
        <tr>
            <th>mas uninstall (패키지명)</th>
            <td>mas로 설치된 해당 패키지를 삭제</td>
        </tr>
        <tr>
            <th>mas outdated</th>
            <td>mas로 설치된 패키지 중 최신 버전이 존재하는 패키지 확인</td>
        </tr>
    </tbody>
</table>

<h3 id="homebrew-삭제">Homebrew 삭제</h3>
<ul>
  <li>터미널 실행 후 다음 명령어를 입력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Homebrew로 설치한 모든 package를 일괄 삭제
brew remove --force --ignore-dependencies $(brew list)

// Homebrew 삭제
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)"
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 Homebrew가 정상적으로 삭제되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew --version
// "zsh: command not found: brew" 출력 : 정상 삭제
// "Homebrew X.X.X" 출력 : 삭제 오류
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Mac" /><summary type="html"><![CDATA[이 항목은 macOS 기반으로 작성되었습니다.&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.]]></summary></entry><entry><title type="html">[Git] Minimal Mistakes으로 Github Blog 만들기</title><link href="http://localhost:4000/git/git1/" rel="alternate" type="text/html" title="[Git] Minimal Mistakes으로 Github Blog 만들기" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-10-11T00:00:00+09:00</updated><id>http://localhost:4000/git/git1</id><content type="html" xml:base="http://localhost:4000/git/git1/"><![CDATA[<p class="notice--info"><strong>이 항목은 macOS 기반으로 작성되었습니다.</strong><br />&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.</p>

<p class="notice--danger"><strong>이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.</strong><br />&gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br />&gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

<h2 id="기본-환경-설정">기본 환경 설정</h2>

<h3 id="ruby-설치">Ruby 설치</h3>
<ul>
  <li>macOS에서는 Ruby가 기본적으로 설치되어 있음</li>
  <li>터미널 실행 후 다음 명령어를 입력해 설치 여부 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -v
// ruby X.X.X 출력 : 정상 설치
// "zsh: command not found: ruby" 출력 : 설치 오류
</code></pre></div></div>

<h3 id="jekyll-설치">Jekyll 설치</h3>
<ul>
  <li>터미널 창에 다음 명령어를 입력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install jekyll
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 Jekyll가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jekyll -v
// jekyll X.X.X 출력 : 정상 설치
// "zsh: command not found: jekyll" 출력 : 설치 오류
</code></pre></div></div>

<h3 id="minimal-mistakes-themes-설치"><code class="language-plaintext highlighter-rouge">Minimal Mistakes Themes</code> 설치</h3>
<ul>
  <li><a href="https://github.com/mmistakes/minimal-mistakes">minimal-mistakes Github 페이지</a>에서 .zip 파일 다운로드 후 압축 해제</li>
  <li>아래 사진을 참고하여, 필요한 파일 및 폴더만 남기고 나머지는 삭제 (기존에 존재하지 않는 <code class="language-plaintext highlighter-rouge">_post</code>와 <code class="language-plaintext highlighter-rouge">_page</code> 디렉토리는 생성)</li>
</ul>

<p><img src="https://i.postimg.cc/855KdXRn/blog1-1.png" width="240" /></p>

<h3 id="github-repository-생성">Github Repository 생성</h3>
<ul>
  <li>Github에 <code class="language-plaintext highlighter-rouge">(Github ID).github.io</code>의 형식으로 Repository 생성</li>
</ul>

<p><img src="https://i.postimg.cc/FRFS4GcW/blog1-2.png" width="360" /></p>

<ul>
  <li>지금까지 정리한 minimal-mistakes 폴더를 github에 push
    <ul>
      <li>블로그 주소 : <code class="language-plaintext highlighter-rouge">https://(Github ID).github.io</code></li>
      <li><code class="language-plaintext highlighter-rouge">https://github.com/(Github ID)/(Github ID).github.io/actions</code>을 통해 블로그 빌드 기록 확인 가능</li>
    </ul>
  </li>
</ul>

<h3 id="로컬-서버-설정-및-실행">로컬 서버 설정 및 실행</h3>
<ul>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">.jekyll-cache</code> 폴더와 <code class="language-plaintext highlighter-rouge">Gemfile.lock</code> 파일 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install bundler
bundle exec jekyll serve
</code></pre></div></div>

<ul>
  <li><a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a>으로 로컬 서버 접속</li>
</ul>

<h2 id="블로그-기본-설정">블로그 기본 설정</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minimal_mistakes_skin    :         # 블로그의 전체적인 스킨 지정 
                                   # (Minimal Mistakes에서 기본적으로 제공)
                                   # "default" "air", "aqua", "contrast", "dark"
                                   # "dirt", "neon", "mint", "plum", "sunrise"

locale                   : "ko-KR" # 블로그에 쓰일 로컬 언어 지정
title                    :         # 메타 태그에 들어갈 블로그의 제목 지정
title_separator          : "-"          
subtitle                 :         # 블로그의 제목 하단에 위치할 부제목 지정
name                     :         # 블로그 저자 이름 지정
description              :         # SEO 향상을 위한 meta description 태그 지정
url                      :         # 블로그 url 
                                   # "https://(github ID).github.io"
baseurl                  :         # 서브 폴더를 위한 url 지정
repository               :         # github repository url
                                   # "https://github.com/(github ID)/(github ID).github.io"
teaser                   :         # 관련 포스트나 검색 등에 들어갈 미리보기 이미지 지정
                                   # ("assets/images/"로 연결)
logo                     :         # 블로그의 제목 옆에 들어갈 로고 이미지 지정
                                   # ("assets/images"로 연결)
masthead_title           :         # 블로그 프로필 상단에 위치할 사이트 제목 지정
breadcrumbs              : true    # 브래드크럼 사용 여부 지정
words_per_minute         : 200     # 포스트를 읽는 데 걸리는 시간을 계산히기 위한 분당 읽는 글자의 지정

</code></pre></div></div>

<h3 id="블로그-댓글-기능-설정-disqus">블로그 댓글 기능 설정 (disqus)</h3>
<ul>
  <li><a href="https://disqus.com">https://disqus.com</a>에 접속해 회원가입</li>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>comments:
  provider               : "disqus"
  disqus:
    shortname            :         # disqus ID 지정
</code></pre></div></div>

<h3 id="블로그-검색-기능-설정">블로그 검색 기능 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>search                   : # 블로그 검색 여부 지정
search_full_content      : # 블로그의 내용 검색 여부 지정
</code></pre></div></div>

<h3 id="google-검색-노출-살정">Google 검색 노출 살정</h3>
<ul>
  <li><a href="https://search.google.com/search-console/about">Google Search Console</a>에서 도메인 입력</li>
  <li>소유권 확인을 위해 다운받은 <code class="language-plaintext highlighter-rouge">.HTML</code>파일을 <code class="language-plaintext highlighter-rouge">root</code>에 위치</li>
  <li>웹 크롤링을 위해 <a href="https://github.com/pocj8ur4in/pocj8ur4in.github.io/blob/main/sitemap.yml"><code class="language-plaintext highlighter-rouge">sitemap.yml</code></a>과 <code class="language-plaintext highlighter-rouge">robots.txt</code> 파일을 생성해 <code class="language-plaintext highlighter-rouge">root</code>에 위치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: *
Allow: /

# 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 차단
User-agent: *
Disallow: /

# 구글 검색 로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: Googlebot
Disallow: /

# 네이버 검색로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: Yeti
Disallow: /

Sitemap: https://pocj8ur4in.github.io/sitemap.xml
</code></pre></div></div>

<h3 id="블로그-포스트-불러오기-설정">블로그 포스트 불러오기 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults:
  # _posts
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      read_time: false
      comments: true
      share: false
      related: false
</code></pre></div></div>

<h2 id="블로그-레이아웃-설정">블로그 레이아웃 설정</h2>

<h3 id="블로그-좌측-사이드바에-위치할-프로필-설정">블로그 좌측 사이드바에 위치할 프로필 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>author:
  name             :       # 저자 이름 지정
  avatar           :       # 저자 이미지 지정
  bio              :       # 저자 바이오그래피 지정
  location         :       # 저자 위치 지정
  email            :       # 저자 이메일 지정
  links:                   # 저자 관련 사이트 링크 지정
    - label:               # 사이트 분류 지정
      icon:                # 사이트 아이콘 지정
      url:                 # 사이트 url 지정
</code></pre></div></div>

<h3 id="블로그-하단에-위치할-꼬리말-설정">블로그 하단에 위치할 꼬리말 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>footer:
  links:                   # 블로그 관련 사이트 링크 지정
    - label:               # 사이트 분류 지정
      icon:                # 사이트 아이콘 지정
      url:                 # 사이트 url 지정
</code></pre></div></div>

<h3 id="블로그-상단에-위치할-네비게이션-바-설정">블로그 상단에 위치할 네비게이션 바 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults:
  # _pages
  - scope:
      path: ""
      type: pages
    values:
      layout: single
      author_profile: true
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">_data/navigation.yml</code> 파일 수정해 원하는 네비게이션 바 설정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
  - title: (카테고리)        # 화면에 보여질 세부 항목의 이름 지정
    url: /(카테고리)/        # _pages 내에 정해진 양식 파일이나 특정 링크로 연결
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">_pages</code>에 필요한 양식 (<code class="language-plaintext highlighter-rouge">.md</code>) 파일 생성</li>
</ul>

<p>예시) <code class="language-plaintext highlighter-rouge">tag-archive.md</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
title: "tags"
permalink: /tags/
layout: tags
author_profile: true
---
</code></pre></div></div>

<h3 id="블로그-너비-설정">블로그 너비 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_sass/minimal_mistakes/_variables.scss</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
   Grid
   ========================================================================== */

$right-sidebar-width-narrow: 100px !default;    // default 200px
$right-sidebar-width: 200px !default;           // default 300px
$right-sidebar-width-wide: 250px !default;      // default 400px
</code></pre></div></div>

<h3 id="블로그-폰트-크기-설정">블로그 폰트 크기 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_sass/minimal_mistakes/_reset.scss</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>html {
  /* apply a natural box layout model to all elements */
  box-sizing: border-box;
  background-color: $background-color;
  font-size: 16px;                    // Default 16px;

  @include breakpoint($medium) {
    font-size: 16px;                  // Default 18px;
  }

  @include breakpoint($large) {
    font-size: 16px;                  // Default 20px;
  }

  @include breakpoint($x-large) {
    font-size: 16px;                  // Default 22px;
  }

  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
</code></pre></div></div>

<h3 id="블로그-아이콘-설정">블로그 아이콘 설정</h3>
<ul>
  <li><a href="https://realfavicongenerator.net/">https://realfavicongenerator.net/</a>에 원하는 사진을 넣기</li>
  <li><code class="language-plaintext highlighter-rouge">_includes/_head/custom.html</code> 파일에 사이트에서 출력된 코드 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- start custom head snippets --&gt;

&lt;!-- insert favicons. use https://realfavicongenerator.net/ --&gt;
&lt;link rel="apple-touch-icon" sizes="180x180" href="/assets/logo.ico/apple-touch-icon.png"&gt;
&lt;link rel="icon" type="image/png" sizes="32x32" href="/assets/logo.ico/favicon-32x32.png"&gt;
&lt;link rel="icon" type="image/png" sizes="16x16" href="/assets/logo.ico/favicon-16x16.png"&gt;
&lt;link rel="mask-icon" href="/assets/logo.ico/safari-pinned-tab.svg" color="#ffffff"&gt;
&lt;meta name="msapplication-TileColor" content="#ffffff"&gt;
&lt;meta name="theme-color" content="#ffffff"&gt;
</code></pre></div></div>

<h2 id="블로그-포스트-작성">블로그 포스트 작성</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_posts</code> 폴더에 <code class="language-plaintext highlighter-rouge">XXXX(YEAR)-XX(MONTH)-XX(DAY)-(NAME).md</code> 파일 생성</li>
  <li>포스트 내용을 쓰기 위한 <code class="language-plaintext highlighter-rouge">MarkDown</code> 문법은 <a href="_posts/2022-10-29-markdown1.md">해당 게시글</a>을, <code class="language-plaintext highlighter-rouge">html</code> 태그의 사용 방법은 <a href="_posts/2022-09-20-html1.md">해당 게시글</a>을 참고</li>
</ul>

<h3 id="상단에-머릿말-양식-작성하기">상단에 머릿말 양식 작성하기</h3>
<ul>
  <li>파일 상단에 <code class="language-plaintext highlighter-rouge">---</code>에 둘러싸인 내용 작성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
title: "[Blog] macOS에서 Minimal Mistakes로 깃허브 블로그 만들기"

categories:
    - Github.io

tag:
    [HTML, JavaScript, SCSS, Ruby]

toc: true
toc_sticky: true

date: 2022-09-26
lastmod: 2022-09-26
---
</code></pre></div></div>

<table>
    <thead>
        <tr>
            <th>양식 이름</th>
            <td>양식 설명</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>title</th>
            <td>포스트 제목</td>
        </tr>
        <tr>
            <th>categories</th>
            <td>포스트 카테고리</td>
        </tr>
        <tr>
            <th>tags</th>
            <td>포스트 태그</td>
        </tr>
        <tr>
            <th>toc</th>
            <td>우측 상단의 목차</td>
        </tr>
        <tr>
            <th>toc_label</th>
            <td>목차 이름</td>
        </tr>
        <tr>
            <th>toc_icon</th>
            <td>목차 아이콘</td>
        </tr>
        <tr>
            <th>toc_sticky</th>
            <td>목차 고정 여부</td>
        </tr>
        <tr>
            <th>date</th>
            <td>포스트 작성일</td>
        </tr>
        <tr>
            <th>lastmod</th>
            <td>포스트 수정일</td>
        </tr>
        <tr>
            <th>author_profile</th>
            <td>프로필 창 표시 여부</td>
        </tr>
    </tbody>
</table>

<h3 id="포스트-내에-문자-박스-양식-넣어보기">포스트 내에 문자 박스 양식 넣어보기</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">minimal-mistakes theme</code> 내에 내장된 상자 양식을 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p class="notice--primary"&gt;
  &lt;strong&gt;
    이 항목은 현재 작성중입니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--info"&gt;
  &lt;strong&gt;
    이 항목은 macOS 기반으로 작성되었습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--danger"&gt;
  &lt;strong&gt;
    이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--warning"&gt;
  &lt;strong&gt;
    이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.
&lt;/p&gt;
</code></pre></div></div>

<div style="background-color: black; padding: 2% 2% 2% 2%">
  <p class="notice--primary">
    <strong>
      이 항목은 현재 작성중입니다.
    </strong><br />
      &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.
  </p>

  <p class="notice--info">
    <strong>
      이 항목은 macOS 기반으로 작성되었습니다.
    </strong><br />
      &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.
  </p>

  <p class="notice--danger">
    <strong>
      이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.
    </strong><br />
      &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.
  </p>

  <p class="notice--warning">
    <strong>
      이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.
    </strong><br />
      &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.
  </p>
</div>

<h2 id="블로그-추가-설정">블로그 추가 설정</h2>

<h3 id="js-빌드-설정">js 빌드 설정</h3>
<ul>
  <li><a href="https://pocj8ur4in.github.io/mac/homebrew1/">해당 게시글</a>을 통해 <code class="language-plaintext highlighter-rouge">homebrew</code> 설치</li>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">node.js</code> 설치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install node
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">node.js</code>가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node -v
// "node X.X.X" 출력 : 정상 설치
// "zsh: command not found: node" 출력 : 설치 오류
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">yarn</code> 설치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install yarn
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">yarn</code>가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn --version
// "X.X.X" 출력 : 정상 설치
// "zsh: command not found: yarn" 출력 : 설치 오류
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">package.json</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  "devDependencies": {
    "concat": "^1.0.3"
    }
  scripts": {
    "concat-js": "...assets/js/custom/custom.js",
    "uglify": "...assets/js/custom/custom.js -c -m -o assets/js/main.min.js"     
    }
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">npm</code> 설치</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력해 <code class="language-plaintext highlighter-rouge">npm</code>가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm -v
// "X.X.X" 출력 : 정상 설치
// "zsh: command not found: npm" 출력 : 설치 오류
</code></pre></div></div>

<h3 id="admin-설정">ADMIN 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Gemfile</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'jekyll-admin', group: :jekyll_plugins
</code></pre></div></div>

<ul>
  <li>터미널 창에 다음 명령어를 입력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle install
jekyll serve
</code></pre></div></div>

<ul>
  <li><a href="http://localhost:4000/admin/">http://localhost:4000/admin/</a>를 통해 ADMIN 페이지 접속</li>
</ul>

<h3 id="블로그-방문자-통계-설정">블로그 방문자 통계 설정</h3>
<ul>
  <li><a href="https://analytics.google.com/analytics/web/provision/#/provision">Google Analytics</a>를 가입한 후 애널리틱스 데이터 스트림 설정</li>
  <li>측정 ID 복사 후 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Analytics
analytics:
  provider               : "google-gtag"
  google:
    tracking_id          : "(측정 ID)"
</code></pre></div></div>

<h3 id="블로그-애드센스-광고-설정">블로그 애드센스 광고 설정</h3>
<ul>
  <li><a href="https://www.google.co.kr/adsense/start/">Google AdSense</a> 가입 후 사이트 추가</li>
  <li><code class="language-plaintext highlighter-rouge">_includes/head/custom.html</code> 파일에 코드 붙어넣기</li>
  <li><code class="language-plaintext highlighter-rouge">_includes/footer/custom.html</code> 파일에 광고 삽입</li>
</ul>

<h2 id="minimal-mistakes-themes-디렉토리-구조">Minimal Mistakes Themes 디렉토리 구조</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minimal-mistakes
├── _data                                 # 테마를 커스터마이징하기 위한 파일을 저장하는 디렉터리 
| |                                       # (yml, yaml, json, csv, tsv 파일을 자동으로 읽어들어 site.data로 사용)
| ├── navigation.yml                      # 상단 메뉴바를 커스터마이징하기 위한 파일
| └── ui-text.yml                         # 언어별로 어떤 텍스트로 표시되는지 나열하는 파일
|
├── _site                                 # 재사용되는 html 파일을 저장하는 디렉터리 (공통된 컴포넌트들 보관)
| ├── search                              # 검색 엔진을 커스터마이징한 내용을 저장하는 디렉터리
| ├── analytics-providers
| └── custom.html                         # 분석 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일
| ├── comments-providers
| └── custom.html                         # 댓글 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일
| ├── head
| └── custom.html                         # head를 커스터마이징한 내용을 저장하는 파일
| ├── footer
| └── custom.html                         # footer를 커스마이징한 내용을 저장하는 파일
| ├── nav_list                            # 메뉴 상단바의 리스트에 대한 helper 파일
| ├── archive-single.html                 # 아카이브 문서에서 단일 문서를 표현하는 방법을 저장하는 파일
| ├── author-profiles.html                # author profile link애 대한 내용을 저장하는 파일
| ├── author-profile-custom-links.html    # author profile link를 커스마이징한 내용을 저장하는 파일
| ├── breadcrumbs.html                    # breadcrumbs에 대한 내용을 저장하는 파일
| ├── single-page
| ├── page__taxonomy.html                 # 단일 문서에서 태그와 카테고리를 표현하는 방법을 저장하는 파일
| ├── tag-list.html                       # 단일 문서에서 태그 리스트를 표현하는 방법을 저장하는 파일
| └── category-list.html                  # 단일 문서에서 카테고리 리스트를 표현하는 방법을 저장하는 파일
├── _posts                                # 블로그에 포스트한 md 파일을 저장하는 디렉터리
├── _includes
├── _layouts                              # 각 문서의 디자인과 직접적으로 연결된 전체적인 레이아웃 디렉토리
├── _sass                                 # minimal-mistakes.scss에 임포트할 수 있는 scss 파일을 저장하는 스타일시트 디렉터리
├── assets                                # css, js, 이미지 파일을 저장하는 디렉터리
| ├── _css
| ├── _images
| └── _js 
├── _config.yml                           # 블로그를 구성하기 위한 기본적인 설정값을 설정하는 yml 파일
├── Gemfile                               # 사용할 gem 플러그인 목록
├── index.html                            # 블로그 처음 홈 페이지
└── package.json
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Git" /><category term="HTML" /><category term="JavaScript" /><summary type="html"><![CDATA[이 항목은 macOS 기반으로 작성되었습니다.&gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.]]></summary></entry></feed>