<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-02T16:40:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[JS] 8. 모듈 (Module)</title><link href="http://localhost:4000/js8/" rel="alternate" type="text/html" title="[JS] 8. 모듈 (Module)" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/js8</id><content type="html" xml:base="http://localhost:4000/js8/"><![CDATA[<h2 id="모듈-module--코드를-재사용-가능한-파일-단위의-조각으로-나눈-것">모듈 (<code class="language-plaintext highlighter-rouge">Module</code>) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것</h2>

<ul>
  <li>자신만의 모듈 스코프를 갖고, 어플리케이션과 독립적으로 자체 컴파일한 단위</li>
  <li>코드의 변수, 상수, 함수, 클래스 등을  선택적으로 공개 (<code class="language-plaintext highlighter-rouge">Export</code>)</li>
  <li>이름 충돌, 종속성 등 문제 해결 및 엄격 모드 자동 적용</li>
  <li><code class="language-plaintext highlighter-rouge">Read-Only</code>로 로드되며 동일 영역에 중복 <code class="language-plaintext highlighter-rouge">import</code> 가능</li>
</ul>

<h3 id="모듈-시스템-module-system--현재는-esm-ecmascript-module이-표준">모듈 시스템 (<code class="language-plaintext highlighter-rouge">Module System</code>) → 현재는 <code class="language-plaintext highlighter-rouge">ESM</code> (<code class="language-plaintext highlighter-rouge">ECMAScript Module</code>)이 표준!</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">"type": "module",</code> 추가</li>
  <li>모든 파일의 확장자를 <code class="language-plaintext highlighter-rouge">mjs</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm i esm → $&gt; node -r esm mod.js</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "name": "js",
  "version": "1.0.0",
  "description": "package.json for test",
  "main": "npm.js",
  "author": "pocj8ur4in",
  "type": "module", 
  "license": "ISC"
}
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/76d1a998-c16d-4823-8f8b-18e7c9399904" width="50%" /></p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[모듈 (Module) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것]]></summary></entry><entry><title type="html">[vocawik] 2. vocawik 프로젝트 설계</title><link href="http://localhost:4000/vocawik2/" rel="alternate" type="text/html" title="[vocawik] 2. vocawik 프로젝트 설계" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/vocawik2</id><content type="html" xml:base="http://localhost:4000/vocawik2/"><![CDATA[<h2 id="프로젝트-목표-project-goal--프로젝트-진행-과정에서-이루고자-하는-사항들을-정리">프로젝트 목표 (<code class="language-plaintext highlighter-rouge">Project Goal</code>) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">목표</td>
        <td nowrap="">설명</td>
        <td nowrap="">달성<br />여부</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">도메인 정의<br />(<code>Domain Definition</code>)</td>
        <td><ul>
          <li>사이트에서 제공하고자 하는 기능 및 책임들이 도메인별로 명확히 분리되어야 한다.</li>
        </ul></td>
        <td></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="어플리케이션-아키텍처-구조도-application-architecture-structure--사이트-내-서비스">어플리케이션 아키텍처 구조도 (<code class="language-plaintext highlighter-rouge">Application Architecture Structure</code>) : 사이트 내 서비스</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<h2 id="유저-프로필-user-profile--사이트를-이용할-사용자들을-분류">유저 프로필 (<code class="language-plaintext highlighter-rouge">User Profile</code>) : 사이트를 이용할 사용자들을 분류</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
        <td nowrap="">업무</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">관리자<br />(<code>Manager; MA</code>)</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td nowrap="">회원<br />(<code>Member; ME</code>)</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td nowrap="">비회원<br />(<code>NonMember; NE</code>)</td>
        <td></td>
        <td></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="기능-명세서-functional-specification--사이트에서-구현할-기능들을-정리">기능 명세서 (<code class="language-plaintext highlighter-rouge">Functional Specification</code>) : 사이트에서 구현할 기능들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">분류</td>
        <td nowrap="">ID</td>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
        <td nowrap="">상태</td>
        <td nowrap="">우선<br />순위</td>
        <td nowrap="">전제<br />조건</td>
        <td nowrap="">수용<br />여부</td>
        <td nowrap="">비고</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="40">회원<br />(<code>Member</code>)</td>
        <td nowrap=""><code>ME-001</code></td>
        <td nowrap="">회원 <code>ID</code> 로그인<br />(<code>MemberIdLogin</code>)</td>
        <td>'비회원'이 '아이디' 또는 '이메일'과 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 때, '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되면 '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-002</code></td>
        <td nowrap="">회원 <code>OAuth</code> 로그인<br />(<code>MemberOAuthLogin</code>)</td>
        <td>'비회원'이 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 로그인 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-003</code></td>
        <td nowrap="">회원 <code>OTP</code> 로그인<br />(<code>MemberLoginCertifyByOTP</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (<code>OTP</code>) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행할 경우에 '일회용 비밀번호'를 확인할 수 있는 '<code>OTP</code> 키'를 발급하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-004</code></td>
        <td nowrap="">회원 로그인 이메일 인증<br />(<code>MemberLoginCertifyByEmail</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (이메일 인증) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되는 경우에 '일회용 비밀번호'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-005</code></td>
        <td nowrap="">회원 로그인 문자 인증<br />(<code>MemberLoginCertifyByPhone</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (문자 인증) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되는 경우에 '일회용 비밀번호'를 확인할 수 있는 '인증 문자'를 생성 및 전송하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-006</code></td>
        <td nowrap="">회원 자동 로그인 방지<br />(<code>MemberLoginCAPTCHA</code>)</td>
        <td>'비회원'이 5회 이상 '로그인'에 실패할 경우, <code>google reCAPTCHA</code>를 통해 보안 문자를 입력한 다음에 로그인을 시도할 수 있도록 한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-007</code></td>
        <td nowrap="">회원 로그인 유지<br />(<code>MemberCreateRememberMe</code>)</td>
        <td>'비회원'이 '로그인 유지 옵션'을 활성화한 상태로 로그인을 성공하였을 때, '회원'이 브라우저를 끄고 다시 접속하더라도 로그인 상태를 2주간 유지한다.</td>
        <td nowrap="">비회원<br />↓<br />회원</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-008</code></td>
        <td nowrap="">회원 비밀번호 재설정 이메일 인증<br />(<code>MemberResetPasswordCertifyByEmail</code>)</td>
        <td>'비회원'이 '비밀번호 재설정' 버튼을 누르면, '비밀번호 재설정 아이디/이메일 입력 화면'으로 이동한다. 입력받은 값과 일치하는 회원 정보가 존재한다면, '임시 비밀번호'를 생성하여 30분간 유효한 '임시 비밀번호'를 포함한 '비밀번호 재설정 이메일'을 생성 및 전송한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-009</code></td>
        <td nowrap="">회원 비밀번호 재설정 문자 인증<br />(<code>MemberResetPasswordCertifyByPhone</code>)</td>
        <td>'비회원'이 '비밀번호 재설정' 버튼을 누르면, '비밀번호 재설정 아이디/이메일 입력 화면'으로 이동한다. 입력받은 값과 일치하는 회원 정보가 존재한다면, '임시 비밀번호'를 생성하여 30분간 유효한 '임시 비밀번호'를 포함한 '비밀번호 재설정 문자'를 생성 및 전송한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-010</code></td>
        <td nowrap="">회원 비밀번호 재설정<br />(<code>MemberResetPassword</code>)</td>
        <td>'회원'이 '로그인'을 시도할 때 '비밀번호 재설정'에서 생성된 '임시 비밀번호'를 입력받았거나, '회원'이 '회원정보 갱신 화면'에서 '비밀번호 재설정' 버튼을 누른 경우, '비밀번호 재설정' 화면으로 이동한다. 입력받은 '비밀번호' 및 '비밀번호 확인'이 이전에 사용된 적이 있는 '중복된 비밀번호'가 아니면서 유효성 검사가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였다면, 입력한 값을 포함하여 회원 정보를 갱신한다. 그리고 이전에 이루어진 '회원 로그인 유지'를 모두 해제한 다음에 '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-011</code></td>
        <td nowrap="">회원 로그아웃<br />(<code>MemberLogout</code>)</td>
        <td>'회원'이 '로그아웃' 버튼을 누르면, (만약 '회원 로그인 유지'가 이루어지고 있다면 이를 해제한 다음에) '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-012</code></td>
        <td nowrap="">회원가입<br />(<code>MemberRegister</code>)</td>
        <td>'비회원'이 '회원가입' 버튼을 누르면, '회원가입 화면'으로 이동한다. '회원가입' 화면에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이, 혹은 선택 정보인 '문자 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 서버 내 데이터베이스에 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-013</code></td>
        <td nowrap=""><code>OAuth</code> 회원가입<br />(<code>MemberOAuthRegister</code>)</td>
        <td>'비회원'이 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 회원가입 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원가입 화면'으로 이동한다. '회원가입' 화면에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이, 혹은 선택 정보인 '문자 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 데이터베이스에 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원<br />↓<br />비회원 (인증)</td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-014</code></td>
        <td nowrap="">회원가입 이메일 인증<br />(<code>MemberRegisterCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원가입 화면에서' '이메일'을 입력하고 '이메일 인증 버튼'을 눌렀을 때, '유효성 검사'가 정상적으로 이루어진다면, '인증 문자열'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고 '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '인증 문자열'과 일치한다면, 인증에 성공하였다는 것을 알린다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-015</code></td>
        <td nowrap="">회원가입 문자 인증<br />(<code>MemberRegisterCertifyByPhone</code>)</td>
        <td>'비회원'이 '회원가입 화면에서' '휴대전화 번호'를 입력하고 '휴대폰 인증 버튼'을 눌렀을 때, '유효성 검사'가 정상적으로 이루어진다면, '인증 문자열'를 확인할 수 있는 '인증 문자'를 생성 및 전송하고 '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '인증 문자열'과 일치한다면, 인증에 성공하였다는 것을 알린다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-016</code></td>
        <td nowrap="">회원정보 조회<br />(<code>MemberReadMyInfo</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-017</code></td>
        <td nowrap="">회원정보 갱신<br />(<code>MemberUpdateMyInfo</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-018</code></td>
        <td nowrap="">회원정보 갱신 이메일 인증<br />(<code>MemberUpdateMyInfoCertifyByEmail</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-019</code></td>
        <td nowrap="">회원정보 갱신 문자 인증<br />(<code>MemberUpdateMyInfoCertifyByPhone</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-020</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동<br />(<code>MemberUpdateMyOAuth</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-021</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동 해제<br />(<code>MemberDeleteMyOAuth</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-022</code></td>
        <td nowrap="">회원 탈퇴<br />(<code>MemberDeleteMyInfo</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-023</code></td>
        <td nowrap="">회원 로그인 기록 조회<br />(<code>MemberReadLoginHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-024</code></td>
        <td nowrap="">회원 비밀번호 재설정 기록 조회<br />(<code>MemberReadResetPasswordHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-025</code></td>
        <td nowrap="">회원 중복 로그인 설정<br />(<code>MemberSetDuplicateLogin</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-026</code></td>
        <td nowrap="">회원 로그인 유지 기기 조회<br />(<code>MemberReadRememberMeHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-027</code></td>
        <td nowrap="">회원 로그인 유지 기기 해제<br />(<code>MemberDeleteRememberMe</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-028</code></td>
        <td nowrap="">회원 프로필 조회<br />(<code>MemberReadMyProfile</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-029</code></td>
        <td nowrap="">회원 프로필 갱신<br />(<code>MemberUpdateMyProfile</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-030</code></td>
        <td nowrap="">회원 인터페이스 설정 조회<br />(<code>MemberReadMyInterface</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-031</code></td>
        <td nowrap="">회원 인터페이스 설정 갱신<br />(<code>MemberUpdateMyInterface</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-032</code></td>
        <td nowrap="">회원 상태 조회<br />(<code>MemberReadMyStatus</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-033</code></td>
        <td nowrap="">회원 상태 갱신<br />(<code>MemberUpdateMyStatus</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-034</code></td>
        <td nowrap="">회원 관리자 권한 요청 생성<br />(<code>MemberCreateAuthRequest</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-035</code></td>
        <td nowrap="">회원 관리자 권한 응답 조회<br />(<code>MemberReadAuthResponse</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-036</code></td>
        <td nowrap="">회원 관리자 권한 요청 및 응답 기록 조회<br />(<code>MemberReadAuthHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-037</code></td>
        <td nowrap=""><br />(<code>Member</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-038</code></td>
        <td nowrap=""><br />(<code>Member</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-039</code></td>
        <td nowrap=""><br />(<code>Member</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-040</code></td>
        <td nowrap=""><br />(<code>Member</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="15">관리자<br />(<code>Manager</code>)</td>
        <td nowrap=""><code>MA-001</code></td>
        <td nowrap="">관리자 보안 로그인<br />(<code>ManagerSecureLogin</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-002</code></td>
        <td nowrap="">관리자 보안 로그아웃<br />(<code>ManagerSecureLogout</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-003</code></td>
        <td nowrap="">관리자 과도한 로그인 시도 제한<br />(<code>ManagerLimitExcessiveLogin</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-004</code></td>
        <td nowrap="">관리자 회원 권한 갱신<br />(<code>ManagerUpdateAuth</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-005</code></td>
        <td nowrap="">관리자 권한 요청 기록 조회<br />(<code>ManagerReadAuthRequestHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-006</code></td>
        <td nowrap="">관리자 권한으로 IP 차단<br />(<code>ManagerAuthBlockIP</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-007</code></td>
        <td nowrap="">관리자 권한으로 회원 제재<br />(<code>ManagerAuthPenaltyMember</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-008</code></td>
        <td nowrap="">관리자 권한으로 문서 생성<br />(<code>ManagerAuthCreateDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-009</code></td>
        <td nowrap="">관리자 권한으로 문서 갱신<br />(<code>ManagerAuthUpdateDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-010</code></td>
        <td nowrap="">관리자 권한으로 문서 삭제<br />(<code>ManagerAuthDeleteDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-011</code></td>
        <td nowrap="">관리자 권한으로 댓글 생성<br />(<code>ManagerAuthCreateComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-012</code></td>
        <td nowrap="">관리자 권한으로 댓글 갱신<br />(<code>ManagerAuthUpdateComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-013</code></td>
        <td nowrap="">관리자 권한으로 댓글 삭제<br />(<code>ManagerAuthDeleteComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-014</code></td>
        <td nowrap=""><br />(<code>Manager</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-015</code></td>
        <td nowrap=""><br />(<code>Manager</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">문서<br />(<code>Document</code>)</td>
        <td nowrap=""><code>DO-001</code></td>
        <td nowrap=""><br />(<code>Document</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">위키<br />(<code>Wiki</code>)</td>
        <td nowrap=""><code>WI-001</code></td>
        <td nowrap=""><br />(<code>Wiki</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">검색<br />(<code>Search</code>)</td>
        <td nowrap=""><code>SE-001</code></td>
        <td nowrap=""><br />(<code>Search</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">게시판<br />(<code>Board</code>)</td>
        <td nowrap=""><code>BO-001</code></td>
        <td nowrap=""><br />(<code>Board</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">댓글<br />(<code>Comment</code>)</td>
        <td nowrap=""><code>CO-001</code></td>
        <td nowrap=""><br />(<code>Comment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">알림<br />(<code>Notice</code>)</td>
        <td nowrap=""><code>NO-001</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
      <tr>
        <td rowspan="1">채팅<br />(<code>Chat</code>)</td>
        <td nowrap=""><code>CH-001</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><code></code></td>
        <td nowrap=""><a></a></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="래퍼런스-references--프로젝트-설계-과정에-참고한-자료">래퍼런스 (<code class="language-plaintext highlighter-rouge">References</code>) : 프로젝트 설계 과정에 참고한 자료</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="" style="padding-left: 4%; padding-right: 4%;">분류</td>
        <td nowrap="">이름</td>
        <td nowrap="">저자</td>
        <td nowrap="">주소</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="" rowspan="2">논문</td>
        <td>보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼 (2018)</td>
        <td nowrap="">김도희</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td>보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문. (2012)</td>
        <td nowrap="">임현정</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="1">기사</td>
        <td>한국 보컬로이드는 어떻게 나아가야할까?</td>
        <td nowrap="">안태춘</td>
        <td nowrap=""><a href="https://www.newslight.kr/news/655301">더뉴스라이트</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">도서</td>
        <td>서비스를 성공시키는 기획자의 비법 노트</td>
        <td nowrap="">조이</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=295601741">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>사례로 배우는 언어 전환 프로젝트 관리</td>
        <td nowrap="">남경호</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>도메인 주도 설계로 시작하는 마이크로서비스 개발</td>
        <td nowrap="">한정헌, 유해식, 최은정, 이주영</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">문서</td>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말">문서</a></td>
      </tr>
      <tr>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말/심화</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말/심화">문서</a></td>
      </tr>
      <tr>
        <td>공공기관 웹사이트 구축·운영 가이드</td>
        <td nowrap="">행정안전부</td>
        <td nowrap=""><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj204K9zoKEAxWtLUQIHQsyB4AQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.mois.go.kr%2Fcmm%2Ffms%2FFileDown.do%3FatchFileId%3DFILE_00084689_1WeMtZ%26fileSn%3D1&amp;usg=AOvVaw1TqMgiQXNjFgQfouwTtQh2&amp;opi=89978449">문서</a></td>
      </tr>
            <tr>
        <td nowrap="" rowspan="2">사이트</td>
        <td nowrap="" colspan="2">나무위키</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:대문">홈페이지</a></td>
      </tr>
      <tr>
        <td nowrap="" colspan="2">openNAMU</td>
        <td nowrap=""><a href="https://github.com/openNAMU/openNAMU">깃허브 저장소</a></td>
      </tr>
    </tbody>
  </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[프로젝트 목표 (Project Goal) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리]]></summary></entry><entry><title type="html">[JS] 7. 객체지향 프로그래밍 (OOP)</title><link href="http://localhost:4000/js7/" rel="alternate" type="text/html" title="[JS] 7. 객체지향 프로그래밍 (OOP)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js7</id><content type="html" xml:base="http://localhost:4000/js7/"><![CDATA[<h2 id="객체지향-프로그래밍-object-oriented-programming--원시-타입을-제외한-모든-것이-객체">객체지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">Object-Oriented Programming</code>) : 원시 타입을 제외한 모든 것이 객체</h2>

<blockquote>
  <p>자바스크립트는 프로토타입 (<code class="language-plaintext highlighter-rouge">Prototype</code>) 기반 객체지향 프로그래밍 언어 (<code class="language-plaintext highlighter-rouge">Lisp</code>  → <code class="language-plaintext highlighter-rouge">Scheme</code> → <code class="language-plaintext highlighter-rouge">JavaScript</code>)</p>
</blockquote>

<ul>
  <li>객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>)과 클래스 (<code class="language-plaintext highlighter-rouge">Class</code>)를 통해 생성된 인스턴스 타입 (<code class="language-plaintext highlighter-rouge">Instance Type</code>) → <code class="language-plaintext highlighter-rouge">this</code></li>
  <li>프로퍼티는 각 인스턴스의 <code class="language-plaintext highlighter-rouge">EnvRec</code>에 생성되고, 메소드는 프로토타입에 할당되어 모든 인스턴스가 동일
    <ul>
      <li>특정 인스턴스에 종속되지 않는 함수는 정적인 클래스 메소드 (<code class="language-plaintext highlighter-rouge">Class Method</code>)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Animal {}
class Dog extends Animal {}
const lucy = new Dog();

console.log(lucy instanceof Dog); // true
console.log(lucy instanceof Animal); // true
console.log(lucy instanceof Object); // true

console.log(Object.getPrototypeOf(lucy)); // Animal {}
console.log(Object.getPrototypeOf(Dog)); // [class Animal]
console.log(Object.getPrototypeOf(Animal)); // {}
</code></pre></div></div>

<ul>
  <li>프로토타입은 단방향 <code class="language-plaintext highlighter-rouge">LinkedList</code>으로 연결된 구조 → 프로토타입 체인 (<code class="language-plaintext highlighter-rouge">Prototype Chain</code>)
    <ul>
      <li>특정 프로퍼티에 접근할 때 해당 객체에 프로퍼티가 없으면, 내부 참조를 따라 상위 프로토타입을 순차적으로 검색</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/eabe913e-8056-4309-bd18-ea12d555dfc5" width="50%" /></p>

<h3 id="정적-필드--메소드-static-field--method--특정-인스턴스와-무관하게-클래스에-존재하는-메소드">정적 필드 &amp; 메소드 (<code class="language-plaintext highlighter-rouge">Static Field &amp; Method</code>) : 특정 인스턴스와 무관하게 클래스에 존재하는 메소드</h3>

<ul>
  <li>인스턴스 프로퍼티를 참조할 수 없음 → <code class="language-plaintext highlighter-rouge">Static</code>  영역에 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Animal {
  static ID = 1;
  static isDog(ani) {
    return ani.name === 'Dog';
  }
} 
const dog = new Animal('Dog');
dog.isDog(dog); // TypeError: dog.isDog is not a function
Animal.isDog(dog); // OK
</code></pre></div></div>

<blockquote>
  <p>싱글톤 패턴 (<code class="language-plaintext highlighter-rouge">Singleton Pattern</code>) : 어떤 클래스가 한 번만 인스턴스화되어, 그 인스턴스에 대한 전역 접근 제공</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Singleton {
  static #_instance; // 관례상 protected
  constructor() {
    if (Singleton.#_instance) return Singleton;
    this.name = 'Singleton';
    Singleton.#_instance = this;
  }

  static getInstance() {
    return this.#_instance || new this();
  }
}

const s1 = new Singleton();
const s2 = new Singleton();
</code></pre></div>  </div>
</blockquote>

<h3 id="접근자-accessor-프로퍼티--특정-인스턴스와-무관하게-클래스에-존재하는-메소드">접근자 (<code class="language-plaintext highlighter-rouge">Accessor</code>) 프로퍼티 : 특정 인스턴스와 무관하게 클래스에 존재하는 메소드</h3>

<ul>
  <li>접근자 프로퍼티을 통해 함수를 프로퍼티처럼 활용할 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Emp1 {
  set fullName(name) { // set을 프로퍼티처럼 활용할 수 있음 → accessor
    [this.firstName, this.lastName] = name.split(' ');
  }
  
  get fullName() {  // get을 프로퍼티처럼 활용할 수 있음 → accessor
    return `${this.firstName} ${this.lastName}`;
  }
}

class Emp2 { // stackOverflow 발생!
  set name(nm) { this.name = nm; }
  get name() { return this.name; }
}

class Emp3 {
  #name;

  set name(#name) { this.#name = name; }
  get name() { return this.name; }
}

const hong1 = new Emp1();
hong1.fullName = 'Gil-Dong Hong';
console.log(hong1.fullName);

const hong2 = new Emp2();
hong2.fullName = 'Gil-Dong Hong';
console.log(hong2.fullName);

const hong3 = new Emp3();
hong3.fullName = 'Gil-Dong Hong';
console.log(hong3.fullName);
</code></pre></div></div>

<h3 id="프록시-proxy-객체--객체의-특정-동작을-가로채서-hooking해서-추가-동작-수행">프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>) 객체 : 객체의 특정 동작을 가로채서 (<code class="language-plaintext highlighter-rouge">Hooking</code>)해서 추가 동작 수행</h3>

<ul>
  <li>객체의 작업에 대한 기록 → 로깅 (<code class="language-plaintext highlighter-rouge">Logging</code>)</li>
  <li>잘못된 접근에 대한 오류 (<code class="language-plaintext highlighter-rouge">Validation Check</code>)</li>
  <li>기능 제어 (읽기 전용 등) 및 객체 정보 숨기기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const obj = {
  id: 1,
  name: 'Hong',
  f() {
    console.log('fffff')
  },
};

export const objProxy = new Proxy(obj, {
  set(target, prop, value){
    console.log('proxy.set&gt;&gt;', prop, value);
    target[prop] = value;
  },
  get(target, prop){
    console.log('proxy.get &gt;&gt; ', prop);
    return target[prop];
  },
});

objProxy.id = 100;
console.log('obj.id&gt;&gt;', objProxy.id, obj['id']);
</code></pre></div></div>

<h3 id="상속-inheritance--subclass가-프로토타입-체인으로-superclass의-모든-데이터와-기능을-상속">상속 (<code class="language-plaintext highlighter-rouge">Inheritance</code>) : <code class="language-plaintext highlighter-rouge">SubClass</code>가 프로토타입 체인으로 <code class="language-plaintext highlighter-rouge">Superclass</code>의 모든 데이터와 기능을 상속</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Dog extends Animal {
  constructor(name) {
    super(name); // 필수(for chaining) + 중복(overload) 불가!
  }

  bark() {
    console.log('bowwow!');
  }
}
</code></pre></div></div>

<ul>
  <li>모든 객체는 프로토타입 체인 (<code class="language-plaintext highlighter-rouge">__proto__</code>) 이라는 내부 속성을 가짐
    <ul>
      <li>객체를 생성하는 생성자 함수는 <code class="language-plaintext highlighter-rouge">prototype</code> 속성을 가짐 → 해당 프로토타입이 객체의 프로토타입가 됨</li>
      <li>하위 객체는 상위 객체의 프로토타입을 따라 상위 객체의 속성 및 메소드를 탐색</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>스택 (<code class="language-plaintext highlighter-rouge">Stack</code>) &amp; 큐 (<code class="language-plaintext highlighter-rouge">Queue</code>) : 데이터를 저장하고 관리하기 위한 자료구조</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Stack { // 스택 자료구조
    collection = [];

    push(value) {
        this.collection.push(value);
    }
    pop() {
        return this.collection.pop();
    }
}

const stack = new Stack();
stack.push(1); // 추가하기
stack.push(2); // 추가하기
stack.push(3); // 추가하기
console.log(stack.pop()) // 마지막으로 추가된 하나 꺼내기

class Queue { // 큐 자료구조
    collection = [];

    enqueue(value) {
        this.collection.push(value);
    }

    dequeue() {
        return this.collection.shift();
    }
}

const queue = new Queue();
queue.enqueue(1); // 추가하기
queue.enqueue(2); // 추가하기
queue.enqueue(3); // 추가하기
console.log(queue.dequeue()) // 마지막으로 추가된 하나 꺼내기


</code></pre></div>  </div>
</blockquote>

<h4 id="메소드-오버라이딩-method-overriding--자식-클래스가-부모-클래스의-메소드를-재정의">메소드 오버라이딩 (<code class="language-plaintext highlighter-rouge">Method Overriding</code>) : 자식 클래스가 부모 클래스의 메소드를 재정의</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Animal {
  ...
  id = 1;       // 멤버 프로퍼티
  #age = 10;    // 멤버 프로퍼티 (protected)
  
  toString() {  // 객체의 toString() 오버라이딩 ([메소드] 다형성!)
    return `This animal's name is ${this.name}.`;
  }
} 
</code></pre></div></div>

<h4 id="다중-상속-multiple-inheritance--한-클래스가-여러-클래스들을-상속">다중 상속 (<code class="language-plaintext highlighter-rouge">Multiple Inheritance</code>) : 한 클래스가 여러 클래스들을 상속</h4>

<ul>
  <li>자바스크립트는 단일 상속 언어 → <code class="language-plaintext highlighter-rouge">Mixin</code>을 통해 제한적으로 구현할 수 있음 (타입스크립트 : <code class="language-plaintext highlighter-rouge">Interface</code>)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Mixin 정의
const myMixin = {
  sayHello() {
    console.log("Hello!");
  },
  sayGoodbye() {
    console.log("Goodbye!");
  },
};

function MyClass() {
  ... // 클래스의 생성자 로직
}

Object.assign(MyClass.prototype, myMixin); // Mixin 적용

const obj = new MyClass(); // 객체 생성 및 Mixin 메서드 호출
obj.sayHello();    // 출력: Hello!
obj.sayGoodbye();  // 출력: Goodbye!
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[객체지향 프로그래밍 (Object-Oriented Programming) : 원시 타입을 제외한 모든 것이 객체]]></summary></entry><entry><title type="html">[JS] 6. 배열 (Array) &amp;amp; 이터레이터 (Iterator)</title><link href="http://localhost:4000/js6/" rel="alternate" type="text/html" title="[JS] 6. 배열 (Array) &amp;amp; 이터레이터 (Iterator)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js6</id><content type="html" xml:base="http://localhost:4000/js6/"><![CDATA[<h2 id="배열-array--순서가-있는-데이터-집합">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 순서가 있는 데이터 집합</h2>

<ul>
  <li>배열의 각 요소 (<code class="language-plaintext highlighter-rouge">element</code>)인 프로퍼티 리터럴을 인덱스 (프로퍼티 키)로 접근</li>
  <li><code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가지며, 배열의 길이보다 큰 접근은 <code class="language-plaintext highlighter-rouge">undefined</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 조정해 배열 길이를 조절할 수 있음 (<code class="language-plaintext highlighter-rouge">-1 &lt; length &lt; 2^32</code>)</li>
    </ul>
  </li>
  <li>자바스크립트에서 배열은 비균질적 (<code class="language-plaintext highlighter-rouge">Nonhomogeneous</code>) : 고정 위치 및 크기를 가지지 않음
    <ul>
      <li>희소 배열 (<code class="language-plaintext highlighter-rouge">sparse array</code>) 자료 구조 : 검색에는 약하지만, 조작에는 우수!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // 3의 크기를 갖는 배열 생성
const arr1 = Array(3); // [ &lt;3 empty items&gt; ]
const arr2 = new Array(3); // [ &lt;3 empty items&gt; ]
const arr3 = [,,,]; // [ &lt;3 empty items&gt; ]

// 3의 크기를 갖고 1로 채워진 배열 생성
const arr4 = Array(3).fill(1); // [ 1,1,1 ]

// 3의 크기를 갖고 인덱스 1부터 1이 존재하는 배열 생성
const arr5 = Array(3).fill(1, 1); // [ &lt;1 empty item&gt;, 1, 1 ]

// 3의 크기를 갖고 인덱스 1 이상 2 미만에 1이 존재하는 배열 생성
const arr6 = Array(3).fill(1, 0, 2); // [ &lt;1 empty item&gt;, 1, &lt;1 empty item&gt; ]

// arr2를 복제한 유사 배열 객체 생성
const arr7 = Array.from(arr2); // [ undefined, undefined, undefined ]

// 3의 크기를 갖는 유사 배열 객체 생성
const arr8 = Array.from(Array(3)); // [ undefined, undefined, undefined ]

// 3의 크기를 갖고 1,2,3이 존재하는 유사 배열 객체 생성
const arr9 = Array.from(Array(3), (_, i)  =&gt; i + 1); // [ 1, 2, 3 ]

// 3의 크기를 갖고 1,2,3이 존재하는 유사 배열 객체 생성
const arr10 = Array.from(Array(3).keys()); // [ 1, 2, 3 ]

// 3의 크기를 갖고 1로 채워진 배열 생성
const arr11 = [];
arr11.push(1); // [ 1 ]
arr11.push(1); // [ 1, 1 ]
arr11.push(1); // [ 1, 1, 1 ]

// 스택 배열
const stack = [];
stack.push(1);
stack.push(2);
stack.push(3);
stack.pop();

// 큐 배열
const queue = [];
queue.push(1);
queue.push(2);
queue.push(3);
queue.shift();

// 스택 배열, 큐 배열 초기화
stack.length = 0;
queue.length = 0;

// 배열 검색
const arr12 = [ 3, 7, 3, 9, 2];
arr12.indexOf(3);  // 0
arr.lastIndexOf(3); // 2
arr.includes(3); // true

const arr13 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 2 } ];
const idx = arr13.findIndex(item =&gt; item.id === 2); // 1

// 배열 루프
arr13.forEach(( arr, idx ) =&gt; console.log(arr.id));

// 배열 요소 합치기
const arr14 = arr1.concat(arr2);
const arr15 = [...arr1, ...arr2];

// 배열 평탄화
const arr16 = [ 1, 2, [3] ].flat();
console.log(arr16); // 1, 2, 3

const arr17 = [ 1, 2, [[3]] ].flat();
console.log(arr17); // 1, 2, [3]

const arr18 = [ 1, 2, [[3]] ].flat(2);
console.log(arr18); // 1, 2, 3
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = [1, 2, 3, 4, 5];

// ex1) [2,3]을 추출
const ex1 = arr.slice(1,3);

console.log(`\n#1`);
console.log(ex1);

// ex2) [3]부터 모두 다 추출
const ex2 = arr.slice(arr.indexOf(3));

console.log(`\n#2`);
console.log(ex2);

// ex3) [2,3,4] 제거하기
arr.splice(1, 3)

console.log(`\n#3`);
console.log(arr);

// ex4) 복원하기
arr.splice(1, 0, 2,3,4)

console.log(`\n#4`);
console.log(arr);

// ex5) [3] 부터 끝까지 제거하기
arr.splice(arr.indexOf(3))

console.log(`\n#5`);
console.log(arr);

// ex6) 복원하기
arr.splice(2, 0, 3,4,5)

console.log(`\n#6`);
console.log(arr);

// ex7) [1,2, 'X', 'Y', 'Z', 4, 5] 만들기
arr.splice(2, 1)
arr.splice(2, 0, 'X', 'Y', 'Z')

console.log(`\n#7`);
console.log(arr);

// ex8) 위 7번 문제를 splice를 사용하지 말고 작성하시오.
arr.splice(2, 3)
const ex8 = [...arr.slice(0, 2), 'X', 'Y', 'Z' , ...arr.slice(2)]

console.log(`\n#8`);
console.log(ex8);
</code></pre></div></div>

<blockquote>
  <p>리스트 (<code class="language-plaintext highlighter-rouge">List</code>) : 중첩 참조 <code class="language-plaintext highlighter-rouge">link</code>를 가진 객체</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const array = [1, 2, 3, …]; // 배열

const list = { // 리스트
    value: 1,
    rest: {   // 메모리 주소 (link)
        value: 2,
        rest: {
            value: 3,
            rest: {...}
        }
    }
}
</code></pre></div>  </div>

  <p>→ 자비스크립트의 <code class="language-plaintext highlighter-rouge">Array</code>는 <code class="language-plaintext highlighter-rouge">List</code> : <code class="language-plaintext highlighter-rouge">List</code>는 검색은 느리지만, 조작하는 것은 쉽다!</p>
</blockquote>

<h3 id="유사-배열-객체-array-like-object--배열과-유사한-형태를-갖지만-배열은-아닌-객체">유사 배열 객체 (<code class="language-plaintext highlighter-rouge">Array-like Object</code>) : 배열과 유사한 형태를 갖지만, 배열은 아닌 객체</h3>

<ul>
  <li>문자열, <code class="language-plaintext highlighter-rouge">Object</code>, <code class="language-plaintext highlighter-rouge">arguments</code>, <code class="language-plaintext highlighter-rouge">NodeList</code>, <code class="language-plaintext highlighter-rouge">JQuery</code> 객체 등 컬렉션 (<code class="language-plaintext highlighter-rouge">Collection</code>) 형태의 객체 데이터</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array.isArray(x) || x instanceof Array : false
</code></pre></div></div>

<ul>
  <li>인덱스는 <code class="language-plaintext highlighter-rouge">0</code>부터 시작해야 하며, 반드시 <code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가짐</li>
  <li><code class="language-plaintext highlighter-rouge">for ~ of</code> 등을 통해 순회 가능한 <code class="language-plaintext highlighter-rouge">iterable</code>한 객체 (<code class="language-plaintext highlighter-rouge">cf</code>. <code class="language-plaintext highlighter-rouge">iterator</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">forEach</code>를 제외한 나머지 유사 배열 객체는 <code class="language-plaintext highlighter-rouge">Array</code> 메소드를 사용할 수 없음</li>
  <li><code class="language-plaintext highlighter-rouge">Array.from()</code>으로 배열로 만들 수 있음</li>
</ul>

<h2 id="이터레이터-iterator--next-함수-호출-시-계속-그-다음-값을-반환하는-객체">이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>) : <code class="language-plaintext highlighter-rouge">next()</code> 함수 호출 시 계속 그 다음 값을 반환하는 객체</h2>

<ul>
  <li>현재 어디에 있고, 다음엔 어디로 가는지 아는 포인터 (<code class="language-plaintext highlighter-rouge">Pointer</code>)
    <ul>
      <li>이터러블 (<code class="language-plaintext highlighter-rouge">Iterable</code>) 프로토콜 : <code class="language-plaintext highlighter-rouge">Symbol.iterator</code>를 구현 및 상속한 메소드를 호출하면, 이터레이터 반환</li>
      <li>이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>) 프로토콜 : <code class="language-plaintext highlighter-rouge">next()</code>를 호출하면, <code class="language-plaintext highlighter-rouge">value()</code>, <code class="language-plaintext highlighter-rouge">done()</code>을 가진 이터레이터 리터럴 반환</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ItDog1 extends Dog {
  [Symbol.iterator]() {
    return this.name.split(', ').values();
  }
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const itDog1 = new ItDog1('Toby, Max, Sam');
console.log([...itDog1]);

class ItDog2 extends Dog {
  [Symbol.iterator]() {
    let idx = 0;
    const names = this.name.split(/,\s?/);
    return {
      next() {
        return { value: names[idx++],
                 done: idx &gt; names.length };
      }
    };
  }
} 
const itDog2 = new ItDog2('Toby, Max, Sam');
for (const d of itDog2) console.log(d);
const iter = itDog2[Symbol.iterator]();
console.log(iter.next());  // 4회 반복
</code></pre></div></div>

<h3 id="제너레이터-generator--제너레이터-함수-function의-실행을-제어하는-함수">제너레이터 (<code class="language-plaintext highlighter-rouge">Generator</code>) : 제너레이터 함수 <code class="language-plaintext highlighter-rouge">function*()</code>의 실행을 제어하는 함수</h3>

<ul>
  <li>실행 과정에서 <code class="language-plaintext highlighter-rouge">yield</code>를 만나면, 호출자 (<code class="language-plaintext highlighter-rouge">caller</code>)에게 정보 반환과 제어권을 넘김
    <ul>
      <li>제너레이터를 호출하면 이터레이터를 얻음 → 실행이 한번에 끝나지 않는다!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function* route() { // function* ~ yield → iterator를 return하고, 일시정지(pause)한 상태로 시작!
  const start = yield "출발 역은?";  // yield가 있으므로 caller에게 제어권을 넘긴다.
  const end = yield "도착 역은?";

  return `${start}역에서 출발하여 ${end}역에 도착합니다.`;
}

const caller = route();
caller.next();
caller.next('을지로입구');
caller.next('강남');
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[배열 (Array) : 순서가 있는 데이터 집합]]></summary></entry><entry><title type="html">[JS] 5. 함수 (Function)</title><link href="http://localhost:4000/js5/" rel="alternate" type="text/html" title="[JS] 5. 함수 (Function)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js5</id><content type="html" xml:base="http://localhost:4000/js5/"><![CDATA[<h2 id="함수-function--일련의-과정을-코드-블록으로-감싸-하나의-단위로-정의한-것">함수 (<code class="language-plaintext highlighter-rouge">Function</code>) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c6d16c9b-7b9c-4340-bbab-88b15bfd53db" width="80%" /></p>

<ul>
  <li>자바스크립트의 함수는 객체 타입의 값 → 함수 또한 함수 리터럴 (<code class="language-plaintext highlighter-rouge">functional literal</code>)로 생성할 수 있음</li>
  <li>일반 객체와 달리, 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 가짐</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/05176279-d1d8-4756-8bb3-5186474aa123" width="80%" /></p>

<h3 id="함수-정의-function-definition--함수-호출-이전에-인수를-전달받을-매개변수-문-반환값을-지정">함수 정의 (<code class="language-plaintext highlighter-rouge">Function Definition</code>) : 함수 호출 이전에 인수를 전달받을 매개변수, 문, 반환값을 지정</h3>

<blockquote>
  <p>함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되므로, 함수는 정의된다고 할 수 있다.</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0b6c992d-5608-47a8-b2bc-0af11c3c9b24" width="80%" /></p>

<h4 id="함수-선언문-function-declaration">함수 선언문 (<code class="language-plaintext highlighter-rouge">Function Declaration</code>)</h4>

<ul>
  <li>함수 선언문은 함수 리터럴과 형태가 동일</li>
  <li>함수 리터럴은 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음</li>
</ul>

<h4 id="함수-표현식-function-expression">함수 표현식 (<code class="language-plaintext highlighter-rouge">Function Expression</code>)</h4>

<h4 id="function-생성자-함수"><code class="language-plaintext highlighter-rouge">Function</code> 생성자 함수</h4>

<h4 id="화살표-함수-arrow-function">화살표 함수 (<code class="language-plaintext highlighter-rouge">Arrow Function</code>)</h4>

<h3 id="함수-매개변수-argument--값-parameter--변수">함수 매개변수 (<code class="language-plaintext highlighter-rouge">Argument</code> : 값, <code class="language-plaintext highlighter-rouge">Parameter</code> : 변수)</h3>

<h3 id="즉시-호출-함수-iife">즉시 호출 함수 <code class="language-plaintext highlighter-rouge">IIFE</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function() { ... })();
</code></pre></div></div>

<h3 id="함수의-호출-방식과-this">함수의 호출 방식과 <code class="language-plaintext highlighter-rouge">this</code></h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b706b06f-966b-458a-a6f5-22131c6681ff" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code>를 바인딩하는 방법 : <code class="language-plaintext highlighter-rouge">call</code>, <code class="language-plaintext highlighter-rouge">apply</code>, <code class="language-plaintext highlighter-rouge">bind</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(id) {
  console.log(this, id, this.name);
}

const obj = { name: 'Kim' };

// bind
const bf1 = func.bind(obj);
bf1(1, '서울');

// apply
func.apply(obj, [ 2, '부산' ]);

// call
func.call(obj, 3, '대구');
</code></pre></div></div>

<h2 id="순수-함수-pure-function--함수로서의-함수">순수 함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>) : 함수로서의 함수</h2>

<ul>
  <li>입력이 같으면 결과도 같다! → <code class="language-plaintext highlighter-rouge">Side Effect</code>가 없다. 즉, 외부의 값을 변경시키지 않아야 한다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const weeks = ['일', '월', '화', '수', '목', '금', '토'];

const getWeekName = function(weekNo) {
  return `${weeks[weekNo]}요일`;
};

const day = new Date().getDay();
console.log(`오늘은 ${getWeekName(day)}입니다!`);
</code></pre></div></div>

<p>→ 외부에 값을 두지 않고 내부에 값을 두는 클로저를 활용해야 한다!</p>

<h2 id="고차-함수-higher-order-function--다른-함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 다른 함수를 인자로 받거나 함수를 반환하는 함수</h2>

<blockquote>
  <p>자바스크립트에서의 함수는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class Citizen</code>)</p>

  <ol>
    <li>변수에 할당 (<code class="language-plaintext highlighter-rouge">Assignment</code>)할 수 있다.</li>
    <li>다른 변수의 인자 (<code class="language-plaintext highlighter-rouge">Argument</code>)로 전달될 수 있다.</li>
    <li>다른 함수의 결과로 반환 (<code class="language-plaintext highlighter-rouge">Return</code>)될 수 있다.</li>
  </ol>

  <p>→ 함수가 일급 객체이므로, 함수를 데이터와 유사하게 다룰 수 있어 ‘고차 함수’로서 활용될 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const double = (n) =&gt; { return n * 2; };
console.log(double(4)); // 4 * 2 = 8
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const adder = added =&gt; num =&gt; num + added;
console.log(adder(5)(3)); // 5 + 3 = 8
</code></pre></div></div>

<ul>
  <li>함수의 형태로 반환되는 함수를 모두 고차 함수라 정의할 수 있다.
    <ul>
      <li>함수는 일급 객체 → 일급 객체로서의 함수는 고차 함수로 활용 가능</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>함수를 리턴하는 함수를 커리 함수 (<code class="language-plaintext highlighter-rouge">Curry Function</code>)라고 부르던데…?</p>

  <ul>
    <li>커리 함수라는 용어로, 고차 함수를 ‘함수를 인자로 받는 함수’에만 한정해 사용할 수 있음
      <ul>
        <li>엄밀히 말하면, 고차 함수가 커리 함수를 포함하는 개념</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Array.map()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 호출한 다음, 그 결과를 새로운 배열로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].map((num) =&gt; { return num * num; })); // [ 1, 4, 9, 16, 25 ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.filter()</code> 함수 : 배열의 요소 중에 주어진 조건을 만족하는 요소만을 추출하여 새로운 배열로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].filter((num) =&gt; { return num % 2 === 0 })); // [ 2, 4 ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.reduce()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 누적하여 하나의 값으로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].reduce((accumulator, currentValue)
  =&gt; { return accumulator + currentValue;}, 0)); // 15
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.forEach()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행 (반환값이 존재하지 않음)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5].forEach((num) =&gt; { console.log(num); }); // 1부터 5까지 순서대로 출력
</code></pre></div></div>

<h2 id="콜백-함수-callback-function--매개변수를-통해-다른-함수의-내부로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) : 매개변수를 통해 다른 함수의 내부로 전달되는 함수</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; { console.log(`출력`); }, 1);
</code></pre></div></div>

<ul>
  <li>고차 함수의 인자로 전달되어, 특정 동작을 수행하거나 완료 시에 호출
    <ul>
      <li>콜백 함수를 전달받은 고차 함수는 함수 내부에서 이 콜백 함수르 호출 (<code class="language-plaintext highlighter-rouge">Invoke</code>)할 수 잇음</li>
      <li>부르는 조건에 따라서 콜백 함수의 실행 조건을 결정할 수 있음</li>
    </ul>
  </li>
  <li>콜백 함수를 언제 호출하는지에 따라, 자바스크립트 엔진이 콜백 함수의 호출 시점을 결정
    <ul>
      <li>함수가 실행되면 콜 스택에 함수를 넣었다가, 함수에서 반환이 일어날 때 가장 위쪽에서 해당 함수를 꺼냄</li>
      <li>이벤트 루프는 콜 스택과 테스크 큐를 주시하고 있다가, 스택이 비어 있으면 큐의 첫번째 콜백을 스택에 쌓아 실행</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>매개변수를 통해 다른 함수로 전달되는 함수는 콜백 함수, 매개변수를 통해 콜백 함수를 전달받는 함수는 고차 함수!</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// printString : 두개의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const printString = (callbackHof, callback_only, str) =&gt; {
    str +=' 반이고';
    callbackHof( callback_only, str ); 
}

// concatFirst : printString의 매개변수로 활용되는 콜백함수이면서,
// 하나의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const concatFirst = (callback_only, str) =&gt; {
  callback_only(str);
}

// concatAgain : concatFirst의 매개변수로 활용되는 콜백함수
const concatAgain = (str) =&gt; {
  str += ' 가만히 있으면 반이라도 간다';
  console.log(str);
}

printString(concatFirst, concatAgain, '시작은'); // 시작은 반이고 가만히 있으면 반이라도 간다
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[함수 (Function) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것]]></summary></entry><entry><title type="html">[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)</title><link href="http://localhost:4000/js4/" rel="alternate" type="text/html" title="[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js4</id><content type="html" xml:base="http://localhost:4000/js4/"><![CDATA[<h2 id="스코프-scope--변수에-접근할-수-있는-범위">스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수에 접근할 수 있는 범위</h2>

<ul>
  <li>변수가 선언되었을 때, 선언 위치에 의해 해당 변수에 접근할 수 있는 코드의 영역이 결정
    <ul>
      <li>자바스크립트 엔진은 스코프를 통해 참조 대상 식별자를 찾아 변수를 식별</li>
    </ul>
  </li>
</ul>

<h3 id="전역-스코프-global-level-scope--코드-어디에서나-참조-가능">전역 스코프 (<code class="language-plaintext highlighter-rouge">Global-level Scope</code>) → 코드 어디에서나 참조 가능</h3>

<ul>
  <li>전역에 선언된 전역 변수 (<code class="language-plaintext highlighter-rouge">Global variable</code>) 는 전역 객체 (<code class="language-plaintext highlighter-rouge">Global Object</code>)의 프로퍼티</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var global = 'global';

function main() {
  var local = 'local';
  console.log(global);
  console.log(local);
}

console.log(global);
console.log(local); // Uncaught ReferenceError: local is not defined
</code></pre></div></div>

<h3 id="함수-스코프-function-level-scope--함수-자신과-하위-함수에서만-참조-가능">함수 스코프 (<code class="language-plaintext highlighter-rouge">Function-level Scope</code>) → 함수 자신과 하위 함수에서만 참조 가능</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function () {
  var local = 'local';
  console.log(local);
})();
</code></pre></div></div>

<h3 id="블록-스코프-block-level-scope--블록-내에서만-참조-가능">블록 스코프 (<code class="language-plaintext highlighter-rouge">Block-level Scope</code>) → 블록 내에서만 참조 가능</h3>

<h3 id="모듈-스코프-module-level-scope-">모듈 스코프 (<code class="language-plaintext highlighter-rouge">Module-level Scope</code>) →</h3>

<h3 id="렉시컬-스코프-lexical-level-scope">렉시컬 스코프 (<code class="language-plaintext highlighter-rouge">Lexical-level Scope</code>)</h3>

<h3 id="암묵적-전역-implicit-global">암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)</h3>

<h2 id="실행-컨텍스트-execution-context--실행할-코드에-제공할-환경-정보들을-모아놓은-객체">실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;

function f1(x, y) {
  var gg = 11;   let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('first');
  { 
    const xx = 99;
    let lll = 0;
    f2('nest-first');
    var zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  function f2(t, u) { console.log(t, 'inner', xx, zz); }
  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); }
  var zz = 800;
  f2('second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f1(1,2);   console.log(kk, yy);

f2('third');
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/40dca0b0-9e4b-44d6-a36c-83aee24fc2e3" /></p>

<p><code class="language-plaintext highlighter-rouge">(1)</code> 전역 코드 평가 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg;  let bb;
function f1(x, y) { ... } // Function Object
function f2(g) { ... }    // Function Object
let xx;
var kk;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(2)</code> 전역 코드 실행 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;
let xx = 9;
if (gg &gt; 0) { ... }
f1(1,2);   console.log(kk, yy);
f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(3)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">if</code>문 코드 블록 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (gg &gt; 0) { // var gg = 1;
  var kk = 33; var yy = 9;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(4)</code> 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  var gg;   let bb;
  { ... }
  // function f2(t, u) { ... } // Function Object
  function f2(t, u, v) { ... } // Function Object
  var zz;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(5)</code> 함수 코드 평가 단계 내부의 블록 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">{ ... }</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  { 
    const xx;
    let lll;
    var zz;
    function f2(t) { ... } // Function Object
  }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(6)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length); // f1&gt; 11, 22, undefined, f2, 3
  f2('first');
  { ... }
  zz = 800;
  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(7)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  f2('first');

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(8)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  f2('first'); // first inner2 9 undefined

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(9)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  { 
    xx = 99;
    lll = 0;
    f2('nest-first');
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(10)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;

  { 
    xx = 99;
    lll = 0;
    f2('nest-first'); // nest-first nested 99 undefined 0
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(11)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }

  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(12)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  f2('second'); // second nested 99 800 0
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(13)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">console.log</code> 문 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1;  bb = 2;

console.log(kk, yy); // 33 9
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(14)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 평가</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(15)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third'); // third global f2&gt; 1 2 9 33
</code></pre></div></div>

<blockquote>
  <p><b>블록 코드 평가 및 실행</b></p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">Global</code>/<code class="language-plaintext highlighter-rouge">Function</code> 평가할 때 <code class="language-plaintext highlighter-rouge">Block scope</code>를 만나면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 생성한다.<br />(별도의 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>를 생성하지 않고 독립적인 <code class="language-plaintext highlighter-rouge">Lexical Environment</code>만을 생성한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block code</code>를 평가하여 이 <code class="language-plaintext highlighter-rouge">Block</code>에 대한 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>를 생성한다.</li>
    <li><code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">let</code>은 <code class="language-plaintext highlighter-rouge">notInitializedYet</code> 상태로 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 등록되고, <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code> 선언식 등은 부모 <code class="language-plaintext highlighter-rouge">Function scope</code>의 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>에 <code class="language-plaintext highlighter-rouge">hoisting</code>한다.<br />(이때 <code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>가 아니라 <code class="language-plaintext highlighter-rouge">var</code>와 같이 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 끝나면, 평가 종료 후 상위 <code class="language-plaintext highlighter-rouge">scope code</code>를 계속 평가한다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 실행되면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 만들고, 부모 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 가져온다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code> 내의 <code class="language-plaintext highlighter-rouge">Function</code> 선언식은 무조건 <code class="language-plaintext highlighter-rouge">Block</code> 최상단에 <code class="language-plaintext highlighter-rouge">hoisting</code>되어 있으므로 먼저 실행한다.<br />(이 시점에 상위 <code class="language-plaintext highlighter-rouge">function-scope</code>에 함수를 정의해, <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>으로 인정된다!)</li>
    <li>그 외의 코드 (할당문 및 다른 함수 호출)를 한 줄씩 실행된다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>의 실행이 끝나면, <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 다시 부모로 돌려준다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>은 조건에 따라 실행 여부가 결정된다. 평가 시 블럭 내의 <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">undefined</code>로 <code class="language-plaintext highlighter-rouge">hoisting</code>되고, 조건이 만족하여 호출 및 실행될 때에만 <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>와 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>를 만들고 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>로 정의된다.</li>
  </ol>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a69498fb-6f39-413d-8a75-ef547e4ba4b5" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1271743-b805-4040-9743-39e7b2cd5bda" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5272ac93-d18b-4112-a45f-46d657839a3d" /></p>

<h2 id="엄격-모드-strict-mode--자바스크립트가-묵인한-에러를-발생시켜-엄격한-오류-검사를-적용">엄격 모드 (<code class="language-plaintext highlighter-rouge">Strict Mode</code>) : 자바스크립트가 묵인한 에러를 발생시켜 엄격한 오류 검사를 적용</h2>

<ul>
  <li>선언하지 않은 식별자는 접근할 수 없음</li>
  <li>암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)은 허용하지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">Delete</code>로 선언된 변수, 함수, 매개변수를 삭제할 수 없음</li>
  <li>블록 내에서의 함수는 블록 스코프 (블록 내 함수는 볼록의 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 존재)</li>
  <li>함수 내에서 매개변수의 이름이 동일해선 안됨</li>
  <li><code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">Infinite</code> 등의 전역 프로퍼티에 값을 할당해선 안됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'use strict';


var gg = 1;
let bb = 2;

function f1(x, y) {
  var gg = 11;
  let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('* first');
  {
    const xx = 99;
    f2('* nest-first');
    var zz = 88;
    function f2(t) {
      console.log(t, '`nested`', xx, zz);
    }
  }
  function f2(t, u) {
    console.log(t, '`inner`', xx, zz);
  }
  function f2(t, u, v) {
    console.log(t, '`inner2`', xx, zz);
  }
  var zz = 800;
  console.log('gg:', gg);
  f2('* second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}
let xx = 9;
if (gg &gt; 0) {
  var kk = 33;
  const yy = 9;
}
f1(1, 2); 
console.log('kkkkk&gt;&gt;', kk);
f2('* third');
</code></pre></div></div>

<h2 id="클로저-closure--함수가-특정-스코프에-접근할-수-있도록-의도적으로-그-스코프에서-정의한-것">클로저 (<code class="language-plaintext highlighter-rouge">Closure</code>) : 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의한 것</h2>

<ul>
  <li>상위 스코프의 식별자를 참조하는 하위 스코프 (함수, 메소드)가 외부에서 참조되어 상위 스코프보다 오래 살아있는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let user;
{
  const private = {
    id: 1,
    name: 'John'
  }
  user = private;
}

user.age = 30;

console.log(user); // { id: 1, name: 'John', age: 30 }
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(x) {
  let clo = function (y) {
    console.log(y);
  }

  return clo(x);
}

func('a'); // a
</code></pre></div></div>

<blockquote>
  <p>클로저를 활용하여 외부변수로 인해 오염될 수 있는 비순수함수 (<code class="language-plaintext highlighter-rouge">Impure Function</code>)를, 함수 내부로 전달된 인수에게만 의존하여 반환값을 만드는 순수함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>)로 바꿀 수 있다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 비순수함수
let cnt1 = 0;

function func1(x) {
  cnt1 += 1;
  return cnt1;
}

console.log(func1()); // 1
console.log(func1()); // 2
console.log(func1()); // 3

// → 순수함수
function func2() {
  let cnt2 = 0;
  return function temp() {
    cnt2 += 1;
    return cnt2;
  };
}

const counter1 = func2();
const counter2 = func2();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[스코프 (Scope) : 변수에 접근할 수 있는 범위]]></summary></entry><entry><title type="html">고차 함수, 콜백 함수 (2024.01.31)</title><link href="http://localhost:4000/digital_hanaro_5.md/" rel="alternate" type="text/html" title="고차 함수, 콜백 함수 (2024.01.31)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_5.md</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_5.md/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 5일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부한-내용">공부한 내용</h2>

<p>고차함수, 콜백함수의 개념을 정리해보고 이 둘의 차이점에 대해 짚어보고자 하였다.</p>

<h3 id="고차-함수-higher-order-function--다른-함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 다른 함수를 인자로 받거나 함수를 반환하는 함수</h3>

<blockquote>
  <p>자바스크립트에서의 함수는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class Citizen</code>)</p>

  <ol>
    <li>변수에 할당 (<code class="language-plaintext highlighter-rouge">Assignment</code>)할 수 있다.</li>
    <li>다른 변수의 인자 (<code class="language-plaintext highlighter-rouge">Argument</code>)로 전달될 수 있다.</li>
    <li>다른 함수의 결과로 반환 (<code class="language-plaintext highlighter-rouge">Return</code>)될 수 있다.</li>
  </ol>

  <p>→ 함수가 일급 객체이므로, 함수를 데이터와 유사하게 다룰 수 있어 ‘고차 함수’로서 활용될 수 있다.</p>
</blockquote>

<ul>
  <li>함수의 형태로 반환되는 함수를 모두 고차 함수라 정의
    <ul>
      <li>함수는 일급 객체 → 일급 객체로서의 함수는 고차 함수로 활용 가능</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const double = (n) =&gt; { return n * 2; };
console.log(double(4)); // 4 * 2 = 8
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const adder = added =&gt; num =&gt; num + added;
console.log(adder(5)(3)); // 5 + 3 = 8
</code></pre></div></div>

<blockquote>
  <p>함수를 리턴하는 함수를 커리 함수 (<code class="language-plaintext highlighter-rouge">Curry Function</code>)라고 부르던데…?</p>

  <ul>
    <li>커리 함수라는 용어로, 고차 함수를 ‘함수를 인자로 받는 함수’에만 한정해 사용할 수 있음
      <ul>
        <li>엄밀히 말하면, 고차 함수가 커리 함수를 포함하는 개념</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="arraymap-함수--배열의-각-요소에-대해-주어진-함수를-호출한-다음-그-결과를-새로운-배열로-반환"><code class="language-plaintext highlighter-rouge">Array.map()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 호출한 다음, 그 결과를 새로운 배열로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].map((num) =&gt; { return num * num; })); // [ 1, 4, 9, 16, 25 ]
</code></pre></div></div>

<h4 id="arrayfilter-함수--배열의-요소-중에-주어진-조건을-만족하는-요소만을-추출하여-새로운-배열로-반환"><code class="language-plaintext highlighter-rouge">Array.filter()</code> 함수 : 배열의 요소 중에 주어진 조건을 만족하는 요소만을 추출하여 새로운 배열로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].filter((num) =&gt; { return num % 2 === 0 })); // [ 2, 4 ]
</code></pre></div></div>

<h4 id="arrayreduce-함수--배열의-각-요소에-대해-주어진-함수를-실행하고-그-결과를-누적하여-하나의-값으로-반환"><code class="language-plaintext highlighter-rouge">Array.reduce()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 누적하여 하나의 값으로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].reduce((accumulator, currentValue) =&gt; { return accumulator + currentValue;}, 0)); // 15
</code></pre></div></div>

<h4 id="arrayforeach-함수--배열의-각-요소에-대해-주어진-함수를-실행-반환값이-존재하지-않음"><code class="language-plaintext highlighter-rouge">Array.forEach()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행 (반환값이 존재하지 않음)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5].forEach((num) =&gt; { console.log(num); }); // 1부터 5까지 순서대로 출력
</code></pre></div></div>

<h3 id="콜백-함수-callback-function--매개변수를-통해-다른-함수의-내부로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) : 매개변수를 통해 다른 함수의 내부로 전달되는 함수</h3>

<ul>
  <li>고차 함수의 인자로 전달되어, 특정 동작을 수행하거나 완료 시에 호출
    <ul>
      <li>콜백 함수를 전달받은 고차 함수는 함수 내부에서 이 콜백 함수르 호출 (<code class="language-plaintext highlighter-rouge">Invoke</code>)할 수 잇음</li>
      <li>부르는 조건에 따라서 콜백 함수의 실행 조건을 결정할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; { console.log(`출력`); }, 1);
</code></pre></div></div>

<ul>
  <li>매개변수를 통해 다른 함수의 내부로 전달되는 함수는 콜백 함수, 매개변수를 통해 콜백 함수를 전달받는 함수는 고차 함수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// printString : 두개의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const printString = (callbackHof, callback_only, str) =&gt; {
    str +=' 반이고';
    callbackHof( callback_only, str );
}

// concatFirst : printString의 매개변수로 활용되는 콜백함수이면서, 하나의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const concatFirst = (callback_only, str) =&gt; {
  callback_only(str);
}

// concatAgain : concatFirst의 매개변수로 활용되는 콜백함수
const concatAgain = (str) =&gt; {
  str += ' 가만히 있으면 반이라도 간다';
  console.log(str);
}

printString(concatFirst, concatAgain, '시작은'); // 시작은 반이고 가만히 있으면 반이라도 간다
</code></pre></div></div>

<blockquote>
  <p>콜백 함수를 언제 호출하는지에 따라, 자바스크립트 엔진이 콜백 함수의 호출 시점을 결정할 수 있다!</p>

  <ul>
    <li>함수가 실행되면, 콜 스택 (<code class="language-plaintext highlighter-rouge">Call Stack</code>)에 함수를 넣었다가 함수에서 반환이 일어날 때 가장 위쪽에서 해당 함수를 꺼낸다.</li>
    <li>이벤트 루프 (<code class="language-plaintext highlighter-rouge">Event Loop</code>)는 콜 스택과 테스크 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>)를 주시하고 있다가, 스택이 비어 있으면 큐의 첫번째 콜백을 스택에 쌓아 실행한다.</li>
  </ul>
</blockquote>

<blockquote>
  <p>참고</p>

  <ul>
    <li><a href="https://www.datoybi.com/callback-promise-async-await/">Steady-Dev, ‘Callback &amp; Promise &amp; async/await 톺아보기’</a></li>
    <li><a href="https://soldonii.tistory.com/119">soldonii, ‘200106(월) : 비동기, 고차함수, 일급객체, V8 엔진 등’</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 5일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[TIL] 2024년 02월 TIL</title><link href="http://localhost:4000/til2/" rel="alternate" type="text/html" title="[TIL] 2024년 02월 TIL" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til2</id><content type="html" xml:base="http://localhost:4000/til2/"><![CDATA[<h2 id="february-2024--til를-작성하자"><code class="language-plaintext highlighter-rouge">February, 2024</code> : <code class="language-plaintext highlighter-rouge">TIL</code>를 작성하자!</h2>

<h3 id="2024년-02월-01일-목">2024년 02월 01일 (목)</h3>

<h3 id="2024년-02월-02일-금">2024년 02월 02일 (금)</h3>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TIL" /><summary type="html"><![CDATA[February, 2024 : TIL를 작성하자!]]></summary></entry><entry><title type="html">[JS] 3. 호이스팅 (Hoisting) &amp;amp; 동적 타이핑 (Type Conversion)</title><link href="http://localhost:4000/js3/" rel="alternate" type="text/html" title="[JS] 3. 호이스팅 (Hoisting) &amp;amp; 동적 타이핑 (Type Conversion)" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/js3</id><content type="html" xml:base="http://localhost:4000/js3/"><![CDATA[<h2 id="호이스팅-hoisting--선언문을-코드-맨-위에-올려진-것처럼-동작시키는-것">호이스팅 (<code class="language-plaintext highlighter-rouge">Hoisting</code>) : 선언문을 코드 맨 위에 올려진 것처럼 동작시키는 것</h2>

<blockquote>
  <p>평가 (<code class="language-plaintext highlighter-rouge">evaluation</code>) : 표현식을 해석해서 값을 생성하거나 참조하는 것</p>

  <ul>
    <li>평가 <code class="language-plaintext highlighter-rouge">=</code> 인터프리터로서의 컴파일 (선언문 실행 + 호이스팅)</li>
    <li>인터프리터로서의 실행 순서 : 전역 코드 평가 → 전역 코드 실행 → 함수 코드 평가 → 함수 코드 실행 → 복귀</li>
  </ul>
</blockquote>

<ul>
  <li>변수, 함수, 클래스와 같이 키워드를 사용해서 선언하는 모든 식별자는 호이스팅이 이루어짐</li>
  <li>스코프 별로 평가가 이루어지면서 호이스팅이 일어남 → 해당 스코프의 상단으로 올려 메모리 선점 (<code class="language-plaintext highlighter-rouge">Linking</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code>도 호이스팅되지만, 초기화되기 전에 접근하면 안됨 (<code class="language-plaintext highlighter-rouge">notInitializedYey</code> 상태로 호이스팅)</li>
      <li>선언문이 없는 변수는 호이스팅되지 않으며, 평가한 다음에 코드를 실행할 때 정의</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log(a);
var a = 10;
&gt; undefined

let v;
console.log(v); // 에러

z = 9; // 암묵적으로 var로 정의
console.log(z);
&gt; 9

console.log(globalThis['z']);

let z = 11; // 에러 (암묵적 정의 → 호이스팅)
</code></pre></div></div>

<ul>
  <li>코드 평가 시점에 호이스팅이 일어나 선언부와 구현부로 구분 → 선언부는 스택 영역에, 구현부는 힙 영역에 저장</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/75425564-29bc-4aaa-8014-63a7d3b3a435" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8e05cc2f-b9d6-45be-b681-73d0f6b98229" width="80%" /></p>

<ul>
  <li>선언문의 실행 시점 : 선언문은 런타임 (<code class="language-plaintext highlighter-rouge">Runtime</code>)이 아닌 그 이전인 평가 과정에 실행
    <ul>
      <li>소스 코드를 한 줄씩 순차적으로 실행하기 앞서, 먼저 소스 코드의 평가 과정에서 선언문을 먼저 실행</li>
      <li>즉, 식별자를 선언하는 선언문과 값을 할당하는 할당문의 실행 시점은 서로 다름</li>
    </ul>
  </li>
</ul>

<h2 id="동적-타이핑-dynamic-typing--변수를-선언할-때-데이터-타입을-사전에-선언하지-않음">동적 타이핑 (<code class="language-plaintext highlighter-rouge">Dynamic Typing</code>) : 변수를 선언할 때 데이터 타입을 사전에 선언하지 않음</h2>

<blockquote>
  <p>정적 타입 (<code class="language-plaintext highlighter-rouge">Static Typing</code>) : 변수를 선언할 때 데이터 타입을 사전에 선언</p>

  <ul>
    <li>변수에 선언한 타입에 해당하는 값만 할당할 수 있음</li>
    <li>컴파일 시점에 타입 체크 (<code class="language-plaintext highlighter-rouge">Type Check</code>)를 수행하고, 통과하지 못하면 에러를 발생시킴</li>
    <li>타입의 일관성을 강제해 안정ㅇ적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임</li>
  </ul>
</blockquote>

<ul>
  <li>자바스크립트는 <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드를 통해 변수만 선언할 수 있음
    <ul>
      <li>자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론 (<code class="language-plaintext highlighter-rouge">Type Inference</code>)이 이루어짐</li>
      <li>재할당에 의해 변수의 타입은 언제든지 동적으로 변화할 수 있음 (<code class="language-plaintext highlighter-rouge">loosely data</code>)</li>
    </ul>
  </li>
  <li>동적 타이핑 및 동적 타입 언어의 단점 : 유연성 (<code class="language-plaintext highlighter-rouge">Flexibility</code>)은 높지만 신뢰성 (<code class="language-plaintext highlighter-rouge">Reliability</code>) 이 떨어진다.
    <ul>
      <li>동적 타입 언어의 변수 값은 언제든지 변할 수 있음
        <ul>
          <li>복잡한 프로그램에서는 변수 값을 추적하기 어려울 수 있음</li>
        </ul>
      </li>
      <li>동적 타입 언어의 변수는 값의 변경에 의해 타입 또한 언제든지 변경될 수 있음
        <ul>
          <li>값을 확인하기 전에는 타입을 확신할 수 없음</li>
          <li>자바스크립트 엔진에 의해 타입이 자동으로 변환될 수도 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자비스크립트에서 변수를 사용할 때 지켜면 좋은 규칙!</p>

  <ul>
    <li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.</li>
    <li>변수의 유효 범위인 스코프는 최대한 좁게 만들어 변수의 부작용을 억제한다.</li>
    <li>전역 변수는 최대한 자제한다.</li>
    <li>변수보다는 상수를 사용해 값의 변경을 억제한다.</li>
    <li>변수 이름은 목적 및 의미를 파악할 수 있도록 네이밍하고, 특히 스코프가 넓을수록 명확하게 명명한다.</li>
  </ul>
</blockquote>

<h2 id="타입-변환-type-conversion--값의-타입이-다른-자료형으로-변환되는-것">타입 변환 (<code class="language-plaintext highlighter-rouge">Type Conversion</code>) : 값의 타입이 다른 자료형으로 변환되는 것</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">typeof()</code> 연산자를 통해 피연산자의 데이터 타입을 문자열로 반환할 수 있음</li>
</ul>

<h3 id="암묵적-타입-변환--자바스크립트-엔진에서-에러를-발생시키지-않도록-타입을-바꿔-표현식을-평가하는-것">암묵적 타입 변환 : 자바스크립트 엔진에서 에러를 발생시키지 않도록 타입을 바꿔 표현식을 평가하는 것</h3>

<ul>
  <li>문자열 타입 변환 : <code class="language-plaintext highlighter-rouge">+</code>의 피연산자 중 하나가 문자열이면, 문자열 연결 연산자로 동작하므로 다른 것을 문자열로 변환</li>
  <li>숫자 타입 변환 : 산술 및 비교 연산자의 피연산자 중에 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환</li>
  <li>불리언 타입 변환 : 논리적 참/거짓을 평가하는 경우에 불리언 타입이 아닌 피연산자를 불리언 타입으로 변환</li>
</ul>

<h3 id="명시적-타입-변환--의도적으로-값의-타입을-변환하는-것--타입-캐스팅-type-casting">명시적 타입 변환 : 의도적으로 값의 타입을 변환하는 것 → 타입 캐스팅 (<code class="language-plaintext highlighter-rouge">type casting</code>)</h3>

<ul>
  <li>문자열 타입으로 변환 : <code class="language-plaintext highlighter-rouge">String()</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, 문자열 연결 연산자 <code class="language-plaintext highlighter-rouge">+</code></li>
  <li>숫자 타입으로 변환 : <code class="language-plaintext highlighter-rouge">Number()</code>, <code class="language-plaintext highlighter-rouge">parseInt()/parseFloat()</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code></li>
  <li>불리언 타입으로 변환 : <code class="language-plaintext highlighter-rouge">Boolean()</code>, 부정 논리 연산자 <code class="language-plaintext highlighter-rouge">!</code>를 2번</li>
</ul>

<blockquote>
  <p>기존 원시 타입을 사용해 다른 타입의 새로운 원시 타입을 생성하는 것!</p>

  <ul>
    <li>원시 타입은 변경 불가능한 값 (<code class="language-plaintext highlighter-rouge">immutable value</code>) → 기존 원시 타입을 직접 변경할 수 없음</li>
    <li>자바스크립트 엔진에서 표현식을 평가하기 위해 피연산자의 값을 암묵적 타입 변환으로 새로운 타입의 값을 만듬</li>
  </ul>
</blockquote>

<h2 id="단축-평가-short-circuit-evaluation--표현식을-평가하는-중에-결과가-확정되면-평가-생략">단축 평가 (<code class="language-plaintext highlighter-rouge">Short-Circuit Evaluation</code>) : 표현식을 평가하는 중에 결과가 확정되면, 평가 생략</h2>

<ul>
  <li>논리 평가 : 논리 연산자를 이용한 단축 평가 (좌항에서 우항으로 평가)
    <ul>
      <li>논리곱 연산자 <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>는 두 피연산자가 모두 <code class="language-plaintext highlighter-rouge">true</code>일 때, <code class="language-plaintext highlighter-rouge">true</code> 반환
        <ul>
          <li>논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 반환</li>
        </ul>
      </li>
      <li>논리합 연산자 <code class="language-plaintext highlighter-rouge">||</code>는 두 피연산자 중 하나만  <code class="language-plaintext highlighter-rouge">true</code>이여도, <code class="language-plaintext highlighter-rouge">true</code> 반환
        <ul>
          <li>논리 연산의 결과를 결정하는 첫번째 피연사자를 그대로 반환</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'Cat' &amp;&amp; 'Dog' // true &amp;&amp; 'Dog' → 'Dog'
'Cat' || 'Dog' // 'Cat'... → 'Cat'
</code></pre></div></div>

<blockquote>
  <p>논리 평가를 사용하는 경우?</p>

  <ul>
    <li>객체를 가리키기 기대하는 변수가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>가 아닌지 확인하고 프로퍼티를 참조할 때</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var elem = null;
// var value = elem.value; // TypeError
var value = elem &amp;&amp; elem.value; // null
</code></pre></div>  </div>

  <ul>
    <li>함수 매개변수에 <code class="language-plaintext highlighter-rouge">undefined</code>가 할당되지 않도록 기본값을 설정할 때</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getStringLength() {
str = str || '';
return str.length;
}
getStringLength(); // 0
getStringLength('hello'); // 5
</code></pre></div>  </div>
</blockquote>

<ul>
  <li>옵셔널 체이닝 (<code class="language-plaintext highlighter-rouge">Optional Chaining</code>) 연산자 <code class="language-plaintext highlighter-rouge">?</code> : 좌항의 피연산자가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이면 <code class="language-plaintext highlighter-rouge">undefined</code>를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 그대로 진행함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var elem = null;
var str = '';

var value1 = elem?.value; console.log(value1); // undefined
var value2 = elem &amp;&amp; elem.value; console.log(value2); // null
var value3 = str &amp;&amp; str.length; console.log(value3); // ''
var value4 = str?.length; console.log(value4); // 0
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 병합 연산자 <code class="language-plaintext highlighter-rouge">??</code> : 좌항의 피연산자가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환 → 변수에 기본값을 설정할 때 사용
    <ul>
      <li>논리 연산자 <code class="language-plaintext highlighter-rouge">||</code>를 사용한 단축 평가와 달리, 피연산자가  <code class="language-plaintext highlighter-rouge">false</code>로 평가받는 <code class="language-plaintext highlighter-rouge">Falsy</code> 값이라도 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이 아니면, 좌항의 피연산자를 반환함</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo = null ?? 'default'; // 'default'
</code></pre></div></div>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Falsy</code> 값 : 피연산자가 <code class="language-plaintext highlighter-rouge">false</code>로 평가받는 값 (<code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">undefined</code>, <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">-0</code>, <code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">''</code>)</li>
    <li><code class="language-plaintext highlighter-rouge">Truthy</code> 값 : 피연산자가 <code class="language-plaintext highlighter-rouge">True</code>로 평가받는 값 (<code class="language-plaintext highlighter-rouge">true</code>, …)</li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[호이스팅 (Hoisting) : 선언문을 코드 맨 위에 올려진 것처럼 동작시키는 것]]></summary></entry><entry><title type="html">[JS] 2. 변수 (Variable) &amp;amp; 객체 (Object)</title><link href="http://localhost:4000/js2/" rel="alternate" type="text/html" title="[JS] 2. 변수 (Variable) &amp;amp; 객체 (Object)" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/js2</id><content type="html" xml:base="http://localhost:4000/js2/"><![CDATA[<h2 id="변수-variable--하나의-값을-저장할-수-있는-메모리-공간">변수 (<code class="language-plaintext highlighter-rouge">Variable</code>) : 하나의 값을 저장할 수 있는 메모리 공간</h2>

<blockquote>
  <p>변수 = 선언 + 식별자 + 타입 + 값 + 소코프</p>
</blockquote>

<ul>
  <li>자바스크립트는 개발자가 메모리 주소를 통해 값에 직접 접근하는 메모리 제어를 허용하지 않음</li>
  <li>변수 이름을 어떤 값을 구별해 식별 가능한 고유한 이름이란 의미에서, 식별자 (<code class="language-plaintext highlighter-rouge">Identifier</code>) 라고도 함
    <ul>
      <li>식별자는 값이 아닌 메모리 주소를 기억하고 있어, 식별자로 메모리 공간에 저장된 값에 접근</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var userId = 1;
var userName = 'John';

var user = { id: 1, name: 'John' };

var users = {
    { id: 1, name: 'John' }
}
</code></pre></div></div>

<ul>
  <li>변수 선언 (<code class="language-plaintext highlighter-rouge">variable declaration</code>)을 통해 변수를 생성 → <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드
    <ul>
      <li>변수에 값을 할당하지 않았으면, 자바스크립트 엔진에 의해 <code class="language-plaintext highlighter-rouge">undefined</code> 값이 할당되어 초기화</li>
      <li>선언하지 않은 식별자에 접근하면 참조 에러 (<code class="language-plaintext highlighter-rouge">ReferenceError</code>)가 발생</li>
    </ul>
  </li>
</ul>

<h3 id="리터럴-literal--사람이-이해할-수-있는-문자나-기호를-통해-값을-생성하는-표기법">리터럴 (<code class="language-plaintext highlighter-rouge">literal</code>) : 사람이 이해할 수 있는 문자나 기호를 통해 값을 생성하는 표기법</h3>

<ul>
  <li>값 (<code class="language-plaintext highlighter-rouge">value</code>) : 표현식이 평가되어 생성된 결과</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 + 20; // 30
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/21a03922-1820-4bdd-82e9-844443ccedf3" width="80%" /></p>

<ul>
  <li>표현식 (<code class="language-plaintext highlighter-rouge">expression</code>) : 값으로 평가될 수 있는 구문
    <ul>
      <li>구문 (<code class="language-plaintext highlighter-rouge">statement</code>) : 프로그램을 이루는 기본 단위이자 최소 실행 단위 (선언문, 할당문, 조건문, 반복문 등)
        <ul>
          <li>토큰 (<code class="language-plaintext highlighter-rouge">token</code>) : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="데이터-타입-date-type--값의-종류">데이터 타입 (<code class="language-plaintext highlighter-rouge">Date Type</code>) : 값의 종류</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c2d012-dc6b-418d-919f-b9dfa828448a" width="80%" /></p>

<ul>
  <li>숫자 타입 : 정수 및 실수를 모두 포함하는 타입으로 존재 (<b>모든 수를 실수로 처리</b>)<br />→ 큰 수를 위한 <code class="language-plaintext highlighter-rouge">BigInt</code> 타입과는 다름! (<code class="language-plaintext highlighter-rouge">BigInt</code>는 객체 타입으로, 모든 수를 정수로 처리)</li>
  <li>문자열 타입 : ‘’, “”, ``로 문자열을 감싼 텍스트 데이터
    <ul>
      <li>템플릿 (<code class="language-plaintext highlighter-rouge">template</code>) 리터럴 : <code class="language-plaintext highlighter-rouge">로 감싼 문자열 (</code><code class="language-plaintext highlighter-rouge">ES6</code>``부터 도입)
        <ul>
          <li>멀티라인 문자열 : 백슬레시 (<code class="language-plaintext highlighter-rouge">\n</code>) 없이 개행 가능</li>
          <li>표현식 삽입 : <code class="language-plaintext highlighter-rouge">+</code>으로 <code class="language-plaintext highlighter-rouge">${}</code>로 감싼 표현식을 문자열로 변환해 삽입할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>불리언 타입 : 참 (<code class="language-plaintext highlighter-rouge">true</code>)과 거짓 (<code class="language-plaintext highlighter-rouge">false</code>) → 제일 작은 값 (<code class="language-plaintext highlighter-rouge">1bit</code>)</li>
  <li>심볼 (<code class="language-plaintext highlighter-rouge">symbol</code>) 타입 : 변경 불가능한 원시 타입 (다른 값과 중복되지 않는 유일무이한 값)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Symbol</code> 함수를 호출해 생성되며, 값은 외부에 노출되지 않음 (<code class="language-plaintext highlighter-rouge">var key = Symbol('key');</code>)</li>
      <li>프로퍼티 값에 고유한 값을 저장하고 싶을 때 사용될 수 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">undefined</code> 타입 : 변수 선언에 의해 확보된 메모리 공간은 쓰레기 값이 아닌 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">null</code> 타입 : 변수에 값이 없다는 것을 의도적으로 명시 (<code class="language-plaintext highlighter-rouge">intentional absence</code>)하기 위해 사용</li>
</ul>

<h2 id="객체-object--소프트웨어에서-속성과-기능을-가지는-프로그램의-단위">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 소프트웨어에서 속성과 기능을 가지는 프로그램의 단위</h2>

<blockquote>
  <p>자바스크립트에서 원시 타입을 제외한 나머지 값들 (객체, 함수, 배열, 정규 표현식)은 객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>)이다.</p>

  <p>→ 객체 타입은 프로퍼티 및 메소드를 모두 포함하고 있어, 상태와 동작을 하나의 단위로 구조화할 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John', // "name: 'John'"은 프로퍼티, 
  age: 21       // "name"은 프로퍼티 키, "'John'"은 프로퍼티 값
};
</code></pre></div></div>

<ul>
  <li>객체 타입은 변경 가능한 값 (<code class="language-plaintext highlighter-rouge">mutable</code>)</li>
  <li>객체 타입을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값 (<code class="language-plaintext highlighter-rouge">Reference value</code>)에 접근</li>
  <li>원시 타입과 다르게, 객체 타입은 여러 개의 식별자들이 하나의 객체를 공유할 수 있음</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/66b574d8-6033-47c4-ac56-47dfd0440077" width="80%" /></p>

<h3 id="원시-타입과-객체-타입의-차이점--메모리-공간에-저장되는-위치에서-비롯된-차이">원시 타입과 객체 타입의 차이점? → 메모리 공간에 저장되는 위치에서 비롯된 차이!</h3>

<ul>
  <li>원시 타입 (<code class="language-plaintext highlighter-rouge">Primitive</code>) : 값이 스택 영역에 들어감 (<code class="language-plaintext highlighter-rouge">Call-By-Value</code>) (<code class="language-plaintext highlighter-rouge">cf.</code> 변수의 주소는 별도로 관리됨)<br />→ (자바스크립트 엔진에 따라) 힙 영역 내의 <code class="language-plaintext highlighter-rouge">Symbol Table</code>이나 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 들어갈 수 있음</li>
  <li>객체 타입 (<code class="language-plaintext highlighter-rouge">Object/Reference</code>) : 값이 힙 영역에 들어감 (<code class="language-plaintext highlighter-rouge">Call-By-Reference</code>)</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8dd9f8c1-57e3-4dda-8ea5-1358ef9db7dc" width="90%" /></p>

<ul>
  <li>원시 값은 변경 불가능한 값 (<code class="language-plaintext highlighter-rouge">immutable</code>)이지만, 객체 값은 변경 가능한 값 (<code class="language-plaintext highlighter-rouge">mutable</code>)</li>
  <li>원시 값을 변수에 할당하면 변수에는 실제 값이 저장되나, 객체를 변수에 할당하면 변수에는 참조 값이 저장</li>
  <li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 (<code class="language-plaintext highlighter-rouge">Pass-By-Value</code>)되나, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 (<code class="language-plaintext highlighter-rouge">Pass-By-Reference</code>)</li>
</ul>

<blockquote>
  <p>변경 불가능하다는 것은 변수가 아니라 값에 대한 진술!</p>

  <ul>
    <li>상수 (재할당이 금지된 변수) != 변경 불가능한 값 (읽기 전용 값)</li>
    <li>처음 원시 값을 변수에 할당하면 실제 값이 저장되고, 값을 재할당하면 메모리 공간의 주소가 변경됨</li>
  </ul>

  <p>→ 원시 값은 상태 변경을 금지해 불변성 (<code class="language-plaintext highlighter-rouge">Immutability</code>)을 보장하여, 데이터의 신뢰성을 보장한다!</p>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/260dcc73-59bf-4cc7-93af-d24dea9d2518" /></p>

  <p>그러므로 <code class="language-plaintext highlighter-rouge">Call-By-Value</code> 또한 엄격히 표현하면, 변수에 메모리 주소가 전달되는 것을 말한다!</p>

  <p>→ 식별자는 메모리에 저장된 값을 식별해야 하므로, 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억한다.</p>
</blockquote>

<h3 id="constant-poll--스택-영역과-힙-영역-외에-리터럴을-저장하기-위해-자바스크립트-v8-엔진에서-도입"><code class="language-plaintext highlighter-rouge">Constant Poll</code> : 스택 영역과 힙 영역 외에 리터럴을 저장하기 위해 자바스크립트 <code class="language-plaintext highlighter-rouge">V8</code> 엔진에서 도입</h3>

<p><a href="https://hwan-shell.tistory.com/367"><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3d5b25eb-e794-444a-a999-6b9f3be49aee" width="80%" /></a></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Integer</code>가 저장되는 방식?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Integer</code>는 기본적으로 스택 영역의 <code class="language-plaintext highlighter-rouge">SMI</code> (<code class="language-plaintext highlighter-rouge">Small Integer</code>)에 저장</li>
      <li><code class="language-plaintext highlighter-rouge">32/64Bit OS</code>에서 <code class="language-plaintext highlighter-rouge">32/64Bit</code>를 넘어서면 힙 영역의 <code class="language-plaintext highlighter-rouge">Constant Poll</code>에 할당</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/67d4d968-9ee8-42b7-9de5-4e87a0c31823" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String</code>이 저장되는 방식?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">String</code>은 문자열으로 취급 → 모든 리터럴은 힙 영역의 <code class="language-plaintext highlighter-rouge">Constant Poll</code>에 할당</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/bf744728-8700-4846-b643-d076ca24712c" width="80%" /></p>

<h3 id="객체-리터럴에-의한-객체의-생성--중괄호--내에-0개-이상의-프로퍼티를-정의">객체 리터럴에 의한 객체의 생성 : 중괄호 (<code class="language-plaintext highlighter-rouge">{}</code>) 내에 0개 이상의 프로퍼티를 정의</h3>

<ul>
  <li>변수에 할당되는 시점에 자바스크립트 엔진이 객체 리터럴을 해석하여 객체를 생성</li>
  <li>객체 리터럴의 중괄호는 코드 블록을 의미하지 않음 → 중괄호 뒤에 세미콜론을 붙이지 않음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John',
  sayHello: function() {
    console.log('Hello');
  }
}
</code></pre></div></div>

<h2 id="프로퍼티-property--객체의-상태를-나타내는-값-data">프로퍼티 (<code class="language-plaintext highlighter-rouge">property</code>) : 객체의 상태를 나타내는 값 (<code class="language-plaintext highlighter-rouge">data</code>)</h2>

<ul>
  <li>객체는 0개 이상의 프로퍼티의 집합 → 프로퍼티는 키 (<code class="language-plaintext highlighter-rouge">key</code>)와 값 (<code class="language-plaintext highlighter-rouge">value</code>)으로 구성
    <ul>
      <li>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.</li>
      <li>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심볼 값 (<code class="language-plaintext highlighter-rouge">''</code>, <code class="language-plaintext highlighter-rouge">""</code>, 식별자)</li>
      <li>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John'
}
</code></pre></div></div>

<ul>
  <li>마침표 프로퍼티 접근 연산자 <code class="language-plaintext highlighter-rouge">.</code>나 대괄호 프로퍼티 접근 연산자 <code class="language-plaintext highlighter-rouge">[]</code>을 통해 프로퍼티 접근, 생성, 갱신, 삭제</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로퍼티 접근
console.log(person.name);
console.log(person[name]);
console.log(person[0]);

// 프로퍼티 갱신
person.name = 'Joo';

// 프로퍼티 동적 생성
person.age = 20;

// 프로퍼티 삭제
delete person.name;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ES6</code> 이후부터 객체 리터럴의 확장된 기능을 제공</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로퍼티 축약 표현
let name = 'Kim', age = 10;
const person = { name, age };

// 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const prefix = 'person';
let i = 0 ;
const obj = {
  [ ${prefix}-${++i} ] : i,
  [ ${prefix}-${++i} ] : i,
  [ ${prefix}-${++i} ] : i
};

// 메소드 축약 표현
const obj = {
  name: 'Lee',
  func() { console.log(this.name); }
};
</code></pre></div></div>

<blockquote>
  <p>자바스크립트 <code class="language-plaintext highlighter-rouge">V8</code> 엔진은 자바스크립트 객체의 프로퍼티에 접근하기 위해 동적 탐색 (<code class="language-plaintext highlighter-rouge">Dynamic Lookup</code>) 방식 대신, <a href="https://engineering.linecorp.com/ko/blog/v8-hidden-class">히든 클래스 (<code class="language-plaintext highlighter-rouge">Hidden Class</code>)</a> 방식으로 사용자 편의성과 일정한 성능을 모두 보장하고자 함</p>
</blockquote>

<h2 id="메소드-method--프로퍼티를-참조하고-조작할-수-있는-동작-behavior">메소드 (<code class="language-plaintext highlighter-rouge">method</code>) : 프로퍼티를 참조하고 조작할 수 있는 동작 (<code class="language-plaintext highlighter-rouge">behavior</code>)</h2>

<ul>
  <li>일반 함수와 달리, 메소드는 객체에 묶어 있는 함수를 의미
    <ul>
      <li>자바스크립트의 함수는 일급 객체이므로, 값으로 취급할 수 있어 프로퍼티 값으로 사용할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John',
  getName: function() {
    return this.name;
  }
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[변수 (Variable) : 하나의 값을 저장할 수 있는 메모리 공간]]></summary></entry></feed>