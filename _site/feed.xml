<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-12T21:19:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[TS] 1. 타입스크립트 (TypeScript)</title><link href="http://localhost:4000/ts1/" rel="alternate" type="text/html" title="[TS] 1. 타입스크립트 (TypeScript)" /><published>2024-02-07T00:00:00+09:00</published><updated>2024-02-07T00:00:00+09:00</updated><id>http://localhost:4000/ts1</id><content type="html" xml:base="http://localhost:4000/ts1/"><![CDATA[<h2 id="타입스크립트-typescript--javascript을-확장하여-정적-타입을-지원하는-프로그래밍-언어">타입스크립트 (<code class="language-plaintext highlighter-rouge">TypeScript</code>) : <code class="language-plaintext highlighter-rouge">JavaScript</code>을 확장하여 정적 타입을 지원하는 프로그래밍 언어</h2>

<ul>
  <li>정적 타입 (<code class="language-plaintext highlighter-rouge">Static Type</code>) : 변수, 매개변수, 함수 반환 값 등에 대한 타입을 명시적으로 지정 가능</li>
  <li>컴파일 언어 (<code class="language-plaintext highlighter-rouge">Compile Language</code>) : <code class="language-plaintext highlighter-rouge">TypeScript</code> 컴파일러는 <code class="language-plaintext highlighter-rouge">TypeScript</code> 코드를 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드로 변환</li>
  <li>타입 검사 (<code class="language-plaintext highlighter-rouge">Type Checking</code>) : 타입을 명시하지 않아도 코드에서 사용된 패턴과 값에 기반해 타입을 추론</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm init -y
npm install -g typescript ts-node
tsc -v
tsc --init
cat tsconfig.json
ts-node temp.ts
</code></pre></div></div>

<h3 id="타입스크립트-컴파일러-tsc--typescript-코드를-javascript-코드로-변환하는-도구">타입스크립트 컴파일러 (<code class="language-plaintext highlighter-rouge">TSC</code>) : <code class="language-plaintext highlighter-rouge">TypeScript</code> 코드를 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드로 변환하는 도구</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">tsconfig.json</code> 조회 : 프로그램 설정 및 파일 실행</li>
  <li>사용 가능한 모든 파일들을 임포트 (<code class="language-plaintext highlighter-rouge">import</code>) (→ 파일들을 하나의 모듈 내에 있는 것처럼 관리)</li>
  <li>추상 구문 트리 (<code class="language-plaintext highlighter-rouge">AST; Abstract Syntax Tree</code>)를 토큰화 (<code class="language-plaintext highlighter-rouge">Tokenize</code>) 및 파싱 (<code class="language-plaintext highlighter-rouge">Parse</code>)</li>
  <li>바인더 (<code class="language-plaintext highlighter-rouge">Binder</code>)가 추상 구문 트리의 식별자를 <code class="language-plaintext highlighter-rouge">Symbol</code>로 변환</li>
  <li>바인더와 추상 구문 트리로 타입 검사를 실행</li>
  <li>프로그램에 설정한 옵션에 기반하여 추상 구문 트리를 <code class="language-plaintext highlighter-rouge">*.js</code>, <code class="language-plaintext highlighter-rouge">*.d.ts</code>의 형태로 변환</li>
</ol>

<h2 id="타입-시스템-type-system--프로그램에서-가질-수-있는-타입을-이해하는-방법에-대한-규칙-집합">타입 시스템 (<code class="language-plaintext highlighter-rouge">Type system</code>) : 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합</h2>

<ol>
  <li>코드를 읽고 존재하는 모든 타입과 값을 이해한다.</li>
  <li>각 값이 초기 선언에서 가질 수 있는 타입을 확인하고, 각 값이 추후 코드에서 어떻게 사용될 수 있는지 확인한다.</li>
  <li>모든 방법을 확인했을 때, 값의 사용법이 타입과 일치하지 않으면 사용자에게 타입 오류로 표시한다.</li>
</ol>

<blockquote>
  <p>타입 오류 vs 구문 오류?</p>

  <ul>
    <li>타입 오류 (<code class="language-plaintext highlighter-rouge">Type Error</code>) : 타입 검사기에 따라 일치하지 않는 것이 감지된 경우
      <ul>
        <li>타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생</li>
      </ul>
    </li>
    <li>구문 오류 (<code class="language-plaintext highlighter-rouge">Syntax Error</code>) : 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
      <ul>
        <li>타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="할당-가능성-assignability--함수-호출이나-변수에-값을-제공할-수-있는지-여부를-확인-가능">할당 가능성 (<code class="language-plaintext highlighter-rouge">Assignability</code>) : 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인 가능</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TypeScript</code>에선 변수나 속성에 값을 할당할 때 해당 값의 타입이 변수나 속성의 타입과 호환 가능해야함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let firstName = "Noah";
firstName = "Tom";
</code></pre></div></div>

<h3 id="타입-어노테이션-type-annotation--초기값을-할당하지-않고도-타입을-명시적으로-지정-가능">타입 어노테이션 (<code class="language-plaintext highlighter-rouge">Type Annotation</code>) : 초기값을 할당하지 않고도 타입을 명시적으로 지정 가능</h3>

<blockquote>
  <p>메모리 사이즈가 변하지 않는 변수는 타입 어노테이션을 추가하지 않는 것이 좋으나, 코드를 명확하게 문서화하거나 실수로 변수 타입이 변경되지 않도록 타입스크립트를 보호하기 위해 변수에 명시적으로 타입 어노테이션을 포함하는 것이 경우에 따라서는 유용할 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let variable: Type; // 변수의 이름 : 값의 타입
</code></pre></div></div>

<h3 id="타입-형태-type-shape--타입을-정의할-때-객체의-형태를-명시적으로-지정-가능">타입 형태 (<code class="language-plaintext highlighter-rouge">Type Shape</code>) : 타입을 정의할 때 객체의 형태를 명시적으로 지정 가능</h3>

<ul>
  <li>인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 객체의 구조를 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Person {
    name: string;
    age: number;
}

let person: Person = {
    name: "John",
    age: 25
};
</code></pre></div></div>

<ul>
  <li>타입 (<code class="language-plaintext highlighter-rouge">Type</code>) : 객체의 타입을 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Point = {
    x: number;
    y: number;
};

let point: Point = {
    x: 10,
    y: 20
};
</code></pre></div></div>

<h2 id="타입-별칭-alias--자주-사용할-타입에-이름을-붙이는-것">타입 별칭 (<code class="language-plaintext highlighter-rouge">Alias</code>) : 자주 사용할 타입에 이름을 붙이는 것</h2>

<blockquote>
  <p>타입 별칭은 타입 어노테이션과 마찬가지로 자바스크립트로 컴파일되지 않으므로, 런타임 코드에서는 참조할 수 없다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Age = number;
type Name = string;

type Person = {
    name: Name;
    age: Age;
};


let person: Person = { name: "John", age: 25 };
</code></pre></div></div>

<h3 id="리터럴-타입-literal-type--원시-타입보다-더-구체적인-원시-값-자체를-타입으로-활용하는-것">리터럴 타입 (<code class="language-plaintext highlighter-rouge">Literal Type</code>) : 원시 타입보다 더 구체적인 원시 값 자체를 타입으로 활용하는 것</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c9e566fc-2985-4d75-aba6-0f42082c8ab1" width="80%" /></p>

<ul>
  <li>특정 값들을 타입으로 정의하고, 해당 값들만이 유효한 값으로 간주
    <ul>
      <li>리터럴 할당 가능성 : 서로 다른 리터럴 타입은 서로 할당될 수 없음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let isString = '문자열';
let isLiteral: 'LITERAL';

isLiteral = isString;
// Error type 'string' is not assignable to type '"LITERAL"'.
</code></pre></div></div>

<h3 id="유니언-타입-union-type--값에-허용되는-타입을-두-개-이상의-가능한-타입으로-확장하는-것">유니언 타입 (<code class="language-plaintext highlighter-rouge">Union Type</code>) : 값에 허용되는 타입을 두 개 이상의 가능한 타입으로 확장하는 것</h3>

<ul>
  <li>둘 이상의 타입으로 확장된 타입에서, 일부 속성들의 조합이 하나의 타입에 할당 가능하면 유니온 타입으로 사용 가능
    <ul>
      <li>유니언으로 선언한 모든 타입에 존재하는 속성에만 접근 가능!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Person = {
   name: string;
   age: number;
   phone: number | string; // number 또는 string 타입을 가질 수 있음
   addr?: string; // 선택적으로 사용할 수 있음
};
</code></pre></div></div>

<h3 id="내로잉-narrowing--값이-더-구체적인-타입임을-코드에서-유추하는-것">내로잉 (<code class="language-plaintext highlighter-rouge">narrowing</code>) : 값이 더 구체적인 타입임을 코드에서 유추하는 것</h3>

<ul>
  <li>타입스크립트에서 변수의 타입을 조건문을 통해 줄여나가는 것
    <ul>
      <li>값 할당 <code class="language-plaintext highlighter-rouge">ex) x = 1</code></li>
      <li><code class="language-plaintext highlighter-rouge">typeof</code> 검사 <code class="language-plaintext highlighter-rouge">ex) typeof(value)</code></li>
      <li>조건 검사 : <code class="language-plaintext highlighter-rouge">ex) if x === 'stringValue'</code></li>
      <li><code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">instanceof</code>, <code class="language-plaintext highlighter-rouge">Array.isArray</code>를 활용</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>내로잉을 수행하는 함수 또는 구문을 타입 가드 (<code class="language-plaintext highlighter-rouge">Type guard</code>)라 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Member = {
  name: string;
  address: string;
}

function inFunc (user: Member) {
  if ('name' in user) // cf. user.hasOwnProperty('name')로는 불가능
    console.log('user.name); 
}
</code></pre></div></div>

<h3 id="strictnullchecks--엄격한-null-검사-활성화-옵션"><code class="language-plaintext highlighter-rouge">strictNullChecks</code> : 엄격한 <code class="language-plaintext highlighter-rouge">null</code> 검사 활성화 옵션</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code> 값을 참조 및 할당 했을 때, 타입 에러를 발생시킬지 여부</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// tsconfig.json 
//  {
//    "compilerOptions": {
//      "strictNullChecks": true
//    }
//  }

let un: string | undefined;
un.toLowerCase(); // Type 'undefined' is not assigned to type 'string'
un?.toLowerCase();
</code></pre></div></div>

<h2 id="객체-타입-object-type--객체의-형태를-정의하고-객체의-할당-가능성을-확인">객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>) : 객체의 형태를 정의하고, 객체의 할당 가능성을 확인</h2>

<ul>
  <li>타입스크립트의 타입 시스템은 타입을 구조화하여 정의하고 있음 → <code class="language-plaintext highlighter-rouge">Structured Type Definition</code>
    <ul>
      <li>타입 체크 시스템 (<code class="language-plaintext highlighter-rouge">Type Check System</code>) 을 통해 구조화된 형식을 검사</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x_user: {id: number, name: string};
x_user = {id: 1, name: 'xx'}; // OK
x_user = {id: 1}; // Error (Property 'name' missing in type)
x_user = {id: 1, name: 'xx', age: 30}; // Error ({id, name, age} is not assignable to type {id,name} )

// 타입 별칭(type alias)
type T_User = {
  id: number;
  name: string;
};

let hong: T_User;
hong = {id: 1, name: 'Hong'}; // OK
hong = {id: 1}; // Error (name property missing)
hong = {id: 1, name: 'Hong', addr: 'Pusan'}; // Error(not assignable) 
hong = {id: 1, name: 'Hong', addr: 'Pusan'} as T_User;
</code></pre></div></div>

<h3 id="타입스트립트는-covariance--contravariance를-원칙으로-하는-언어">타입스트립트는 <code class="language-plaintext highlighter-rouge">CoVariance | ContraVariance</code>를 원칙으로 하는 언어?</h3>

<ul>
  <li>공변성 (<code class="language-plaintext highlighter-rouge">CoVariance</code>) : 원래 지정된 것보다 더 파생된 형식을 사용 가능한 것<br />→ 타입 간의 계층 구조가 유지되면 변환을 허용 <code class="language-plaintext highlighter-rouge">ex)</code> 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let baseArray: Animal[] = [];
let derivedArray: Dog[] = [];

// Covariant: 하위 타입인 Dog[]가 상위 타입인 Animal[]로 할당 가능
baseArray = derivedArray;
</code></pre></div></div>

<ul>
  <li>반변성 (<code class="language-plaintext highlighter-rouge">ContraVariance</code>) : 원래 지정된 것보다 덜 파생적인 형식을 사용 가능한 것<br />→ 하위 타입이 하위 타입으로 할당될 수 있음 <code class="language-plaintext highlighter-rouge">ex)</code> 함수의 매개변수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type AnimalHandler = (animal: Animal) =&gt; void;
type DogHandler = (dog: Dog) =&gt; void;

// Contravariant: 상위 타입인 AnimalHandler가 하위 타입인 DogHandler로 할당 가능
let animalHandler: AnimalHandler = (animal: Animal) =&gt; { /*...*/ };
let dogHandler: DogHandler = animalHandler;
</code></pre></div></div>

<blockquote>
  <p>타입스크립트는 <code class="language-plaintext highlighter-rouge">CoVariance</code>를 원칙이나, 함수의 매개변수처럼 <code class="language-plaintext highlighter-rouge">ContraVariance</code>가 적용되는 경우 또한 존재한다.</p>
</blockquote>

<h3 id="신선도-freshness--구조적으로-타입-호환성이-있는-객체-리터럴의-타입-검사">신선도 (<code class="language-plaintext highlighter-rouge">Freshness</code>) : 구조적으로 타입 호환성이 있는 객체 리터럴의 타입 검사</h3>

<ul>
  <li>신선도로 인한 오류는 ‘객체 리터럴을 사용한 경우에만’ 발생한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function logName(something: { name: string }) {
    console.log(something.name);
}

var person = { name: 'John', job: 'cowboy' };
var animal = { name: 'cow', description: 'element who hate John' };
var event = { note: `random` };

logName(person);
logName(animal);
logName(event); // 오류: 속성 `name` 누락 (신선도로 인한 오류 O)

function logName(something: { name: string }) {
  console.log(something.name);
}

logName({ name: 'John' });
logName({ name: 'John', job: 'cowboy' }); // 오류: 객체 리터럴은 정의된 속성만 지정해야 함. (신선도로 인한 오류 X)
</code></pre></div></div>

<blockquote>
  <p>신선도를 끄는 방법?</p>

  <ol>
    <li>변수에 할당한다.</li>
    <li>강제로 타입 캐스팅 (<code class="language-plaintext highlighter-rouge">type casting</code>)을 한다.</li>
    <li><code class="language-plaintext highlighter-rouge">union</code> 타입으로 제외시킨다.</li>
    <li><code class="language-plaintext highlighter-rouge">suppressExcessPropertyError</code>를 활성화한다.</li>
  </ol>
</blockquote>

<h2 id="함수-타입-function-type--함수가-가져야-하는-매개변수와-반환-타입을-명시">함수 타입 (<code class="language-plaintext highlighter-rouge">Function Type</code>) : 함수가 가져야 하는 매개변수와 반환 타입을 명시</h2>

<ul>
  <li>변수에 할당되거나 매개변수로 전달되는 함수의 타입을 정의
    <ul>
      <li>필수 매개변수 : 함수에 선언된 모든 매개변수를 필수라고 가정 → 타입 안정성이 강화</li>
      <li>선택 매개변수 : 타입 애너테이션의 : 앞에 <code class="language-plaintext highlighter-rouge">?</code>를 추가하여, 매개변수가 선택적이란 것을 표시</li>
      <li>기본 매개변수 : 기본적으로 값을 제공되므로, 함수 내부에 암묵적으로 <code class="language-plaintext highlighter-rouge">| undefined union type</code>이 추가<br />→ 타입스크립트는 함수의 매개변수에 대해 인수를 누락하거나 <code class="language-plaintext highlighter-rouge">undefined</code> 인수를 사용한 호출을 허용</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(a: number, b: number) {
   return a + b;
}

type ANY = any;
function addY (a: ANY, b: ANY) {
  return a + b;
}

function addZ (a: ANY, b?: ANY) {
  return a + (b ?? 0);
}

addX(1, 0); addY(1, 0); addZ(1, 0);
addZ(1); // addX(1); addY(1);
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">?</code>으로 표시된 선택 매개변수가 아닌 필수 매개변수는 값이 명시적으로 <code class="language-plaintext highlighter-rouge">undefined</code>이라도 항상 제공되어야 한다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const introduce2 = (name:string, 

height : number|undefined ) =&gt; {
   console.log(`이름 : ${name}`);

if(typeof height === 'number'){
   	console.log(`키 : ${height + 10}`)   
 	}
}

introduce2("김군"); // Error : Expected 2 arguments, but got 1.
introduce2("김군", undefined);
introduce2("김군", 170);
</code></pre></div>  </div>
</blockquote>

<h3 id="함수-오버로딩-function-overloading--동일한-이름에-매개-변수만-다른-함수를-여러-개-만드는-것">함수 오버로딩 (<code class="language-plaintext highlighter-rouge">Function Overloading</code>) : 동일한 이름에 매개 변수만 다른 함수를 여러 개 만드는 것</h3>

<ul>
  <li>매개변수의 형태가 다양한 여러 케이스에 대응하는 같은 이름의 함수를 만드는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 서로 다른 버전의 함수들 -&gt; `오버로드 시그니처`
function func(a : number): void;
function func(a : number, b : number, c : number) : void;

// 실제 구현부 -&gt; `구현 시그니처`
function func(a:number, b?: number, c?:number) {
  if(typeof b === 'number' &amp;&amp; typeof c === 'number') {
    console.log(a + b + c);
  } else {
    console.log(a + b + c);
  }
}

func(1); func(1, 2, 3);
</code></pre></div></div>

<h2 id="인터페이스-interface--타입을-정의할-때-객체의-구조를-명시적으로-지정-가능">인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 타입을 정의할 때 객체의 구조를 명시적으로 지정 가능</h2>

<h3 id="호출-시그니처-call-signature--함수-호출-방법에-대한-타입-시스템을-설명">호출 시그니처 (<code class="language-plaintext highlighter-rouge">Call Signature</code>) : 함수 호출 방법에 대한 타입 시스템을 설명</h3>

<ul>
  <li>매개변수의 목록 (<code class="language-plaintext highlighter-rouge">with type</code>)과 반환 타입을 포함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type FunctionAlias = (input: string) =&gt; number;

interface CallSignature {
    (input: string): number;
}

const typedFunctionAlias: FunctionAlias = (input) =&gt; input.length;

const typedCallSignature: CallSignature = (input) =&gt; input.length;
</code></pre></div></div>

<blockquote>
  <p>호출 시그니처는 사용자 정의 속성을 추가로 갖는 함수를 설명하는 데에도 사용할 수 있다.</p>
</blockquote>

<h3 id="인덱스-시그니처-index-signature--임의의-키를-받고-해당-키에-대한-값의-타입을-지정">인덱스 시그니처 (<code class="language-plaintext highlighter-rouge">Index Signature</code>) : 임의의 키를 받고, 해당 키에 대한 값의 타입을 지정</h3>

<blockquote>
  <p>인덱스 시그니처를 사용하면, 프로퍼티의 존재 유무를 알 수 없다!</p>
</blockquote>

<h3 id="중첩-시그니처-nested-interface--속성의-타입이-다른-인터페이스나-객체-타입을-가질-수-있음">중첩 시그니처 (<code class="language-plaintext highlighter-rouge">Nested Interface</code>) : 속성의 타입이 다른 인터페이스나 객체 타입을 가질 수 있음</h3>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TS" /><summary type="html"><![CDATA[타입스크립트 (TypeScript) : JavaScript을 확장하여 정적 타입을 지원하는 프로그래밍 언어]]></summary></entry><entry><title type="html">[JS] 9. 비동기 처리 (Asynchronous Processing)</title><link href="http://localhost:4000/js9/" rel="alternate" type="text/html" title="[JS] 9. 비동기 처리 (Asynchronous Processing)" /><published>2024-02-05T00:00:00+09:00</published><updated>2024-02-05T00:00:00+09:00</updated><id>http://localhost:4000/js9</id><content type="html" xml:base="http://localhost:4000/js9/"><![CDATA[<h2 id="비동기-처리-asynchronous-processing--프로세스의-완료를-기다리지-않고-다른-작업을-진행">비동기 처리 (<code class="language-plaintext highlighter-rouge">Asynchronous Processing</code>) : 프로세스의 완료를 기다리지 않고 다른 작업을 진행</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a3f7aa41-e708-45b7-8397-068980fc6f3c" width="70%" /></p>

<ul>
  <li>싱글 쓰레드 (<code class="language-plaintext highlighter-rouge">Single Thread</code>) : 한번에 하나의 함수만 실행 → 동기 처리 (<code class="language-plaintext highlighter-rouge">Synchronous Processing</code>)과 동일
    <ul>
      <li>자바스크립트는 콜 스택이 하나 → 콜 스택에 쌓인 함수나 코드를 위에서 아래로 차례대로 실행</li>
    </ul>
  </li>
  <li>논블로킹 (<code class="language-plaintext highlighter-rouge">Non-Blocking</code>) : <code class="language-plaintext highlighter-rouge">I/O</code>를 수행하는 비동기 함수는 백그라운드에 넘김</li>
  <li>멀티 프로세스 (<code class="language-plaintext highlighter-rouge">Multi Processes</code>) : 백그라운드는 <code class="language-plaintext highlighter-rouge">OS</code> 프로세스에 의존</li>
</ul>

<blockquote>
  <p>비동기 처리의 순서?</p>

  <ol>
    <li>런타임 (<code class="language-plaintext highlighter-rouge">Runtime</code>) → 실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) → 콜 스택 (<code class="language-plaintext highlighter-rouge">CallStack</code>)</li>
    <li>백그라운드 (<code class="language-plaintext highlighter-rouge">Background</code>) → 운영체제 (<code class="language-plaintext highlighter-rouge">OS</code>)</li>
    <li>테스크 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>) → 콜 스택 (<code class="language-plaintext highlighter-rouge">Call Stack</code>)</li>
  </ol>
</blockquote>

<h3 id="자바스크립트-런타임-javascript-runtime--자바스크립트가-실행되는-환경">자바스크립트 런타임 (<code class="language-plaintext highlighter-rouge">JavaScript Runtime</code>) : 자바스크립트가 실행되는 환경</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c9726e-4743-4b62-aa15-5a5cde2cdef9" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Web API</code> : 브라우저에서 제공하는 <code class="language-plaintext highlighter-rouge">API</code> (<code class="language-plaintext highlighter-rouge">setTimeout</code>, <code class="language-plaintext highlighter-rouge">HTTP</code> 요청 메소드, <code class="language-plaintext highlighter-rouge">DOM</code> 이벤트)</li>
  <li>테스트 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>) : 이벤트가 발생한 뒤에 호출되어야 할 콜백 함수들이 대기하는 공간</li>
  <li>이벤트 루프 (<code class="language-plaintext highlighter-rouge">Event Loop</code>) : 이벤트 발생 시 콜백 함수들을 관리, 호출된 콜백 함수의 실행 순서 결정</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1ebeb0a1-a9fc-4234-ab64-f4b720b9cc43" width="80%" /></p>

<h3 id="비동기-콜백-패턴-asynchronous-callback-pattern--비동기-작업의-완료를-다루는-전통적인-방식">비동기 콜백 패턴 (<code class="language-plaintext highlighter-rouge">Asynchronous Callback Pattern</code>) : 비동기 작업의 완료를 다루는 전통적인 방식</h3>

<ul>
  <li>현재 실행되고 있는 함수가 끝난 뒤에 실행되는 콜백 함수를 통해 실행 순서를 지정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(function() {
  console.log('task1', new Date());
  setTimeout(function() {
    console.log('task2', new Date());
    setTimeout(function() {
      console.log('task3', new Date());
      console.log('END&gt;&gt;', new Date());
    }, 1000 );
  }, 2000);
}, 3000);
console.log('START', new Date());
</code></pre></div></div>

<blockquote>
  <p>콜백 함수를 여러 개 중첩하면, 코드의 가독성이 떨어지는 콜백 지옥 (<code class="language-plaintext highlighter-rouge">Callback Hell</code>)이 발생!</p>
</blockquote>

<h2 id="프로미스-promise--비동기-작업의-성공-및-실패에-대한-완료-결과를-처리하는-객체">프로미스 (<code class="language-plaintext highlighter-rouge">Promise</code>) : 비동기 작업의 성공 및 실패에 대한 완료 결과를 처리하는 객체</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/6acaa363-7157-4636-9f62-1da04e7a6a9c" width="90%" /></p>

<ul>
  <li>콜백 지옥을 피하고 비동기 처리를 쉽게 처리할 수 있도록 <code class="language-plaintext highlighter-rouge">ES6</code>부터 <code class="language-plaintext highlighter-rouge">then</code> 도입</li>
  <li>프로미스를 호출하면 프로미스 인스턴스 (<code class="language-plaintext highlighter-rouge">Promise Instance</code>)를 반환한 후 <code class="language-plaintext highlighter-rouge">Resolve</code> &amp; <code class="language-plaintext highlighter-rouge">Reject</code></li>
</ul>

<blockquote>
  <p>프로미스의 3가지 상태 (<code class="language-plaintext highlighter-rouge">Status</code>)</p>

  <ul>
    <li>대기 (<code class="language-plaintext highlighter-rouge">Pending</code>) : 비동기 처리 로직이 미완료된 초기 상태, 성공 또는 실패할 때까지 대기</li>
    <li>이행 (<code class="language-plaintext highlighter-rouge">Fulfilled</code> ): 비동기 처리가 완료되어, 프로미스가 결과 값을 반환한 상태</li>
    <li>거부 (<code class="language-plaintext highlighter-rouge">Rejected</code>) : 비동기 처리가 실패하거나 오류가 발생한 상태</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        const now = Date.now();
        
        if (now % 2 === 0) {
            resolve(console.log('[Fulfilled]'), now);    
        } else reject('Rejected');
    }, 1000);

    setTimeout(() =&gt; {
        reject(new Error('[TimeExceeded]'),);
    }, 1001);
});

promise.then(
    success =&gt; console.log('[Resolved]'),
    fail =&gt; console.log('[Rejected]')
)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로미스를 클래스로 표현한다면?
class Promise {
  constructor(callback) {
    console.log('[Promise 생성자]')
    callback (this.resolve.bind(this), this.reject.bind(this));
}

  then(resolve) {
    console.log('[then 메소드 실행]')
    this.success = callback;
  }

  catch(x) {
    console.log('[catch 메소드 실행]')
    this.failure = callback;
  }

  success(x) {
    console.log('[success 메소드 실행] ' + x)
  }

  failure(x) {
    console.log('[failure 메소드 실행] ' + x)
  }

  resolve(x) { 
    console.log('[resolve 메소드 실행]')
    return this.success(x);
  }

  reject(x) {
    console.log('[reject 메소드 실행]')
    return this.failure(x);
  }

  callback(resolve, reject) {
    console.log('[callback 메소드 실행]')
  }
};

let promise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            const now = Date.now();
            console.log('이행 :', now)

            if (now % 2 === 0)
                resolve(now)
            else
                reject(new Error("실패"))

            console.log("[setTimeout 메소드 실행]")
        }, 1000)
    }
);
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/71628456-0e58-4bbb-b1f7-45cff3e5b96a" width="90%" /></p>

<h3 id="프로미스-클래스-메소드-promise-class-method--프로미스에서-비동기-작업을-다루기-위해-제공">프로미스 클래스 메소드 (<code class="language-plaintext highlighter-rouge">Promise Class Method</code>) : 프로미스에서 비동기 작업을 다루기 위해 제공</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Promise.resolve</code> : 주어진 값을 성공 상태의 프로미스로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.resolve(x).then(val =&gt; console.log(val));</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.reject</code> : 주어진 값을 실패 상태의 프로미스로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.reject(new Error('...')).catch(console.error);</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.all</code> : 여러 프로미스가 모두 성공 시 <b>시간과 무관하게 순서를 보장하여</b> 프로미스들을 모두 반환, 하나라도 실패하면 첫번째로 실패한 프로미스 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.all(iterables).then().catch(...)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.race</code> : 여러 프로미스 중에서 가장 빠른 것을 반환, 하나라도 실패하면 첫번째로 실패한 프로미스 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.race(iterables).then().catch(...)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.any</code> : 여러 프로미스 중에서 제일 빨리 성공한 것을 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.any(iterables).then().catch(...)</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Node.js</code> 모듈의 <code class="language-plaintext highlighter-rouge">util.promisify</code> : 콜백 함수 기반의 비동기 함수를 프로미스 기반으로 변환</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function promisify(fn) {
  return new Promise( (resolve, reject) =&gt; {
    try {
      const ret = fn();
      resolve(ret);
    } catch(err) {
      reject(err);
    }
  })
}

const exec = util.promisify(execute);
exec.then(...).catch(...)
</code></pre></div>  </div>
</blockquote>

<h2 id="async-await--프로미스를-생성하고-소비하기-위한-문법적-설탕"><code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> : 프로미스를 생성하고 소비하기 위한 문법적 설탕</h2>

<blockquote>
  <p>문법적 설탕 (<code class="language-plaintext highlighter-rouge">Syntax Sugar</code>) : 문법적 기능은 그대로인데, 사람이 직관적으로 읽을 수 있게끔 만드는 것</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4297057d-9df5-4864-aaf9-1fa77598e056" width="40%" /></p>

<ul>
  <li>비동기 함수에서 콜백을 사용하는 대신에, 단순한 논리적 흐름을 작성
    <ul>
      <li>프로미스의 <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">catch</code>, <code class="language-plaintext highlighter-rouge">finally</code>를 사용할 필요 없음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">async</code>는 프로미스를 반환하고, <code class="language-plaintext highlighter-rouge">await</code>는 <code class="language-plaintext highlighter-rouge">resolve</code> 및 <code class="language-plaintext highlighter-rouge">reject</code>와 매핑
    <ul>
      <li>성공 : <code class="language-plaintext highlighter-rouge">return</code> → <code class="language-plaintext highlighter-rouge">resolve</code> → <code class="language-plaintext highlighter-rouge">result</code></li>
      <li>실패 : <code class="language-plaintext highlighter-rouge">error</code> → <code class="language-plaintext highlighter-rouge">reject</code> → <code class="language-plaintext highlighter-rouge">throw</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// const fn = async() =&gt; {...}
async function fn() {   // Promise 반환
  ...
  result = await fetch(url);  // fetch.then().catch()
}
console.log(await fn());
</code></pre></div></div>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Promise</code> &amp; <code class="language-plaintext highlighter-rouge">then</code> : 각각이 별도의 쓰레드로 실행되므로 <b>병렬</b></li>
    <li><code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> : 단일 쓰레드를 차례로 실행하므로 <b>직렬</b></li>
  </ul>

  <p>→ 연관이 없는 비동기 함수 실행에 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code>을 남발하지 말자!</p>

</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// promise, async, await을 활용하여 페치한 뒤에 2초간 sleep 구현
const f = async () =&gt; {
  const res = await fetch("https://jsonplaceholder.typicode.com/users/1");  
  if (!res.ok) throw new Error("Fail to Fetch!!");
  console.log(Date.now())
  await new Promise((resolve) =&gt; {setTimeout(resolve, 2000)});
  const data = await res.json();
  return data.name;
};

console.log(await f());
console.log(Date.now())
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// promise, async, await을 활용하여 1초 간격으로 3번 출력하는 depthTimer 구현
let depthTimer = async (str) =&gt; {
  console.log(str, new Date());
  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));
};
  
(async function () {
  await depthTimer('START!');
  await depthTimer('depth1');
  await depthTimer('depth2');
  await depthTimer('depth3');
  console.log('Already 3-depth!!');
})();
</code></pre></div></div>

<h3 id="for-await-of--비동기적으로-이터레이터-iterator를-반복하는-문법"><code class="language-plaintext highlighter-rouge">for-await-of</code> : 비동기적으로 이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>)를 반복하는 문법</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async</code> 함수에서 비동기적으로 값을 가져와 처리할 때 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const afterTime = sec =&gt; new Promise(
    resolve =&gt; setTimeout(resolve, sec * 1000, sec
  ));
  console.time('for-await-of ');
  const arr = [afterTime(1), afterTime(2)];
  
  for (const fo of arr.values()) {
    console.log('fo =', fo);
  }
  
  for await (const fao of arr.values()) {
    console.log('fao =', fao);
  }
  
  console.timeEnd('for-await-of ');

// &gt; fo = Promise { &lt;pending&gt; }
// &gt; fo = Promise { &lt;pending&gt; }
// &gt; fao = 1
// &gt; fao = 2
// &gt; for-await-of : 2.003s
</code></pre></div></div>
<hr />]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[비동기 처리 (Asynchronous Processing) : 프로세스의 완료를 기다리지 않고 다른 작업을 진행]]></summary></entry><entry><title type="html">자바스크립트 프록시 (2024.02.04)</title><link href="http://localhost:4000/digital_hanaro_6/" rel="alternate" type="text/html" title="자바스크립트 프록시 (2024.02.04)" /><published>2024-02-04T00:00:00+09:00</published><updated>2024-02-05T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_6</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_6/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 6일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부한-이유">공부한 이유</h2>

<p>프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>)를 번역하면 어떤 일을 대신 수행하는 대리자, 대변인의 의미를 갖고 있다. 디자인패턴에서도 어떤 객체를 사용하고자 할 때, 객체를 직접 참조하는 것이 아니라 해댱 객체를 대행할 수 있는 프록시 객체를 통해 대상하고자 하는 객체에 접근하는 방식을 프록시 패턴 (<code class="language-plaintext highlighter-rouge">Proxy Pattern</code>)이라고 부른다. 자바스크립트에서도 프록시 객체가 있다는 것을 이번 수업을 통해 알게 되어 이에 대해 정리하고자 하였다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9a0c5c88-3e49-43f9-a2e1-55ae60429d27" width="60%" /></p>

<ul>
  <li>프록시 객체 (<code class="language-plaintext highlighter-rouge">Proxy Object</code>) : 원본 객체의 어떤 작업을 가로채 대신 처리하는 객체
    <ul>
      <li>타겟 (<code class="language-plaintext highlighter-rouge">target</code>) : 프록시 객체가 감쌀 (<code class="language-plaintext highlighter-rouge">wrapping</code>) 원본 객체</li>
      <li>핸들러 (<code class="language-plaintext highlighter-rouge">handler</code>) : 동작을 가로채는 ‘트랩 (<code class="language-plaintext highlighter-rouge">trap</code>)’이 담겨 타겟의 동작을 제어하는 메소드를 정의한 객체</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let target = {};
let proxy = new Proxy(target, handler)

proxy.test = 5;
alert(proxy.test); // 5
</code></pre></div></div>

<blockquote>
  <p>특정 객체를 감싸 해당 객체에 작업이 가해지고, 핸들러에 상응하는 트랩이 있다면 중간에서 작업을 트랩</p>
</blockquote>

<ul>
  <li>프록시는 일반 객체와 달리 프로퍼티가 없는 ‘특수 객체’
    <ul>
      <li>핸들러가 비어 있으면 프록시에 가해지는 작업은 원본 객체인 타겟으로 바로 전달</li>
    </ul>
  </li>
  <li>프록시의 트랩은 원본 객체에 수행하는 동작을 수행하는 내부 메소드의 호출을 가로챔</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4c6317c5-a2b0-4643-994f-ba45f073239b" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let numbers = [0, 1, 2];

numbers = new Proxy(numbers, {
  get(target, prop) {
    if (prop in target) return target[prop];
    return 0;
  }
});

alert( numbers[1] ); // 1
alert( numbers[123] ); // 0
</code></pre></div></div>

<blockquote>
  <p>프록시가 <code class="language-plaintext highlighter-rouge">Reflect</code>와 다른 점?</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Reflect</code>는 타겟 객체의 상태를 <code class="language-plaintext highlighter-rouge">Boolean</code>으로 반환하는 여러 메소드를 가진 자바스크립트 기본 객체
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Reflect</code>의 메소드가 프록시와 연동하여, <code class="language-plaintext highlighter-rouge">Reflect</code>의 메소드를 통해 검증하는 값을 프록시에도 핸들러에 할당해 처리 가능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#1</code>. 프록시는 비싼 함수 호출을 캐싱 (<code class="language-plaintext highlighter-rouge">Caching</code>)할 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function calculateCost(price, taxRate) {
  console.log('계산 : ');
  return price * (1 + taxRate);
}

const cache = new Map();

const proxy = new Proxy(calculateCost, {
  apply(target, thisArg, args) {
    const key = args.join('-');
    if (cache.has(key)) {
      console.log('캐시된 결과 반환 : ');
      return cache.get(key);
    } else {
      const result = Reflect.apply(target, thisArg, args);
      cache.set(key, result);
      return result;
    }
  },
});

console.log(proxy(10, 0.2)); // 계산 : 12
console.log(proxy(10, 0.2)); // 캐시된 결과 반환 : 12
console.log(proxy(20, 0.2)); // 계산 : 24
console.log(proxy(20, 0.3)); // 계산 : 26
console.log(proxy(20, 0.3)); // 캐시된 결과 반환 : 26
</code></pre></div></div>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#2</code>. 프록시는 데이터 검증에 활용하는 유효성 검사기 (<code class="language-plaintext highlighter-rouge">Validator</code>)로 활용될 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = {
  name: 'John',
  password: '',
};

const proxy = new Proxy(user, {
  set(target, prop, value) {
    if (prop === 'password' &amp;&amp; value.length &lt; 8) {
      throw new Error('Password must be at least 8 characters long');
    }
    target[prop] = value;
    return true;
  },
});

console.log(proxy.name); // John
console.log(proxy.password); // 

proxy.password = '12345678';
console.log(proxy.password); // 12345678

proxy.password = '123'; // 'Password must be at least 8 characters long' 에러 반환
</code></pre></div></div>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#3</code>. 프록시는 데이터 변화를 감지하는 로거 (<code class="language-plaintext highlighter-rouge">logger</code>)로 활용될 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = {
  name: 'John',
  email: 'john@example.com',
};

const proxy = new Proxy(user, {
  get(target, prop) {
    console.log(`Getting ${prop} property`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} property to ${value}`);
    target[prop] = value;
    return true;
  },
});

console.log(proxy.name); // Getting name property -&gt; John
proxy.email = 'bob@example.com'; // Setting email property to bob@example.com
console.log(proxy.email); // Getting email property -&gt; bob@example.com
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 6일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[vocawik] 2. vocawik 프로젝트 설계</title><link href="http://localhost:4000/vocawik2/" rel="alternate" type="text/html" title="[vocawik] 2. vocawik 프로젝트 설계" /><published>2024-02-03T00:00:00+09:00</published><updated>2024-02-03T00:00:00+09:00</updated><id>http://localhost:4000/vocawik2</id><content type="html" xml:base="http://localhost:4000/vocawik2/"><![CDATA[<h2 id="프로젝트-목표-project-goal--프로젝트-진행-과정에서-이루고자-하는-사항들을-정리">프로젝트 목표 (<code class="language-plaintext highlighter-rouge">Project Goal</code>) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">목표</td>
        <td nowrap="">설명</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">도메인 정의<br />(<code>Domain Definition</code>)</td>
        <td><ul>
          <li>사이트에서 제공하고자 하는 기능 및 책임들이 도메인별로 명확히 분리되어야 한다.</li>
        </ul></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="아키텍처-구조도-architecture-structure--사이트의-아키텍처를-설계">아키텍처 구조도 (<code class="language-plaintext highlighter-rouge">Architecture Structure</code>) : 사이트의 아키텍처를 설계</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<h2 id="유저-프로필-user-profile--사이트의-이용자들을-정의하여-분류">유저 프로필 (<code class="language-plaintext highlighter-rouge">User Profile</code>) : 사이트의 이용자들을 정의하여 분류</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">관리자<br />(<code>Manager; MA</code>)</td>
        <td>사이트 및 사이트 내부 기능들의 기획, 설계, 개발, 운영, 관리를 담당하는 사람들을 총칭한다.</td>
      </tr>
      <tr>
        <td nowrap="">회원<br />(<code>Member; ME</code>)</td>
        <td>사이트 이용자들 중에 회원 데이터베이스에 등록된 사람들을 총칭한다.</td>
      </tr>
      <tr>
        <td nowrap="">비회원<br />(<code>NonMember; NE</code>)</td>
        <td>사이트 이용자들 중에 회원 데이터베이스에 등록되지 않은 사람들을 총칭한다.</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="기능-명세서-functional-specification--사이트에서-구현할-기능들을-정리">기능 명세서 (<code class="language-plaintext highlighter-rouge">Functional Specification</code>) : 사이트에서 구현할 기능들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">분류</td>
        <td nowrap="">ID</td>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
        <td nowrap="">상태</td>
        <td nowrap="">우선<br />순위</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="32">회원<br />(<code>Member</code>)</td>
        <td nowrap=""><code>ME-001</code></td>
        <td nowrap="">회원 <code>ID</code> 로그인<br />(<code>MemberIdLogin</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '아이디' 또는 '이메일'과 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 때, '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되면 '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-002</code></td>
        <td nowrap="">회원 <code>OAuth</code> 로그인<br />(<code>MemberOAuthLogin</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 로그인 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-003</code></td>
        <td nowrap="">회원 <code>OTP</code> 로그인<br />(<code>MemberLoginCertifyByOTP</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (<code>OTP</code>) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행할 경우에 (즉 로그인이 정상적으로 수행되었다면), '일회용 비밀번호'를 확인할 수 있는 '<code>OTP</code> 키'를 발급하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-004</code></td>
        <td nowrap="">회원 로그인 이메일 인증<br />(<code>MemberLoginCertifyByEmail</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (이메일 인증) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되는 경우에 (즉 로그인이 정상적으로 수행되었다면), '일회용 비밀번호'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-005</code></td>
        <td nowrap="">회원 자동 로그인 방지<br />(<code>MemberLoginCAPTCHA</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 5회 이상 '로그인'에 실패할 경우, <code>google reCAPTCHA</code>를 통해 보안 문자를 입력한 다음에 로그인을 시도할 수 있도록 한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-006</code></td>
        <td nowrap="">회원 로그인 유지<br />(<code>MemberCreateRememberMe</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '로그인 유지 옵션'을 활성화한 상태로 로그인을 성공하였을 때, '회원'이 브라우저를 끄고 다시 접속하더라도 로그인 상태를 2주간 유지한다.</td>
        <td nowrap="">비회원<br />↓<br />회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-007</code></td>
        <td nowrap="">회원 비밀번호 재설정 이메일 인증<br />(<code>MemberResetPasswordCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '비밀번호 재설정' 버튼을 누르면, '비밀번호 재설정 아이디/이메일 입력 화면'으로 이동한다. 입력받은 값과 일치하는 회원 정보가 존재한다면, '임시 비밀번호'를 생성하여 30분간 유효한 '임시 비밀번호'를 포함한 '비밀번호 재설정 이메일'을 생성 및 전송한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-008</code></td>
        <td nowrap="">회원 비밀번호 재설정<br />(<code>MemberResetPassword</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '로그인'을 시도할 때 '비밀번호 재설정'에서 생성된 '임시 비밀번호'를 입력받았거나, '회원'이 '회원정보 갱신 화면'에서 '비밀번호 재설정' 버튼을 누른 경우, '비밀번호 재설정' 화면으로 이동한다. 입력받은 '비밀번호' 및 '비밀번호 확인'이 이전에 사용된 적이 있는 '중복된 비밀번호'가 아니면서 유효성 검사가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였다면, 입력한 값을 포함하여 회원 정보를 갱신한다. 그리고 이전에 이루어진 '회원 로그인 유지'를 모두 해제한 다음에 '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-009</code></td>
        <td nowrap="">회원 로그아웃<br />(<code>MemberLogout</code>)</td>
        <td>'회원'이 어떤 화면에서 '로그아웃 버튼'을 누르면, (만약 '회원 로그인 유지'가 이루어지고 있다면 이를 해제한 다음에) '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-010</code></td>
        <td nowrap="">회원가입<br />(<code>MemberRegister</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 바탕으로 서버 내 데이터베이스에 '회원'을 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-011</code></td>
        <td nowrap=""><code>OAuth</code> 회원가입<br />(<code>MemberOAuthRegister</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 회원가입 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원가입 화면'으로 이동한다. '회원가입' 화면에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 바탕으로 데이터베이스에 '회원'을 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원<br />↓<br />비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-012</code></td>
        <td nowrap="">회원가입 이메일 인증<br />(<code>MemberRegisterCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '이메일'을 입력하고 '이메일 인증 버튼'을 눌렀을 때, '유효성 검사'가 정상적으로 이루어진다면, '인증 문자열'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고 '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '인증 문자열'과 일치한다면, 인증에 성공하였다는 것을 알린다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-013</code></td>
        <td nowrap="">회원 개인정보 조회<br />(<code>MemberReadMyInfo</code>)</td>
        <td>'회원'이 어떤 화면에 존재하는 '회원 개인정보 조회' 버튼을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '비밀번호 확인 화면'으로 이동한다. 입력한 값이 해당 회원의 '비밀번호'와 일치하고 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '개인정보 조회 화면'을 제공한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-014</code></td>
        <td nowrap="">회원 개인정보 갱신<br />(<code>MemberUpdateMyInfo</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인정보를 수정하고 '개인정보 갱신 버튼'을 눌렀을 때, 각각의 '개인정보'에 대한 유효성 검사가 정상적으로 이루어지고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원'의 '개인정보'에 해당하는 값들을 데이터베이스에 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-015</code></td>
        <td nowrap="">회원 개인정보 갱신 이메일 인증<br />(<code>MemberUpdateMyInfoCertifyByEmail</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인정보 중에 '이메일'을 수정하고 '이메일 인증' 버튼을 눌렀을 때, '이메일'에 대한 유효성 검사가 정상적으로 이루어지고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '인증 주소'를 생성하여 30분간 유효한 '인증 주소'를 포함한 '인증 이메일'을 생성 및 전송한다. 만약 해당 '인증 주소'을 열람한다면, 인증이 성공하였다는 것을 알린다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-016</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동<br />(<code>MemberUpdateMyOAuth</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인 정보 중에 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 연동 버튼'을 눌렀을 때 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '<code>OAuth</code>'에 대한 정보를 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-017</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동 해제<br />(<code>MemberDeleteMyOAuth</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인 정보 중에 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 연동 해제 버튼'을 눌렀을 때 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '<code>OAuth</code>'에 대한 정보를 삭제한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-018</code></td>
        <td nowrap="">회원 탈퇴 (회원 개인정보 삭제)<br />(<code>MemberDeleteMyAccount</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 탈퇴 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '비밀번호 재확인 화면'을 제공한다. 입력한 값이 해당 회원의 '비밀번호'와 일치하고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원 탈퇴 안내 화면'을 제공한다. 만약 '회원 탈퇴 안내 화면'에서 '회원 탈퇴 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '개인정보'를 삭제한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-019</code></td>
        <td nowrap="">회원 로그인 기록 조회<br />(<code>MemberReadLoginHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '로그인 기록 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '로그인 기록' ('로그인 일시', '로그인 <code>IP</code>', '로그인 국가', '로그인 기기')을 제공하는 '로그인 기록 화면'으로 이동한다. (이때 '로그인 기록'은 최근 3개월까지의 기록을 한정해 제공하며, 최대 1,000건까지 한정해 제공한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-020</code></td>
        <td nowrap="">회원 비밀번호 재설정 기록 조회<br />(<code>MemberReadResetPasswordHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '비밀번호 재설정 기록 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '비밀번호 재설정 기록' ('비밀번호 재설정 일시', '비밀번호 재설정 <code>IP</code>', '비밀번호 재설정 국가')을 제공하는 '비밀번호 재설정 기록 화면'으로 이동한다. (이때 '비밀번호 재설정 기록'은 최근 6개월까지의 기록을 한정해 제공하며, 최대 1,000건까지 한정해 제공한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-021</code></td>
        <td nowrap="">회원 중복 로그인 설정<br />(<code>MemberSetDuplicateLogin</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 중복 로그인 설정 옵션'을 비활성화할 때, 팝업 창을 통해 비활성화가 이루어질 때 수행될 작업에 대해 안내한다. 만약 팝업 창에 참인 값이 반환되었다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원이 로그인을 유지하고 있는 기기가 모두 해제되고, 회원이 앞으로 로그인 유지를 활성화한 상태로 로그인을 시도하더라도 로그인 유지가 이루어지지 않는다. '회원 중복 로그인 설정 옵션'을 활성화하면, 활성화가 이루어질 때 수행될 작업에 대해 안내한다. 만약 팝업 창에 참인 값이 반환되었다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원이 앞으로 로그인 유지를 활성화한 상태로 로그인을 시도한다면 로그인 유지가 이루어진다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-022</code></td>
        <td nowrap="">회원 로그인 유지 기기 조회<br />(<code>MemberReadRememberMeHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 로그인 유지 기기 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원 로그인 유지 기기 기록' ('운영체제', '브라우저', '로그인 <code>IP</code>', '최근 접속 일시', '최초 로그인 일시')를 제공하는 '로그인 유지 기기 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-023</code></td>
        <td nowrap="">회원 로그인 유지 기기 해제<br />(<code>MemberDeleteRememberMe</code>)</td>
        <td>'회원'이 '로그인 유지 기기 화면'에서 특정 기기에 대한 '로그아웃 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 특정 기기에 대한 로그인 유지 기록을 삭제한다. (이때, 현재 접속 중인 기기는 삭제할 수 없도록 한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-024</code></td>
        <td nowrap="">회원 프로필 조회<br />(<code>MemberReadMyProfile</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '프로필'을 조회해야 할 때, 해당 '회원'에 대한 프로필 정보를 제공하는 '프로필 화면'을 제공한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-025</code></td>
        <td nowrap="">회원 프로필 갱신<br />(<code>MemberUpdateMyProfile</code>)</td>
        <td>'회원'이 해당 회원에 대한 '프로필 화면'에서 '프로필 갱신' 버튼을 눌렀을 때, 해당 '회원'에 대한 인가가 정상적으로 수행될 경우에 프로필 정보를 갱신할 수 있는 '프로필 갱신 화면'을 제공한다. 만약 '프로필 갱신 화면'에서 '프로필 갱신 버튼'을 누른다면 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 프로필 정보를 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-026</code></td>
        <td nowrap="">회원 인터페이스 설정 조회<br />(<code>MemberReadMyInterface</code>)</td>
        <td>'회원'이 어떤 화면에 존재하는 특정 회원에 대한 '인터페이스 설정 조회' 버튼을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 '회원'에 대한 인터페이스 정보를 제공하는 '인터페이스 설정 화면'을 제공한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-027</code></td>
        <td nowrap="">회원 인터페이스 설정 갱신<br />(<code>MemberUpdateMyInterface</code>)</td>
        <td>'회원'이 '인터페이스 설정 화면'에 존재하는 특정 정보를 갱신한다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 이를 반영한 화면을 즉각적으로 표현한다. 만약 '인터페이스 화면'에 존재하는 '인터페이스 설정 저장 버튼'을 누른다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 인터페이스 설정 정보를 갱신한다. 또한 '인터페이스 화면'에 존재하는 '인터페이스 설정 초기화' 버튼을 누르거나 '인터페이스 설정 저장 버튼'을 누르지 않고 다른 화면을 이동한다면, 기존 값을 반영한 화면을 표현한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-028</code></td>
        <td nowrap="">회원 상태 조회<br />(<code>MemberReadMyStatus</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '상태'를 조회해야 할 때, 해당 '회원'에 대한 상태 정보를 제공하는 '상태 화면'을 제공한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-029</code></td>
        <td nowrap="">회원 상태 갱신<br />(<code>MemberUpdateMyStatus</code>)</td>
        <td>특정 '회원'이 사이트 내에서 어떤 작업을 실행할 때, 해당 '회원'에 대한 상태 정보가 '오프라인'이라면, 이를 '오프라인'에서 '온라인'으로 갱신한다. 만약 '회원'이 어떤 화면에서 '방해 금지 활성화 버튼'을 눌렀다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원의 상태 정보를 '방해 금지'으로 갱신한다. ('방해 금지'가 활성화된 상태에서는 중요한 알림을 제외한 모든 알림들을 전달받지 않늗다.) 만약 '회원'이 어떤 화면에서 '방해 금지 비활성화 버튼'을 눌렀다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원의 상태 정보를 '온라인'으로 갱신한다. 만약 로그인 유지 기기가 하나일 때 로그아웃을 실행하거나 1시간 이상 사이트 내에서 작업이 이루어지지 않는다면, 해당 '회원'에 대한 상태 정보가 '온라인'에서 '오프라인'으로 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-030</code></td>
        <td nowrap="">회원 권한 조회<br />(<code>MemberReadAuth</code>)</td>
        <td>'회원'이 어떤 화면으로 이동할 때, 특정 작업에 대한 '권한'을 갖고 있다면 '회원'에 대한 인가가 정상적으로 수행될 경우에 특정 작업의 실행을 위해 이를 다른 도메인 서비스에 요청할 수 있는 '권한 버튼'을 표시한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-031</code></td>
        <td nowrap="">회원 권한 요청<br />(<code>MemberPublishAuth</code>)</td>
        <td>'회원'이 어떤 화면에서 특정 작업에 대한 '권한 버튼'을 눌렀을 때, 특정 작업의 실행을 위해 이를 다른 도메인 서비스에 요청하여 요청에 대한 응답을 반환한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-032</code></td>
        <td nowrap="">회원 권한 기록 조회<br />(<code>MemberReadAuthHistory</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '권한 기록 버튼'을 눌렀을 때, 해당 회원이 다른 도메인에 권한을 요청하여 응답받은 '권한 기록' ('권한 요청 일시', '권한 응답 일시', '권한 이름', '권한 내용', '권한 응답 결과', '권한 요청자', '권한 실행자')를 제공하는 '권한 기록 화면'으로 이동한다.</td>
        <td nowrap="">-</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="7">관리자<br />(<code>Manager</code>)</td>
        <td nowrap=""><code>MA-001</code></td>
        <td nowrap="">관리자 보안 로그인<br />(<code>ManagerSecureLogin</code>)</td>
        <td>지정된 <code>IP</code>에서 접속한 '비회원'이 '관리자 로그인 화면'에서 '아이디'와 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 대, '유효성 검사' 및 관리자에 대한 '인증'이 정상적으로 수행되면 '관리자'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (보안)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-002</code></td>
        <td nowrap="">관리자 보안 로그아웃<br />(<code>ManagerSecureLogout</code>)</td>
        <td>'관리자'가 어떤 화면에서 '로그아웃 버튼'을 누를 때, 관리자에 대한 '인증'이 정상적으로 수행되면 '관리자'에 대한 '인가'를 비활성화하고 '관리자 로그인 화면'으로 이동한다.</td>
        <td nowrap="">관리자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-003</code></td>
        <td nowrap="">관리자 과도한 로그인 시도 제한<br />(<code>ManagerLimitExcessiveLogin</code>)</td>
        <td>지정된 <code>IP</code>에서 접속한 '비회원'이 '관리자 로그인 화면'에서 5회 이상 '로그인'에 실패할 경우에 해당 <code>IP</code>에서 접속하는 것을 30분간 금지한다.</td>
        <td nowrap="">비회원 (보안)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-004</code></td>
        <td nowrap="">관리자 회원 권한 갱신<br />(<code>ManagerUpdateAuthOnUser</code>)</td>
        <td>'관리자'가 '관리자 콘솔 화면'에서 '회원 권한 갱신 버튼'을 누르면, 관리자에 대한 '인증'이 정상적으로 수행되면 회원 <code>ID</code>를 검색할 수 있는 '(관리자) 회원 검색 화면'을 제공한다. 입력한 값과 일치하는 회원 <code>ID</code>이 존재할 때, 관리자에 대한 '인증'이 정상적으로 수행되면 회원 프로필 정보를 제공하고 회원 권한을 갱신할 수 있는 '(관리자) 회원 권한 갱신 화면'을 제공한다. '회원 권한 갱신 버튼'을 눌렀을 때, 관리자에 대한 '인증'이 정상적으로 수행되면 '회원 서비스'에 존재하는 해당 회원의 권한 정보를 갱신한다. (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-005</code></td>
        <td nowrap="">관리자 권한 실행 기록 조회<br />(<code>ManagerReadAuthRequestHistory</code>)</td>
        <td>'관리자'가 '관리자 콘솔 화면'에서 '권한 실행 기록 조회 버튼'을 누르면, 관리자에 대한 '인증'이 정상적으로 수행되면 모든 '회원'이 '관리자 서비스'에 권한을 요청하여 응답받은 '권한 기록' ('권한 요청 일시', '권한 응답 일시', '권한 이름', '권한 내용', '권한 응답 결과', '권한 요청자', '관한 실행자') (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-006</code></td>
        <td nowrap="">관리자 IP 차단<br />(<code>ManagerBlockIP</code>)</td>
        <td> (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-007</code></td>
        <td nowrap="">관리자 회원 제재<br />(<code>ManagerPenaltyMember</code>)</td>
        <td> (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="19">위키<br />(<code>Wiki</code>)</td>
        <td nowrap=""><code>WI-001</code></td>
        <td nowrap="">카테고리 생성<br />(<code>~CreateCategory</code>)</td>
        <td>'관리자'나 해당 권한을 가진 회원이 '위키 메인 화면'에서 '카테고리 생성 버튼'을 누를 때, 각각의 '인증'이 정상적으로 수행되면 카테고리의 구성 요소들을 입력할 수 있는 '카테고리 생성 화면'으로 이동한다. '카테고리 생성 화면'에서 '카테고리 생성 버튼'을 눌렀다면, 카테고리의 구성 요소들 중에 필수 항목들이 모두 입력되고 입력한 값들에 대한 '유효성 검사'가 정상적으로 수행되었을 때, 각각의 '인증'이 정상적으로 수행되면 데이터베이스에 '카테고리'를 생성한 다음 '위키 메인 화면'으로 이동한다.</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-002</code></td>
        <td nowrap="">카테고리 갱신<br />(<code>~UpdateCategory</code>)</td>
        <td>'관리자'나 해당 권한을 가진 회원이 특정한 '카테고리 메인 화면'에서 '카테고리 갱신 버튼'을 누를 때, 각각의 '인증'이 정상적으로 수행되면 해당 카테고리의 구성 요소들을 수정할 수 있는 '카테고리 수정 화면'으로 이동한다. '카테고리 갱신 화면'에서 '카테고리 갱신 버튼'을 눌렀다면, 카테고리의 구성 요소들 중에 필수 항목들이 모두 입력되고 입력한 값들에 대한 '유효성 검사'가 정상적으로 수행되었을 때, 각각의 '인증'이 정상적으로 수행되면 데이터베이스에 해당 '카테고리'를 생성한 다음에 생성된 '카테고리 메인 화면'으로 이동한다.</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-003</code></td>
        <td nowrap="">카테고리 읽기<br />(<code>~ReadCategory</code>)</td>
        <td>어떤 화면에서 특정한 '카테고리 이동 버튼'을 누르면, 해당 카테고리의 정보와 하위 문서들을 볼 수 있는 '카테고리 메인 화면'으로 이동한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-004</code></td>
        <td nowrap="">카테고리 삭제<br />(<code>~DeleteCategory</code>)</td>
        <td>'관리자'나 해당 권한을 가진 회원이 특정한 '카테고리 메인 화면'에서 '카테고리 삭제 버튼'을 누를 때, 각각의 '인증'이 정상적으로 수행되면 해당 카테고리를 삭제할 수 있는 '카테고리 삭제 화면'으로 이동한다. '카테고리 삭제 화면'에서 '카테고리 삭제 버튼'을 눌렀다면, 각각의 '인증'이 정상적으로 수행되면 데이터베이스에 '카테고리'를 생성한 다음 '위키 메인 화면'으로 이동한다.</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-005</code></td>
        <td nowrap="">문서 생성<br />(<code>~CreateDocument</code>)</td>
        <td>어떤 화면에서 '문서 생성 버튼'을 누르면, 문서의 구성 요소들을 작성할 수 있는 '문서 생성 화면'으로 이동한다. '문서 생성 화면'에서 '문서 생성 버튼'을 눌렀다면, 문서의 구성 요소들 중에 필수 항목들이 모두 입력되고 입력한 값들에 대한 '유효성 검사'가 정상적으로 수행되었을 때, 데이터베이스에 해당 '문서' </td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-006</code></td>
        <td nowrap="">문서 갱신<br />(<code>~UpdateDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-007</code></td>
        <td nowrap="">문서 읽기<br />(<code>~ReadDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-008</code></td>
        <td nowrap="">문서 삭제<br />(<code>~DeleteDocument</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-009</code></td>
        <td nowrap="">특정 카테고리에서 문서 검색<br />(<code>~SearchDocumentOnCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-010</code></td>
        <td nowrap="">모든 카테고리에서 문서 검색<br />(<code>~SearchDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-011</code></td>
        <td nowrap="">카테고리 검색<br />(<code>~SearchCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DO-012</code></td>
        <td nowrap="">특정 카테고리 기록 조회<br />(<code>~ReadCategoryHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-013</code></td>
        <td nowrap="">특정 문서 기록 조회<br />(<code>~ReadDocumentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-014</code></td>
        <td nowrap="">템플릿 생성<br />(<code>~CreateTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-015</code></td>
        <td nowrap="">템플릿 갱신<br />(<code>~UpdateTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-016</code></td>
        <td nowrap="">템플릿 읽기<br />(<code>~ReadTemplate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-017</code></td>
        <td nowrap="">템플릿 삭제<br />(<code>~DeleteTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-018</code></td>
        <td nowrap="">템플릿 검색<br />(<code>~SearchTemplate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-019</code></td>
        <td nowrap="">문서에 템플릿 가져오기<br />(<code>~AddTemplateOnDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">토론<br />(<code>Debate</code>)</td>
        <td nowrap=""><code>DE-001</code></td>
        <td nowrap="">문서에 토론 생성<br />(<code>CreateDebateOnDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-002</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-003</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-004</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-005</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="15">게시판<br />(<code>Board</code>)</td>
        <td nowrap=""><code>BO-001</code></td>
        <td nowrap="">게시판 생성<br />(<code>~CreateBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-002</code></td>
        <td nowrap="">게시판 조회<br />(<code>~ReadBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-003</code></td>
        <td nowrap="">게시판 갱신<br />(<code>~UpdateBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-004</code></td>
        <td nowrap="">게시판 삭제<br />(<code>~DeleteBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-005</code></td>
        <td nowrap="">특정 게시판에서 게시글 조회<br />(<code>~ReadPostOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-006</code></td>
        <td nowrap="">특정 게시판에서 게시글 갱신<br />(<code>~UpdatePostOnBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />작성자 (게시글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-007</code></td>
        <td nowrap="">특정 게시판에서 게시글 삭제<br />(<code>~DeletePostOnBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />작성자 (게시글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-008</code></td>
        <td nowrap="">특정 게시판에서 게시글 목록 조회<br />(<code>~ReadPostHistoryOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-009</code></td>
        <td nowrap="">게시판 검색<br />(<code>~SearchBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-010</code></td>
        <td nowrap="">특정 게시판에서 게시글 검색<br />(<code>~SearchPostOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-011</code></td>
        <td nowrap="">모든 게시판에서 게시글 검색<br />(<code>~SearchPost</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-012</code></td>
        <td nowrap="">회원이 작성한 게시글 기록 조회<br />(<code>~ReadUserPostHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-013</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-014</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-015</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="6">댓글<br />(<code>Comment</code>)</td>
        <td nowrap=""><code>CO-001</code></td>
        <td nowrap="">댓글 생성<br />(<code>~CreateComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-002</code></td>
        <td nowrap="">댓글 조회<br />(<code>~ReadComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-003</code></td>
        <td nowrap="">댓글 갱신<br />(<code>~UpdateComment</code>)</td>
        <td></td>
        <td nowrap="">작성자 (댓글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-004</code></td>
        <td nowrap="">댓글 삭제<br />(<code>~DeleteComment</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />작성자 (댓글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-005</code></td>
        <td nowrap="">회원이 작성한 댓글 기록 조회<br />(<code>~ReadUserCommentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-006</code></td>
        <td nowrap="">최근에 등록된 댓글 기록 조회<br />(<code>~ReadCreateCommentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">알림<br />(<code>Notice</code>)</td>
        <td nowrap=""><code>NO-001</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-002</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-003</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-004</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-005</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">채팅<br />(<code>Chat</code>)</td>
        <td nowrap=""><code>CH-001</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-002</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-003</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-004</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-005</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="래퍼런스-references--프로젝트-설계-과정에-참고한-자료">래퍼런스 (<code class="language-plaintext highlighter-rouge">References</code>) : 프로젝트 설계 과정에 참고한 자료</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="" style="padding-left: 4%; padding-right: 4%;">분류</td>
        <td nowrap="">이름</td>
        <td nowrap="">저자</td>
        <td nowrap="">주소</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="" rowspan="2">논문</td>
        <td>보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼 (2018)</td>
        <td nowrap="">김도희</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td>보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문. (2012)</td>
        <td nowrap="">임현정</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="1">기사</td>
        <td>한국 보컬로이드는 어떻게 나아가야할까?</td>
        <td nowrap="">안태춘</td>
        <td nowrap=""><a href="https://www.newslight.kr/news/655301">더뉴스라이트</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">도서</td>
        <td>서비스를 성공시키는 기획자의 비법 노트</td>
        <td nowrap="">조이</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=295601741">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>사례로 배우는 언어 전환 프로젝트 관리</td>
        <td nowrap="">남경호</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>도메인 주도 설계로 시작하는 마이크로서비스 개발</td>
        <td nowrap="">한정헌, 유해식, 최은정, 이주영</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">문서</td>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말">문서</a></td>
      </tr>
      <tr>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말/심화</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말/심화">문서</a></td>
      </tr>
      <tr>
        <td>공공기관 웹사이트 구축·운영 가이드</td>
        <td nowrap="">행정안전부</td>
        <td nowrap=""><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj204K9zoKEAxWtLUQIHQsyB4AQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.mois.go.kr%2Fcmm%2Ffms%2FFileDown.do%3FatchFileId%3DFILE_00084689_1WeMtZ%26fileSn%3D1&amp;usg=AOvVaw1TqMgiQXNjFgQfouwTtQh2&amp;opi=89978449">문서</a></td>
      </tr>
            <tr>
        <td nowrap="" rowspan="2">사이트</td>
        <td nowrap="" colspan="2">나무위키</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:대문">홈페이지</a></td>
      </tr>
      <tr>
        <td nowrap="" colspan="2">openNAMU</td>
        <td nowrap=""><a href="https://github.com/openNAMU/openNAMU">깃허브 저장소</a></td>
      </tr>
    </tbody>
  </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[프로젝트 목표 (Project Goal) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리]]></summary></entry><entry><title type="html">[JS] 8. 모듈 (Module)</title><link href="http://localhost:4000/js8/" rel="alternate" type="text/html" title="[JS] 8. 모듈 (Module)" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/js8</id><content type="html" xml:base="http://localhost:4000/js8/"><![CDATA[<h2 id="모듈-module--코드를-재사용-가능한-파일-단위의-조각으로-나눈-것">모듈 (<code class="language-plaintext highlighter-rouge">Module</code>) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것</h2>

<ul>
  <li>자신만의 모듈 스코프를 갖고, 어플리케이션과 독립적으로 자체 컴파일한 단위</li>
  <li>코드의 변수, 상수, 함수, 클래스 등을  선택적으로 공개 (<code class="language-plaintext highlighter-rouge">Export</code>)</li>
  <li>이름 충돌, 종속성 등 문제 해결 및 엄격 모드 자동 적용</li>
  <li><code class="language-plaintext highlighter-rouge">Read-Only</code>로 로드되며 동일 영역에 중복 <code class="language-plaintext highlighter-rouge">import</code> 가능</li>
</ul>

<h3 id="모듈-시스템-module-system--현재는-esm-ecmascript-module이-표준">모듈 시스템 (<code class="language-plaintext highlighter-rouge">Module System</code>) → 현재는 <code class="language-plaintext highlighter-rouge">ESM</code> (<code class="language-plaintext highlighter-rouge">ECMAScript Module</code>)이 표준!</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">"type": "module",</code> 추가</li>
  <li>모든 파일의 확장자를 <code class="language-plaintext highlighter-rouge">mjs</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm i esm → $&gt; node -r esm mod.js</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "name": "js",
  "version": "1.0.0",
  "description": "package.json for test",
  "main": "npm.js",
  "author": "pocj8ur4in",
  "type": "module", 
  "license": "ISC"
}
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/76d1a998-c16d-4823-8f8b-18e7c9399904" width="50%" /></p>

<h3 id="임포트-import--익스포트-export--특정-모듈에서-export한-것을-import">임포트 (<code class="language-plaintext highlighter-rouge">Import</code>) &amp; 익스포트 (<code class="language-plaintext highlighter-rouge">Export</code>) : 특정 모듈에서 <code class="language-plaintext highlighter-rouge">Export</code>한 것을 <code class="language-plaintext highlighter-rouge">Import</code></h3>

<ul>
  <li>모듈을 찾을 위치를 문자열로 지정하는 모듈 지정자 (<code class="language-plaintext highlighter-rouge">Module Specifier</code>) 사용</li>
  <li>중복으로 임포트하더라도 실행 컨텍스트 단위 하나당 한번만 로드 (<code class="language-plaintext highlighter-rouge">Module Map</code>/<code class="language-plaintext highlighter-rouge">Tree</code>)</li>
  <li>임포트 및 익스포트 선언은 최상위 스코프에서만 가능, 표현식이 아니라 선언이므로 호이스팅</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export function fn() { ... }
export const value = 1;
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import {} from './mod.js';
import '.mod.js'; // side-effect only! → 임포트로 실행만 할 경우에 선언
</code></pre></div></div>

<h4 id="간접-익스포트-indirect-export--aggregating--다른-모듈의-일부-혹은-전체를-받아-다시-익스포트">간접 익스포트 (<code class="language-plaintext highlighter-rouge">Indirect Export &amp; Aggregating</code>) : 다른 모듈의 일부 혹은 전체를 받아 다시 익스포트</h4>

<ul>
  <li>필요한 모듈만 모아놓은 또 다른 모듈을 만들 때에 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export { xxx } from './mod1.js';
export { yyy } from './mod2.js';
export { zzz } from './mod3.js'; // 사용하려면 명시적으로 import한 후 export해야 함

→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

// import 후 export
import { xxx } from './mod3.js';
export { xxx };

→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

// 개선된 방법 with Aggregating
import { xxx, yyy, zzz } from './agg.js';

export * from './mod1.js';
export * from './mod2.js';
export * from './mod3.js';

import * as agg from './agg.js';
</code></pre></div></div>

<h3 id="동적-임포트-dynamic-import--코드-실행-중에-모듈을-비동기적으로-불러옴">동적 임포트 (<code class="language-plaintext highlighter-rouge">Dynamic Import</code>) : 코드 실행 중에 모듈을 비동기적으로 불러옴</h3>

<ul>
  <li>어플리케이션 초기 로딩 시 모든 모듈을 불러오지 않고, 필요한 모듈만 필요한 시점에 불러와서 성능을 최적화</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 동적 임포트
import('./path/to/module')
  .then((module) =&gt; {
    // 모듈을 사용
    console.log(module);
  })
  .catch((error) =&gt; {
    // 에러 처리
    console.error('모듈을 불러오는 동안 에러 발생:', error);
  });
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 조건에 따라 모듈 동적으로 로드
const condition = true;

if (condition) {
  import('./path/to/someModule')
    .then((someModule) =&gt; {
      someModule.doSomething();
    })
    .catch((error) =&gt; {
      console.error('모듈을 불러오는 동안 에러 발생:', error);
    });
}
</code></pre></div></div>

<h3 id="모듈-로더-module-loader--내부에서-임포트-및-익스포트를-관리">모듈 로더 (<code class="language-plaintext highlighter-rouge">Module Loader</code>) : 내부에서 임포트 및 익스포트를 관리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[ImportEntries]</code>와 <code class="language-plaintext highlighter-rouge">[ExportEntries]</code>라는 내장 슬롯으로 관리
    <ol>
      <li>임포트 &amp; 파싱 (구문 분석) : 모듈 레코드, 모듈 맵을 생성</li>
      <li>인스턴스화 : 모듈의 바인딩 및 환경 레코드를 생성</li>
      <li>모듈 실행 : 모듈 코드를 실행, 모듈이 ‘평가됨’으로 표시</li>
    </ol>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/fbced0dc-3bf5-4cd8-83f1-c98863730512" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { a } from './A.js'

Name: 'a'
Type: identifier
Value: 100
Mutable: false
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d48c71cd-d17e-4267-93f8-41aff403005f" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/19645c89-cbc7-4c04-a114-99a01716f725" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/07c4ee10-d19f-44d9-8170-9df928164a5b" /></p>

<h3 id="npm-모듈-생성-및-업로드-httpswwwnpmjscom"><code class="language-plaintext highlighter-rouge">npm</code> 모듈 생성 및 업로드 (<a href="https://www.npmjs.com"><code class="language-plaintext highlighter-rouge">https://www.npmjs.com</code></a>)</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">npm</code> : <code class="language-plaintext highlighter-rouge">Node.js</code>의 패키지를 관리할 수 있는 도구</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Node.js</code>에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 <code class="language-plaintext highlighter-rouge">CLI</code> 제공</li>
    <li><code class="language-plaintext highlighter-rouge">npx</code> (<code class="language-plaintext highlighter-rouge">node package execute</code>)을 통해 패키지를 설치 및 실행</li>
    <li>국내에서는 패키지 중복 문제를 링크 방식으로 해결한 <code class="language-plaintext highlighter-rouge">yarn</code>을 많이 사용하는 추세</li>
  </ul>
</blockquote>

<ol>
  <li>패키지 이름 정하기 (<code class="language-plaintext highlighter-rouge">npm info &lt;pkg&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">npm init</code>으로 <code class="language-plaintext highlighter-rouge">package.json</code> 작성</li>
  <li>의존 관계가 있으면 <code class="language-plaintext highlighter-rouge">npm install</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm login</code> 후 배포 <code class="language-plaintext highlighter-rouge">npm publish --access public</code></li>
</ol>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[모듈 (Module) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것]]></summary></entry><entry><title type="html">[JS] 6. 배열 (Array) &amp;amp; 이터레이터 (Iterator)</title><link href="http://localhost:4000/js6/" rel="alternate" type="text/html" title="[JS] 6. 배열 (Array) &amp;amp; 이터레이터 (Iterator)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js6</id><content type="html" xml:base="http://localhost:4000/js6/"><![CDATA[<h2 id="배열-array--순서가-있는-데이터-집합">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 순서가 있는 데이터 집합</h2>

<ul>
  <li>배열의 각 요소 (<code class="language-plaintext highlighter-rouge">element</code>)인 프로퍼티 리터럴을 인덱스 (프로퍼티 키)로 접근</li>
  <li><code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가지며, 배열의 길이보다 큰 접근은 <code class="language-plaintext highlighter-rouge">undefined</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 조정해 배열 길이를 조절할 수 있음 (<code class="language-plaintext highlighter-rouge">-1 &lt; length &lt; 2^32</code>)</li>
    </ul>
  </li>
  <li>자바스크립트에서 배열은 비균질적 (<code class="language-plaintext highlighter-rouge">Nonhomogeneous</code>) : 고정 위치 및 크기를 가지지 않음
    <ul>
      <li>희소 배열 (<code class="language-plaintext highlighter-rouge">sparse array</code>) 자료 구조 : 검색에는 약하지만, 조작에는 우수!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // 3의 크기를 갖는 배열 생성
const arr1 = Array(3); // [ &lt;3 empty items&gt; ]
const arr2 = new Array(3); // [ &lt;3 empty items&gt; ]
const arr3 = [,,,]; // [ &lt;3 empty items&gt; ]

// 3의 크기를 갖고 1로 채워진 배열 생성
const arr4 = Array(3).fill(1); // [ 1,1,1 ]

// 3의 크기를 갖고 인덱스 1부터 1이 존재하는 배열 생성
const arr5 = Array(3).fill(1, 1); // [ &lt;1 empty item&gt;, 1, 1 ]

// 3의 크기를 갖고 인덱스 1 이상 2 미만에 1이 존재하는 배열 생성
const arr6 = Array(3).fill(1, 0, 2); // [ &lt;1 empty item&gt;, 1, &lt;1 empty item&gt; ]

// arr2를 복제한 유사 배열 객체 생성
const arr7 = Array.from(arr2); // [ undefined, undefined, undefined ]

// 3의 크기를 갖는 유사 배열 객체 생성
const arr8 = Array.from(Array(3)); // [ undefined, undefined, undefined ]

// 3의 크기를 갖고 1,2,3이 존재하는 유사 배열 객체 생성
const arr9 = Array.from(Array(3), (_, i)  =&gt; i + 1); // [ 1, 2, 3 ]

// 3의 크기를 갖고 1,2,3이 존재하는 유사 배열 객체 생성
const arr10 = Array.from(Array(3).keys()); // [ 1, 2, 3 ]

// 3의 크기를 갖고 1로 채워진 배열 생성
const arr11 = [];
arr11.push(1); // [ 1 ]
arr11.push(1); // [ 1, 1 ]
arr11.push(1); // [ 1, 1, 1 ]

// 스택 배열
const stack = [];
stack.push(1);
stack.push(2);
stack.push(3);
stack.pop();

// 큐 배열
const queue = [];
queue.push(1);
queue.push(2);
queue.push(3);
queue.shift();

// 스택 배열, 큐 배열 초기화
stack.length = 0;
queue.length = 0;

// 배열 검색
const arr12 = [ 3, 7, 3, 9, 2];
arr12.indexOf(3);  // 0
arr.lastIndexOf(3); // 2
arr.includes(3); // true

const arr13 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 2 } ];
const idx = arr13.findIndex(item =&gt; item.id === 2); // 1

// 배열 루프
arr13.forEach(( arr, idx ) =&gt; console.log(arr.id));

// 배열 요소 합치기
const arr14 = arr1.concat(arr2);
const arr15 = [...arr1, ...arr2];

// 배열 평탄화
const arr16 = [ 1, 2, [3] ].flat();
console.log(arr16); // 1, 2, 3

const arr17 = [ 1, 2, [[3]] ].flat();
console.log(arr17); // 1, 2, [3]

const arr18 = [ 1, 2, [[3]] ].flat(2);
console.log(arr18); // 1, 2, 3
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = [1, 2, 3, 4, 5];

// ex1) [2,3]을 추출
const ex1 = arr.slice(1,3);

console.log(`\n#1`);
console.log(ex1);

// ex2) [3]부터 모두 다 추출
const ex2 = arr.slice(arr.indexOf(3));

console.log(`\n#2`);
console.log(ex2);

// ex3) [2,3,4] 제거하기
arr.splice(1, 3)

console.log(`\n#3`);
console.log(arr);

// ex4) 복원하기
arr.splice(1, 0, 2,3,4)

console.log(`\n#4`);
console.log(arr);

// ex5) [3] 부터 끝까지 제거하기
arr.splice(arr.indexOf(3))

console.log(`\n#5`);
console.log(arr);

// ex6) 복원하기
arr.splice(2, 0, 3,4,5)

console.log(`\n#6`);
console.log(arr);

// ex7) [1,2, 'X', 'Y', 'Z', 4, 5] 만들기
arr.splice(2, 1)
arr.splice(2, 0, 'X', 'Y', 'Z')

console.log(`\n#7`);
console.log(arr);

// ex8) 위 7번 문제를 splice를 사용하지 말고 작성하시오.
arr.splice(2, 3)
const ex8 = [...arr.slice(0, 2), 'X', 'Y', 'Z' , ...arr.slice(2)]

console.log(`\n#8`);
console.log(ex8);
</code></pre></div></div>

<blockquote>
  <p>리스트 (<code class="language-plaintext highlighter-rouge">List</code>) : 중첩 참조 <code class="language-plaintext highlighter-rouge">link</code>를 가진 객체</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const array = [1, 2, 3, …]; // 배열

const list = { // 리스트
    value: 1,
    rest: {   // 메모리 주소 (link)
        value: 2,
        rest: {
            value: 3,
            rest: {...}
        }
    }
}
</code></pre></div>  </div>

  <p>→ 자비스크립트의 <code class="language-plaintext highlighter-rouge">Array</code>는 <code class="language-plaintext highlighter-rouge">List</code> : <code class="language-plaintext highlighter-rouge">List</code>는 검색은 느리지만, 조작하는 것은 쉽다!</p>
</blockquote>

<h3 id="유사-배열-객체-array-like-object--배열과-유사한-형태를-갖지만-배열은-아닌-객체">유사 배열 객체 (<code class="language-plaintext highlighter-rouge">Array-like Object</code>) : 배열과 유사한 형태를 갖지만, 배열은 아닌 객체</h3>

<ul>
  <li>문자열, <code class="language-plaintext highlighter-rouge">Object</code>, <code class="language-plaintext highlighter-rouge">arguments</code>, <code class="language-plaintext highlighter-rouge">NodeList</code>, <code class="language-plaintext highlighter-rouge">JQuery</code> 객체 등 컬렉션 (<code class="language-plaintext highlighter-rouge">Collection</code>) 형태의 객체 데이터</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array.isArray(x) || x instanceof Array : false
</code></pre></div></div>

<ul>
  <li>인덱스는 <code class="language-plaintext highlighter-rouge">0</code>부터 시작해야 하며, 반드시 <code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가짐</li>
  <li><code class="language-plaintext highlighter-rouge">for ~ of</code> 등을 통해 순회 가능한 <code class="language-plaintext highlighter-rouge">iterable</code>한 객체 (<code class="language-plaintext highlighter-rouge">cf</code>. <code class="language-plaintext highlighter-rouge">iterator</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">forEach</code>를 제외한 나머지 유사 배열 객체는 <code class="language-plaintext highlighter-rouge">Array</code> 메소드를 사용할 수 없음</li>
  <li><code class="language-plaintext highlighter-rouge">Array.from()</code>으로 배열로 만들 수 있음</li>
</ul>

<h2 id="이터레이터-iterator--next-함수-호출-시-계속-그-다음-값을-반환하는-객체">이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>) : <code class="language-plaintext highlighter-rouge">next()</code> 함수 호출 시 계속 그 다음 값을 반환하는 객체</h2>

<ul>
  <li>현재 어디에 있고, 다음엔 어디로 가는지 아는 포인터 (<code class="language-plaintext highlighter-rouge">Pointer</code>)
    <ul>
      <li>이터러블 (<code class="language-plaintext highlighter-rouge">Iterable</code>) 프로토콜 : <code class="language-plaintext highlighter-rouge">Symbol.iterator</code>를 구현 및 상속한 메소드를 호출하면, 이터레이터 반환</li>
      <li>이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>) 프로토콜 : <code class="language-plaintext highlighter-rouge">next()</code>를 호출하면, <code class="language-plaintext highlighter-rouge">value()</code>, <code class="language-plaintext highlighter-rouge">done()</code>을 가진 이터레이터 리터럴 반환</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ItDog1 extends Dog {
  [Symbol.iterator]() {
    return this.name.split(', ').values();
  }
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const itDog1 = new ItDog1('Toby, Max, Sam');
console.log([...itDog1]);

class ItDog2 extends Dog {
  [Symbol.iterator]() {
    let idx = 0;
    const names = this.name.split(/,\s?/);
    return {
      next() {
        return { value: names[idx++],
                 done: idx &gt; names.length };
      }
    };
  }
} 
const itDog2 = new ItDog2('Toby, Max, Sam');
for (const d of itDog2) console.log(d);
const iter = itDog2[Symbol.iterator]();
console.log(iter.next());  // 4회 반복
</code></pre></div></div>

<h3 id="제너레이터-generator--제너레이터-함수-function의-실행을-제어하는-함수">제너레이터 (<code class="language-plaintext highlighter-rouge">Generator</code>) : 제너레이터 함수 <code class="language-plaintext highlighter-rouge">function*()</code>의 실행을 제어하는 함수</h3>

<ul>
  <li>실행 과정에서 <code class="language-plaintext highlighter-rouge">yield</code>를 만나면, 호출자 (<code class="language-plaintext highlighter-rouge">caller</code>)에게 정보 반환과 제어권을 넘김
    <ul>
      <li>제너레이터를 호출하면 이터레이터를 얻음 → 실행이 한번에 끝나지 않는다!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function* route() { // function* ~ yield → iterator를 return하고, 일시정지(pause)한 상태로 시작!
  const start = yield "출발 역은?";  // yield가 있으므로 caller에게 제어권을 넘긴다.
  const end = yield "도착 역은?";

  return `${start}역에서 출발하여 ${end}역에 도착합니다.`;
}

const caller = route();
caller.next();
caller.next('을지로입구');
caller.next('강남');
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[배열 (Array) : 순서가 있는 데이터 집합]]></summary></entry><entry><title type="html">[JS] 5. 함수 (Function)</title><link href="http://localhost:4000/js5/" rel="alternate" type="text/html" title="[JS] 5. 함수 (Function)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js5</id><content type="html" xml:base="http://localhost:4000/js5/"><![CDATA[<h2 id="함수-function--일련의-과정을-코드-블록으로-감싸-하나의-단위로-정의한-것">함수 (<code class="language-plaintext highlighter-rouge">Function</code>) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c6d16c9b-7b9c-4340-bbab-88b15bfd53db" width="80%" /></p>

<ul>
  <li>자바스크립트의 함수는 객체 타입의 값 → 함수 또한 함수 리터럴 (<code class="language-plaintext highlighter-rouge">functional literal</code>)로 생성할 수 있음</li>
  <li>일반 객체와 달리, 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 가짐</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/05176279-d1d8-4756-8bb3-5186474aa123" width="80%" /></p>

<h3 id="함수-정의-function-definition--함수-호출-이전에-인수를-전달받을-매개변수-문-반환값을-지정">함수 정의 (<code class="language-plaintext highlighter-rouge">Function Definition</code>) : 함수 호출 이전에 인수를 전달받을 매개변수, 문, 반환값을 지정</h3>

<blockquote>
  <p>함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되므로, 함수는 정의된다고 할 수 있다.</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0b6c992d-5608-47a8-b2bc-0af11c3c9b24" width="80%" /></p>

<h4 id="함수-선언문-function-declaration">함수 선언문 (<code class="language-plaintext highlighter-rouge">Function Declaration</code>)</h4>

<ul>
  <li>함수 선언문은 함수 리터럴과 형태가 동일</li>
  <li>함수 리터럴은 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음</li>
</ul>

<h4 id="함수-표현식-function-expression">함수 표현식 (<code class="language-plaintext highlighter-rouge">Function Expression</code>)</h4>

<h4 id="function-생성자-함수"><code class="language-plaintext highlighter-rouge">Function</code> 생성자 함수</h4>

<h4 id="화살표-함수-arrow-function">화살표 함수 (<code class="language-plaintext highlighter-rouge">Arrow Function</code>)</h4>

<h3 id="함수-매개변수-argument--값-parameter--변수">함수 매개변수 (<code class="language-plaintext highlighter-rouge">Argument</code> : 값, <code class="language-plaintext highlighter-rouge">Parameter</code> : 변수)</h3>

<h3 id="즉시-호출-함수-iife">즉시 호출 함수 <code class="language-plaintext highlighter-rouge">IIFE</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function() { ... })();
</code></pre></div></div>

<h3 id="함수의-호출-방식과-this">함수의 호출 방식과 <code class="language-plaintext highlighter-rouge">this</code></h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b706b06f-966b-458a-a6f5-22131c6681ff" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code>를 바인딩하는 방법 : <code class="language-plaintext highlighter-rouge">call</code>, <code class="language-plaintext highlighter-rouge">apply</code>, <code class="language-plaintext highlighter-rouge">bind</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(id) {
  console.log(this, id, this.name);
}

const obj = { name: 'Kim' };

// bind
const bf1 = func.bind(obj);
bf1(1, '서울');

// apply
func.apply(obj, [ 2, '부산' ]);

// call
func.call(obj, 3, '대구');
</code></pre></div></div>

<h2 id="순수-함수-pure-function--함수로서의-함수">순수 함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>) : 함수로서의 함수</h2>

<ul>
  <li>입력이 같으면 결과도 같다! → <code class="language-plaintext highlighter-rouge">Side Effect</code>가 없다. 즉, 외부의 값을 변경시키지 않아야 한다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const weeks = ['일', '월', '화', '수', '목', '금', '토'];

const getWeekName = function(weekNo) {
  return `${weeks[weekNo]}요일`;
};

const day = new Date().getDay();
console.log(`오늘은 ${getWeekName(day)}입니다!`);
</code></pre></div></div>

<p>→ 외부에 값을 두지 않고 내부에 값을 두는 클로저를 활용해야 한다!</p>

<h2 id="고차-함수-higher-order-function--다른-함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 다른 함수를 인자로 받거나 함수를 반환하는 함수</h2>

<blockquote>
  <p>자바스크립트에서의 함수는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class Citizen</code>)</p>

  <ol>
    <li>변수에 할당 (<code class="language-plaintext highlighter-rouge">Assignment</code>)할 수 있다.</li>
    <li>다른 변수의 인자 (<code class="language-plaintext highlighter-rouge">Argument</code>)로 전달될 수 있다.</li>
    <li>다른 함수의 결과로 반환 (<code class="language-plaintext highlighter-rouge">Return</code>)될 수 있다.</li>
  </ol>

  <p>→ 함수가 일급 객체이므로, 함수를 데이터와 유사하게 다룰 수 있어 ‘고차 함수’로서 활용될 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const double = (n) =&gt; { return n * 2; };
console.log(double(4)); // 4 * 2 = 8
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const adder = added =&gt; num =&gt; num + added;
console.log(adder(5)(3)); // 5 + 3 = 8
</code></pre></div></div>

<ul>
  <li>함수의 형태로 반환되는 함수를 모두 고차 함수라 정의할 수 있다.
    <ul>
      <li>함수는 일급 객체 → 일급 객체로서의 함수는 고차 함수로 활용 가능</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>함수를 리턴하는 함수를 커리 함수 (<code class="language-plaintext highlighter-rouge">Curry Function</code>)라고 부르던데…?</p>

  <ul>
    <li>커리 함수라는 용어로, 고차 함수를 ‘함수를 인자로 받는 함수’에만 한정해 사용할 수 있음
      <ul>
        <li>엄밀히 말하면, 고차 함수가 커리 함수를 포함하는 개념</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Array.map()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 호출한 다음, 그 결과를 새로운 배열로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].map((num) =&gt; { return num * num; })); // [ 1, 4, 9, 16, 25 ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.filter()</code> 함수 : 배열의 요소 중에 주어진 조건을 만족하는 요소만을 추출하여 새로운 배열로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].filter((num) =&gt; { return num % 2 === 0 })); // [ 2, 4 ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.reduce()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 누적하여 하나의 값으로 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].reduce((accumulator, currentValue)
  =&gt; { return accumulator + currentValue;}, 0)); // 15
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.forEach()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행 (반환값이 존재하지 않음)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5].forEach((num) =&gt; { console.log(num); }); // 1부터 5까지 순서대로 출력
</code></pre></div></div>

<h2 id="콜백-함수-callback-function--매개변수를-통해-다른-함수의-내부로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) : 매개변수를 통해 다른 함수의 내부로 전달되는 함수</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; { console.log(`출력`); }, 1);
</code></pre></div></div>

<ul>
  <li>고차 함수의 인자로 전달되어, 특정 동작을 수행하거나 완료 시에 호출
    <ul>
      <li>콜백 함수를 전달받은 고차 함수는 함수 내부에서 이 콜백 함수르 호출 (<code class="language-plaintext highlighter-rouge">Invoke</code>)할 수 잇음</li>
      <li>부르는 조건에 따라서 콜백 함수의 실행 조건을 결정할 수 있음</li>
    </ul>
  </li>
  <li>콜백 함수를 언제 호출하는지에 따라, 자바스크립트 엔진이 콜백 함수의 호출 시점을 결정
    <ul>
      <li>함수가 실행되면 콜 스택에 함수를 넣었다가, 함수에서 반환이 일어날 때 가장 위쪽에서 해당 함수를 꺼냄</li>
      <li>이벤트 루프는 콜 스택과 테스크 큐를 주시하고 있다가, 스택이 비어 있으면 큐의 첫번째 콜백을 스택에 쌓아 실행</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>매개변수를 통해 다른 함수로 전달되는 함수는 콜백 함수, 매개변수를 통해 콜백 함수를 전달받는 함수는 고차 함수!</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// printString : 두개의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const printString = (callbackHof, callback_only, str) =&gt; {
    str +=' 반이고';
    callbackHof( callback_only, str ); 
}

// concatFirst : printString의 매개변수로 활용되는 콜백함수이면서,
// 하나의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const concatFirst = (callback_only, str) =&gt; {
  callback_only(str);
}

// concatAgain : concatFirst의 매개변수로 활용되는 콜백함수
const concatAgain = (str) =&gt; {
  str += ' 가만히 있으면 반이라도 간다';
  console.log(str);
}

printString(concatFirst, concatAgain, '시작은'); // 시작은 반이고 가만히 있으면 반이라도 간다
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[함수 (Function) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것]]></summary></entry><entry><title type="html">[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)</title><link href="http://localhost:4000/js4/" rel="alternate" type="text/html" title="[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/js4</id><content type="html" xml:base="http://localhost:4000/js4/"><![CDATA[<h2 id="스코프-scope--변수에-접근할-수-있는-범위">스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수에 접근할 수 있는 범위</h2>

<ul>
  <li>변수가 선언되었을 때, 선언 위치에 의해 해당 변수에 접근할 수 있는 코드의 영역이 결정
    <ul>
      <li>자바스크립트 엔진은 스코프를 통해 참조 대상 식별자를 찾아 변수를 식별</li>
    </ul>
  </li>
</ul>

<h3 id="전역-스코프-global-level-scope--코드-어디에서나-참조-가능">전역 스코프 (<code class="language-plaintext highlighter-rouge">Global-level Scope</code>) → 코드 어디에서나 참조 가능</h3>

<ul>
  <li>전역에 선언된 전역 변수 (<code class="language-plaintext highlighter-rouge">Global variable</code>) 는 전역 객체 (<code class="language-plaintext highlighter-rouge">Global Object</code>)의 프로퍼티</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var global = 'global';

function main() {
  var local = 'local';
  console.log(global);
  console.log(local);
}

console.log(global);
console.log(local); // Uncaught ReferenceError: local is not defined
</code></pre></div></div>

<h3 id="함수-스코프-function-level-scope--함수-자신과-하위-함수에서만-참조-가능">함수 스코프 (<code class="language-plaintext highlighter-rouge">Function-level Scope</code>) → 함수 자신과 하위 함수에서만 참조 가능</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function () {
  var local = 'local';
  console.log(local);
})();
</code></pre></div></div>

<h3 id="블록-스코프-block-level-scope--블록-내에서만-참조-가능">블록 스코프 (<code class="language-plaintext highlighter-rouge">Block-level Scope</code>) → 블록 내에서만 참조 가능</h3>

<h3 id="모듈-스코프-module-level-scope-">모듈 스코프 (<code class="language-plaintext highlighter-rouge">Module-level Scope</code>) →</h3>

<h3 id="렉시컬-스코프-lexical-level-scope">렉시컬 스코프 (<code class="language-plaintext highlighter-rouge">Lexical-level Scope</code>)</h3>

<h3 id="암묵적-전역-implicit-global">암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)</h3>

<h2 id="실행-컨텍스트-execution-context--실행할-코드에-제공할-환경-정보들을-모아놓은-객체">실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;

function f1(x, y) {
  var gg = 11;   let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('first');
  { 
    const xx = 99;
    let lll = 0;
    f2('nest-first');
    var zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  function f2(t, u) { console.log(t, 'inner', xx, zz); }
  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); }
  var zz = 800;
  f2('second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f1(1,2);   console.log(kk, yy);

f2('third');
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/40dca0b0-9e4b-44d6-a36c-83aee24fc2e3" /></p>

<p><code class="language-plaintext highlighter-rouge">(1)</code> 전역 코드 평가 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg;  let bb;
function f1(x, y) { ... } // Function Object
function f2(g) { ... }    // Function Object
let xx;
var kk;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(2)</code> 전역 코드 실행 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;
let xx = 9;
if (gg &gt; 0) { ... }
f1(1,2);   console.log(kk, yy);
f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(3)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">if</code>문 코드 블록 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (gg &gt; 0) { // var gg = 1;
  var kk = 33; var yy = 9;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(4)</code> 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  var gg;   let bb;
  { ... }
  // function f2(t, u) { ... } // Function Object
  function f2(t, u, v) { ... } // Function Object
  var zz;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(5)</code> 함수 코드 평가 단계 내부의 블록 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">{ ... }</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  { 
    const xx;
    let lll;
    var zz;
    function f2(t) { ... } // Function Object
  }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(6)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length); // f1&gt; 11, 22, undefined, f2, 3
  f2('first');
  { ... }
  zz = 800;
  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(7)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  f2('first');

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(8)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  f2('first'); // first inner2 9 undefined

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(9)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  { 
    xx = 99;
    lll = 0;
    f2('nest-first');
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(10)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;

  { 
    xx = 99;
    lll = 0;
    f2('nest-first'); // nest-first nested 99 undefined 0
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(11)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }

  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(12)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  f2('second'); // second nested 99 800 0
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(13)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">console.log</code> 문 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1;  bb = 2;

console.log(kk, yy); // 33 9
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(14)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 평가</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(15)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third'); // third global f2&gt; 1 2 9 33
</code></pre></div></div>

<blockquote>
  <p><b>블록 코드 평가 및 실행</b></p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">Global</code>/<code class="language-plaintext highlighter-rouge">Function</code> 평가할 때 <code class="language-plaintext highlighter-rouge">Block scope</code>를 만나면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 생성한다.<br />(별도의 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>를 생성하지 않고 독립적인 <code class="language-plaintext highlighter-rouge">Lexical Environment</code>만을 생성한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block code</code>를 평가하여 이 <code class="language-plaintext highlighter-rouge">Block</code>에 대한 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>를 생성한다.</li>
    <li><code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">let</code>은 <code class="language-plaintext highlighter-rouge">notInitializedYet</code> 상태로 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 등록되고, <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code> 선언식 등은 부모 <code class="language-plaintext highlighter-rouge">Function scope</code>의 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>에 <code class="language-plaintext highlighter-rouge">hoisting</code>한다.<br />(이때 <code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>가 아니라 <code class="language-plaintext highlighter-rouge">var</code>와 같이 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 끝나면, 평가 종료 후 상위 <code class="language-plaintext highlighter-rouge">scope code</code>를 계속 평가한다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 실행되면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 만들고, 부모 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 가져온다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code> 내의 <code class="language-plaintext highlighter-rouge">Function</code> 선언식은 무조건 <code class="language-plaintext highlighter-rouge">Block</code> 최상단에 <code class="language-plaintext highlighter-rouge">hoisting</code>되어 있으므로 먼저 실행한다.<br />(이 시점에 상위 <code class="language-plaintext highlighter-rouge">function-scope</code>에 함수를 정의해, <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>으로 인정된다!)</li>
    <li>그 외의 코드 (할당문 및 다른 함수 호출)를 한 줄씩 실행된다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>의 실행이 끝나면, <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 다시 부모로 돌려준다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>은 조건에 따라 실행 여부가 결정된다. 평가 시 블럭 내의 <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">undefined</code>로 <code class="language-plaintext highlighter-rouge">hoisting</code>되고, 조건이 만족하여 호출 및 실행될 때에만 <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>와 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>를 만들고 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>로 정의된다.</li>
  </ol>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a69498fb-6f39-413d-8a75-ef547e4ba4b5" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1271743-b805-4040-9743-39e7b2cd5bda" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5272ac93-d18b-4112-a45f-46d657839a3d" /></p>

<h2 id="엄격-모드-strict-mode--자바스크립트가-묵인한-에러를-발생시켜-엄격한-오류-검사를-적용">엄격 모드 (<code class="language-plaintext highlighter-rouge">Strict Mode</code>) : 자바스크립트가 묵인한 에러를 발생시켜 엄격한 오류 검사를 적용</h2>

<ul>
  <li>선언하지 않은 식별자는 접근할 수 없음</li>
  <li>암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)은 허용하지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">Delete</code>로 선언된 변수, 함수, 매개변수를 삭제할 수 없음</li>
  <li>블록 내에서의 함수는 블록 스코프 (블록 내 함수는 볼록의 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 존재)</li>
  <li>함수 내에서 매개변수의 이름이 동일해선 안됨</li>
  <li><code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">Infinite</code> 등의 전역 프로퍼티에 값을 할당해선 안됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'use strict';


var gg = 1;
let bb = 2;

function f1(x, y) {
  var gg = 11;
  let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('* first');
  {
    const xx = 99;
    f2('* nest-first');
    var zz = 88;
    function f2(t) {
      console.log(t, '`nested`', xx, zz);
    }
  }
  function f2(t, u) {
    console.log(t, '`inner`', xx, zz);
  }
  function f2(t, u, v) {
    console.log(t, '`inner2`', xx, zz);
  }
  var zz = 800;
  console.log('gg:', gg);
  f2('* second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}
let xx = 9;
if (gg &gt; 0) {
  var kk = 33;
  const yy = 9;
}
f1(1, 2); 
console.log('kkkkk&gt;&gt;', kk);
f2('* third');
</code></pre></div></div>

<h2 id="클로저-closure--함수가-특정-스코프에-접근할-수-있도록-의도적으로-그-스코프에서-정의한-것">클로저 (<code class="language-plaintext highlighter-rouge">Closure</code>) : 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의한 것</h2>

<ul>
  <li>상위 스코프의 식별자를 참조하는 하위 스코프 (함수, 메소드)가 외부에서 참조되어 상위 스코프보다 오래 살아있는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let user;
{
  const private = {
    id: 1,
    name: 'John'
  }
  user = private;
}

user.age = 30;

console.log(user); // { id: 1, name: 'John', age: 30 }
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(x) {
  let clo = function (y) {
    console.log(y);
  }

  return clo(x);
}

func('a'); // a
</code></pre></div></div>

<blockquote>
  <p>클로저를 활용하여 외부변수로 인해 오염될 수 있는 비순수함수 (<code class="language-plaintext highlighter-rouge">Impure Function</code>)를, 함수 내부로 전달된 인수에게만 의존하여 반환값을 만드는 순수함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>)로 바꿀 수 있다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 비순수함수
let cnt1 = 0;

function func1(x) {
  cnt1 += 1;
  return cnt1;
}

console.log(func1()); // 1
console.log(func1()); // 2
console.log(func1()); // 3

// → 순수함수
function func2() {
  let cnt2 = 0;
  return function temp() {
    cnt2 += 1;
    return cnt2;
  };
}

const counter1 = func2();
const counter2 = func2();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[스코프 (Scope) : 변수에 접근할 수 있는 범위]]></summary></entry><entry><title type="html">고차 함수, 콜백 함수 (2024.01.31)</title><link href="http://localhost:4000/digital_hanaro_5.md/" rel="alternate" type="text/html" title="고차 함수, 콜백 함수 (2024.01.31)" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-01-31T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_5.md</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_5.md/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 5일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부한-내용">공부한 내용</h2>

<p>고차함수, 콜백함수의 개념을 정리해보고 이 둘의 차이점에 대해 짚어보고자 하였다.</p>

<h3 id="고차-함수-higher-order-function--다른-함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 다른 함수를 인자로 받거나 함수를 반환하는 함수</h3>

<blockquote>
  <p>자바스크립트에서의 함수는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class Citizen</code>)</p>

  <ol>
    <li>변수에 할당 (<code class="language-plaintext highlighter-rouge">Assignment</code>)할 수 있다.</li>
    <li>다른 변수의 인자 (<code class="language-plaintext highlighter-rouge">Argument</code>)로 전달될 수 있다.</li>
    <li>다른 함수의 결과로 반환 (<code class="language-plaintext highlighter-rouge">Return</code>)될 수 있다.</li>
  </ol>

  <p>→ 함수가 일급 객체이므로, 함수를 데이터와 유사하게 다룰 수 있어 ‘고차 함수’로서 활용될 수 있다.</p>
</blockquote>

<ul>
  <li>함수의 형태로 반환되는 함수를 모두 고차 함수라 정의
    <ul>
      <li>함수는 일급 객체 → 일급 객체로서의 함수는 고차 함수로 활용 가능</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const double = (n) =&gt; { return n * 2; };
console.log(double(4)); // 4 * 2 = 8
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const adder = added =&gt; num =&gt; num + added;
console.log(adder(5)(3)); // 5 + 3 = 8
</code></pre></div></div>

<blockquote>
  <p>함수를 리턴하는 함수를 커리 함수 (<code class="language-plaintext highlighter-rouge">Curry Function</code>)라고 부르던데…?</p>

  <ul>
    <li>커리 함수라는 용어로, 고차 함수를 ‘함수를 인자로 받는 함수’에만 한정해 사용할 수 있음
      <ul>
        <li>엄밀히 말하면, 고차 함수가 커리 함수를 포함하는 개념</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="arraymap-함수--배열의-각-요소에-대해-주어진-함수를-호출한-다음-그-결과를-새로운-배열로-반환"><code class="language-plaintext highlighter-rouge">Array.map()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 호출한 다음, 그 결과를 새로운 배열로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].map((num) =&gt; { return num * num; })); // [ 1, 4, 9, 16, 25 ]
</code></pre></div></div>

<h4 id="arrayfilter-함수--배열의-요소-중에-주어진-조건을-만족하는-요소만을-추출하여-새로운-배열로-반환"><code class="language-plaintext highlighter-rouge">Array.filter()</code> 함수 : 배열의 요소 중에 주어진 조건을 만족하는 요소만을 추출하여 새로운 배열로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].filter((num) =&gt; { return num % 2 === 0 })); // [ 2, 4 ]
</code></pre></div></div>

<h4 id="arrayreduce-함수--배열의-각-요소에-대해-주어진-함수를-실행하고-그-결과를-누적하여-하나의-값으로-반환"><code class="language-plaintext highlighter-rouge">Array.reduce()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 누적하여 하나의 값으로 반환</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log([1, 2, 3, 4, 5].reduce((accumulator, currentValue) =&gt; { return accumulator + currentValue;}, 0)); // 15
</code></pre></div></div>

<h4 id="arrayforeach-함수--배열의-각-요소에-대해-주어진-함수를-실행-반환값이-존재하지-않음"><code class="language-plaintext highlighter-rouge">Array.forEach()</code> 함수 : 배열의 각 요소에 대해 주어진 함수를 실행 (반환값이 존재하지 않음)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5].forEach((num) =&gt; { console.log(num); }); // 1부터 5까지 순서대로 출력
</code></pre></div></div>

<h3 id="콜백-함수-callback-function--매개변수를-통해-다른-함수의-내부로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) : 매개변수를 통해 다른 함수의 내부로 전달되는 함수</h3>

<ul>
  <li>고차 함수의 인자로 전달되어, 특정 동작을 수행하거나 완료 시에 호출
    <ul>
      <li>콜백 함수를 전달받은 고차 함수는 함수 내부에서 이 콜백 함수르 호출 (<code class="language-plaintext highlighter-rouge">Invoke</code>)할 수 잇음</li>
      <li>부르는 조건에 따라서 콜백 함수의 실행 조건을 결정할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; { console.log(`출력`); }, 1);
</code></pre></div></div>

<ul>
  <li>매개변수를 통해 다른 함수의 내부로 전달되는 함수는 콜백 함수, 매개변수를 통해 콜백 함수를 전달받는 함수는 고차 함수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// printString : 두개의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const printString = (callbackHof, callback_only, str) =&gt; {
    str +=' 반이고';
    callbackHof( callback_only, str );
}

// concatFirst : printString의 매개변수로 활용되는 콜백함수이면서, 하나의 함수와 하나의 문장을 매개변수로 사용하는 고차함수
const concatFirst = (callback_only, str) =&gt; {
  callback_only(str);
}

// concatAgain : concatFirst의 매개변수로 활용되는 콜백함수
const concatAgain = (str) =&gt; {
  str += ' 가만히 있으면 반이라도 간다';
  console.log(str);
}

printString(concatFirst, concatAgain, '시작은'); // 시작은 반이고 가만히 있으면 반이라도 간다
</code></pre></div></div>

<blockquote>
  <p>콜백 함수를 언제 호출하는지에 따라, 자바스크립트 엔진이 콜백 함수의 호출 시점을 결정할 수 있다!</p>

  <ul>
    <li>함수가 실행되면, 콜 스택 (<code class="language-plaintext highlighter-rouge">Call Stack</code>)에 함수를 넣었다가 함수에서 반환이 일어날 때 가장 위쪽에서 해당 함수를 꺼낸다.</li>
    <li>이벤트 루프 (<code class="language-plaintext highlighter-rouge">Event Loop</code>)는 콜 스택과 테스크 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>)를 주시하고 있다가, 스택이 비어 있으면 큐의 첫번째 콜백을 스택에 쌓아 실행한다.</li>
  </ul>
</blockquote>

<blockquote>
  <p>참고</p>

  <ul>
    <li><a href="https://www.datoybi.com/callback-promise-async-await/">Steady-Dev, ‘Callback &amp; Promise &amp; async/await 톺아보기’</a></li>
    <li><a href="https://soldonii.tistory.com/119">soldonii, ‘200106(월) : 비동기, 고차함수, 일급객체, V8 엔진 등’</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 5일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[TIL] 2024년 02월 TIL</title><link href="http://localhost:4000/til2/" rel="alternate" type="text/html" title="[TIL] 2024년 02월 TIL" /><published>2024-01-31T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til2</id><content type="html" xml:base="http://localhost:4000/til2/"><![CDATA[<h2 id="february-2024--시간-관리의-중요성"><code class="language-plaintext highlighter-rouge">February, 2024</code> : 시간 관리의 중요성!</h2>

<p>앞서 2023년이 다사다난한 해라고 말하였는데, 2024년 01월은 그것보다 더 폭풍 같은 한달이었던 것 같다. 다른 것보다도 디지털하나路 2기에 합격하여 9시부터 6시까지 수업을 듣고, 또 6시부터 8시까지 자습하는 생활을 2주간 하다보니 이전보다 내 실력이 증진되는 것 같다는 느낌을 많이 받고 있다. 그렇지만 한달을 회고해보면 아쉬운 점 또한 있다. 1월 1일에 신년을 맞이하면서 내가 해야할 일을 크게 7개의 항목으로 정리하였던 적이 있는데, 어떤 항목은 잘 진행되고 있는데 또다른 어떤 항목은 아직 손도 못댄 부분도 있기 때문이다. 지속적으로 개발 관련 도서를 챕터를 나누어 공부하거나 협업 프로젝트를 진행하고자 기획서를 작성하려고 노력하고 있는데, 아무래도 주중에 수업 및 스터디가 있어서 주말에 한정된 시간을 쓰다보니 생각만큼 진행이 되지 않는 부분이 있다. 그래서 결국 내게 지금 필요한 것은 <b>시간을 효율적으로 관리하여 이를 성과로 이끌어내는 것</b>이라고 생각이 든다. 당장 다음달 초에 정보처리기사와 <code class="language-plaintext highlighter-rouge">SQLD</code> 필기가 예정되어 있는 만큼, 이번 한 달 역시 모든 것에 열심히 임하고자 한다.</p>

<h3 id="2024년-02월-01일-목">2024년 02월 01일 (목)</h3>

<ul>
  <li>디지털하나路 및 모던 자바스크립트 <code class="language-plaintext highlighter-rouge">Deep Dive</code>에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>오늘은 자바스크립트의 객체지향 프로그래밍에 대해 공부하는 시간을 가졌다. 흔히 자바스크립트는 프로토타입 기반 객체지향 언어로 정의되는데, 각각의 프로퍼티들은 프로토타입 체인을 통해 내부 참조를 따라 상위 프로토타입을 순차적으로 검색하는 구조를 가진다. 아무래도 <code class="language-plaintext highlighter-rouge">C++</code>, <code class="language-plaintext highlighter-rouge">Java</code>에도 존재하는 개념이라 금방 이해가 되서 클래스, 오버라이딩, 상속을 자바스크립트에 적용할 수 있었던 것 같다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-02일-금">2024년 02월 02일 (금)</h3>

<ul>
  <li>디지털하나路 및 모던 자바스크립트 <code class="language-plaintext highlighter-rouge">Deep Dive</code>에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>오늘은 자바스크립트의 배열에 대해 공부하는 시간을 가졌다. 어제처럼 배열도 다른 언어에 존재해서 금방 적용해 볼 수 있었는데, 배열과 유사 배열 객체의 차이점이 잘 이해가 되지 않아 코드를 작성하는 데에 애를 먹었다. 그렇지만 <code class="language-plaintext highlighter-rouge">length</code> 프로퍼티를 가지면서 <code class="language-plaintext highlighter-rouge">iterable</code>한 객체들의 구조가 배열과 유사해서 유사 배열 객체라 분류하지만, 배열과는 프로토타입이 달라 <code class="language-plaintext highlighter-rouge">Array</code>가 제공하는 메소드를 사용하지 못한다고 내 나름대로 정리해보니 이후에는 비교적 수월하게 코드를 작성할 수 있었다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-03일-토">2024년 02월 03일 (토)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서의 기능 명세서를 작성하고 있다.
    <ul>
      <li>이전에 협업하기로 한 분과 만나기로 한 날짜를 착각해서 (…) 하루가 생겼는데, <code class="language-plaintext highlighter-rouge">MSA</code>나 이벤트 드리븐으로 프로젝트를 진행하는 것은 처음이라 아직 설계 관련 내용에 미완성된 부분이 많아 우선 소개 및 기획에 해당하는 부분을 전달드리고 작성중인 설계에 해당하는 부분을 전반적으로 검토하는 방향으로 이야기가 진행되었다. 그래도 기능 명세를 최대한 할 수 있는 부분까지 작성하면서, 구현 과정에 들어가기 앞서 진행할 작업들을 진행하고자 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-04일-일">2024년 02월 04일 (일)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 프로젝트를 위한 도커 레지스트리 서버 및 <code class="language-plaintext highlighter-rouge">UI</code> 컨테이너를 생성하였다.
    <ul>
      <li>그동안 <code class="language-plaintext highlighter-rouge">vocawik</code> 프로젝트에서 활용될 이미지를 정리하고 구현 과정에서 생성된 이미지를 관리할 수 있는 방안에 대해 고심하고 있었는데, 도커 교과서를 통해 도커 레지스트리 서버에 대해 알게 되었다. 그래서 우선 이를 로컬 환경에 구축해본 다음에, 어느 정도 프로젝트가 진행되면 외부 서버에 마이그레이션할 계획으로 도커 컴포즈를 통해 컨테이너들을 구현하였다. (이후에 작성된 도커 컴포즈 파일로 외부 서버에서도 적용하긴 하였는데, 외부에서 도커 레지스트리로 접속하는 것이 잘 작동하지 않아 보류하기로 하였다. 추가로 여러 기술 블로그에서 도커 레지스트리와 비슷한 기능을 지원하는 <code class="language-plaintext highlighter-rouge">Harbor</code>을 적용한 것을 알게 되었는데, 일단은 프로젝트의 빠른 진행을 위해서 도커 레지스트리를 이용하다가, 마이그레이션할 필요성이 있다고 느낄 때 이를 적용해볼까 한다.)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서와 관련한 내용을 바탕으로 <code class="language-plaintext highlighter-rouge">vocawik</code> <a href="https://pocj8ur4in.github.io/vocawik1/">프로젝트 소개</a> 및 <a href="https://pocj8ur4in.github.io/vocawik2/">프로젝트 설계</a>에 대한 포스트를 작성하였다.
    <ul>
      <li>오늘 프로젝트 기획 및 설계에 대해 검토받는 시간을 가졌는데, 기능 명세서만이 아닌 프로젝트 목표 정의나 아키텍처 구조도 등과 같은 다른 설계 자료 또한 작성할 필요성이 있다는 피드백을 받았다. 그래서 원래는 하나로 통합되어 있던 소개 및 기획과 설계에 관련된 부분을 나누고, 후자를 작성하는 데에 집중하기로 하였다. 추가로 도커 레지스트리 서버 말고도 프로젝트 구현에 필요한 사항들을 검토하는 시간을 가졌는데, 이전에 작성한 스프링 이니셜라이저와 관련된 스크립트를 보다 더 발전시켜서, 아예 템플릿 프로젝트를 만들면 어떨까 하는 생각을 하게 되었다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-05일-월">2024년 02월 05일 (월)</h3>

<ul>
  <li>디지털하나路 및 모던 자바스크립트 <code class="language-plaintext highlighter-rouge">Deep Dive</code>에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>오늘은 자바스크립트의 꽃이라고 할 수 있는 비동기 처리에 대해 학습하였다. 나 같은 경우에는 <code class="language-plaintext highlighter-rouge">async</code>나 <code class="language-plaintext highlighter-rouge">await</code>를 활용하여 자바스크립트 함수를 구현해본 경험이 있었는데, 프로미스는 이번에 처음 접해서 이해하고 구현하는 데에 조금 애를 먹었다. (사실 프로미스를 쉽게 사용할 수 있도록 나온 것이 <code class="language-plaintext highlighter-rouge">async</code>나 <code class="language-plaintext highlighter-rouge">await</code>이므로, 나만 어려운 게 아니라는 데에 안도하긴 했는데… 과제로 나온 것이 이 세개를 골고루 활용해 구현하는 거라;;)</li>
    </ul>
  </li>
  <li>디지털하나路 스터디 6일차 주제에 대해 스터디 팀원과 이야기를 나누고, 서로 자유롭게 의견을 교류하는 시간을 가졌다.
    <ul>
      <li>오늘은 자바스크립트에서 활용된 프록시에 대해 다루었다. 사실 프록시 자체보다는 프록시가 활용되는 부분에 관심이 있어서 프록시 패턴이나 프록시 객체는 간단히 정리한 다음에 프록시를 응용한 사례인 캐싱, 유효성 검사기, 로거를 직접 구현해보는 데에 중점을 두었다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-06일-화">2024년 02월 06일 (화)</h3>

<ul>
  <li>디지털하나路 및 모던 자바스크립트 <code class="language-plaintext highlighter-rouge">Deep Dive</code>에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>오늘은 브라우저에 직접 <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>, 자바스크립트를 활용하여 구성 요소를 만들어 보는 시간을 가졌다. 아래의 내용은 해당 시간에서 테이블을 구현해본 연습 문제이다. 오늘을 끝으로 자바스크립트 수업은 마무리를 지었지만, 아직 자바스크립트 시리즈 내의 게시글들은 전반적인 틀만 잡혀있고 군데군데 부족한 부분들이 많다고 생각한다. 그래서 추후에 도서를 공부한 내용을 지속적으로 더해나가 더 완성도 있는 글을 작성할 계획이다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const users = [
    { id: 1, name: '홍길동', tel: '01088889991', addr: '서울' },
    { id: 2, name: '김길동', tel: '01088889992', addr: '부산' },
    { id: 3, name: '이길동', tel: '01088889993', addr: '서울' },
    { id: 4, name: '박길동', tel: '01088889994', addr: '서울' },
    { id: 5, name: '오길동', tel: '01088889995', addr: '서울' },
    { id: 6, name: '박길동', tel: '01088889996', addr: '부산' },
    { id: 7, name: '윤길동', tel: '01088889997', addr: '대구' },
    { id: 8, name: '송길동', tel: '01088889998', addr: '대전' },
    { id: 9, name: '신길동', tel: '01088889999', addr: '광주' },
  ];
  
const createTable =  (data) =&gt; {
  let table = document.createElement('table');
  table.style.textAlign = 'center';
  table.style.textDecoration = 'underline';
  table.style.padding = '1%';

  let headerRow = table.insertRow();

  for (let key in data[0]) {
    let th = document.createElement('th');
    th.textContent = key.toUpperCase();
    headerRow.appendChild(th);
  }

  let th1 = document.createElement('th');
  th1.textContent = 'RES';
  headerRow.appendChild(th1);
  let th2 = document.createElement('th');
  th2.textContent = 'DEL';
  headerRow.appendChild(th2);

  data.forEach(user =&gt; {
    let row = table.insertRow();
    for (let key in user) {
        let cell = row.insertCell();
      cell.textContent = user[key];
    }
  
    let restoreCell = row.insertCell();
    let restoreButton = document.createElement('button');
    restoreButton.textContent = '복구';
    restoreButton.addEventListener('click', () =&gt; {
      console.log(`복구: ${user.id}`);

      Array.from(row.cells).forEach((cell, columnIndex) =&gt; {
        if (columnIndex !== 0) cell.style.display = 'block';
      });
    })

    let deleteCell = row.insertCell();
    let deleteButton = document.createElement('button');
    deleteButton.textContent = '삭제';
    deleteButton.addEventListener('click', () =&gt; {
      console.log(`삭제: ${user.id}`);
      
      Array.from(row.cells).forEach((cell, columnIndex) =&gt; {
        if (columnIndex !== 0 &amp;&amp; columnIndex !== row.cells.length - 2) cell.style.display = 'none';
      });
    });

    deleteCell.appendChild(deleteButton);
    restoreCell.appendChild(restoreButton);
  });

  document.body.appendChild(table);
}

createTable(users);
</code></pre></div></div>

<h3 id="2024년-02월-07일-수">2024년 02월 07일 (수)</h3>

<ul>
  <li>디지털하나路 및 우아한 타입스크립트 <code class="language-plaintext highlighter-rouge">with</code> 리액트에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>어제부로 드디어 자바스크립트를 마치고, 오늘부터 며칠간 타입스크립트에 대해 배우게 되었다. 처음 접했을 때의 인상은 자바스크립트에 정적 타입만 확장한 것뿐인데 왜 굳이 현업에서 자주 활용되는지 몰랐는데, 배우면 배울수록 타입을 도입한 것 자체가 안정적이고 가독성 있는 코드를 작성하는 데에 도움이 된다는 생각이 들었다. 다만 타입스크립트를 배우는 시간이 너무 짧아 (일주일도 안된다…), 추후에 따로 공부하는 시간을 가져야 할 것 같아 공부할 때 참고할만한 책을 더해 게시글을 작성하려고 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-08일-목">2024년 02월 08일 (목)</h3>

<ul>
  <li>디지털하나路 및 우아한 타입스크립트 <code class="language-plaintext highlighter-rouge">with</code> 리액트에서 배운 내용을 정리한 게시글을 작성하고 있다.
    <ul>
      <li>어제는 타입스크립트의 타입 시스템에 대해 전반적으로 배웠다면, 오늘은 타입스크립트의 함수 타입와 인터페이스에 대해 다루는 시간을 가졌다. 자바스크립트와 달리 타입을 쓰면서 제약 조건이 많아진 것 같으면서도, 오히려 확장성 측면에서는 무궁무진하다는 말에 맞게 다양한 개념들이 적용되었다고 생각한다. 특히 인터페이스를 타입으로 하는 객체 리터럴에서 인터페이스에 정의되지 않은 동적 타입이 할당되는 것을 금지하면서도, 객체의 새로운 추가 속성을 명시적으로 any 타입으로 설정하는 인덱스 시그니처를 통해서는 가능하게 하는 것은… 처음에 각 개념들을 바로바로 이해하는 것은 어렵지만 실제로 코드를 작성할 때 왜 타입을 통해 어떤 부분이 제약되었나, 그리고 제약된 부분을 확장하고자 어떤 시도가 있었는지를 생각하다보니 조금이나마 알게 되었던 것 같다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-09일-금">2024년 02월 09일 (금)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 템플릿 프로젝트로 <code class="language-plaintext highlighter-rouge">vw-temp</code>에 대한 작업을 진행하고 있다.
    <ul>
      <li>4일에 구상하였던 템플릿 프로젝트를 시간 날 때 틈틈이 해보려고 한다. 일단 프레임워크는 내가 가장 빠르게 작업할 수 있는 자바 스프링부트로 진행하고, 내부 구조는 멀티 모듈로 구성하였다. 그러나 그동안 작업해본 토이 프로젝트와 달리, 모듈을 10개로 나누었는데 이는 책에서 배운 클린 마이크로서비스의 아키텍처를 최대한 반영해보려고 한 것이다. 그리고 커밋의 단위를 어떤 기능을 만들었는지, 가 아닌 어떤 기술을 적용하는지, 로 하고, 분류는 모두 <code class="language-plaintext highlighter-rouge">init:</code>로 하여 향후 <code class="language-plaintext highlighter-rouge">fork</code>하여 프로젝트를 분화시키기 쉽도록 하려고 한다. 원래대로라면 서비스에 특화된 아키텍처 구조를 가진 각각의 배포판이 나오는 것이 가장 이상적일 것 같지만… 너무 작업량이 많아 배보다 배꼽이 큰 상황이 되버리므로 올인원 (<code class="language-plaintext highlighter-rouge">All-in-one</code>)으로 하여 프로젝트에서 필요할 때 의존 관계나 모듈을 제외할 수 있도록 할 생각이다. 또 기술을 적용한 부분이 많아 코드처럼 바로바로 그것이 무엇인지 체크하기 어려우므로 주석을 굉장히 세세하게 달아서 향후 내가 작업할 때 최대한 참고할 수 있도록 할 것이다. 사실 그동안 <code class="language-plaintext highlighter-rouge">HTML</code>이랑 자바스크립트만 보다가 오랜만에 본 자바 &amp; 스프링부트라 좀 삽질이 많았는데, 연휴라고 놀지 말고 빠르게 작업하도록 해야겠다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-10일-토">2024년 02월 10일 (토)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 템플릿 프로젝트로 <code class="language-plaintext highlighter-rouge">vw-temp</code>에 대한 작업을 진행하고 있다.
    <ul>
      <li>먼저 <code class="language-plaintext highlighter-rouge">vw-temp</code> 각 모듈들에 의존 관계를 하나씩 추가해보면서 바로 적용하는 데에 실패하면 오류를 찾아 해결하고, 성공하면 이게 이 모듈에 들어가는 것이 맞나? 혹은 더 나은 방향이 있나 생각해보고 있다. 그래도 딱히 많이 한 건 아니고 이제 웹이랑 데이터베이스 쪽의 의존 관계를 건드려보는 중이라 생각보다 더딘데, 아직까지 초반이라 그런지 좀 실행 과정에 오류가 잦아 최대한 해결해보려 하고 있다. (내일 외가에 내려갈 예정이라 좀 많이 다뤄보려고 했는데, 속도가 다소 아쉽긴 하다.)</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-11일-일">2024년 02월 11일 (일)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 템플릿 프로젝트로 <code class="language-plaintext highlighter-rouge">vw-temp</code>에 대한 작업을 진행하고 있다.
    <ul>
      <li>이전부터 관심 있었던 커스텀 어노테이션을 적용해보았는데, 막상 설정하고 보니 할 수 있는 일이 없는 것 같아 커스텀 어노테이션에 대해 더 찾아보았다. 내가 생각한 것은 프록시 패턴처럼 해당 정보를 가져와 로그를 출력하는 로깅 (<code class="language-plaintext highlighter-rouge">Logging</code>)을 처리하는 것이었는데, 리플렉션 (<code class="language-plaintext highlighter-rouge">reflection</code>)을 이용해 내가 생각한 작업을 한다는 것을 알게 되어서 향후 그 부분을 <code class="language-plaintext highlighter-rouge">common</code>이나 <code class="language-plaintext highlighter-rouge">infra</code> 모듈에 추가할 생각이다.</li>
    </ul>
  </li>
</ul>

<h3 id="2024년-02월-12일-월">2024년 02월 12일 (월)</h3>

<ul>
  <li>디지털하나路 1차 과제를 해결하였다.
    <ul>
      <li>그동안 배웠던 프론트엔드 기초에 해당하는 영역에서 총 4문제들을 주어진 기한 내에 해결하는 것이었는데, 생각보다 자잘한 조건들이 많아서 시간이 오래 걸렸던 것 같다. 모레까지 제출이긴 하지만 내일 수업도 다시 진행될테니 미리 다 해결하려고 노력하였다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 템플릿 프로젝트로 <code class="language-plaintext highlighter-rouge">vw-temp</code>에 대한 작업을 진행하고 있다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sonarqube</code>, <code class="language-plaintext highlighter-rouge">Feign</code>, <code class="language-plaintext highlighter-rouge">Redis</code>를 프로젝트에 적용하는 작업을 진행하였다. <code class="language-plaintext highlighter-rouge">sonarqube</code>는 일단 의존 관계와 설정만 추가하고, 이를 젠킨스와 같은 <code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인 툴에 적용할 수 있도록 할 계획이고, <code class="language-plaintext highlighter-rouge">Feign</code>와 <code class="language-plaintext highlighter-rouge">Redis</code> 역시 추후 예시 클래스를 만들 때 쓸 수 있고자 도입하였다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TIL" /><summary type="html"><![CDATA[February, 2024 : 시간 관리의 중요성!]]></summary></entry></feed>