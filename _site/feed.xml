<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-24T17:45:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[JS] 자바스크립트 (JavaScript)</title><link href="http://localhost:4000/js1/" rel="alternate" type="text/html" title="[JS] 자바스크립트 (JavaScript)" /><published>2024-01-24T00:00:00+09:00</published><updated>2024-01-24T00:00:00+09:00</updated><id>http://localhost:4000/js1</id><content type="html" xml:base="http://localhost:4000/js1/"><![CDATA[<h2 id="자바스크립트-javascript--동적-클라이언트-사이드-스크립트-언어">자바스크립트 (<code class="language-plaintext highlighter-rouge">JavaScript</code>) : 동적 클라이언트 사이드 스크립트 언어</h2>

<ul>
  <li>웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 개발
    <ul>
      <li>초창기에는 웹 서버로부터 전달받은 <code class="language-plaintext highlighter-rouge">HTML/CSS</code>를 단순히 렌더링하는 수준에 머무름</li>
      <li>1999년, 비동기로 데이터를 교환하는 <code class="language-plaintext highlighter-rouge">Ajax</code> 기능이 도입돼, 필요한 데이터만 받아 렌더링하는 것이 가능해짐</li>
      <li>2006년, <code class="language-plaintext highlighter-rouge">DOM</code>을 쉽게 제어할 수 있는 <code class="language-plaintext highlighter-rouge">JQuery</code>가 등장</li>
      <li>2008년, 구글의 크롬 <code class="language-plaintext highlighter-rouge">V8</code> 자바스크립트 엔진으로 웹 서버에서 수행되던 로직이 브라우저로 이동</li>
      <li>2009년, <code class="language-plaintext highlighter-rouge">Node.js</code>로 브라우저 이외의 환경에서도 자바스크립트 엔진을 동작시킬 수 있게 됨
        <ul>
          <li>프런트엔드와 백엔드 모두에서 활용될 수 있는 동형성 (<code class="language-plaintext highlighter-rouge">isomorphic</code>)이 보장</li>
          <li>비동기 <code class="language-plaintext highlighter-rouge">I/O</code>를 지원하고 단일 스레드 이벤트 루프를 기반하여, 실시간 데이터 처리가 빈번한 <code class="language-plaintext highlighter-rouge">SPA</code>에 적합
            <ul>
              <li><code class="language-plaintext highlighter-rouge">SPA</code> (<code class="language-plaintext highlighter-rouge">Single Page Application</code>) : <code class="language-plaintext highlighter-rouge">React</code>, <code class="language-plaintext highlighter-rouge">Vue.js</code> 등</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>모든 브라우저에 내장된 브라우저 표준 프로그래밍 언어로 자리잡음
    <ul>
      <li>개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어 (<code class="language-plaintext highlighter-rouge">Interpreter Language</code>)</li>
      <li>모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해, 비교적 속도가 느린 인터프리터의 단점 해결</li>
      <li>명령형 (<code class="language-plaintext highlighter-rouge">imperative</code>), 함수형 (<code class="language-plaintext highlighter-rouge">functional</code>), 프로토타입 기반 (<code class="language-plaintext highlighter-rouge">prototype-based</code>), 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어</li>
    </ul>
  </li>
</ul>

<h3 id="nodejs--브라우저-밖에서-자바스크립트-코드를-실행하게-해주는-런타임-환경"><code class="language-plaintext highlighter-rouge">Node.js</code> : 브라우저 밖에서 자바스크립트 코드를 실행하게 해주는 런타임 환경</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>를 실행하여 웹 페이지를 브라우저 화면에 렌더링하는 브라우저와 달리, <code class="language-plaintext highlighter-rouge">Node.js</code> 는 브라우저 외부에서 자바스크립트를 실행할 수 있는 환경을 제공</p>

  <ul>
    <li>브라우저와 동일하게 자바스크립트의 코어인 <code class="language-plaintext highlighter-rouge">ECMScript</code>를 제공</li>
    <li>파싱된 <code class="language-plaintext highlighter-rouge">HTML</code> 요소를 선택 및 조작하는 <code class="language-plaintext highlighter-rouge">DOM API</code>이나 클라이언트 사이드 <code class="language-plaintext highlighter-rouge">Web API</code>를 제공되지 않음</li>
    <li>파일을 생성 및 수정할 수 있는 파일 시스템 및 <code class="language-plaintext highlighter-rouge">Node.js</code> 고유 <code class="language-plaintext highlighter-rouge">API</code> 제공</li>
  </ul>

  <p>브라우저가 제공하는 개발자 도구 (<code class="language-plaintext highlighter-rouge">DevTools</code>) 기능</p>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c788a167-03a3-49c3-86b1-9340a67c688c" /></p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">npm</code> : <code class="language-plaintext highlighter-rouge">Node.js</code>의 패키지를 관리할 수 있는 도구
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Node.js</code>에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 <code class="language-plaintext highlighter-rouge">CLI</code> 제공</li>
      <li><code class="language-plaintext highlighter-rouge">npx</code> (<code class="language-plaintext highlighter-rouge">node package execute</code>)을 통해 패키지를 설치 및 실행</li>
      <li>국내에서는 패키지 중복 문제를 링크 방식으로 해결한 <code class="language-plaintext highlighter-rouge">yarn</code>을 많이 사용하는 추세</li>
    </ul>
  </li>
</ul>

<h2 id="변수-variable--하나의-값을-저장할-수-있는-메모리-공간">변수 (<code class="language-plaintext highlighter-rouge">variable</code>) : 하나의 값을 저장할 수 있는 메모리 공간</h2>

<blockquote>
  <p>변수 = 선언 + 식별자 + 타입 + 값 + 소코프</p>
</blockquote>

<ul>
  <li>메모리 주소를 통해 값에 직접 접근하는 것은 위험 → 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음</li>
  <li>변수 이름을 어떤 값을 구별해 식별 가능한 고유한 이름이란 의미에서, 식별자 (<code class="language-plaintext highlighter-rouge">Identifier</code>)라고도 함
    <ul>
      <li>식별자는 값이 아닌 메모리 주소를 기억하고 있어, 식별자로 메모리 공간에 저장된 값에 접근</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var userId = 1;
var userName = 'John';

var user = { id: 1, name: 'John' };

var users = {
    { id: 1, name: 'John' }
}
</code></pre></div></div>

<ul>
  <li>변수 선언 (<code class="language-plaintext highlighter-rouge">variable declaration</code>)을 통해 변수를 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드로 변수를 선언</li>
      <li>변수에 값을 할당하지 않았으면, 자바스크립트 엔진에 의해 <code class="language-plaintext highlighter-rouge">undefined</code> 값이 할당되어 초기화</li>
      <li>선언하지 않은 식별자에 접근하면 참조 에러 (<code class="language-plaintext highlighter-rouge">ReferenceError</code>)가 발생</li>
    </ul>
  </li>
</ul>

<h3 id="변수-호이스팅-variable-hoisting--변수-선언문을-코드-맨-위에-올려진-것처럼-동작시킴">변수 호이스팅 (<code class="language-plaintext highlighter-rouge">variable hoisting</code>) : 변수 선언문을 코드 맨 위에 올려진 것처럼 동작시킴</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log(a);
var a = 10;

&gt; undefined
</code></pre></div></div>

<ul>
  <li>선언문의 실행 시점 : 선언문은 런타임 (<code class="language-plaintext highlighter-rouge">Runtime</code>)이 아닌 그 이전 단계에 먼저 실행
    <ul>
      <li>소스 코드를 한 줄씩 순차적으로 실행하기 앞서, 먼저 소스 코드의 평가 과정에서 선언문을 먼저 실행</li>
      <li>즉, 식별자를 선언하는 선언문과 값을 할당하는 할당문의 실행 시점은 서로 다름</li>
    </ul>
  </li>
  <li>변수, 함수, 클래스와 같이 키워드를 사용해서 선언하는 모든 식별자는 호이스팅됨</li>
</ul>

<h3 id="값-value--표현식이-평가되어-생성된-결과">값 (<code class="language-plaintext highlighter-rouge">value</code>) : 표현식이 평가되어 생성된 결과</h3>

<ul>
  <li>평가 (<code class="language-plaintext highlighter-rouge">evaluation</code>) : 표현식을 해석해서 값을 생성하거나 참조하는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 + 20; // 30
</code></pre></div></div>

<ul>
  <li>리터럴 (<code class="language-plaintext highlighter-rouge">literal</code>) : 사람이 이해할 수 있는 문자 혹인 기호를 통해 값을 생성하는 표기법</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/21a03922-1820-4bdd-82e9-844443ccedf3" width="80%" /></p>

<ul>
  <li>표현식 (<code class="language-plaintext highlighter-rouge">expression</code>) : 값으로 평가될 수 있는 구문
    <ul>
      <li>구문 (<code class="language-plaintext highlighter-rouge">statement</code>) : 프로그램을 이루는 기본 단위이자 최소 실행 단위 (선언문, 할당문, 조건문, 반복문 등)
        <ul>
          <li>토큰 (<code class="language-plaintext highlighter-rouge">token</code>) : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="데이터-타입-date-type--값의-종류">데이터 타입 (<code class="language-plaintext highlighter-rouge">Date Type</code>) : 값의 종류</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c2d012-dc6b-418d-919f-b9dfa828448a" width="80%" /></p>

<ul>
  <li>숫자 타입 : 정수 및 실수를 모두 포함하는 타입으로 존재 (<b>모든 수를 실수로 처리</b>)</li>
  <li>문자열 타입 : ‘’, “”, ``로 문자열을 감싼 텍스트 데이터
    <ul>
      <li>템플릿 (<code class="language-plaintext highlighter-rouge">template</code>) 리터럴 : <code class="language-plaintext highlighter-rouge">로 감싼 문자열 (</code><code class="language-plaintext highlighter-rouge">ES6</code>``부터 도입)
        <ul>
          <li>멀티라인 문자열 : 백슬레시 (<code class="language-plaintext highlighter-rouge">\n</code>) 없이 개행 가능</li>
          <li>표현식 삽입 : <code class="language-plaintext highlighter-rouge">+</code>으로 <code class="language-plaintext highlighter-rouge">${}</code>로 감싼 표현식을 문자열로 변환해 삽입할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>불리언 타입 : 참 (<code class="language-plaintext highlighter-rouge">true</code>)과 거짓 (<code class="language-plaintext highlighter-rouge">false</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">undefined</code> 타입 : 변수 선언에 의해 확보된 메모리 공간은 쓰레기 값이 아닌 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">null</code> 타입 : 변수에 값이 없다는 것을 의도적으로 명시 (<code class="language-plaintext highlighter-rouge">intentional absence</code>)하기 위해 사용</li>
  <li>심벌 (<code class="language-plaintext highlighter-rouge">symbol</code>) 타입 : 변경 불가능한 원시 타입 (다른 값과 중복되지 않는 유일무이한 값)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Symbol</code> 함수를 호출해 생성되며, 값은 외부에 노출되지 않음 (<code class="language-plaintext highlighter-rouge">var key = Symbol('key');</code>)</li>
    </ul>
  </li>
</ul>

<h3 id="동적-타이핑-dynamic-typing--변수를-선언할-때-데이터-타입을-사전에-선언하지-않음">동적 타이핑 (<code class="language-plaintext highlighter-rouge">Dynamic Typing</code>) : 변수를 선언할 때 데이터 타입을 사전에 선언하지 않음</h3>

<ul>
  <li>자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론 (<code class="language-plaintext highlighter-rouge">Type Inference</code>)이 이루어짐</li>
  <li>재할당에 의해 변수의 타입은 언제든지 동적으로 변화할 수 있음 (<code class="language-plaintext highlighter-rouge">loosely data</code>)</li>
</ul>

<blockquote>
  <p>정적 타입 (<code class="language-plaintext highlighter-rouge">Static Typing</code>) : 변수를 선언할 때 데이터 타입을 사전에 선언</p>

  <ul>
    <li>변수에 선언한 타입에 해당하는 값만 할당할 수 있음</li>
    <li>컴파일 시점에 타입 체크 (<code class="language-plaintext highlighter-rouge">Type Check</code>)를 수행하고, 통과하지 못하면 에러를 발생시킴</li>
    <li>타입의 일관성을 강제해 안정ㅇ적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임</li>
  </ul>
</blockquote>

<ul>
  <li>자바스크립트는 <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드를 통해 변수만 선언
    <ul>
      <li><code class="language-plaintext highlighter-rouge">typeof()</code> 연산자를 통해 피연산자의 데이터 타입을 문자열로 반환할 수 있음</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>동적 타이핑 및 동적 타입 언어의 단점?</p>

  <ul>
    <li>동적 타입 언어의 변수 값은 언제든지 변할 수 있음
      <ul>
        <li>복잡한 프로그램에서는 변수 값을 추적하기 어려울 수 있음</li>
      </ul>
    </li>
    <li>동적 타입 언어의 변수는 값의 변경에 의해 타입 또한 언제든지 변경될 수 있음
      <ul>
        <li>값을 확인하기 전에는 타입을 확신할 수 없음</li>
        <li>자바스크립트 엔진에 의해 타입이 자동으로 변환될 수도 있음</li>
      </ul>
    </li>
  </ul>

  <p>→ 동적 타입 언어는 유연성 (<code class="language-plaintext highlighter-rouge">Flexibility</code>)은 높지만 신뢰성 (<code class="language-plaintext highlighter-rouge">Reliability</code>)는 떨어진다.</p>

  <blockquote>
    <p>변수를 사용할 때 지켜면 좋은 규칙</p>

    <ul>
      <li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.</li>
      <li>변수의 유효 범위인 스코프는 최대한 좁게 만들어 변수의 부작용을 억제한다.</li>
      <li>전역 변수는 최대한 자제한다.</li>
      <li>변수보다는 상수를 사용해 값의 변경을 억제한다.</li>
      <li>변수 이름은 목적 및 의미를 파악할 수 있도록 네이밍하고, 특히 스코프가 넓을수록 명확하게 명명한다.</li>
    </ul>
  </blockquote>
</blockquote>

<h3 id="암묵적-타입-변환--자바스크립트-엔진에서-에러를-발생시키지-않도록-타입을-바꿔-표현식을-평가하는-것">암묵적 타입 변환 : 자바스크립트 엔진에서 에러를 발생시키지 않도록 타입을 바꿔 표현식을 평가하는 것</h3>

<ul>
  <li>문자열 타입 변환 : <code class="language-plaintext highlighter-rouge">+</code>의 피연산자 중 하나가 문자열이면, 문자열 연결 연산자로 동작하므로 다른 것을 문자열로 변환</li>
  <li>숫자 타입 변환 : 산술 및 비교 연산자의 피연산자 중에 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환</li>
  <li>불리언 타입 변환 : 논리적 참/거짓을 평가하는 경우에 불리언 타입이 아닌 피연산자를 불리언 타입으로 변환</li>
</ul>

<h3 id="명시적-타입-변환--의도적으로-값의-타입을-변환하는-것--타입-캐스팅-type-casting">명시적 타입 변환 : 의도적으로 값의 타입을 변환하는 것 → 타입 캐스팅 (<code class="language-plaintext highlighter-rouge">type casting</code>)</h3>

<ul>
  <li>문자열 타입으로 변환 : <code class="language-plaintext highlighter-rouge">String()</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, 문자열 연결 연산자 <code class="language-plaintext highlighter-rouge">+</code></li>
  <li>숫자 타입으로 변환 : <code class="language-plaintext highlighter-rouge">Number()</code>, <code class="language-plaintext highlighter-rouge">parseInt()/parseFloat()</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code></li>
  <li>불리언 타입으로 변환 : <code class="language-plaintext highlighter-rouge">Boolean()</code>, 부정 논리 연산자 <code class="language-plaintext highlighter-rouge">!</code>를 2번</li>
</ul>

<blockquote>
  <p>기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것!</p>

  <ul>
    <li>원시 값은 변경 불가능한 값 (<code class="language-plaintext highlighter-rouge">immutable value</code>) → 기존 원시 값을 직접 변경 ✘</li>
    <li>자바스크립트 엔진에서 표현식을 평가하기 위해 피연산자의 값을 암묵적 타입 변환으로 새로운 타입의 값을 만듬</li>
  </ul>
</blockquote>

<h3 id="단축-평가-short-circuit-evaluation--표현식을-평가하는-중에-결과가-확정되면-평가-과정을-생략">단축 평가 (<code class="language-plaintext highlighter-rouge">short-circuit evaluation</code>) : 표현식을 평가하는 중에 결과가 확정되면, 평가 과정을 생략</h3>

<ul>
  <li>논리 평가 : 논리 연산자를 이용한 단축 평가 (좌항에서 우항으로 평가)
    <ul>
      <li>논리곱 연산자 <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>는 두 피연산자가 모두 <code class="language-plaintext highlighter-rouge">true</code>일 때, <code class="language-plaintext highlighter-rouge">true</code> 반환
        <ul>
          <li>논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 반환</li>
        </ul>
      </li>
      <li>논리합 연산자 <code class="language-plaintext highlighter-rouge">||</code>는 두 피연산자 중 하나만  <code class="language-plaintext highlighter-rouge">true</code>이여도, <code class="language-plaintext highlighter-rouge">true</code> 반환
        <ul>
          <li>논리 연산의 결과를 결정하는 첫번째 피연사자를 그대로 반환</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'Cat' &amp;&amp; 'Dog' // true &amp;&amp; 'Dog' → 'Dog'
'Cat' || 'Dog' // 'Cat'... → 'Cat'
</code></pre></div></div>

<blockquote>
  <p>논리 평가를 사용하는 경우?</p>

  <ul>
    <li>객체를 가리키기 기대하는 변수가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>가 아닌지 확인하고 프로퍼티를 참조할 때</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var elem = null;
// var value = elem.value; // TypeError
var value = elem &amp;&amp; elem.value; // null
</code></pre></div>  </div>

  <ul>
    <li>함수 매개변수에 <code class="language-plaintext highlighter-rouge">undefined</code>가 할당되지 않도록 기본값을 설정할 때</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getStringLength() {
str = str || '';
return str.length;
}
getStringLength(); // 0
getStringLength('hello'); // 5
</code></pre></div>  </div>
</blockquote>

<ul>
  <li>옵셔널 체이닝 (<code class="language-plaintext highlighter-rouge">Optional Chaining</code>) 연산자 <code class="language-plaintext highlighter-rouge">?</code> : 좌항의 피연산자가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이면 <code class="language-plaintext highlighter-rouge">undefined</code>를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 그대로 진행함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var elem = null;
var str = '';

var value1 = elem?.value; console.log(value1); // undefined
var value2 = elem &amp;&amp; elem.value; console.log(value2); // null
var value3 = str &amp;&amp; str.length; console.log(value3); // ''
var value4 = str?.length; console.log(value4); // 0
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 병합 연산자 <code class="language-plaintext highlighter-rouge">??</code> : 좌항의 피연산자가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환 → 변수에 기본값을 설정할 때 사용
    <ul>
      <li>논리 연산자 <code class="language-plaintext highlighter-rouge">||</code>를 사용한 단축 평가와 달리, 피연산자가  <code class="language-plaintext highlighter-rouge">false</code>로 평가받는 <code class="language-plaintext highlighter-rouge">Falsy</code> 값 (<code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">undefined</code>, <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">-0</code>, <code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">''</code>)이라도 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이 아니면, 좌항의 피연산자를 반환함</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo = null ?? 'default'; // 'default'
</code></pre></div></div>

<h2 id="객체-object--소프트웨어에서-속성과-기능을-가지는-프로그램의-단위">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 소프트웨어에서 속성과 기능을 가지는 프로그램의 단위</h2>

<blockquote>
  <ul>
    <li>원시 타입 (<code class="language-plaintext highlighter-rouge">Primitive</code>) : 값이 스택 영역에 들어감 (<code class="language-plaintext highlighter-rouge">Call-By-Value</code>)</li>
    <li>객체 타입 (<code class="language-plaintext highlighter-rouge">Object</code>) : 값이 힙 영역에 들어감 (<code class="language-plaintext highlighter-rouge">Call-By-Reference</code>)</li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/2afeda63-c90d-4989-bf9c-88af481e4acc" /></p>
</blockquote>

<ul>
  <li>원시 값을 제외한 나머지 값, 함수, 배열, 정규 표현식 등음 모두 객체</li>
  <li>원시 값은 변경 불가능한 값이지만, 객체 값은 변경 가능한 값</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John', // "name: 'John'"은 프로퍼티, 
  age: 21       // "name"은 프로퍼티 키, "'John'"은 프로퍼티 값
};
</code></pre></div></div>

<ul>
  <li>객체는 0개 이상의 프로퍼티의 집합 → 프로퍼티는 키 (<code class="language-plaintext highlighter-rouge">key</code>)와 값 (<code class="language-plaintext highlighter-rouge">value</code>)으로 구성
    <ul>
      <li>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.</li>
    </ul>
  </li>
  <li>객체는 프로퍼티와 메소드를 모두 포함하고 있어, 상태와 동작을 하나의 단위로 구조화할 수 있다.
    <ul>
      <li>프로퍼티 (<code class="language-plaintext highlighter-rouge">property</code>) : 객체의 상태를 나타내는 값 (<code class="language-plaintext highlighter-rouge">data</code>)</li>
      <li>메소드 (<code class="language-plaintext highlighter-rouge">method</code>) : 프로퍼티를 참조하고 조작할 수 있는 동작 (<code class="language-plaintext highlighter-rouge">behavior</code>)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">C++</code>이나 <code class="language-plaintext highlighter-rouge">Java</code> → 클래스 (<code class="language-plaintext highlighter-rouge">Class</code>) 기반 객체지향 언어 : 클래스를 사전에 정의하고, 필요한 시점에 <code class="language-plaintext highlighter-rouge">new</code> 연산자와 함께 생성자 (<code class="language-plaintext highlighter-rouge">constructor</code>)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성</li>
    <li>자바스크립트 → 프로토타입 (<code class="language-plaintext highlighter-rouge">Prototype</code>) 기반 객체지향 언어 : 다양한 객체 생성 방법을 지원</li>
  </ul>
</blockquote>

<h3 id="객체-리터럴에-의한-객체-생성---내에-0개-이상의-프로퍼티를-정의">객체 리터럴에 의한 객체 생성 : <code class="language-plaintext highlighter-rouge">{}</code> 내에 0개 이상의 프로퍼티를 정의</h3>

<ul>
  <li>변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John',
  ...
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[자바스크립트 (JavaScript) : 동적 클라이언트 사이드 스크립트 언어]]></summary></entry><entry><title type="html">[Docker] 5. Docker Registry</title><link href="http://localhost:4000/docker5/" rel="alternate" type="text/html" title="[Docker] 5. Docker Registry" /><published>2024-01-23T00:00:00+09:00</published><updated>2024-01-23T00:00:00+09:00</updated><id>http://localhost:4000/docker5</id><content type="html" xml:base="http://localhost:4000/docker5/"><![CDATA[]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[SpringBoot] 2. SpringBoot Common Task</title><link href="http://localhost:4000/springboot2/" rel="alternate" type="text/html" title="[SpringBoot] 2. SpringBoot Common Task" /><published>2024-01-22T00:00:00+09:00</published><updated>2024-01-22T00:00:00+09:00</updated><id>http://localhost:4000/springboot2</id><content type="html" xml:base="http://localhost:4000/springboot2/"><![CDATA[<h2 id="어플리케이션-설정-관리--여러-환경에-따른-설정-정보의-다중화">어플리케이션 설정 관리 : 여러 환경에 따른 설정 정보의 다중화</h2>

<ul>
  <li>개발 환경의 다중화 → 개발 (<code class="language-plaintext highlighter-rouge">dev</code>), 테스트 (<code class="language-plaintext highlighter-rouge">test</code>), 스테이징 (<code class="language-plaintext highlighter-rouge">staging</code>), 배포 (<code class="language-plaintext highlighter-rouge">prod</code>)
    <ul>
      <li>여러 환경에 배포할 때 설정 정보는 매번 변경되어야 하지만, 소스 코드는 변경되어선 안됨</li>
      <li>즉, 설정 정보를 외부화하여 관리할 필요성이 있음</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>어플리케이션 설정 관리 방법의 우선순위</p>

  <ol>
    <li>명령행 인자</li>
    <li>운영 체제의 환경 변수</li>
    <li>설정 정보 파일 (<code class="language-plaintext highlighter-rouge">application.properties</code> 혹은 <code class="language-plaintext highlighter-rouge">application.yml</code>)</li>
    <li><code class="language-plaintext highlighter-rouge">@PropertySource</code></li>
    <li><code class="language-plaintext highlighter-rouge">SpringApplication</code></li>
  </ol>
</blockquote>

<h3 id="springapplication-클래스-사용"><code class="language-plaintext highlighter-rouge">SpringApplication</code> 클래스 사용</h3>

<ul>
  <li>소스 코드로 정의하는 방식이므로 한 번 정의하면 나중에 바뀌지 않는 경우에 적합함</li>
  <li><code class="language-plaintext highlighter-rouge">java.util.Properties</code>나 <code class="language-plaintext highlighter-rouge">java.util.Map&lt;String, Object&gt;</code>가 인자인 <code class="language-plaintext highlighter-rouge">setDefaultProperties()</code> 메소드 호출
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Properties</code>나 <code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>를 통해 설정 정보를 어플리케이션에 적용</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/41016cdc-001c-4c27-bc87-3d366061017f" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application.properties</code> 파일은 다른 설정 파일들을 <code class="language-plaintext highlighter-rouge">spring.config.import</code> 프로퍼티를 통해 임포트해서 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">spring.config.import=classpath:additional-application.properties</code>를 추가하면 스프링부트는 <code class="language-plaintext highlighter-rouge">additional-application.properties</code> 파일에 있는 설정 정보를 읽어 사용할 수 있음
        <ul>
          <li>만약 클래스패스에 파일이 없으면, <code class="language-plaintext highlighter-rouge">ConfigDataLocationNotFoundException</code> 예외가 발생</li>
          <li><code class="language-plaintext highlighter-rouge">spring.config.on-not-found</code>에 <code class="language-plaintext highlighter-rouge">ignore</code>를 지정하면, 클래스파일에 설정 파일이 없을 때 예외 처리를 하고 종료하는 대신 어플리케이션 시동 작업을 계속 진행하게 할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="propertysource-사용"><code class="language-plaintext highlighter-rouge">@PropertySource</code> 사용</h3>

<ul>
  <li>설정 파일의 위치를 어노테이션을 사용해 지정 (자바 8 이후로는 동일한 어노테이션을 여러 번 사용할 수 있음)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">src/main/resources/</code>의 파일은 <code class="language-plaintext highlighter-rouge">JAR</code>로 패키징된 후 클래스패스에 위치하므로, 해당 디렉터리에 설정 파일 작성</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/080afe26-f960-4980-8551-1acc165c7d0e" width="80%" /></p>

<ul>
  <li>스프링이 제공하는 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스를 주입받으면, 설정 파일에 있는 정보를 읽을 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@SpringBootApplication
public class SpringBootApplication {
    public static final Logger log = Logger.getLogger(SpringBootApplication.class);

    public static void main(String[] args) {
        ConfigurableApplicationContext configurableApplicationContext
         = SpringApplication.run(SpringBootApplication.class, args);

        CustomConfiguration customConfiguration
         = applicationContext.getBean(CustomConfiguration.class);

        log.info(customConfiguration.toString());
    }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@PropertySource</code>로는 <code class="language-plaintext highlighter-rouge">.yml</code> 파일 지정해서 사용할 수 없으므로, 추가적인 작업이 필요</li>
</ul>

<h3 id="환경-설정-파일-applicationproperties-또는-applicationyml">환경 설정 파일 (<code class="language-plaintext highlighter-rouge">application.properties</code> 또는 <code class="language-plaintext highlighter-rouge">application.yml</code>)</h3>

<ul>
  <li>환경 설정 파일에 명시된 설정 프로퍼티 정보는 스프리의 <code class="language-plaintext highlighter-rouge">Environment</code> 객체에 로딩
    <ul>
      <li>어플리케이션 클래스에서 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스나 <code class="language-plaintext highlighter-rouge">@Value</code> 어노테이션을 통해 설정 정보를 읽을 수 있음</li>
      <li><code class="language-plaintext highlighter-rouge">spring.config.name</code> 프로퍼티로 환경 설정 파일의 이름을 지정할 수 있음</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>스프링부트가 기본적으로 읽는 환경 설정 파일의 위치는,</p>

  <ul>
    <li>클래스패스 루트</li>
    <li>클래스패스 <code class="language-plaintext highlighter-rouge">/config</code> 패키지</li>
    <li>현재 디렉터리</li>
    <li>현재 디렉터리 <code class="language-plaintext highlighter-rouge">/config</code> 디렉터리</li>
    <li><code class="language-plaintext highlighter-rouge">/config</code> 디렉터리의 바로 하위에 위치한 디렉터리</li>
  </ul>

  <p>추가로, <code class="language-plaintext highlighter-rouge">spring.config.location</code> 프로퍼티를 통해 상대 경로나 절대 경로의 환경 설정 파일을 읽을 수 있음<br />(<code class="language-plaintext highlighter-rouge">optional:</code> 접두어를 통해 해당된 경로에 환경 설정 파일이 없더라도, 예외 처리 없이 스프링부트 기본 설정값으로 실행할 수 있음)</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -jar target/config-data-file.jar --spring.config.location=optional:data/application.yml
</code></pre></div>  </div>

  <blockquote>
    <p><code class="language-plaintext highlighter-rouge">spring.config.name</code>과 <code class="language-plaintext highlighter-rouge">spring.config.properties</code>는 환경 설정 파일에 지정할 수 없음<br />→ <code class="language-plaintext highlighter-rouge">SpringApplication.setDefaultProperties()</code> 메소드나 환경 변수, 혹은 명령행 인자를 통해 지정</p>
  </blockquote>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application-{profile}.properties</code> : 프로파일 (<code class="language-plaintext highlighter-rouge">profile</code>)별로 프로퍼티 파일 지정 가능
    <ul>
      <li>환경 설정 파일의 <code class="language-plaintext highlighter-rouge">spring.profile.active</code> 프로퍼티를 통해 프로파일를 지정하면, 프로퍼티 파일의 내용이 로딩</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {
    // ...
}
</code></pre></div></div>

<blockquote>
  <p>설정 파일의 로딩 순서</p>

  <ol>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 안에 패키징되는 환경 설정 파일</li>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 안에 패키징되는 <code class="language-plaintext highlighter-rouge">profile</code>별 환경 설정 파일</li>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 밖에서 패키징되는 환경 설정 파일</li>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 안에 패키징되는 <code class="language-plaintext highlighter-rouge">profile</code>별 환경 설정 파일</li>
  </ol>
</blockquote>

<h3 id="운영-체제의-환경-변수">운영 체제의 환경 변수</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application.properties</code> 파일에서 <code class="language-plaintext highlighter-rouge">app.timeout</code> 커스텀 프로퍼티를 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app.timeout=${APP_TIMEOUT}
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c8c54862-d56a-43d8-b491-dc1251c7e0d1" width="80%" /></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ConfigurableApplicationContext</code> 인스턴스에 접근</li>
  <li><code class="language-plaintext highlighter-rouge">Environment</code> 빈을 가져옴</li>
  <li>프로퍼티 값을 <code class="language-plaintext highlighter-rouge">env.getProperty()</code> 메소드로 읽어 콘솔 로그로 출력</li>
</ol>

<h2 id="configurationproperties--커스텀-프로퍼티-생성"><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> : 커스텀 프로퍼티 생성</h2>

<blockquote>
  <p>스프링부트 빌트인 프로퍼티 전체 목록은 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html">공식 래퍼런스 문서</a>에서 확인 가능</p>
</blockquote>

<ul>
  <li>스프링 어플리케이션이 복잡해지고 기능이 많아질수록, 커스텀 프로퍼티의 필요성이 높아짐
    <ul>
      <li>외부 <code class="language-plaintext highlighter-rouge">REST</code> 웹 서비스 <code class="language-plaintext highlighter-rouge">URL</code>이나 특정 기능 활성화 여부를 지정할 <code class="language-plaintext highlighter-rouge">boolean</code> 플래그 등</li>
    </ul>
  </li>
</ul>

<h3 id="environment-인스턴스-주입을-통한-프로퍼티-값-사용"><code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스 주입을 통한 프로퍼티 값 사용</h3>

<ul>
  <li>스프링의 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스에 프로퍼티가 바인딩 → <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스를 주입받아 프로퍼티 값 사용 가능</li>
  <li>프로퍼티 값의 타입 안정성 (<code class="language-plaintext highlighter-rouge">Type-Safety</code>)이 보장되지 않아, 이로 인해 런타임 에러가 발생할 수 있음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">URL</code>이나 이메일 주소를 프로퍼티로 사용할 때 유효성 검증 (<code class="language-plaintext highlighter-rouge">Vadlidation</code>)을 수행할 수 없음</li>
    </ul>
  </li>
  <li>프로퍼티 값을 일정한 단위로 묶어서 읽을 수 없음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Value</code> 어노테이션이나 스프링의 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스를 사용해서 하나하나 개별적으로만 읽을 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="configurationproperties-어노테이션을-사용한-커스텀-프로퍼티-정의"><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 어노테이션을 사용한 커스텀 프로퍼티 정의</h3>

<blockquote>
  <p>요구 사항 : 커스텀 프로퍼티에 대한 타입 안정성을 보장하고, 값의 유효성을 검증해야 한다.</p>
</blockquote>

<ul>
  <li>스프링부트 설정 처리기 (<code class="language-plaintext highlighter-rouge">Configuration Processor</code>)를 통해 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>이 붙은 클래스에 대한 메타데이터 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">spring-boot-configuration-processor</code> 의존 관계를 추가해 스프링부트 설정 처리기를 활성화</li>
      <li>생성된 메타데이터는 환경 설정 파일에 기술된 프로퍼티에 대한 자동 완성이나 문서화 지원</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring.config.import</code>와 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>을 함께 사용해, 연관된 프로퍼티들을 그룹화한 프로퍼티 파일로 관리 가능</li>
  <li><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 어노테이션을 클래스 안에서 빈을 생성하는 <code class="language-plaintext highlighter-rouge">@Bean</code> 메소드에도 붙일 수 있음</li>
  <li>아래처럼 생성자를 사용해서 바인딩하는 방식이 아닌, <code class="language-plaintext highlighter-rouge">setter</code> 메소드를 통해 바인딩하는 방식 또한 가능</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/264e5990-ee36-44a5-bfe3-420b68fd02d2" width="80%" /></p>

<ul>
  <li>커스텀 프로퍼티를 사용하려면 환경 설정 파일에 해당 프로퍼티에 대한 정보를 추가해야 함</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8f9f02c6-0ce3-4bb0-b9c4-a5534462fbc3" width="80%" /></p>

<ul>
  <li>프로퍼티를 정의하고 이를 담은 <code class="language-plaintext highlighter-rouge">AppProperties</code> 클래스를 통해 서비스 클래스에서 <code class="language-plaintext highlighter-rouge">AppProperties</code> 객체를 주입받을 수 있음</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ac00105a-cd9c-4b8c-8dfa-14bf4d1c49ed" width="80%" /></p>

<ul>
  <li>스프링부트 어플리케이션 클래스는 서비스 클래스를 사용해서 <code class="language-plaintext highlighter-rouge">AppProperties</code> 객체에 접근하여 프로퍼티 값을 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@EnableConfigurationProperties</code> 어노테이션은 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>이 붙은 클래스를 스프링 컨테이너에 등록</li>
      <li><code class="language-plaintext highlighter-rouge">@ConfigurationPropertiesScan</code> 어노테이션으로 기준 패키지을 지정하면, 지정 패키지 하위에 있는 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>가 붙은 클래스를 모두 탐색해서 스프링 컨테이너에 등록</li>
      <li><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 어노테이션이 붙은 클래스를 자동 탐색해서 등록하는 것이 아니라 직접 명시해야 함</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1975bd6-5a08-44eb-914e-572a5d539585" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConstructorBinding</code> 어노테이션을 <code class="language-plaintext highlighter-rouge">POJO</code> 클래스에 사용하면, 생성자를 통해 프로퍼티 정보값이 설정
    <ul>
      <li>생성자가 하나만 있으면 클래스에, 생성자가 여러 개라면 프로퍼티 정보값 설정에 사용할 생성자에 어노테이션을 붙이면 됨</li>
      <li>설정 정보 클래스의 불변성을 보장하기 위해선 세터 바인딩 대신 생성자 바인딩으로 프로퍼티 값을 설정해야 함</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3ae42b22-9e2e-47cb-a8fb-3d2f25357007" width="80%" /></p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SpringBoot" /><summary type="html"><![CDATA[어플리케이션 설정 관리 : 여러 환경에 따른 설정 정보의 다중화]]></summary></entry><entry><title type="html">TailwindCSS란? (2024.01.22)</title><link href="http://localhost:4000/digital_hanaro_study2/" rel="alternate" type="text/html" title="TailwindCSS란? (2024.01.22)" /><published>2024-01-22T00:00:00+09:00</published><updated>2024-01-22T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_study2</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_study2/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 2일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부하고자-한-이유">공부하고자 한 이유</h2>

<p>토이 프로젝트를 만들 때 부트스트랩 (<code class="language-plaintext highlighter-rouge">Bootstrap</code>)을 많이 활용하여 화면을 구성하곤 하였는데, 오늘 강사님께서 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>라는 새로운 프론트엔드 프레임워크 기술에 대해 말씀해주시면서, 현재는 부트스트랩보다 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>를 사용한 사이트가 훨씬 다수임을 알려주셨다. 그래서 향후 토이 프로젝트에 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>를 적용할 수 있도록 부트스트랩과 차이점을 비교해보면서 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>에 대해 공부해보고자 한다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p>부트스트랩 (<code class="language-plaintext highlighter-rouge">BootStrap</code>)은 2011년에 트위터에서 시작된 오픈 소스 프론트엔드 프레임워크이다. 글자, 인용문, 목록, 표 등 자잘한 요소부터 메뉴, 바, 버튼 등까지 웹 페이지에서 자주 쓰이는 요소들을 모두 내장하고 있어, 부트스트랩의 <code class="language-plaintext highlighter-rouge">CSS</code>와 <code class="language-plaintext highlighter-rouge">JS</code>를 사이트에 반영만 하면 일정한 디자인을 빠른 시간 내에 제작할 수 있다. 그리고 데스크탑만이 아니라 모바일 화면 또한 비율에 맞게 반응형으로 지원하여 크로스 브라우저 (<code class="language-plaintext highlighter-rouge">Cross-Browser</code>) 환경에도 적합하다. 또한 해상도 크기에 맞게 자동으로 정렬되고 크기 조절이 가능한 그리드 시스템 (<code class="language-plaintext highlighter-rouge">Grid System</code>)이 내장되어 있어 화면에 특정한 요소를 배치하는 것에 대한 커스텀마이징 또한 매우 간단한 편이다. <a href="https://getbootstrap.com">부트스트랩 공식 웹 사이트</a>에서 여러 예시 화면들을 볼 수도 있다.</p>

<p>나 같은 경우에는 전문적인 프론트엔드 개발자가 아니라서, 부트스트랩을 처음 접했을 때에는 블로그를 운영하는 과정에서 배운 <code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>에 대한 지식들만 있는 상태였다. 그러나 예시 화면들의 각 요소들을 직접 뜯어보고 수정하는 과정에서 사용해본 내부 클래스들로만으로도 내가 필요로 한 화면들을 금방금방 구성해낼 수 있었다. 아래의 화면은 내가 기획하였던 사이트의 노래 검색 화면으로, 화면 구상에서 실제 구현까지 2~3일 정도 걸린 것으로 기억한다. <code class="language-plaintext highlighter-rouge">Header</code>와 <code class="language-plaintext highlighter-rouge">Footer</code> 부분은 템플릿 엔진을 통해 이전에 만든 요소를 그대로 사용하였고, 상세 검색 화면은 그리드 시스템과 내장된 글자 및 버튼 속성을 적절히 적용하여 구현하였다. 그리고 버튼을 눌렀을 때 나올 수 있는 동작들, 예를 들어 마우스 포커싱 기능들도 <code class="language-plaintext highlighter-rouge">CSS</code>로 구현되어 있어 따로 만들 필요가 없었다. 그리고 작년에 <code class="language-plaintext highlighter-rouge">7</code> 버전이 출시될 만큼 꾸준한 개발 및 지원이 이루어지고 있고, 또 부트스트랩을 사용하는 웹 사이트 및 래퍼런스들도 여전히 많이 존재한다.</p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/625ec1e6-55ec-48a3-9ae8-5b415405f4b1" /></p>

<p>그럼 부트스트랩 대신에 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>가 대세가 된 이유는 무엇일까? 내가 처음 떠올린 이유는 부트스트랩만으로는 생각보다 직접 커스텀마이징을 하는 데에 한계가 있다는 것이다. 물론 오픈 소스이므로 래퍼런스가 정말 많고, 원하는 페이지를 만드는 것도 얼마든지 가능한 것 또한 사실이다. 그런데 사실 이건 <code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>을 다룰 수 있으면 얼마든지 가능한 부분이고, 이젠 피그마 등을 활용해 원하는 화면을 빠르게 배치해 만드는 것도 가능하다. 오히려 부트스트랩 기반으로 한, 비슷한 디자인의 사이트들이 많아져서 타 사이트와의 차별성을 두기 어려운 부분 또한 맞는 말이라고 생각한다. 부트스트랩의 취지는 <code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>들을 미리 만들어 개발자가 사용할 수 있는 것인데, 내가 구현하지 않는 부분까지 빌트인 (<code class="language-plaintext highlighter-rouge">built-in</code>)되어 있다보니, 부트스트랩 자제 문법을 공부하는 데에도 시간이 꽤 걸린다.</p>

<p>그러면 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>에 대해 알아보자. <code class="language-plaintext highlighter-rouge">TailwindCSS</code>는 2017년에 <code class="language-plaintext highlighter-rouge">Tailwind Labs</code>에서 개발한 <code class="language-plaintext highlighter-rouge">CSS</code> 프레임워크이다. <code class="language-plaintext highlighter-rouge">TailwindCSS</code>는 <code class="language-plaintext highlighter-rouge">CSS</code>를 작성하지 않고 클래스 이름을 제공하여 <code class="language-plaintext highlighter-rouge">HTML</code>에 필요한 <code class="language-plaintext highlighter-rouge">CSS</code> 유틸리티만 입혀도 스타일이 완성되는 ‘유틸리티 우선 <code class="language-plaintext highlighter-rouge">CSS</code>‘를 지향한다. <a href="https://tailwindcss.com"><code class="language-plaintext highlighter-rouge">TailwindCSS</code> 공식 사이트</a>를 보면, 클래스 이름만 적어도 <code class="language-plaintext highlighter-rouge">CSS</code>가 적용되는 여러 예시들을 볼 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div&gt;
    &lt;style&gt;
    .rainbow-block {
      display: inline-block;
      width: 100%;
      height: 150px;
      background: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);
    }
  &lt;/style&gt;
  &lt;div class="rainbow-block"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre></div></div>

<div>
    <style>
    .rainbow-block {
      display: inline-block;
      width: 100%;
      height: 150px;
      background: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);
    }
  </style>
  <div class="rainbow-block"></div>
</div>

<p>무지개색 블록을 만들고자 할 때, 순수 <code class="language-plaintext highlighter-rouge">CSS</code>는 위의 스타일 코드를 적어야 한다. 반면 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>는 아래의 예시처럼 미리 정의된 유틸리티 클래스들을 활용하여 클래스 이름만으로 스타일을 적용할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

.rainbow-block {
  @apply inline-block w-32 h-32 bg-gradient-to-r from-violet to-red;
}
</code></pre></div></div>

<p>사실 이게 왜 장점이지? 할 수도 있다. 어쨌든 <code class="language-plaintext highlighter-rouge">HTML/CSS</code> 또한 기능 자체를 제공하기는 한다! 하지만 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>가 제공하는 유틸리티 클래스는 부트스트랩의 장점인 일관성 있는 디자인을 가지면서, 기본 스타일 값을 직접 커스텀마이징할 수 있는 <code class="language-plaintext highlighter-rouge">key-value</code>를 제공한다. 그리고 로우 레벨의 스타일 또한 제공하므로, 미리보기, 자동완성, 신택스 하이라이팅 및 린팅을 지원하는 <code class="language-plaintext highlighter-rouge">IntelliSense</code> 플러그인을 활용하여 필요한 디자인을 세밀하게 구현할 수 있다. 무엇보다 프론트엔드 개발자가 가장 장점으로 꼽는 부분은 <b>클래스 이름을 고민하지 않아도 된다는 점</b>인데, 이건 함수의 이름을 잘 짓기 위해 프로젝트 시작 전에 매번 고민하는 시간을 갖는 나에게도 와닿는 문제라 공감이 가는 부분이 많다.</p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 2일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">프로그래밍 언어로서의 JavaScript와 TypeScript (2024.01.19)</title><link href="http://localhost:4000/digital_hanaro_study1/" rel="alternate" type="text/html" title="프로그래밍 언어로서의 JavaScript와 TypeScript (2024.01.19)" /><published>2024-01-19T00:00:00+09:00</published><updated>2024-01-19T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_study1</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_study1/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 1일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부하고자-한-이유">공부하고자 한 이유</h2>

<p><code class="language-plaintext highlighter-rouge">JavaScript</code>와 <code class="language-plaintext highlighter-rouge">TypeScript</code>는 그동안 내가 주로 사용해온 <code class="language-plaintext highlighter-rouge">C</code>, <code class="language-plaintext highlighter-rouge">C++</code>, <code class="language-plaintext highlighter-rouge">Java</code>와 같은 컴파일 언어와는 많은 차이점이 있는 스크립트 언어이다. 오늘은 본격적으로 자바스크립트를 배우기 앞서 자바스크립트와 타입스크립트가 프로그래밍 언어로서 어떤 특성을 가지는지 알아보고자 한다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p>프로그래밍 언어 (<code class="language-plaintext highlighter-rouge">Programming Language</code>)는 기계가 읽을 수 있고, 사람이 읽을 수 있는 형식으로, 계산을 서술하기 위한 표기 체계이다. 여기에서 주목할 점은 ‘사람이 읽을 수 있는 형식으로’이다. 사실 기계의 성능을 가장 높이는 방법은 기계의 방식을 그대로 따르는 것이지만, 프로그래밍 언어는 사람의 편의성을 위해 지속적으로 여러 개념들을 도입하였다. 대표적인 예시로 추상화 (<code class="language-plaintext highlighter-rouge">Abstraction</code>)이 있다. 추상화는 속성들의 일부분만으로, 주어진 작업이나 객체를 필요한 정도로만 묘사하는 것이다. 예를 들어 <code class="language-plaintext highlighter-rouge">int x;</code>라는 구문이 있을 때, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">;</code>는 해당 단어나 기호를 아는 사람들에게 있어 어떤 의미를 가진다는 것을 유추할 수 있게끔 한다. 그리고 컴퓨터 역시 예약어인 <code class="language-plaintext highlighter-rouge">int</code>나 <code class="language-plaintext highlighter-rouge">;</code>가 어떤 의미를 가질 때, 그리고 <code class="language-plaintext highlighter-rouge">x</code>라는 단어가 쓰였을 때 어떤 일련의 작업, 즉 명령의 순차적 실행, 위치를 표현할 변수의 사용, 그리고 변수의 값을 변경하는 배정문의 사용 등을 진행하면 되는지 알고 있다.</p>

<p>이 ‘사람이 읽을 수 있는 형식으로’라는 조건은 계산을 서술하는 방식에도 영향을 미쳤다. 앞서 설명한 일련의 흐름을 그대로 진행하는 언어는 절차 언어 (<code class="language-plaintext highlighter-rouge">Procedural Language</code>)라고 부른다. 하지만, 절차 언어는 계산이 순차적인 명령에 의하여 실행되어야 하기 때문에 공유 버스 (<code class="language-plaintext highlighter-rouge">Shared Bus</code>) 내에서 폰 노이만 병목 현상이 발생한다. <code class="language-plaintext highlighter-rouge">RAM</code>과 <code class="language-plaintext highlighter-rouge">CPU</code>의 속도 차이가 발생하는 하드웨어적 한계를 극복하지 못한 것이다. 또한 절차 언어는 많은 자료를 동시에 적용하는 연산, 아직 계산할 값이 아직 할당되지 않은 비결정적인 연산, 혹은 순서에 의존하지 않는 비절차적인 연산을 기술하는 데에 비효율적이다. 그래서 이 한계를 극복하기 위해 나온 방식이 바로 함수형 언어와 논리형 언어이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 절차형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램

// 단계 1: 사용자로부터 두 수를 입력받기
var num1 = parseFloat(prompt("첫 번째 숫자를 입력하세요:"));
var num2 = parseFloat(prompt("두 번째 숫자를 입력하세요:"));

// 단계 2: 입력받은 수를 더하기
var sum = addNumbers(num1, num2);

// 단계 3: 결과 출력
alert("두 수의 합은 " + sum + "입니다.");

// 함수: 두 수를 더하는 함수 정의
function addNumbers(a, b) {
  return a + b;
}
</code></pre></div></div>

<p>함수형 언어 (<code class="language-plaintext highlighter-rouge">Functional Language</code>)는 알려진 값들을 함수들에 적용하는 것을 기반에 둔다. 함수형 언어에서의 계산은 아래의 예시와 재귀적 함수를 활용해 기술된다. 함수형 언어에서의 함수는 함수에 변수를 할당하거나 인자로 전달할 수 있는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class</code>)로 취급하면서, 주어진 입력에 대해 항상 동일한 출력을 생성하는 불변성 (<code class="language-plaintext highlighter-rouge">Immutability</code>)의 특성을 가진다. 실제로 함수형 언어는 변수나 변수에 대한 배정문이 존재하지 않는 대신 함수와 함수를 평가하고 호출하는 방법을 제공한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 함수형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램

// 단계 1: 사용자로부터 두 수를 입력받기
var num1 = parseFloat(prompt("첫 번째 숫자를 입력하세요:"));
var num2 = parseFloat(prompt("두 번째 숫자를 입력하세요:"));

// 단계 2: 두 수를 더하는 함수 정의
function addNumbers(a, b) {
  return a + b;
}

// 단계 3: 입력받은 수를 더하기
var sum = addNumbers(num1, num2);

// 단계 4: 결과 출력
alert("두 수의 합은 " + sum + "입니다.");
</code></pre></div></div>

<p>논리형 언어 (<code class="language-plaintext highlighter-rouge">Logical Language</code>)은 논리적인 규칙과 규칙 간의 관계를 정의해, 순서가 아닌 무엇을 하고자 하려는지 기술하는 방식으로, 계산의 내용만을 선언하듯이 기술한다. 그렇기 때문에 논리형 언어는 선언적 언어 (<code class="language-plaintext highlighter-rouge">Declarative Language</code>)로 불리기도 한다. 그래서 논리형 언어에서의 변수는 기억 장소의 위치보다는 계산 과정의 중간 결과 값에 대한 이름의 성격이 강하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 규칙 정의
function isHuman(animal) {
  return animal.species === 'Human';
}

function canSpeak(animal) {
  return animal.canSpeak === true;
}

// 사람 객체 생성
const person = {
  species: 'Human',
  canSpeak: true
};

// 규칙을 통한 논리적 추론
if (isHuman(person) &amp;&amp; canSpeak(person)) {
  console.log('This is a speaking human.');
} else {
  console.log('This is not a speaking human.');
}
</code></pre></div></div>

<p>객체 지향 (<code class="language-plaintext highlighter-rouge">Object-Oriented</code>) 언어는 여기서 한 발 더 나아가, 프로그램을 단순히 데이터와 이를 처리하는 방법으로 나누지 않고 수많은 객체들의 집합으로 보았다. 메소드와 변수를 가지는 객체라는 추상적인 개념을 프로그램에 도입하고 이를 객체의 상호 작용으로 봄으로써, 이전에 존재하던 지나치게 많은 이름의 생성으로 인한 네임스페이스 포화 문제를 해결하고 큰 문제를 작은 문제를 하기 위한 객체들로 해결하는 상향식 (<code class="language-plaintext highlighter-rouge">Bottom-up</code>) 해결 방식을 적용하는 것이 가능해졌다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 클래스 정의
class Animal {
  constructor(species, canSpeak) {
    this.species = species;
    this.canSpeak = canSpeak;
  }
}

// Human 클래스 정의, Animal 클래스를 상속받음
class Human extends Animal {
  constructor(canSpeak) {
    // Human은 species가 'Human'으로 고정된다고 가정
    super('Human', canSpeak);
  }

  isSpeakingHuman() {
    return this.species === 'Human' &amp;&amp; this.canSpeak === true;
  }
}

// 사람 객체 생성
const person = new Human(true);

// 객체지향 방식의 논리적 추론
if (person.isSpeakingHuman()) {
  console.log('This is a speaking human.');
} else {
  console.log('This is not a speaking human.');
}
</code></pre></div></div>

<p>이제 다시 자바스크립트가 탄생하던 시점으로 돌아오자. 자바스크립트가 탄생한 시점에는 이전에 정적으로만 존재하던 페이지가 브라우저를 통해 동적으로 페이지를 변경하는 방식이 공개되면서 브라우저에서 사용할 언어나 기술이 요구되고 있었다. <code class="language-plaintext highlighter-rouge">Java Applet</code>처럼 웹 브라우저에 <code class="language-plaintext highlighter-rouge">Java</code> 어플리케이션을 내장해 동적인 페이지를 제공하는 방식으로 동작하는 기술이 있었지만, 성능 및 보안 이슈가 존재하였다. 이때 자바스크립트는 강력한 추상화와 인터프리터 방식를 내세워 꾸준히 개발자들을 유입하였고, <code class="language-plaintext highlighter-rouge">Ajax</code>와 <code class="language-plaintext highlighter-rouge">JQuery</code>, <code class="language-plaintext highlighter-rouge">Node.js</code>를 통해 기존에 가진 문제점 또한 개선해나갔다.</p>

<p>자바스크립트의 강력한 추상화는 앞서 언급한 여러 언어들의 장점들을 채택하는 데에서 비롯되었다. 자바스크립트는 함수형 언어라고 부르지만, 객체나 함수를 통한 추상화를 지원하면서 변수를 선언할 때 타입을 명시적으로 지정할 필요가 없는 동적 타이핑 (<code class="language-plaintext highlighter-rouge">Dynamic Typing</code>) 또한 지원한다. 또한 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">Ajax</code>와 같은 비동기 이벤트의 처리를 위해 콜백 (<code class="language-plaintext highlighter-rouge">Callback</code>)과 프로미스 (<code class="language-plaintext highlighter-rouge">Promises</code>) 또한 지원한다.</p>

<p>인터프리터 방식은 소스 코드를 한 줄씩 기계어로 번역하는 방식이므로 컴파일 방식에 비해 속도는 느리지만, 어떤 코드를 작성한 다음 바로 실행하여 문제가 있으면 바로 수정할 수 있는 디버깅이 가능하다. 그리고 반복적으로 쓰이는 함수, 클래스의 기계어를 캐싱하는 <code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러를 인터프리터에 내장하여 속도 또한 이전에 비해 개선되었다. <code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러를 통해 오류가 있어도 그전까지 계속 실행되거나 오류를 오류로 처리하지 않는 경우 또한 줄어들었다.</p>

<blockquote>
  <ol>
    <li>파싱 (<code class="language-plaintext highlighter-rouge">Parsing</code>) : 소스 코드가 먼저 브라우저 엔진에 의해 파싱되어 코드의 문법적 구조를 이해하기 위한 토큰들이 생성</li>
    <li><code class="language-plaintext highlighter-rouge">AST</code> (<code class="language-plaintext highlighter-rouge">Abstract Syntax Tree</code>) 생성 : 파싱된 토큰들은 코드의 추상 구문을 나타내는 트리 구조인 <code class="language-plaintext highlighter-rouge">AST</code>로 변환</li>
    <li>바이트코드 생성 : 코드를 실행 가능한 형태로 변환하기 위한 중간 단계의 표현 생성</li>
    <li>(<code class="language-plaintext highlighter-rouge">JIT</code> 컴파일) 후 실행 : 변환된 코드는 런타임 환경에서 실행되거나, <code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러에 의해 기계 코드로 컴파일되어 실행</li>
  </ol>
</blockquote>

<p>그리고 인터프리터 방식의 장점 중 하나는 프로그래밍 언어의 설계가 쉽다는 점이다. 컴파일 언어가 설계되려면 기계어에 대한 이해가 필요하지만, 스크립트 언어는 컴파일 언어나 심지어 스크립트 언어를 통해 구현될 수 있다. 타입스크립트가 바로 대표적인 예시로, 최근에는 앞서 정의한 타입스크립트 문법을 활용해 다시 문법을 만드는 것 또한 이루어지고 있다.</p>

<p>그렇다면 자바스크립트가 브라우저에서 어떻게 동작하는 걸까? 클라이언트 측에서 동작하는 자바스크립트는 브라우저가 웹 페이지를 로딩할 때 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 태그를 통해 위의 컴파일 과정이 이루어진 다음에 단일 스레드로 동작하며, 이벤트 기반 비동기 모델을 활용한다. 이런 비동기 작업을 위해 브라우저는 추가로 이벤트 큐와 이벤트 루프를 활용하고 자바스크르립트 또한 콜백 함수와 <code class="language-plaintext highlighter-rouge">Ajax</code> 처리를 지원한다.</p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 1일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[MicroService] 5. MicroService Design</title><link href="http://localhost:4000/microservice5/" rel="alternate" type="text/html" title="[MicroService] 5. MicroService Design" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/microservice5</id><content type="html" xml:base="http://localhost:4000/microservice5/"><![CDATA[<h2 id="마이크로서비스-설계--응집성-높게-high-cohesion-의존도-낮게-low-coupling">마이크로서비스 설계 : 응집성 높게 (<code class="language-plaintext highlighter-rouge">High Cohesion</code>), 의존도 낮게 (<code class="language-plaintext highlighter-rouge">Low Coupling</code>)</h2>

<ul>
  <li>마이크로서비스의 내부 구조를 구성하는 각 요소들은 역할별로 모듈화 (<code class="language-plaintext highlighter-rouge">Modulation</code>)되어야 함
    <ol>
      <li>자체적인 응집도가 높고, 서로 간의 의존성이 낮은 모듈들이 모여 하나의 마이크로서비스를 이룸</li>
      <li>하나의 마이크로서비스는 다른 마이크로서비스와 의존성이 낮아야 함</li>
    </ol>
  </li>
</ul>

<p>→ 마이크로서비스를 구성하는 각각의 요소들을 모두 유연해야 한다.</p>

<h3 id="마이크로서비스를-도출하는-방법">마이크로서비스를 도출하는 방법</h3>

<ul>
  <li></li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[마이크로서비스 설계 : 응집성 높게 (High Cohesion), 의존도 낮게 (Low Coupling)]]></summary></entry><entry><title type="html">[SpringBoot] 1. SpringBoot</title><link href="http://localhost:4000/springboot1/" rel="alternate" type="text/html" title="[SpringBoot] 1. SpringBoot" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/springboot1</id><content type="html" xml:base="http://localhost:4000/springboot1/"><![CDATA[<h2 id="객체지향-프로그래밍-oop---프로그램을-일련의-독립된-객체들로-이해하는-프로그래밍-방법론">객체지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">OOP</code>) :  프로그램을 일련의 독립된 객체들로 이해하는 프로그래밍 방법론</h2>

<ul>
  <li>캡슐화 (<code class="language-plaintext highlighter-rouge">Encapsulation</code>) : 변수와 함수를 하나의 단위로 묶는 것</li>
  <li>정보 은닉 (<code class="language-plaintext highlighter-rouge">Information Hiding</code>) : 프로그램의 구현을 외부로 드러나지 않게 내부로 감추는 것</li>
  <li>상속 (<code class="language-plaintext highlighter-rouge">Inheritance</code>) : 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것</li>
  <li>다형성 (<code class="language-plaintext highlighter-rouge">Polymorphism</code>) : 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석되는 것</li>
</ul>

<h3 id="객체지향-5원칙-solid--객체자향을-올바르게-설계할-수-있도록-도와주는-원칙">객체지향 5원칙 (<code class="language-plaintext highlighter-rouge">SOLID</code>) : 객체자향을 올바르게 설계할 수 있도록 도와주는 원칙</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SRP</code> (<code class="language-plaintext highlighter-rouge">Single Responsibility Principle</code>) : 객체는 오직 하나의 책임을 가져야 한다.
    <ul>
      <li>클래스를 설계할 때 어플리케이션의 경계를 정하고, 추상화로 어플리케이션 내의 속성과 메소드를 설계해야 한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">OCP</code> (<code class="language-plaintext highlighter-rouge">Open Closed Principle</code>) : 객체는 확장에 대해 개방적이고 수정에 대해 폐쇄적이어야 한다.
    <ul>
      <li>클래스, 모듈, 함수와 연동할 때는 상위 클래스나 인터페이스를 중간에 두어 직접적인 연동을 피해야 한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">LSP</code> (<code class="language-plaintext highlighter-rouge">Liskov Substitution Principle</code>) : 자식 클래스는 항상 자신의 부모 클래스를 대체할 수 있다.
    <ul>
      <li>자식 클래스의 인스턴스는 부모 클래스의 인스턴스 역할을 대신할 때에도 논리적으로 문제가 없어야 한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ISP</code> (<code class="language-plaintext highlighter-rouge">Interface Segregation Principle</code>) : 클라이언트에서 사용하지 않는 메서드는 사용해선 안 된다.
    <ul>
      <li>각 상황에 맞는 메소드만 클래스에게 제공하도록 인터페이스를 작게 나누어 설계해야 한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DIP</code> (<code class="language-plaintext highlighter-rouge">Dependency Inversion Principle</code>) : 자신보다 변하기 쉬운 것에 의존해선 안된다.
    <ul>
      <li>추상성이 높고 고수준의 클래스는 구체적이고 저수준의 클래스에 의존하지 않도록 설계해야 한다.</li>
    </ul>
  </li>
</ol>

<h3 id="자바-빈-java-bean--자바-객체를-재사용-가능하도록-컴포넌트화한-클래스">자바 빈 (<code class="language-plaintext highlighter-rouge">Java Bean</code>) : 자바 객체를 재사용 가능하도록 컴포넌트화한 클래스</h3>

<ul>
  <li>클래스는 반드시 패키지화되어야 한다.</li>
  <li>멤버변수는 프로퍼티 (<code class="language-plaintext highlighter-rouge">Property</code>) 라고 부른다.</li>
  <li>프로퍼티의 접근 제어자는 <code class="language-plaintext highlighter-rouge">private</code>이다.</li>
  <li>데이터를 저장하는 필드와 그 데이터를 조작하기 위한 외부에서의 접근은 <code class="language-plaintext highlighter-rouge">getter</code>와 <code class="language-plaintext highlighter-rouge">setter</code> 메소드로 한다.</li>
  <li>프로퍼티가 <code class="language-plaintext highlighter-rouge">boolean</code>이면, <code class="language-plaintext highlighter-rouge">get</code>가 아닌 <code class="language-plaintext highlighter-rouge">is</code>를 사용해도 된다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MemberInfo {
  private int id;
  private String Name;
  private String pw;
  
  public int getId() { return id; }
  public void setId(int id) { this.id = id; }
  public String getName() { return Name; }
  public void setName(String name) { this.Name = name; }
  public String getPw() { return pw; }
  public void setPw(String pw) { this.pw = pw; }
}
</code></pre></div></div>

<blockquote>
  <p>… 서버 사이드에서 어플리케이선을 개발할 때 자바 빈만으로 해결하지 못하는 문제가 발생한다.</p>

  <ul>
    <li>기존 어플리케이션에 필요한 비즈니스 로직만이 아닌, <code class="language-plaintext highlighter-rouge">DB</code>와 트랜젝션 처리를 위한 프로그램이 추가로 필요하다.</li>
    <li>각각의 어플리케이션 서버에는 독자적인 <code class="language-plaintext highlighter-rouge">API</code>이 제공되기에 어플리케이션의 컴포넌트화가 어렵다.</li>
  </ul>
</blockquote>

<h3 id="ejb-j2ee--비즈니스-로직과-시스템-서비스-로직을-분산하고-로직-간의-규약을-규정"><code class="language-plaintext highlighter-rouge">EJB</code>, <code class="language-plaintext highlighter-rouge">J2EE</code> : 비즈니스 로직과 시스템 서비스 로직을 분산하고, 로직 간의 규약을 규정</h3>

<ul>
  <li>비즈니스 로직을 탑재한 부품을 <code class="language-plaintext highlighter-rouge">Enterprise Bean</code>이라 부른다.</li>
  <li><code class="language-plaintext highlighter-rouge">DB</code>와 트랙젝션 처리 등의 시스템 서비스를 이용하는 부품을 컨테이너 (<code class="language-plaintext highlighter-rouge">Container</code>)라 부른다.</li>
  <li>비즈니스 객체들을 관리하는 <code class="language-plaintext highlighter-rouge">EJB</code> 컨테이너에서 필요할 때마다 객체를 꺼내는 방식으로 객체들 간의 의존성을 해결한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Stateless
public class Service {

  @PersistenceContext
  private Manager Manager;

  public void addCustomer(Customer customer) {
    Manager.persist(customer);
  }
}
</code></pre></div></div>

<blockquote>
  <p>… <code class="language-plaintext highlighter-rouge">EJB</code>는 비즈니스 로직이 특정 <code class="language-plaintext highlighter-rouge">EJB</code> 컨테이너에 종속되는 문제가 발생한다. (→ 기술 침투)</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">EJB</code> 컨테이너를 사용하기 위한 코드 (상속 &amp; 구현)들이 많고, <code class="language-plaintext highlighter-rouge">EJB</code> 컨테이너가 없으면 불필요한 코드가 된다.</li>
    <li>회사마다 <code class="language-plaintext highlighter-rouge">EJB</code> 컨테이너를 구현한 내용이 달라 다른 회사의 <code class="language-plaintext highlighter-rouge">EJB</code> 컨테이너로의 변경이 어렵다.</li>
  </ul>

  <p>→ 회사마다 다르고 복잡한 자바 엔터프라이즈 어플리케이션의 개발을 하나로 단순화하자!</p>
</blockquote>

<h3 id="스프링-spring--자바-java-기반의-웹-프레임워크-web-framework">스프링 (<code class="language-plaintext highlighter-rouge">Spring</code>) : 자바 (<code class="language-plaintext highlighter-rouge">JAVA</code>) 기반의 웹 프레임워크 (<code class="language-plaintext highlighter-rouge">Web Framework</code>)</h3>

<ul>
  <li>순수 자바 객체 (<code class="language-plaintext highlighter-rouge">Plain Old Java Object</code>) 방식 : <code class="language-plaintext highlighter-rouge">POLO</code>
    <ul>
      <li>인터페이스를 직접 구현하거나 상속받지 않아 기존 라이브러리 지원에 용이하고, 코드가 간결하며 객체가 가벼움</li>
    </ul>
  </li>
  <li>관점지향 프로그래밍 (<code class="language-plaintext highlighter-rouge">Aspect Oriented Programming</code>) : <code class="language-plaintext highlighter-rouge">AOP</code>
    <ul>
      <li>로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리할 수 있음</li>
    </ul>
  </li>
  <li>의존성 주입 (<code class="language-plaintext highlighter-rouge">Dependency Injection</code>) : <code class="language-plaintext highlighter-rouge">DI</code>
    <ul>
      <li>프로그래밍 구성 요소 간 의존 관계를 코드 밖에서 설정을 통해 정의해, 재사용률을 높이고 모듈 간 결합도를 낮춤</li>
    </ul>
  </li>
  <li>제어의 역전 (<code class="language-plaintext highlighter-rouge">Inversion of Control</code>) : <code class="language-plaintext highlighter-rouge">IoC</code>
    <ul>
      <li>객체의 생성부터 소멸까지의 제어권이 프레임워크에게 있어, 외부 라이브러리 코드가 개발자의 코드를 호출</li>
    </ul>
  </li>
  <li>모델-뷰-컨트롤러 (<code class="language-plaintext highlighter-rouge">Model-View-Controller</code>) : <code class="language-plaintext highlighter-rouge">MVC</code> 패턴
    <ul>
      <li>사용자 인터페이스, 데이터 및 논리 제어의 구현에 사용되는 소프트웨어 디자인 패턴</li>
    </ul>
  </li>
  <li>모듈화 디자인 (<code class="language-plaintext highlighter-rouge">Modulation</code>) : 한 프레임워크을 여러 기능적 구성요소 (<code class="language-plaintext highlighter-rouge">Module</code>)로 조합해 완성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Core</code> : 제어의 역전 (<code class="language-plaintext highlighter-rouge">IOC</code>)과 의존성 주입 (<code class="language-plaintext highlighter-rouge">DI</code>) 기능 제공</li>
      <li><code class="language-plaintext highlighter-rouge">DAO</code> : 자바 데이터베이스 커넥터 (<code class="language-plaintext highlighter-rouge">JDBC</code>) 추상 계층 제공 (<code class="language-plaintext highlighter-rouge">VO</code> 클래스로 접근)</li>
      <li><code class="language-plaintext highlighter-rouge">ORM</code> : <code class="language-plaintext highlighter-rouge">ORM</code>이나 데이터베이스 <code class="language-plaintext highlighter-rouge">API</code>와의 통합 기능 제공</li>
      <li><code class="language-plaintext highlighter-rouge">Web</code> : 웹 어플리케이션 구현과 관련된 기능 제공</li>
      <li><code class="language-plaintext highlighter-rouge">JEE</code> : 엔터프라이즈 <code class="language-plaintext highlighter-rouge">J2EE</code> 스펙과 관한 기능 제공</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>… 스프링 프레임워크가 나왔지만 여전히 개발자가 신경써야 할 일이 많다.</p>

  <ul>
    <li>서블릿 (<code class="language-plaintext highlighter-rouge">Servlet</code>)에 대한 이해와 서블릿의 배포를 위해 필요한 <code class="language-plaintext highlighter-rouge">web.xml</code>에 대한 이해</li>
    <li>어플리케이션 컴포넌트를 패키징한 <code class="language-plaintext highlighter-rouge">WAR</code>, <code class="language-plaintext highlighter-rouge">EAR</code> 디렉터리 구조에 대한 지식</li>
    <li>도메인, 포트, 스레드, 데이터 소스 등 어플리케이션을 배포할 때에 필요한 서버 지식</li>
    <li>복잡한 클래스 로딩 전략, 어플리케이션 모니터링, 유지 관리, 로깅 처리</li>
  </ul>

  <p>→ 어플리케이션에 비즈니스 로직을 작성하고, 실행 가능한 파일로 만들어 커맨드라인으로 바로 실행하자!</p>
</blockquote>

<h2 id="스프링부트-springboot--스프링-프레임워크-기술을-편리하게-사용할-수-있도록-지원">스프링부트 (<code class="language-plaintext highlighter-rouge">SpringBoot</code>) : 스프링 프레임워크 기술을 편리하게 사용할 수 있도록 지원</h2>

<ul>
  <li>빠른 구동 (<code class="language-plaintext highlighter-rouge">Quick Run</code>) : 어플리케이션에 필요한 의존 관계만 명시하면, 어플리케이션을 빠르게 실행할 수 있음
    <ul>
      <li>스프링 <code class="language-plaintext highlighter-rouge">MVC</code> 의존 관계를 추가하고 메이븐 혹은 그레이들 프로젝트 설정</li>
      <li>스프링 <code class="language-plaintext highlighter-rouge">MVC</code>의 <code class="language-plaintext highlighter-rouge">DispatcherServlet</code>의 설정</li>
      <li>어플리케이션 컴포넌트를 <code class="language-plaintext highlighter-rouge">WAR</code> 파일로 패키징</li>
      <li><code class="language-plaintext highlighter-rouge">WAR</code> 파일을 아파치 톰캣 (<code class="language-plaintext highlighter-rouge">Apache Tomcat</code>) 같은 서블릿 컨테이너에 배포</li>
    </ul>
  </li>
  <li>자동 구성 (<code class="language-plaintext highlighter-rouge">Auto Configuration</code>) : 어플리케이션에 필요한 최소한의 컴포넌트를 대신해서 설정
    <ul>
      <li>클래스패스에 있는 <code class="language-plaintext highlighter-rouge">JAR</code> 파일이나 여러 설정 파일에 지정된 프로퍼티 정보를 바탕으로 구성</li>
      <li><code class="language-plaintext highlighter-rouge">XML</code> 파일을 자체적으로 빌드하여 스프링 프로젝트 내 객체 의존성 관리를 자동화</li>
      <li>스프링 외부에 존재하는 라이브러리 또한 가져와 자동으로 구성</li>
    </ul>
  </li>
  <li>미리 정의된 방식 (<code class="language-plaintext highlighter-rouge">Opinionated</code>) : 어플리케이션 실행에 필요한 컴포넌트들을 <code class="language-plaintext highlighter-rouge">starter</code> 의존 관계를 기준으로 구성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">spring-boot-starter-web</code>만 추가하면, 웹 어플리케이션 개발에 필요한 의존 관계를 클래스패스에 모두 넣어줌</li>
    </ul>
  </li>
  <li>독립 실행형 (<code class="language-plaintext highlighter-rouge">Standalone</code>) : 어플리케이션에 웹 서버를 내장하여 독립적으로 실행 가능
    <ul>
      <li>실행 가능한 <code class="language-plaintext highlighter-rouge">JAR</code> 파일로 패키징 → <code class="language-plaintext highlighter-rouge">java -jar</code> 명령어로 실행 가능</li>
      <li>어플리케이션이 쉽게 컨테이너화될 수 있어 클라우드 네이티브 (<code class="language-plaintext highlighter-rouge">Cloud Native</code>)에도 적합</li>
    </ul>
  </li>
  <li>실제 서비스 환경에 사용 가능 (<code class="language-plaintext highlighter-rouge">Production-Ready</code>)
    <ul>
      <li>헬스 체크 (<code class="language-plaintext highlighter-rouge">Health Check</code>)나 스레드 덤프 (<code class="language-plaintext highlighter-rouge">Thread</code>) 분석을 통한 어플리케이션 모니터링 기능 제공</li>
      <li>매트릭 (<code class="language-plaintext highlighter-rouge">Metric</code>), 상태 확인, 외부 구성과 같은 프로덕션 준비 기능 제공</li>
    </ul>
  </li>
</ul>

<h3 id="스프링부트-컴포넌트-springboot-components--어플리케이션-개발의-특정-영역에-특화된-요소">스프링부트 컴포넌트 (<code class="language-plaintext highlighter-rouge">SpringBoot Components</code>) : 어플리케이션 개발의 특정 영역에 특화된 요소</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring-boot</code> : 스프링부트의 기본 컴포넌트로서, 다른 컴포넌트를 사용할 수 있도록 지원
    <ul>
      <li>톰캣 (<code class="language-plaintext highlighter-rouge">Tomcat</code>)과 같은 내장 웝 서버 기능</li>
      <li>데이터베이스 연결 정보와 같은 어플리케이션 설정 정보를 외부화하는 기능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-autoconfigure</code> : 어플리케이션에 필요한 의존 관계의 자동 구성을 담당
    <ul>
      <li>클래스패스와 설정 파일의 포로퍼티에 저장된 의존 관계를 바탕으로 스프링 빈 (<code class="language-plaintext highlighter-rouge">Spring Boot</code>)을 추론해 생성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-starters</code> : 개발의 편의를 위해 제공하는 미리 패키징된 의존 관셰 기술서의 모음</li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-CLI</code> : 그루브 코드를 컴파일하고 실행할 수 있는, 관리자 친화적 명령행 도구
    <ul>
      <li>어플리케이션에 수정 사항이 발생할 때마다 파일 내용의 변경 감지</li>
      <li>의존 관계 관리나 빌드 관련 문제에 대한 걱정 없이 프로트타입 어플리케이션을 빠르게 만들 수 있게 해줌</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-actuator</code> : 어플리케이션을 모니터링하고 검사 가능한 엑추에이터 엔드포인트 제공
    <ul>
      <li><code class="language-plaintext highlighter-rouge">JMX</code>나 <code class="language-plaintext highlighter-rouge">HTTP</code> 엔드포인트로 관리할 수 있음</li>
      <li>어플리케이션의 여러 측면의 상태를 감지할 수 있도록 미리 정의된 형태의 다양한 엑추에이터 엔드포인드들을 제공</li>
      <li>커스텀 엑추에이터 엔드포인트를 추가하거나, 엑추에이터 엔드포인트의 활성화 여부를 설정할 수 있음</li>
      <li>인가되지 않은 접근으로부터 엔드포인트를 보호할 수도 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-actuator-autoconfigure</code> : 클래스패스에 있는 클래스를 기반으로 엑추에이터 엔드포인트를 자동 구성
    <ul>
      <li>의존 관계가 클래스패스에 있으면, 이에 해당되는 것을 엑추에이터 엔드포인트로 추가</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-test</code> : 테스트 케이스의 작성에 필요한 에너테이션 (<code class="language-plaintext highlighter-rouge">annotation</code>) 및 메소드 포함</li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-test-autoconfigure</code> : 어플리케이션의 테스트 케이스에 필요한 의존 관계를 자동 구성</li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-loader</code> : 어플리케이션을 <code class="language-plaintext highlighter-rouge">JAR</code> 파일로 패키징하기 위해 필요한 모든 의존 관계와 내장 웹 서버를 포함
    <ul>
      <li>독립적으로 사용되지 않고 메이븐이나 그레이들 플러그인과 함께 사용</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-boot-devtools</code> : 어플리케이션 개발을 돕는 여러 개발자 도구들</li>
</ul>

<h3 id="스프링부트-프로젝트-구조--스프링-이니셜라이저-spring-initializr로-자동-생성">스프링부트 프로젝트 구조 : 스프링 이니셜라이저 (<code class="language-plaintext highlighter-rouge">Spring Initializr</code>)로 자동 생성</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pom.xml / build.gradle</code> : 스프링 이니셜라이저에서 스프링부트 프로젝트를 생성할 때 지정한 의존 관계가 들어 있음
    <ul>
      <li>메이븐 (<code class="language-plaintext highlighter-rouge">Maven</code>) 혹은 그레이들 (<code class="language-plaintext highlighter-rouge">Gradle</code>)과 같은 빌드 도구를 통해 빌드 가능</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;  &lt;!-- spring-boot-starter-parent : 스타터 의존 관계나 플러그인에 대한 기본 설정 제공 및 관리 --&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.2.1&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- 메이븐 리포지토리에서 parent를 가져옴 --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;pocj8ur4in&lt;/groupId&gt;  &lt;!-- 프로젝트 아티펙트 정보 --&gt;
    &lt;artifactId&gt;test&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;pocj8ur4inTest&lt;/name&gt;
    &lt;description&gt;pocj8ur4inTest&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;21&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;  &lt;!-- dependencies : 스타터 의존 관계들을 선언 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;  &lt;!-- JUnit, Mockito 등으올 스프링부트 어플리케이션 테스트를 지원 --&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;  &lt;!-- plugins : 플러그인들을 선언 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre></div></div>

<blockquote>
  <p>빌드 플러그인을 통한 스프링부트 어플리케이션의 실행 흐름</p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">resource-plugin</code>의 호출 : <code class="language-plaintext highlighter-rouge">src/main/java</code>의 소스 파일들을 빌드 결과가 저장될 디렉터리에 복사</li>
    <li><code class="language-plaintext highlighter-rouge">compiler-plugin</code>의 호출 : 어플리케이션을 시작하기 전에 소스 코드를 컴파일</li>
  </ol>

  <p>→ 빌드 플러그인은 저수준의 세부 작업을 모두 추상화하여 개발자가 쉽게 사용할 수 있게끔 해줌</p>
</blockquote>

<ul>
  <li>래퍼 (<code class="language-plaintext highlighter-rouge">wrapper</code>) 파일 : 빌드 도구를 로컬에 설치하지 않고 프로젝트를 빌드할 수 있게 해줌</li>
  <li>패키지 (<code class="language-plaintext highlighter-rouge">Packages</code>) 구조 : 자바 클래스를 포함하는 소스 패키지와 테스트 클래스를 포함하는 테스트 패키지로 분리</li>
  <li><code class="language-plaintext highlighter-rouge">application.properties</code> 파일이 존재하는 리소스 (<code class="language-plaintext highlighter-rouge">resource</code>) 폴더 : 프로젝트를 진행하면서 사용할 파일들</li>
</ul>

<h4 id="스프링부트-메인-클래스-main-class--패키지-내에서-어플리케이션-실행을-담당">스프링부트 메인 클래스 (<code class="language-plaintext highlighter-rouge">Main Class</code>) : 패키지 내에서 어플리케이션 실행을 담당</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package pocj8ur4in.vocawik;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class VocawikApplication {
    public static void main(String[] args) {
        SpringApplication.run(VocawikApplication.class, args);
    }
}
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">main()</code> 메소드 : 웹 어플리케이션을 실행하는 메소드
    <ul>
      <li>어플리케이션 컴포넌트를 빌드 및 패키징한 <code class="language-plaintext highlighter-rouge">WAR / EAR</code> 파일을 만들어 웹 서버에 배포할 필요가 없음</li>
      <li>전통적인 자바 어플리케이션을 실행하는 것처럼 웹 어플리케이션을 실행할 수 있음</li>
    </ul>
    <ul>
      <li>별도의 서블릿 컨테이너를 실행하지 않고, 스프링부트 어플리케이션이 내장된 서블릿 컨테이너 안에서 실행됨
        <ul>
          <li><code class="language-plaintext highlighter-rouge">spring-boot-starter-web</code>이 <code class="language-plaintext highlighter-rouge">spring-boot-starter-tomcat</code> 모듈에 대한 의존 관계를 포함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@SpringBootApplication</code> 어노테이션 : 루트 패키지부터 스프링 어노테이션이 붙은 컴포넌트를 탐색해 관리
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code> : 어플리케이션 클래스패스의 <code class="language-plaintext highlighter-rouge">JAR</code> 파일을 바탕으로 어플리케이션을 자동 구성</li>
      <li><code class="language-plaintext highlighter-rouge">@ComponentScan</code> : 어플리케이션에 존재하는 스프링 컴포넌트를 탐색
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Component</code>, <code class="language-plaintext highlighter-rouge">@Bean</code> 등이 붙은 자바 빈을 스프링에서 관리하기 위해 루트에서부터 탐색</li>
          <li><code class="language-plaintext highlighter-rouge">@ComponentScan(basePackage = {})</code>로 탐색 범위를 직접 지정할 수 있음
     - <code class="language-plaintext highlighter-rouge">@SpringBootConfiguration</code> : 스프링부트 어플리케이션 설정을 담당</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">@Configuration</code>를 내부적으로 포함하여, 컴포넌트 탐색을 통해 어플리케이션 설정 과정에 참여</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SpringApplication()</code> 클래스 : <code class="language-plaintext highlighter-rouge">run()</code> 정적 메소드를 통해 스프링부트 어플리케이션을 편리하게 실행</li>
</ol>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">run()</code> 메소드가 실행될 때 수행하는 적업의 흐름</p>

  <ol>
    <li>클래스패스에 있는 라이브러리를 기준으로 <code class="language-plaintext highlighter-rouge">SpringApplication</code> 클래스의 인스턴스 생성</li>
    <li><code class="language-plaintext highlighter-rouge">CommandLinePropertySource</code>를 등록해서 명령행 인자를 스프링 프로퍼티로 읽음</li>
    <li>1단계에서 생성한 <code class="language-plaintext highlighter-rouge">ApplicationContext</code>를 통해 싱글톤 빈 로딩</li>
    <li>어플리케이션에 설정된 <code class="language-plaintext highlighter-rouge">ApplicationRunner</code>와 <code class="language-plaintext highlighter-rouge">CommandRunner</code> 실행</li>
  </ol>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SpringApplication</code> 클래스는 클래스패스에 있는 <code class="language-plaintext highlighter-rouge">JAR</code>의 의존 관계를 바탕으로 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 인스턴스 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ApplicationContext</code>는 빈을 생성할 때 필요한 의존 관계 주입을 실행할 스프링 <code class="language-plaintext highlighter-rouge">IoC</code> 컨테이너의 역할을 담당</li>
      <li>클래스패스에 있는 클래스로 어플리케이션 타입이 서블릿 (<code class="language-plaintext highlighter-rouge">Servlet</code>) 혹은 리액티브 (<code class="language-plaintext highlighter-rouge">Reactive</code>)인지 유추</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>스프링부트가 <code class="language-plaintext highlighter-rouge">ApplicationContext</code>를 로딩할 때의 전략</p>

  <ol>
    <li>서블릿 기반 : <code class="language-plaintext highlighter-rouge">AnnotationConfigServletWebSErverApplicationContext</code> 클래스 인스턴스 생성</li>
    <li>리액티브 기반 : <code class="language-plaintext highlighter-rouge">AnnotationConfigReactiveWebServletApplicationContext</code> 클래스 인스턴스 생성</li>
    <li>둘다 아닐 경우 : <code class="language-plaintext highlighter-rouge">AnnotationConfigApplicationContext</code> 클래스 인스턴스 생성</li>
  </ol>
</blockquote>

<ul>
  <li>필요한 경우에 <code class="language-plaintext highlighter-rouge">SpringApplication</code> 클래스의 인스턴스를 직접 생성해 어플리케이션 시동 모드를 변경 가능</li>
  <li>스프링 프로파일 지정, 어플리케이션 리소스 리소스 로더 지정과 같은 기능을 <code class="language-plaintext highlighter-rouge">Setter</code> 메소드로 제공</li>
</ul>

<h4 id="applicationproperties-또는-applicationyml--어플리케이션의-설정-정보-관리"><code class="language-plaintext highlighter-rouge">application.properties</code> 또는 <code class="language-plaintext highlighter-rouge">application.yml</code> : 어플리케이션의 설정 정보 관리</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/main/resources/</code> 디렉토리에 자동으로 생성 (기본값은 <code class="language-plaintext highlighter-rouge">.properties</code>)</li>
  <li>서버 접속 정보, 데이터베이스 접속 정보와 같은 어플리케이션 설정 정보를 소스 코드에서 분리해서 외부화</li>
  <li>멀티 모듈을 구성하거나 배포 환경가 다중화된 경우에, 파일을 여러 개로 나누어 설정을 다르게 관리할 수 있음</li>
</ul>

<h3 id="jar-파일--스프링부트-프로젝트로부터-생성된-실행-가능한-파일"><code class="language-plaintext highlighter-rouge">JAR</code> 파일 : 스프링부트 프로젝트로부터 생성된 실행 가능한 파일</h3>

<ul>
  <li>설정한 패키징 방식에 따라 프로젝트의 <code class="language-plaintext highlighter-rouge">target</code> 디렉터리에 <code class="language-plaintext highlighter-rouge">.JAR</code> 파일 생성
    <ul>
      <li>메이븐은 <code class="language-plaintext highlighter-rouge">spring-boot-maven-plugin</code> 플러그인의 <code class="language-plaintext highlighter-rouge">repackage</code> 골 (<code class="language-plaintext highlighter-rouge">goal</code>)이 메이븐 <code class="language-plaintext highlighter-rouge">package</code> 라이프사이클과 연동되어, 컴파일된 클래스 파일 (<code class="language-plaintext highlighter-rouge">.class</code>)를 리패키징</li>
      <li>그레이들은 스프링부트 프로젝트를 빌드할 때 <code class="language-plaintext highlighter-rouge">org.springframework.boot</code> 플러그인이 생성한 <code class="language-plaintext highlighter-rouge">bootJar</code> 테스크가 그레이들 <code class="language-plaintext highlighter-rouge">build</code> 라이프사이클에 편입되어 패키징</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">java -jar</code> 명령의 인자로 지정하면 어플리케이션을 실행할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">ctrl+c</code> 등을 통해 자바 프로세스를 종료하면, 스프링부트 어플리케이션 또한 종료</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ef10695d-0893-4d9a-aadc-cc63f96841fb" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">META-INF</code> : 실행할 <code class="language-plaintext highlighter-rouge">JAR</code> 파일의 핵심 정보를 담고 있는 <code class="language-plaintext highlighter-rouge">MANIFEST.MF</code> 파일
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Start-Class</code> 패러미터 : 어플리케이션을 시작할 클래스를 지정</li>
      <li><code class="language-plaintext highlighter-rouge">Main-Class</code> 패러미터 :  <code class="language-plaintext highlighter-rouge">Start-Class</code>를 사용해서 어플리케이션을 시작하는 <code class="language-plaintext highlighter-rouge">Launcher</code> 클래스를 지정</li>
    </ul>
  </li>
  <li>스프링부트 로더 컴포넌트 : <code class="language-plaintext highlighter-rouge">JAR/WAR</code> 파일을 로딩하는 <code class="language-plaintext highlighter-rouge">JarLauncher/WarLauncher</code> 클래스
    <ul>
      <li><code class="language-plaintext highlighter-rouge">loader.*</code> 프로퍼티에 값을 지정하면, <code class="language-plaintext highlighter-rouge">PropertiesLauncher</code> 클래스로 클래스 로딩 과정 커스텀마이징 가능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">BOOT-INF/classes</code> : 컴파일된 모든 어플리케이션 클래스가 위치한 디렉터리</li>
  <li><code class="language-plaintext highlighter-rouge">BOOT-INF/lib</code>  : 의존 관계로 지정한 라이브러리가 들어있는 디렉터리</li>
  <li><code class="language-plaintext highlighter-rouge">classpath.idx</code> : 클래스로더가 로딩해야 하는 순서대로 정렬된 의존 관계 목록이 들어있음</li>
  <li><code class="language-plaintext highlighter-rouge">layer.idx</code> : 도커 이미지를 생성할 때 논리적 계층으로 <code class="language-plaintext highlighter-rouge">JAR</code>를 분할할 때 사용</li>
</ul>

<blockquote>
  <p>안전 종료 (<code class="language-plaintext highlighter-rouge">Graceful shutdown</code>) : 처리 중인 요청이 완료될 때까지 기다릴 타임아웃 설정</p>

  <ul>
    <li>어플리케이션을 종료할 때, 처리 중인 요청의 처리가 보장되지 않음</li>
    <li>종료 명령어 실행되면 더 이상의 요청을 받지 않되, 이미 처리 중인 요청은 완료를 보장해야 함</li>
    <li>스프링부트 <code class="language-plaintext highlighter-rouge">2.3.0</code>부터 도입되어, 그 이전 버전에서는 동작하지 않음</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server.shutdown=graceful # 기본값: immediate
spring.lifecycle.timeout-per-shutdown-phase=1m # 기본값: 30s
</code></pre></div>  </div>
</blockquote>

<h3 id="스프링부트-스타트업-이벤트--스프링-어플리케이션-시작-및-초기화-과정에서-사용-가능한-빌트인-이벤트">스프링부트 스타트업 이벤트 : 스프링 어플리케이션 시작 및 초기화 과정에서 사용 가능한 빌트인 이벤트</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ApplicationStartingEvent</code> : 어플리케이션이 시작되어 리스너 (<code class="language-plaintext highlighter-rouge">Listener</code>가 등록될 때 발행
    <ul>
      <li>스프링부트의 <code class="language-plaintext highlighter-rouge">LoggingSystem</code>이 해당 이벤트를 통해 어플리케이션 초기화 단계 이전에 필요한 작업 수행</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationEnvironmentPreparedEvent</code> : 어플리케이션이 시작되고 <code class="language-plaintext highlighter-rouge">Environment</code>가 준비될 때 발행
    <ul>
      <li><code class="language-plaintext highlighter-rouge">MessageConverter</code>, <code class="language-plaintext highlighter-rouge">ConversionService</code>, <code class="language-plaintext highlighter-rouge">Jackson</code>의 초기화 등 서비스 사전 초기화 (<code class="language-plaintext highlighter-rouge">PreInitialize</code>) 작업 수행</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationContextInitializedEvent</code> : <code class="language-plaintext highlighter-rouge">ApplicationContext</code>가 준비되고 <code class="language-plaintext highlighter-rouge">ApplicationContextInitializer</code>가 실행되면 발행
    <ul>
      <li>빈이 스프링 컨테이너에 로디오디어 초기화되기 전에 이루어질 작업이 필요할 때 이 이벤트를 사용</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationPreparedEvent</code> : <code class="language-plaintext highlighter-rouge">ApplicationContext</code>가 준비되고 빈이 로딩되었으나 <code class="language-plaintext highlighter-rouge">ApplicationContext</code>가 초기화되기 전에 발행
    <ul>
      <li>이 이벤트가 발행된 이후에 <code class="language-plaintext highlighter-rouge">Environment</code>를 사용할 수 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ContextRefreshedEvent</code> : <code class="language-plaintext highlighter-rouge">ApplicationContext</code>가 초기화된 이후에 발행
    <ul>
      <li>스프링부트가 아닌 스프링이 발행한 이벤트로, <code class="language-plaintext highlighter-rouge">SpringApplicationEvent</code>를 상속하지 않음</li>
      <li>스프링부트의 <code class="language-plaintext highlighter-rouge">ConditionEvaluationLoggingListener</code>가 이 이벤트가 발행되면 자동 구성 보고서를 출력</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">WebServerInitializedEvent</code> : 웹 서버가 준비되면 발행
    <ul>
      <li>스프링부트가 아닌 스프링이 발행한 이벤트로, <code class="language-plaintext highlighter-rouge">SpringApplicationEvent</code>를 상속하지 않음</li>
      <li>어플리케이션 타입에 따른 하위 이벤트가 존재 (<code class="language-plaintext highlighter-rouge">ServletServerInitializedEvent</code>, <code class="language-plaintext highlighter-rouge">ReactiveServerInitializedEvent</code>)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationStartedEvent</code> : <code class="language-plaintext highlighter-rouge">ApplicationContext</code>가 초기화되고 <code class="language-plaintext highlighter-rouge">ApplicationRunner</code>, <code class="language-plaintext highlighter-rouge">CommandLineRunner</code>가 호출되기 전에 발행</li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationReadyEvent</code> : 어플리케이션 요청 처리가 준비되었을 때 <code class="language-plaintext highlighter-rouge">SpringApplication</code>에 의해 발행
    <ul>
      <li>모든 어플리케이션 초기화가 완료된 이후에 발행 : 이후에 어플리케이션 내부 상태를 변경하는 것은 권장되지 않음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationFailedEvent</code> : 어플리케이션 시작 과정에서 예외가 발생하면 발행
    <ul>
      <li>예외 발생 시 스크립트를 실행하거나, 스타트업 실패를 알릴 때 사용</li>
    </ul>
  </li>
</ul>

<h3 id="스프링부트-어플리케이션-이벤트-감지--스프링부트-스타트업-이벤트가-제공하는-정보들을-활용하기-위해-이벤트를-구독">스프링부트 어플리케이션 이벤트 감지 : 스프링부트 스타트업 이벤트가 제공하는 정보들을 활용하기 위해 이벤트를 구독</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@EventListener</code> 어노테이션 : 스프링 프레임워크에서 제공하는 이벤트를 구독하는 어노테이션
    <ul>
      <li>어플리케이션 스타트업 극초기에 발행되는 이벤트는 감지하지 못함</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># @EventListener를 사용해서 ApplicationReadyEvent를 구독
@EventListener(ApplicationReadyEvent.class)
public void funcForApplicationReadyEvent(ApplicationReadyEvent applicationReadyEvent) {
  System.out.println("ApplicationReadyEvent generated at "
  + new Date(funcForApplicationReadyEvent.getTimestamp()));
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SpringApplication</code> 클래스 : 어플리케이션 스타트업을 커스텀마이징할 수 있는 <code class="language-plaintext highlighter-rouge">setter</code> 메소드를 통해 리스너 등록
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ApplicationListener</code> 인터페이스의 <code class="language-plaintext highlighter-rouge">onApplicationEvent</code> 메소드를 구현해 <code class="language-plaintext highlighter-rouge">SpringApplication</code>에 추가</li>
      <li><code class="language-plaintext highlighter-rouge">SpringApplication</code>에 리스너를 등록하거나 수정하는 것은 클래스 코드의 변경을 유발</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 커스텀 ApplicationListener 구현체 작성
public class ApplicationStartEventListener
 implements ApplicationListener&lt;ApplicationStartingEvent&gt; {
  @Override
  public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {
    System.out.println("Application Starting Event logged at "
    + new Date(applicationStartingEvent.getTimestamp()));
  }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># SpringApplication에 어플리케이션 이벤트 리스너 추가
@SpringBootApplication
public class SpringBootEventApplication {
  public static void main(String[] args) {
    SpringApplication springApplication
     = new SpringApplication(SpringBootEventApplication.class);
  }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring.factories</code> 파일 : 어플리케이션 기능 설정 및 커스터마이징을 가능하도록 스프링부트가 제공
    <ul>
      <li><del>스프링부트 이전부터 스프링 프레임워크에서 제공 (<code class="language-plaintext highlighter-rouge">spring-beans.jar</code>에서 확인 가능)</del> → 스프링부트 <code class="language-plaintext highlighter-rouge">2.7.0</code>부터 <code class="language-plaintext highlighter-rouge">deprecated</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=330484424">실전 스프링부트</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SpringBoot" /><summary type="html"><![CDATA[객체지향 프로그래밍 (OOP) : 프로그램을 일련의 독립된 객체들로 이해하는 프로그래밍 방법론]]></summary></entry><entry><title type="html">[MicroService] 4. Agile Development Process</title><link href="http://localhost:4000/microservice4/" rel="alternate" type="text/html" title="[MicroService] 4. Agile Development Process" /><published>2024-01-15T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/microservice4</id><content type="html" xml:base="http://localhost:4000/microservice4/"><![CDATA[<h2 id="에자일-개발-프로세스-agile-development-process--피드백을-통한-지속적인-개선-추구">에자일 개발 프로세스 (<code class="language-plaintext highlighter-rouge">Agile Development Process</code>) : 피드백을 통한 지속적인 개선 추구</h2>

<ul>
  <li>에자일 방법론 (<code class="language-plaintext highlighter-rouge">Agile Methodology</code>) : 신속한 반복 작업으로 소프트웨어를 지속적으로 제공하고자 함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CI/CD</code>, <code class="language-plaintext highlighter-rouge">DevOps</code> 등의 에자일 방법론 중심의 프랙티스</li>
      <li>효율적인 의사소통 구조와 협업 체계를 가진 다기능 팀으로 만듣 수 있는 결과물 → ‘마이크로서비스’</li>
      <li><code class="language-plaintext highlighter-rouge">XP</code>의 ‘지속적 통합’ 프랙티스 : 품질이 보장된 소프트웨어를 반복적으로 개발할 수 있게 함</li>
      <li>스크럼 프로세스 : ‘스크럼 팀’이라는 조직과 ‘스프린트’라는 짧은 반복 주기를 통해 피드백과 개선 작업을 촉진함</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">XP</code>나 스크럼을 살펴보면 개발 문화 및 관리 프로세스를 자세히 다루나, 설계 및 개발 공정에 대해 자세히 언급하지 않음</p>

  <ul>
    <li>에자일 자체가 성숙한 개발 문화에서 좋은 프랙티스을 가속화하고 기존 공정에서 낭비를 제거하는 방식으로 진행
      <ul>
        <li>개발 문화가 미성숙한 팀을 위해 기민한 반복 주기게 적합하며 핵심 활동에 집중할 수 있는 방법이 필요</li>
      </ul>
    </li>
  </ul>

  <p>→ <code class="language-plaintext highlighter-rouge">DDD</code>를 중심으로 에자일 프로세스와 연계하여 마이크로서비스를 설계 및 개발하는 공정이 필요하다!</p>
</blockquote>

<h3 id="기민한-설계-및-개발을-위한-절차--스크럼-기반-마이크로서비스-개발-프로세스">기민한 설계 및 개발을 위한 절차 → 스크럼 기반 마이크로서비스 개발 프로세스</h3>

<ul>
  <li>스크럼 (<code class="language-plaintext highlighter-rouge">Scrum</code>) : 프로젝트 개발 및 관리를 위한 에자일 개발 방법론 중 하나
    <ol>
      <li>제품 백로그 (<code class="language-plaintext highlighter-rouge">Product Backlog</code>) : 개발할 제품에 대한 요구 사항 목록</li>
      <li>스프린트 계획 회의 (<code class="language-plaintext highlighter-rouge">Sprint Planning Meeting</code>) : 스프린트 목표 및 스프린트 백로그를 계획하는 회의</li>
      <li>스프린트 백로그 (<code class="language-plaintext highlighter-rouge">Sprint Backlog</code>) : 각 스프린트 목표에 도달하기 위해 필요한 작업 목록</li>
      <li>스프린트 (<code class="language-plaintext highlighter-rouge">Sprint</code>) : 반복적인 개발 주기 (계획 회의부터 제품 리뷰가 진행되는 날짜까지의 기간 : 1~4주)</li>
      <li>일일 스크럼 회의 (<code class="language-plaintext highlighter-rouge">Daily Scrum Meeting</code>) : 어제 한 일, 오늘 할 일, 장애 등을 공유하는 회의</li>
      <li>시연 (<code class="language-plaintext highlighter-rouge">Testing</code>) : 초기에 정의한 백로그가 모두 구현되고 그 요건을 만족하는지 확인</li>
      <li>회고 (<code class="language-plaintext highlighter-rouge">Review</code>) : 팀원들이 자기 스스로를 돌아보면서 개선점을 논의하여 다음 스프린트에 적용</li>
    </ol>
  </li>
</ul>

<h4 id="구현-스프린트를-진행하기-위한-준비-및-계획--아키텍처-정의-및-마이크로서비스-도출">구현 스프린트를 진행하기 위한 준비 및 계획 → 아키텍처 정의 및 마이크로서비스 도출</h4>

<ul>
  <li>아키텍처 정의 : 마이크로서비스 내부/외부 아키텍처를 정의하는 공정 → 아키텍처 구성도
    <ul>
      <li>기존 워터풀 개발 방식과 달리, 기술 세부사항은 늦게 결정할 수 있어야 한다. (<code class="language-plaintext highlighter-rouge">Robert C. Martin</code>)</li>
      <li>그러나 최소한의 개발 및 테스팅 환경을 준비하는 게 바람직 : 스프린트에 실제 동작하는 어플리케이션 시연 가능
        <ul>
          <li>도커나 쿠버네티스, 스프링부트 등을 미리 결정한다면, 빠르게 개발 환경을 구축해 개발 과정에 진입 가능</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>마이크로서비스 도출 : 스크럼 팀이 개발할 전체 마이크로서비스를 파악하는 작업 → 컨텍스트 맵
    <ul>
      <li>모든 마이크로서비스를 하나의 스크럼 팀이 개발할 수 없음</li>
      <li><code class="language-plaintext highlighter-rouge">DDD</code>의 전략적 설계로 마이크로서비스를 도출하고, 그것들 간의 대략적인 매핑 관계를 정의해, 우선순위 산정</li>
    </ul>
  </li>
</ul>

<h4 id="백엔드와-프런트엔드-개발-공정의-접목--api-명세--도메인-모델링">백엔드와 프런트엔드 개발 공정의 접목 → <code class="language-plaintext highlighter-rouge">API</code> 명세 &amp; 도메인 모델링</h4>

<blockquote>
  <p>백엔드와 프런트엔드 영역 간 계악으로 해당 작업이 선행되고, 각각의 공정이 영역을 나누어서 진행</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">API</code> 명세 (<code class="language-plaintext highlighter-rouge">API Details</code>) : 각 백엔드 마이크로서비스가 프론트엔드에 제공할 서비스 명제들을 정리</li>
  <li>도메인 모델링 (<code class="language-plaintext highlighter-rouge">Domain Modeling</code>) : 화이트보드, 포스트잇 등으로 도메인 설계 모델을 작성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">OOAD</code> 방식과 다른 점? : <code class="language-plaintext highlighter-rouge">UML</code> 등으로 정형화된 설계 모델을 작성해 소스 코드로 변환하지 않음
        <ul>
          <li>단순한 도구들로 작성해 이를 공유하고 피드백을 받아 곧바로 소스 코드로 도메인을 개발</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">MDD</code>와 다른 점? : 추상적인 모델을 완벽히 만들고, 특정 기술이나 프레임워크를 통해 구체화하지 않음
        <ul>
          <li>코드 자체가 모델의 기본 표현 형식을 그대로 반영하므로, 모델과 코드가 단절되지 않음</li>
        </ul>
      </li>
      <li>핵심 도메인 모델을 이해시키기 위해 역공학 도구를 통해 <code class="language-plaintext highlighter-rouge">UML</code> 모델을 표현할 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="ui-레이아웃-정의-및-백엔드-api-호출--프론트엔드-영역-설계-및-개발"><code class="language-plaintext highlighter-rouge">UI</code> 레이아웃 정의 및 백엔드 <code class="language-plaintext highlighter-rouge">API</code> 호출 → 프론트엔드 영역 설계 및 개발</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 흐름 정의 : 비즈니스 흐름에 따른 <code class="language-plaintext highlighter-rouge">UI</code> 흐름 정의 → <code class="language-plaintext highlighter-rouge">UI</code> 스토리보드</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 레이아수 정의 : 사용자 접점인 사용자 인터페이스 정의 → 발사믹 오븐, 카카오 오븐 등으로 산출</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 이벤트 및 액션 정의 : <code class="language-plaintext highlighter-rouge">UI</code> 레이아웃 내에서 특정 행위를 했을 때 발생하는 이벤트 및 액션 정의</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code> 개발 : <code class="language-plaintext highlighter-rouge">UI</code> 레아아웃 및 이벤트에 맞게 프론트엔드 어플리케이션 개발 → <code class="language-plaintext highlighter-rouge">UI</code> 프레임워크 등으로 산출</li>
</ul>

<h4 id="어플리케이션을-지속적으로-빌드하고-자동으로-배포--빌드-및-배포-환경-자동화">어플리케이션을 지속적으로 빌드하고 자동으로 배포 → 빌드 및 배포 환경 자동화</h4>

<ul>
  <li>소스 코드 리포지토리 구성 : 프론트엔드, 백엔드 코드를 위한 소스 코드 저장소 구성 (<code class="language-plaintext highlighter-rouge">Git</code>)</li>
  <li>통합 빌드 잡 (<code class="language-plaintext highlighter-rouge">Build Job</code>) 구성 : 리포지토리에 존재하는 소스 코드를 통합해 컴파일 및 테스트 (<code class="language-plaintext highlighter-rouge">Jenkins</code>)</li>
  <li>컨테이너 생성 파일 생성 : 컨테이너 배포 환경에서 운영 체제, <code class="language-plaintext highlighter-rouge">WAS</code>, 어플리케이션을 묶어 이미지 생성 (<code class="language-plaintext highlighter-rouge">Dockerfile</code>)</li>
  <li>배포 스크립트 : 자동으로 배포되는 스크립트 작성 (<code class="language-plaintext highlighter-rouge">Jenkins</code>, <code class="language-plaintext highlighter-rouge">Github Actions</code>)</li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[에자일 개발 프로세스 (Agile Development Process) : 피드백을 통한 지속적인 개선 추구]]></summary></entry><entry><title type="html">[MicroService] 3. MicroService Architecture</title><link href="http://localhost:4000/microservice3/" rel="alternate" type="text/html" title="[MicroService] 3. MicroService Architecture" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-15T00:00:00+09:00</updated><id>http://localhost:4000/microservice3</id><content type="html" xml:base="http://localhost:4000/microservice3/"><![CDATA[<h2 id="비즈니스-로직-business-logic--시스템이-목표로-하는-비즈니스-영역의-규칙-흐름-개념">비즈니스 로직 (<code class="language-plaintext highlighter-rouge">Business Logic</code>) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념</h2>

<blockquote>
  <ul>
    <li>소프트웨어의 가치는? <code class="language-plaintext highlighter-rouge">by Clean Architecture</code>
      <ul>
        <li>행위 기치 : 소프트웨어의 기능</li>
        <li>구조 가치 : 소프트웨어의 아키텍처 → 소프트웨어를 <code class="language-plaintext highlighter-rouge">Soft</code>하게 만드는 것</li>
      </ul>

      <p>→ 코드나 설계의 구조를 깔끔히 하는 대신 기능 구현만 목표하면, 엉망이 된 소프트웨어 대처에 더 많은 비용 발생</p>
    </li>
    <li>문제 영역에서 비즈니스 로직을 분석 및 이해하고, 프로그래밍 언어로 잘 표현하는 것이 개발자의 역할
      <ul>
        <li>기능이 정확하게 동작하는 것과 더불어, 이해하기 쉽고 변경하기 쉬운 시스템을 만드는 것</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="관심사의-분리-separation-of-concerns--시스템의-각-영역이-처리하는-관심사가-분리해-관리되어야-함">관심사의 분리 (<code class="language-plaintext highlighter-rouge">Separation of Concerns</code>) : 시스템의 각 영역이 처리하는 관심사가 분리해 관리되어야 함</h3>

<ul>
  <li>각 영역은 고유의 관심사에 의해 분리되어 집중되어야 함 → 모듈화, 계층화
    <ul>
      <li>비즈니스 로직은 어플리케이션의 핵심 영역이므로, 기술에 영향을 적게 받게 설계해야</li>
      <li>기술과 비즈니스 로직을 분리했을 때, 어플리케이션의 복잡성이 낮아지고 유지보수성이 높아짐</li>
      <li>비즈니스 로직을 모두가 이해할 수 있게 구조화된 객체 모델로 표현되어야 함</li>
    </ul>

    <p>→ 유연하고 확장성 있는 <code class="language-plaintext highlighter-rouge">MSA</code> 시스템을 개발하려면, 마이크로서비스의 내부 구조를 어떻게 유연하게 만들지 고민해야!</p>
  </li>
</ul>

<h2 id="데이터베이스-중심-아키텍처-database-centric-architecture--데이터-중심-서비스-구현">데이터베이스 중심 아키텍처 (<code class="language-plaintext highlighter-rouge">Database Centric Architecture</code>) : 데이터 중심 서비스 구현</h2>

<ol>
  <li>특정한 관계형 데이터베이스에 의존한 데이터 모델링을 수행한다.</li>
  <li>물리 테이블 모델을 중심에 두고 어플리케이션을 구현한다. (예시 : <code class="language-plaintext highlighter-rouge">SpringBoot Application</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Controller</code>, <code class="language-plaintext highlighter-rouge">Service</code>, <code class="language-plaintext highlighter-rouge">DTO</code>, <code class="language-plaintext highlighter-rouge">Repository &amp; Entity</code>로 어플리케이션을 구성</li>
      <li><code class="language-plaintext highlighter-rouge">SQL</code> 매핑 프레임워크인 <code class="language-plaintext highlighter-rouge">MyBatis</code>나 <code class="language-plaintext highlighter-rouge">Java Persistence API</code>인 <code class="language-plaintext highlighter-rouge">JPA</code>로 데이터를 처리</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>데이터베이스 중심 아키텍처에서 비즈니스 로직은 서비스에 존재해야 한다. 그러나,</p>

  <ul>
    <li>흐름 제어 로직만 서비스에 존재하고, 비즈니스 개념이나 규칙은 테이블이나 <code class="language-plaintext highlighter-rouge">SQL</code> 질의로 존재한다.</li>
    <li><code class="language-plaintext highlighter-rouge">DTO</code>는 <code class="language-plaintext highlighter-rouge">SQL</code> 질의를 통해 정보를 가져오는 정보 묶음 (<code class="language-plaintext highlighter-rouge">Information Holder</code>)의 역할밖에 할 수 없다.</li>
  </ul>

</blockquote>

<ul>
  <li>간단한 처리 로직의 경우에는 적합하나, 업무가 다양해지면 점점 복잡성을 제어할 수 없음</li>
  <li>업무 개념이 특정 관계형 테이블 데이터베이스의 테이블로 표현되어, 데이터 질의어인 <code class="language-plaintext highlighter-rouge">SQL</code>가 필요한 경우가 있음</li>
  <li>서비스의 비즈니스 개념과 규칙이 대부분 데이터베이스에 표현 → 성능이 데이터베이스에 의존
    <ul>
      <li>데이터가 늘어남에 따라 데이터베이스의 성능은 지속적으로 떨이짐
        <ul>
          <li>데이터베이스 서버의 <code class="language-plaintext highlighter-rouge">Scale-out</code>과 <code class="language-plaintext highlighter-rouge">SQL</code> 질의문 튜닝에 의존하게 됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="msa-시스템의-확장성과-유연성을-위한-내부-어플리케이션의-아키텍처-구조"><code class="language-plaintext highlighter-rouge">MSA</code> 시스템의 확장성과 유연성을 위한 내부 어플리케이션의 아키텍처 구조</h2>

<ul>
  <li>클라우드의 풍부한 자원 환경에서는, 어플리케이션 자체의 성능보단 어플리케이션의 확장성과 유연성이 더 중요하다!</li>
</ul>

<h3 id="계층형-아키텍처-layered-architecture">계층형 아키텍처 (<code class="language-plaintext highlighter-rouge">Layered Architecture</code>)</h3>

<ul>
  <li>티어 (<code class="language-plaintext highlighter-rouge">Tear</code>) : 물리적인 장비나 서버 컴퓨터 등의 물리 계층</li>
  <li>레이어 (<code class="language-plaintext highlighter-rouge">Layer</code>) : 물리적인 티어 내부에서 어플리케이션이 처리할 관심사를 구분하는 논리 계층
    <ul>
      <li>프레젠테이션 (<code class="language-plaintext highlighter-rouge">Presentation</code>) : 화면 표현 및 전환 처리</li>
      <li>비즈니스 로직 (<code class="language-plaintext highlighter-rouge">Business Logic</code>) : 비즈니스 개념, 규칙, 흐름 제어</li>
      <li>데이터 액세스 (<code class="language-plaintext highlighter-rouge">Data Access</code>) : 데이터 처리</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>계층형 아키텍처를 개발하기 위하여 지켜야 할 규칙!</p>

  <ul>
    <li>상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.</li>
    <li>상위 계층은 하위의 여러 계층을 모두 알 필요 없이 바로 밑의 근접 계층만을 활용한다.</li>
    <li>상위 계층이 하위 계층에 영향받지 않게 구성해야 한다.</li>
    <li>하위 계층은 자신을 사용하는 상위 계층을 알지 못하게끔 구성해야 한다.</li>
    <li>계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.
      <ul>
        <li>구현 클래스에 직접 의존하지 않게끔 하여 약결합을 유지해야 한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>의존성 역전의 원칙 (<code class="language-plaintext highlighter-rouge">DIP</code>) : ‘유연성이 극대화된 시스템은 코드 의존성이 구체가 아닌 추상에 의존한다.’ → <code class="language-plaintext highlighter-rouge">O</code></li>
  <li>개방 폐쇄의 원칙 (<code class="language-plaintext highlighter-rouge">OCP</code>) : ‘소프트웨어 객체는 확장에 열리되, 변경에 닫혀 있어야 한다.’ → <code class="language-plaintext highlighter-rouge">X</code>
    <ul>
      <li>개체의 행위는 확장될 수 있지만, 이때 객체를 변경해서는 안된다. 그러나 상위 계층에서 하위 계층으로 제어의 흐름 (<code class="language-plaintext highlighter-rouge">Flow of Control</code>)이 흐르는 계층형 아키텍처에서 소스 코드의 의존성 또한 그 방향을 따를 수 밖에 없다.</li>
      <li>상위 계층이 하위 계층의 구체 클래스가 아닌 추상 인터페이스에 의존시키고 그 인터페이스의 구현체를 달리해 의존성을 줄이면서 다형성을 유지할 수 있지만, 인터페이스는 그 계층이 정의하는 추상 특성의 한계를 벗어날 수 없다.</li>
    </ul>

    <p>→ 즉, 하위 계층의 유형이 추가되어 확장될 때, 닫혀 있어야 할 상위 계층이 하위 계층이 정의한 특성이 영향받는다!</p>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DIP</code>를 철저히 적용하여 <code class="language-plaintext highlighter-rouge">OCP</code>가 가능하게 하는, 의존 관계 역전의 방법 또한 존재한다.</p>

  <ul>
    <li>프레젠테이션, 비즈니스 로직, 데이터 액세스을 갖는 3계층 시스템이라 가정할 때,
      <ul>
        <li>고수준 영역인 비즈니스 로직이 저수준 영역인 데이터 액세스에 의존한다. (싱위 != 고수준 → 중요도)</li>
        <li>그러나 데이터 액세스 계층에서 정의한 인터페이스가 경계를 넘어 비즈니스 로직 계층에 존재하도록 하면,
          <ul>
            <li>데이터 액세스의 구현체는 비즈니스 로직 계층의 인터페이스만을 보게 된다.</li>
          </ul>

          <p>→ 아례 계층이 위 계층에 의존하게 하는 것이이 의존 관계 역전!</p>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="헥사고날-아키텍처-hexagonal-architecture">헥사고날 아키텍처 (<code class="language-plaintext highlighter-rouge">Hexagonal Architecture</code>)</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DIP</code>를 적용한 계층형 아키텍처의 한계?</p>

  <ul>
    <li>프레젠테이션, 데이터 액세스 계층만이 아닌 다양한 인터페이스를 필요로 하는 현대 어플리케이션
      <ul>
        <li>어플리케이션을 호출하는 다양한 시스템 유형과 어플리케이션과 상호작용하는 다양한 저장소가 존재</li>
      </ul>
    </li>
  </ul>

  <p>→ 단방향 계층 구조가 가지는 근본적인 한계를 넘어서자!</p>
</blockquote>

<ul>
  <li>포트 엔드 어댑터 아키텍처 (<code class="language-plaintext highlighter-rouge">Port and Adapter Architecture</code>)
    <ul>
      <li>저수준의 외부 영역 : 인터페이스 처리를 담당
        <ul>
          <li>인바운드 어댑터 (<code class="language-plaintext highlighter-rouge">Inbound Adaptor</code>) : 서비스 외부에서 들어오는 요청을 처리
            <ul>
              <li><code class="language-plaintext highlighter-rouge">REST API</code>를 발행하는 컨트롤러</li>
              <li>웹 페이지를 구성하는 스프링 <code class="language-plaintext highlighter-rouge">MVC</code> 컨트롤러</li>
              <li>이벤트 메시지를 구독하는 이벤트 핸들러 등</li>
            </ul>
          </li>
          <li>아웃바운드 어댑터 (<code class="language-plaintext highlighter-rouge">Outbound Adaptor</code>) : 서비스 내부의 비즈니스 로직에 의해 호출되어 외부와 연계
            <ul>
              <li>데이터 액세스 처리를 담당하는 <code class="language-plaintext highlighter-rouge">DAO</code></li>
              <li>이벤트 메시지를 발행하는 이벤트 클래스</li>
              <li>외부 서비스를 호출하는 프락시 (<code class="language-plaintext highlighter-rouge">Proxy</code>)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>고수준의 내부 영역 : 순수한 비즈니스 로직 표현
        <ul>
          <li>외부 영역과 연계되는 포트 (<code class="language-plaintext highlighter-rouge">Port</code>)를 가짐 → 어댑터가 포트를 호출
            <ul>
              <li>인바운드 포트 (<code class="language-plaintext highlighter-rouge">Inbound Port</code>) : 내부 영역의 사용을 위해 표출된 <code class="language-plaintext highlighter-rouge">API</code></li>
              <li>아웃바운드 포트 (<code class="language-plaintext highlighter-rouge">Outbound Port</code>) : 내부 영역이 외부를 호출하는 방법 정의</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>-&gt; 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게끔 한다.</p>

<h3 id="클린-아키텍처-clean-architecture">클린 아키텍처 (<code class="language-plaintext highlighter-rouge">Clean Architecture</code>)</h3>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Robert C. Martin</code> : ‘소프트웨어는 행위 가치와 구조 가치를 가지며, 구조 가치는 더 중요하다.’
      <ul>
        <li>왜? : 소프트웨어를 더 유연하게 하는 것이 구조 가치이므로</li>
        <li>소프트웨어를 유연하게 유지하는 방법? : 구조 중에서 선택할 수 있는 사항들을 오랫동안 여는 것
          <ul>
            <li>특히 열어두어야 할 선택 사항은, 중요하지 않는 세부사항</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>엔티티 (<code class="language-plaintext highlighter-rouge">Entity</code>) : 비즈니스 업무 규칙 (사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙)
    <ul>
      <li>모든 시스템에는 해당 도메인의 업무를 규정하는 업무 규칙이 존재 → 시스템 내에서 자동화</li>
      <li>업무 규칙과 데이터를 결합하여 엔티티 객체로 만들 수 있음</li>
    </ul>
  </li>
  <li>유스케이스 (<code class="language-plaintext highlighter-rouge">UseCase</code>) : 어플리케이션 업무 규칙
    <ul>
      <li>자동화된 시스템을 사용하는 처리 절차를 기술</li>
      <li>어플리케이션에 특화된 업무 규칙을 표현하며, 엔티티 내의 업무 규칙을 호출해 시스템을 사용하는 흐름을 닫음</li>
      <li>엔티티는 프레임워크, 데이터베이스에 의존하지 않고 유스케이스 객체를 통해 조작되는 간단한 객체로 존재해야 함</li>
    </ul>
  </li>
  <li>컨트롤러 (<code class="language-plaintext highlighter-rouge">Controller</code>) : 인터페이스 어댑터 (게이트웨어를 통해 연결)</li>
  <li>인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 프레임워크 &amp; 디바이스 (프레젠터를 통해 연결)</li>
</ul>

<blockquote>
  <ul>
    <li>엔티티와 유스케이스를 감싸고 있는 나머지 모든 영역이 세부 사항
      <ul>
        <li>입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토클 등</li>
      </ul>
    </li>
  </ul>

  <p>→ 세부 사항과 유스케이스의 관계를 <code class="language-plaintext highlighter-rouge">DIP</code>를 통해 플러그인처럼 유연하게 처리해야 한다.</p>
</blockquote>

<h2 id="바람직한-마이크로서비스의-내부-아키텍처--클린-마이크로서비스-clean-microservice">바람직한 마이크로서비스의 내부 아키텍처 → 클린 마이크로서비스 (<code class="language-plaintext highlighter-rouge">Clean Microservice</code>)</h2>

<ul>
  <li>마이크로서비스 시스템에서 정의해야 할 마이크로서비스의 내부 구조가 다양할 수 있음
    <ul>
      <li>자율적인 마이크로서비스 팀에 의한 폴리글랏한 내부 구조를 가질 수 있기 때문</li>
      <li>간단한 기능이면 모노리스를, 복잡한 기능이면 헥사고날/클린 아키텍처의 구조를 기반으로 정의하는 게 바람직</li>
    </ul>
  </li>
</ul>

<h3 id="클린-마이크로서비스-아키텍처가-지향해야-할-원칙">클린 마이크로서비스 아키텍처가 지향해야 할 원칙</h3>

<ul>
  <li>지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.</li>
  <li>업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.</li>
  <li>세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분된다.</li>
  <li>고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 한다.</li>
  <li>저수준 영역은 언제든지 교체 및 확장이 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안 된다.</li>
  <li>인터페이스나 추상 클래스를 지원하는 <code class="language-plaintext highlighter-rouge">Java</code>의 경우, 구체 클래스가 추상 인터페이스에 의존하는 <code class="language-plaintext highlighter-rouge">DIP</code>를 적용한다.</li>
  <li>인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수주느이 어댑터가 이를 구현한다.</li>
</ul>

<h3 id="클린-마이크로서비스-아키텍처의-구조">클린 마이크로서비스 아키텍처의 구조</h3>

<ul>
  <li>
    <h4 id="내부-영역-inbound-area--비즈니스-로직을-표현하는-영역">내부 영역 (<code class="language-plaintext highlighter-rouge">Inbound Area</code>) : 비즈니스 로직을 표현하는 영역</h4>
    <ul>
      <li>
        <h5 id="도메인-domain--내부-영역의-중심부에-존재하는-영역">도메인 (<code class="language-plaintext highlighter-rouge">Domain</code>) : 내부 영역의 중심부에 존재하는 영역</h5>
        <ul>
          <li>핵심 비즈니스 개념과 규칙을 구현</li>
          <li>엔티티 (<code class="language-plaintext highlighter-rouge">Entity</code>)와 값 객체 (<code class="language-plaintext highlighter-rouge">VO</code>)를 갖는 에그리거트 (<code class="language-plaintext highlighter-rouge">Aggregate</code>)로 존재</li>
        </ul>
      </li>
      <li>
        <h5 id="서비스-service---내부-영역에서-도메인을-감싸는-영역">서비스 (<code class="language-plaintext highlighter-rouge">Service</code>) :  내부 영역에서 도메인을 감싸는 영역</h5>
        <ul>
          <li>도메인을 호출하여 업무를 처리하는 절차를 기술</li>
        </ul>
      </li>
      <li>
        <h5 id="서비스-인터페이스-service-if--서비스-처리를-위한-인터페이스">서비스 인터페이스 (<code class="language-plaintext highlighter-rouge">Service I/F</code>) : 서비스 처리를 위한 인터페이스</h5>
        <ul>
          <li>외부에서 내부 영역에 존재하는 서비스를 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">API</code>를 제공</li>
        </ul>
      </li>
      <li>
        <h5 id="api-프록시-인터페이스-api-proxy-if--다른-서비스의-api-프록시-호출을-위한-인터페이스"><code class="language-plaintext highlighter-rouge">API</code> 프록시 인터페이스 (<code class="language-plaintext highlighter-rouge">API Proxy I/F</code>) : 다른 서비스의 <code class="language-plaintext highlighter-rouge">API</code> 프록시 호출을 위한 인터페이스</h5>
        <ul>
          <li>프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>) 패턴 : 프록시에게 어떤 일을 대신하게 함
            <ul>
              <li>어떤 객체를 사용할 때, 객체를 직접 참조하지 않고 이에 대응되는 프록시 객체로 대상 객체에 접근</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <h5 id="레포지토리-인터페이스-repository-if--저장소-처리를-위한-인터페이스">레포지토리 인터페이스 (<code class="language-plaintext highlighter-rouge">Repository I/F</code>) : 저장소 처리를 위한 인터페이스</h5>
        <ul>
          <li>비즈니스를 처리하는 데에 필요한 기본적인 저장소 처리 사항을 추상화해 정의</li>
          <li>외부 영역의 저장소 어댑터가 각 저장소에 맞는 저장소 처리 세부 기술로 구현</li>
        </ul>
      </li>
      <li>
        <h5 id="도메인-이벤트-발행-인터페이스-domain-event-publish-if--이벤트-메시지-발행을-위한-인터페이스">도메인 이벤트 발행 인터페이스 (<code class="language-plaintext highlighter-rouge">Domain Event Publish I/F</code>) : 이벤트 메시지 발행을 위한 인터페이스</h5>
        <ul>
          <li>도메인 이벤트 (<code class="language-plaintext highlighter-rouge">Domain Event</code>) : 어떤 사건에 따른 상태의 변경 사항</li>
          <li>하나의 도메인 이벤트를 각 명칭을 갖는 클래스로 구현 → 컨슈머 (<code class="language-plaintext highlighter-rouge">Consumer</code>)에 전달되어 발행 (<code class="language-plaintext highlighter-rouge">Publish</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="외부-영역-outbound-area--기술-중심의-세부-사항을-의미하는-영역">외부 영역 (<code class="language-plaintext highlighter-rouge">Outbound Area</code>) : 기술 중심의 세부 사항을 의미하는 영역</h4>
    <ul>
      <li>
        <h5 id="api-퍼플리싱-어댑터--클라이언트--서비스-인터페이스"><code class="language-plaintext highlighter-rouge">API</code> 퍼플리싱 어댑터 : 클라이언트 ↔ 서비스 인터페이스</h5>
        <ul>
          <li>내부 영역의 서비스 인터페이스를 호출해 <code class="language-plaintext highlighter-rouge">REST API</code>를 발행하는 인바운드 어댑터</li>
          <li>명시적인 <code class="language-plaintext highlighter-rouge">REST</code> 리소스 명칭을 정의하고, 각 <code class="language-plaintext highlighter-rouge">REST</code> 메소드가 의도에 맞게 서비스 인터페이스를 호출</li>
          <li>엔티티를 직접 제공하지 않고 <code class="language-plaintext highlighter-rouge">API</code>에 맞는 <code class="language-plaintext highlighter-rouge">DTO</code>를 생성해 엔티티를 변환 및 매핑해 전달해야 함</li>
        </ul>
      </li>
      <li>
        <h5 id="api-호출-프록시-어댑터--프록시-인터페이스--다른-서비스"><code class="language-plaintext highlighter-rouge">API</code> 호출 프록시 어댑터 : 프록시 인터페이스 ↔ 다른 서비스</h5>
        <ul>
          <li>내부 영역에 정의된 프록시 인터페이스를 구현하여 다른 서비스의 <code class="language-plaintext highlighter-rouge">API</code>를 호출하는 아웃바운드 어댑터</li>
          <li><code class="language-plaintext highlighter-rouge">REST API</code>, 소켓이나 <code class="language-plaintext highlighter-rouge">SOAP</code> 프로토콜 등 각 기술에 맞는 적절한 통신 방법을 구현해야 함</li>
        </ul>
      </li>
      <li>
        <h5 id="저장소-처리-어댑터--레포지토리-인터페이스--데이터베이스">저장소 처리 어댑터 : 레포지토리 인터페이스 ↔ 데이터베이스</h5>
        <ul>
          <li>데이터 처리 메커니즘의 선택 → <code class="language-plaintext highlighter-rouge">SQL vs OR?</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">SQL</code> 매핑 방식 (<code class="language-plaintext highlighter-rouge">MyBatis</code>) : <code class="language-plaintext highlighter-rouge">SQL</code> 질의문을 수동으로 작성할 수 있어 세밀한 <code class="language-plaintext highlighter-rouge">SQL</code> 제어가 가능</li>
              <li><code class="language-plaintext highlighter-rouge">OR</code> 매핑 방식 (<code class="language-plaintext highlighter-rouge">JPA</code>, <code class="language-plaintext highlighter-rouge">Spring Data</code>) : 런타임 시 <code class="language-plaintext highlighter-rouge">OR</code> 매퍼가 저장소에 따라 자동으로 질의문 생성
                <ul>
                  <li>질의문을 수동으로 작성할 필요가 줄어들어 균일한 질의문 품질과 생산성 향상 가능</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <h5 id="도메인-이벤트-발행-어댑터--이벤트-인터페이스--메시지-브로커">도메인 이벤트 발행 어댑터 : 이벤트 인터페이스 ↔ 메시지 브로커</h5>
        <ul>
          <li>도메인 이벤트를 발행하여 송신하는 아웃바운드 어댑터</li>
          <li>실제 도메인 이벤트가 생성되는 위치는 내부 영역
            <ul>
              <li>에그리거트 패턴을 적용했을 때의 도메인 이벤트는 에그리거트에서 발생한 사건이 됨</li>
            </ul>
          </li>
          <li>도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스의 구현체
            <ul>
              <li>특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <h5 id="도메인-이벤트-핸들러-어댑터--메시지-브로커--서비스-인터페이스">도메인 이벤트 핸들러 어댑터 : 메시지 브로커 ↔ 서비스 인터페이스</h5>
        <ul>
          <li>발행된 도메인 이벤트를 수신할 수 있는 인바운드 어댑터</li>
          <li>외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달</li>
          <li>이벤트의 상태에 따라 적절한 서비스 인터페이스를 호출해서 내부 영역에 이벤트를 전달해야 함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="클린-마이크로서비스의-내부-영역에-참고할-만한-패턴">클린 마이크로서비스의 내부 영역에 참고할 만한 패턴</h3>

<ul>
  <li>서비스 인터페이스는 외부 영역이 내부 영역에 대해 많이 알지 못하게 함
    <ul>
      <li>서비스 인터페이스가 없다면? : 추이 종속성이 발생할 수 있고, 정보 은닉성이 보장될 수 없음</li>
    </ul>
  </li>
  <li>리포지토리 인터페이스, 도메인 이벤트 인터페이스, <code class="language-plaintext highlighter-rouge">API</code> 프록시 인터페이스는 <code class="language-plaintext highlighter-rouge">DIP</code>를 지원
    <ul>
      <li>고수준 영역에 인터페이스가 존재하면, 저수준 영역의 외부 어댑터가 이러한 인터페이스를 구현하도록 해야 함</li>
    </ul>
  </li>
  <li>도메인은 비즈니스 개념을 표현하는 엔티티의 역할울 수행</li>
  <li>서비스는 도메인을 활용하여 시스템의 흐름 처리를 수행하는 유스케이스의 역할을 수행</li>
</ul>

<h4 id="간단한-비즈니스-로직의-처리--트랜잭션-스크립트-transaction-script-패턴">간단한 비즈니스 로직의 처리 → 트랜잭션 스크립트 (<code class="language-plaintext highlighter-rouge">Transaction Script</code>) 패턴</h4>

<ul>
  <li>비즈니스 개념을 표현하는 도메인 객체가 행위를 가지고 있지 않음</li>
  <li>모든 비즈내스 행위, 즉 무언가를 수행하는 책임은 서비스에 있음</li>
  <li>서비스가 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행
    <ul>
      <li>절차식 프로그래밍 방식과 같기 때문에 객체지향 지식이 없어도 일반적으로 쉽게 이해할 수 있는 구조</li>
      <li>기존의 데이터베이스 중심 아키텍처에 익숙하다면 더 빠르게 적응할 수 있음</li>
    </ul>
  </li>
  <li>비즈니스가 복잡해질수록 서비스 코드의 양이 늘어남
    <ul>
      <li>서비스가 비대해지면서, 도메인 객체는 정보 묶음의 역할만을 수행</li>
      <li>비즈니스 로직 처리가 서비스에서 이루어지므로, 비슷한 유스케이스로 중복된 코드가 생겨나 유지보수에 어려움</li>
    </ul>
  </li>
</ul>

<h4 id="복잡한-비즈니스-로직의-처리--도메인-모델-domain-model-패턴">복잡한 비즈니스 로직의 처리 → 도메인 모델 (<code class="language-plaintext highlighter-rouge">Domain Model</code>) 패턴</h4>

<ul>
  <li>도메인 객체가 데이터뿐만이 아니라 비즈니스 행위를 가짐
    <ul>
      <li>도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉</li>
      <li>도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행</li>
    </ul>
  </li>
  <li>서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임하여 처리
    <ul>
      <li>서비스의 책임이 도메인으로 적절히 분산되므로 서비스 메소드가 단순해짐</li>
    </ul>
  </li>
  <li>도메인 모델 패턴의 도메인 모델은 객체지향 설계의 객체 모델
    <ul>
      <li>각기 적절한 책임을 가진 여러 클래스들로 구성되므로 이해하기 쉽고 관리 및 테스트가 용이</li>
      <li>잘 만들어진 도메인 모델은 복잡한 비즈니스 로직의 처리에 유용</li>
      <li>잘 정의된 도메인 모델은 코드의 양을 줄이고 재사용성을 높일 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="복잡한-도메인-모델의-단순화--에그리거트-aggregate-패턴">복잡한 도메인 모델의 단순화 → 에그리거트 (<code class="language-plaintext highlighter-rouge">Aggregate</code>) 패턴</h4>

<blockquote>
  <ul>
    <li>도메인 모델링 : 객체간의 관계를 참조로 표현
      <ul>
        <li>일대다 (<code class="language-plaintext highlighter-rouge">One-to-Many</code>) 관계의 객체를 쉽게 사용할 수 있음</li>
        <li>업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고, 그로 인해 참조 관계가 복잡해짐</li>
      </ul>
    </li>
  </ul>

  <p>→ 즉, 복잡한 도메인 모델은 모델 내부의 경계가 불명확하다. 이 문제를 어떻게 해결할까?</p>
</blockquote>

<ul>
  <li>에그리거트 : 데이터 변경의 단위로 다루는 연관 객체의 묶음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Root Entity</code>에서 개념적으로 묶인 엔티티의 집합</li>
      <li>1개 이상의 연관된 엔티티와 값 객체 (<code class="language-plaintext highlighter-rouge">VO</code>)로 구성된 하나의 묶음 전체</li>
      <li>개별 객체 수준의 모델 → 에그리거트 단위의 모델을 통해 도메인 모델을 단순화</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>에그리거트를 한 단위로 일관되게 처리하기 위한 규칙</p>

  <ul>
    <li>에그리거트 루트만 참조한다.</li>
    <li>에그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해서만 참조해야 한다. 수정할 때도 동일하다.</li>
    <li>에그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.</li>
    <li>기본 키를 사용하면 느슨하게 연관되고 수정이 필요없는 에그리거트를 함께 수정하는 실수를 방지한다.</li>
    <li>하나의 트랜잭션으로 하나의 에그리거트만을 생성 및 수정한다.</li>
  </ul>
</blockquote>

<h3 id="클린-마이크로서비스의-내부-영역에-참고할-만한-패턴-1">클린 마이크로서비스의 내부 영역에 참고할 만한 패턴</h3>

<ul>
  <li>어댑터는 각각의 인터페이스에 대한 동기/비동기 통신 및 저장소 처리를 작업한다.
    <ul>
      <li>외부 영역은 내부 영역에 존재하는 서비스 인터페이스를 사용하는 인바운드 어댑터와,<br />내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 아웃바운드 어댑터로 구성된다.</li>
    </ul>
  </li>
  <li>어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야 한다.
    <ul>
      <li>내부 영역이 먼저 정의된 후에 외부 영역의 세부 사항은 늦게 정의돼도 상관없도록 해야 한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[비즈니스 로직 (Business Logic) : 시스템이 목표로 하는 비즈니스 영역의 규칙, 흐름, 개념]]></summary></entry><entry><title type="html">[Java] 2. 변수 (variable)</title><link href="http://localhost:4000/java2/" rel="alternate" type="text/html" title="[Java] 2. 변수 (variable)" /><published>2024-01-14T00:00:00+09:00</published><updated>2024-01-14T00:00:00+09:00</updated><id>http://localhost:4000/java2</id><content type="html" xml:base="http://localhost:4000/java2/"><![CDATA[<h2 id="변수-variable--하나의-값을-저장할-수-있는-메모리-번지에-붙어진-이름">변수 (<code class="language-plaintext highlighter-rouge">variable</code>) : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름</h2>

<ul>
  <li>변수의 선언 : 어떤 차입의 데이터를 저장할지, 그리고 변수의 이름이 무엇인지 결정</li>
  <li>변수의 이름 : 첫번째 글자는 소문자로 시작하되, 캐멀 스타일 (<code class="language-plaintext highlighter-rouge">Camel Style</code>)로 작성하는 것이 관례</li>
  <li>값의 대입 (<code class="language-plaintext highlighter-rouge">=</code>) : 선언된 변수에 값을 저장 → 변수의 초기화</li>
  <li></li>
</ul>

<h3 id="원시-자료형-primitive-type--선언-시-메모리-주소-위치-jvm-stack에-실제-값이-저장">원시 자료형 (<code class="language-plaintext highlighter-rouge">Primitive type</code>) : 선언 시 메모리 주소 위치 (<code class="language-plaintext highlighter-rouge">JVM stack</code>)에 실제 값이 저장</h3>

<h4 id="논리-리터럴-boolean--참과-거짓을-의미">논리 리터럴 (<code class="language-plaintext highlighter-rouge">Boolean</code>) : 참과 거짓을 의미</h4>

<ul>
  <li>논리 타입 (<code class="language-plaintext highlighter-rouge">boolean</code>) : <code class="language-plaintext highlighter-rouge">true</code> / <code class="language-plaintext highlighter-rouge">false</code></li>
</ul>

<h4 id="정수-리터럴-integers--정수를">정수 리터럴 (<code class="language-plaintext highlighter-rouge">Integers</code>) : 정수를</h4>

<ul>
  <li>문자 (<code class="language-plaintext highlighter-rouge">char</code>) : <code class="language-plaintext highlighter-rouge">''</code>를 이용해 표시 (초기값 : <code class="language-plaintext highlighter-rouge">'\0'</code>=<code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>바이트 (<code class="language-plaintext highlighter-rouge">byte</code>) : 데이터를 나타내는 바이트 값 (초기값 : <code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>정수 (<code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>) : <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>바이트 크기 내의 정수 (초기값 : <code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>실수 (<code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>) : <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>바이트 크기 내의 실수 (초기값 : <code class="language-plaintext highlighter-rouge">0.0</code>)</li>
</ul>

<h3 id="참조-자료형-reference-type--선언-시-메모리-주소-위치에-실제-값이-가리키는-다른-주소를-저장">참조 자료형 (<code class="language-plaintext highlighter-rouge">Reference type</code>) : 선언 시 메모리 주소 위치에 실제 값이 가리키는 다른 주소를 저장</h3>
<ul>
  <li>원시 자료형을 기초로 하여 만들어짐 → <code class="language-plaintext highlighter-rouge">Non-Primitive type</code></li>
  <li>실제 값은 <code class="language-plaintext highlighter-rouge">Heap</code>에 저장</li>
</ul>

<blockquote>
  <p>자바는 주소값의 추상화를 금지함, <code class="language-plaintext highlighter-rouge">Call by value</code>만 가능 (<code class="language-plaintext highlighter-rouge">C/C++</code> : 주소값 저장 (<code class="language-plaintext highlighter-rouge">*</code>) 및 추출 (<code class="language-plaintext highlighter-rouge">&amp;</code>) 가능)</p>
</blockquote>

<h3 id="var--데이터-타입을-명시하지-않아도-지역-변수의-타입을-자동으로-추론하는-키워드"><code class="language-plaintext highlighter-rouge">var</code> : 데이터 타입을 명시하지 않아도 지역 변수의 타입을 자동으로 추론하는 키워드</h3>
<ul>
  <li>지역 변수만 사용 가능 (<code class="language-plaintext highlighter-rouge">static</code> 적용 불가)</li>
  <li>선언과 함께 명시적인 초기화를 반드시 해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">NULL</code>로 초기화할 수 없음</li>
  <li>람다 표현식과 같이 사용할 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var s = 'String';
var n = 100;
</code></pre></div></div>

<h2 id="변수의-스코프-scope--변수가-유효한-범위">변수의 스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수가 유효한 범위</h2>

<ul>
  <li>접근 지정자 (<code class="language-plaintext highlighter-rouge">access modifier</code>) : 접근 가능한 수준 지정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code> : 어느 클래스에서든 해당 클래스에 대해 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">protected</code> : 해당 패키지와 같은 패키지 내에 있는 클래스와 상속받은 클래스가 해당 클래스에 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">default</code> : 해당 클래스와 같은 패키지 내에 있는 클래스만이 해당 클래스에 대해 접근 가능</li>
      <li><code class="language-plaintext highlighter-rouge">private</code> : 해당 클래스 및 그 클래스를 포함한 클래스만이 해당 클래스에 대해 접근 가능</li>
    </ul>
  </li>
</ul>

<h2 id="변수의-라이프타임-lifetime--변수가-메모리-영역에-저장되어-있는-시간">변수의 라이프타임 (<code class="language-plaintext highlighter-rouge">LifeTime</code>) : 변수가 메모리 영역에 저장되어 있는 시간</h2>

<ul>
  <li>인스턴스 변수 (<code class="language-plaintext highlighter-rouge">static block</code>과 <code class="language-plaintext highlighter-rouge">static method</code>를 제외한 클래스 전체) : 객체가 생성되어 메모리에 존재하는 동안</li>
  <li>클래스 변수 (클래스 전체) : 클래스가 초기화되고 프로그램이 끝날 때까지</li>
  <li>로컬 변수 (변수가 선언된 블록의 내부) : 변수 선언 이후부터 블록을 벗어날 때까지</li>
</ul>

<h2 id="변수의-형변환-type-conversion--현재의-타입을-다른-타입올-바꾸는-것">변수의 형변환 (<code class="language-plaintext highlighter-rouge">Type Conversion</code>) : 현재의 타입을 다른 타입올 바꾸는 것</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">boolean</code>을 제외한 나머지 기본 자료형 간의 타입 변환이 가능</p>
</blockquote>

<ul>
  <li>타입 프로모션 (<code class="language-plaintext highlighter-rouge">Type Promotion</code>) : 범위가 작은 데이터 타입의 값을 더 큰 범위의 데이터 타입에 할당 (묵시적 형변환)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">byte</code> &lt; <code class="language-plaintext highlighter-rouge">short</code> &lt; <code class="language-plaintext highlighter-rouge">int</code> &lt; <code class="language-plaintext highlighter-rouge">long</code> &lt; <code class="language-plaintext highlighter-rouge">float</code> &lt; <code class="language-plaintext highlighter-rouge">double</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int intN = 23;
long longN = intN;
</code></pre></div></div>

<ul>
  <li>캐스팅 (<code class="language-plaintext highlighter-rouge">Casting</code>) : 범위가 큰 데이터 타입의 값을 더 작은 범위의 데이터 타입으로 할당 (명시적 형변환)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int n = 100;
c = (char) n;
</code></pre></div></div>

<ul>
  <li>업캐스팅 (<code class="language-plaintext highlighter-rouge">Up-Casting</code>) : 부모-자식 관계의 객체에서 자식 객체를 부모 객체로 형변환 (묵시적 형변환)</li>
  <li>다운캐스팅 (<code class="language-plaintext highlighter-rouge">Down-Casting</code>) : 부모-자식 관계의 객체에서 부모 객체를 자식 객체로 형변환 (명시적 형변환)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass {
  String name;
  String ID;

  public MyClass(String name){
    this.name = name;
  }
}

class StudentClass extends MyClass {
  String grade;

  public StudentClass(String name){
    super(name);
  }
}

public class UpClass {
  public Static void main(String[] args){
    MyClass P;
    StudentClass S = new StudentClass("I");
    
    P = S; // 업캐스팅 발생

    System.out.println(P.name); // 컴파일 오류 없음

    S = (StudentClass) P;   // 다운캐스팅 발생

    System.out.println(S.name); // 컴파일 오류 없음
  }
}
</code></pre></div></div>

<h2 id="배열-array--인덱스-index와-그-인덱스에-대응하는-데이터들로-이루어진-선형-자료구조">배열 (<code class="language-plaintext highlighter-rouge">Array</code>) : 인덱스 (<code class="language-plaintext highlighter-rouge">Index</code>)와 그 인덱스에 대응하는 데이터들로 이루어진 선형 자료구조</h2>

<ul>
  <li>배열의 생성 : 배열 공간을 할당받는 과정 (배열에 대한 래퍼런스 변수 선언 + 배열 생성)
    <ul>
      <li>래퍼런스 변수 : 메모리 상에 생성된 인스턴스를 가리키는 데에 사용되는 변수 (배열의 주소 값을 가짐)</li>
      <li><code class="language-plaintext highlighter-rouge">new</code> : 클래스의 새로운 객체를 생성할 때, 객체를 저장할 메모리를 할당하고 생성자를 호출해 객체를 초기화</li>
      <li><code class="language-plaintext highlighter-rouge">=</code> : 스택의 래퍼런스 변수가 힙의 배열 데이터를 가리킴</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] intArray;
intArray = new int [10];
int[] intArray = new int [10];
int[] intArray = {1,2,3,4,5,6,7,8,9};
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[][] intArray2;
int intArray2 = new int[2][3];
int intArray2 = { {1, 2, 3}, {4, 5, 6} };
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.length</code> 필드 : 배열이 가진 길이 (원소의 개수)를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len = intArray.length
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len1 = intArray2.length     // 2차원 배열이 가진 행의 개수
len2 = intArray2[n].length  // 2차원 배열 중 n번째 행이 가진 열의 개수
</code></pre></div></div>

<ul>
  <li>비정방형 배열 : 행마다 열의 개수가 서로 다른 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[][] intArray3 = new int[3][];
intArray3[0] = new int[1];
intArray3[1] = new int[2];
intArray3[2] = new int[3];
int intArray3 = { {0}, {1,2}, {3,4,5} };
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int intArray3[][] = { {0}, {1,2}, {3,4,5} };
</code></pre></div></div>

<ul>
  <li>메소드의 배열 반환 : 실제 배열에 대한 래퍼런스가 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int makeArray() {
    int t = new int[4];
    return t;
}

int[] intArr = makeArray();
</code></pre></div></div>

<ul>
  <li>객체 배열 : 객체에 대한 래퍼런스를 원소로 갖는 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person[] people = new Person[20];

for(int i = 0; i &lt; people.length; i++){
    people[i] = new Person();
    people[i].age = 20 + i;
}
</code></pre></div></div>

<h2 id="객체-object--프로그램에서-사용되는-데이터-혹은-식별자에-의해-참조되는-공간">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 프로그램에서 사용되는 데이터 혹은 식별자에 의해 참조되는 공간</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">new</code> : 객체를 생성하는 연산자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P = new Person("A");
P.age = 30;
</code></pre></div></div>

<ul>
  <li>생성자 : 객체가 생성될 때 자동으로 호출되는 메소드 (객체에 필요한 초기화 수행)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">this</code> : 객체 자신을 참조</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass {
    int id;

    public MyClass (int x) { // 생성자는 클래스 이름과 동일한 이름을 가짐
        this.id = x;
    }

    public void MyFunc (int id) {
        this.id = id;
    } 
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this()</code> : 동일한 클래스 내의 다른 생성자를 호출할 때 사용 (반드시 생성자의 첫 문장에서 사용되어야 함)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public MyClass {
    String title;
    int price;
    int id = 0;

    public MyClass(String title, int price, int id) {
        this.title = title;
        this.price = price;
        this.id = id;
        id += 1;
    }

    public MyClass(String title, int price, int id) {
        this.title = title;
        this.price = price;
        this.id = id;
        id += 1;
    }

    public MyClass(String title, int price) {
        this(title, price, id);
        id += 1;
    }

    public static void main(String[] args) {
        MyClass mart1 = new MyClass("apple", 100, 1);
        MyClass mart2 = new MyClass("banana", 200);
    }
}
</code></pre></div></div>

<ul>
  <li>가비지 컬렉션 (<code class="language-plaintext highlighter-rouge">garbage Collection</code>) : <code class="language-plaintext highlighter-rouge">new</code>로 할당받고 사용하지 않는 객체의 메모리 공간을 자동으로 <code class="language-plaintext highlighter-rouge">JVM</code>에 반환
    <ul>
      <li>소멸자 (<code class="language-plaintext highlighter-rouge">delete</code>)로 객체의 소멸을 명시해야 하는 <code class="language-plaintext highlighter-rouge">C++</code>과 달리, 자바는 소멸자가 필요 없음</li>
    </ul>
  </li>
</ul>

<h2 id="클래스-class--객체를-생성하기-위해-변수와-메소드를-정의하는-틀">클래스 (<code class="language-plaintext highlighter-rouge">Class</code>) : 객체를 생성하기 위해 변수와 메소드를 정의하는 틀</h2>

<ul>
  <li>필드 (<code class="language-plaintext highlighter-rouge">Field</code>) : 객체의 상태 혹은 속성 (인스턴스 변수, <code class="language-plaintext highlighter-rouge">static</code> 변수)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    String name;
    static long id;
}
</code></pre></div></div>

<ul>
  <li>메소드 (<code class="language-plaintext highlighter-rouge">method</code>) : 객체의 행동 (인스턴스 메소드, <code class="language-plaintext highlighter-rouge">static</code> 메소드)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    long id;

    string getName() {
        return name;
    }
    
    long getID() {
        return id;
    }

    void setName(String name) {
        this.name = name;
    }

    void setID(long id) {
        this.id = id;
    }
}
</code></pre></div></div>

<ul>
  <li>생성자 (<code class="language-plaintext highlighter-rouge">Constructor</code>) : 객체를 생성한 후에 필요한 초기화 작업을 수행하는 메소드</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    long id;

    MyClass(String name, long id) {
        this.name = name;
        this.id = id;
    }
}
</code></pre></div></div>

<ul>
  <li>초기화 블럭 (<code class="language-plaintext highlighter-rouge">Initializer</code>) : 객체를 생성한 후에 필요한 초기화 작업을 세분화
    <ul>
      <li>클래스 초기화 블럭 : 클래스가 최초로 로딩될 때</li>
      <li>인스턴스 초기화 블럭 : 인스턴스가 생성되었을 때</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MyClass {
    string name;
    static long id;
        // 클래스 초기화 블럭
    static {
        id = 1;
    }
        // 인스턴스 초기화 블럭
    {
        name = "이름";
        id += 1;
    }
}
</code></pre></div></div>

<blockquote>
  <p>캡슐화 (<code class="language-plaintext highlighter-rouge">Encapsulation</code>) : 변수나 메소드는 반드시 클래스 내에서만 구현 가능 / 클래스 안의 내부 클래스 구현 가능</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class (클래스 이름) {
    public static void main(String[] args {
        ...
    }

    class (내부 클래스 1 이름) {
        ...
    }

    static class (내부 클래스 2 이름) {
        ...
    }

    void (내부 함수 이름)() {
        ...
    }

   ...
}
</code></pre></div>  </div>

  <p>상속 (<code class="language-plaintext highlighter-rouge">Inheritance</code>) : 부모 클래스에 정의된 필드와 메소드를 자식 클래스가 물려받는 것</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Person {
   Person() { ... }
...
}
public class Student extends Person {
  super(); // 부모 클래스의 생성자를 호출
  ...
}
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">instanceof</code> : 객체의 타입을 검사하는 연산자 (상속 관계 &amp; 구현 관계 모두 포함)</p>

  <p>```
class Lee extends Student implements Person { … }</p>

  <p>Lee lee = new Lee();
assertThat(lee instanceof Lee).isTrue();
assertThat(lee instanceof Student).isTrue();
assertThat(lee instanceof Animal).isTrue();
assertThat(lee instanceof Person).isTrue();</p>
</blockquote>

<blockquote>
  <p>```</p>
</blockquote>

<h3 id="main--해당-클래스를-자바-어플리케이션에서-실행하는-메소드"><code class="language-plaintext highlighter-rouge">main()</code> : 해당 클래스를 자바 어플리케이션에서 실행하는 메소드</h3>

<ul>
  <li>접근 제어자 <code class="language-plaintext highlighter-rouge">public</code>  : 다른 모든 클래스에서 호출 가능 (클래스 외부의 <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 호출되어야 하므로)</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> : 프로그램 시작부터 메모리에 저장됨 (프로그램이 시작할 때부터 <code class="language-plaintext highlighter-rouge">JVM</code>에 의해 호출되어야 하므로)</li>
  <li><code class="language-plaintext highlighter-rouge">void</code> : 종료 코드를 등록하기 위해 <code class="language-plaintext highlighter-rouge">int</code>를 반환해야 하는 ```C``와 달리, 종료 코드를 등록할 필요 없음</li>
  <li><code class="language-plaintext highlighter-rouge">String[] args</code> : 명령줄에 주어진 모든 인자를 문자열로 처리해 <code class="language-plaintext highlighter-rouge">main()</code>에 전달</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class (클래스 이름) {
    public static void main(String[] args {
        ...
    }
}
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">static</code> : 모든 객체에 공통으로 사용하기 위해 정적으로 선언 (프로그램 시작부터 메모리에 저장)</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">static</code> 메소드는 <code class="language-plaintext highlighter-rouge">static</code> 멤버만 사용할 수 있고, <code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용할 수 없음</li>
  </ul>
</blockquote>

<h3 id="final--오직-한-번만-할당할-수-있어-항상-같은-값을-가지는-entity를-정의할-때-사용하는-키워드"><code class="language-plaintext highlighter-rouge">final</code> : 오직 한 번만 할당할 수 있어 항상 같은 값을 가지는 <code class="language-plaintext highlighter-rouge">entity</code>를 정의할 때 사용하는 키워드</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 클래스 : 클래스가 상속받을 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class MyClass { ... }
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 메소드 : 오버라이딩으로 수정할 수 없음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class MySuperClass { 
    protected final void MyFunc() { ... }
}
public final class MyClass extends MySuperClass { 
    protected final void MyFunc() { ... } // 컴파일 오류
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">final</code> 변수 : 한번 값을 할당하면 수정할 수 없는 상수 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static float Pl = 3.141592;
</code></pre></div></div>

<h2 id="어노테이션-annotation--컴파일--실행-과정에서-코드를-어떻게-처리할지-알리는-메타데이터">어노테이션 (<code class="language-plaintext highlighter-rouge">Annotation</code>) : 컴파일 &amp; 실행 과정에서 코드를 어떻게 처리할지 알리는 메타데이터</h2>

<ul>
  <li>클래스나 메소드 위에 붙으며, <code class="language-plaintext highlighter-rouge">@</code>로 시작 : 어노테이션의 유무나 어노테이션에 설정한 값을 통해 클래스를 다르게 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Override // 메소드를 오버라이딩 (상속받은 부모 클래스나 인터페이스에서 해당 메소드가 없으면 컴파일 오류)
</code></pre></div></div>

<h2 id="자바-모듈-java-module--클래스-jar-패키지-수준의-코드-그룹화-제공">자바 모듈 (<code class="language-plaintext highlighter-rouge">Java Module</code>) : 클래스, <code class="language-plaintext highlighter-rouge">JAR</code>, 패키지 수준의 코드 그룹화 제공</h2>

<ul>
  <li>하나의 자바 어플리케이션은 하나 이상의 <code class="language-plaintext highlighter-rouge">.class</code> 파일로 구성</li>
  <li>다수의 클래스 파일을 <code class="language-plaintext highlighter-rouge">.jar</code> 파일로 압축해 배포 및 실행 가능</li>
  <li>서로 관련 있는 클래스들은 하나의 패키지로 묶어서 관리</li>
</ul>

<h2 id="jdk의-scanner-클래스--자바의-키-입력-key-input"><code class="language-plaintext highlighter-rouge">JDK</code>의 <code class="language-plaintext highlighter-rouge">Scanner</code> 클래스 : 자바의 키 입력 (<code class="language-plaintext highlighter-rouge">Key input</code>)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String next()</code> : 문자열 타입으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">Byte nextByte()</code> : 바이트 타입으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">short nextShort()</code>, <code class="language-plaintext highlighter-rouge">int nextInt()</code>, <code class="language-plaintext highlighter-rouge">long nextLong()</code> : 정수 타입 (<code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>)으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">float nextFloat()</code>, <code class="language-plaintext highlighter-rouge">double nextDouble()</code> : 실수 타입 (<code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>)으로 반환</li>
  <li><code class="language-plaintext highlighter-rouge">String nextLine()</code> : 한 줄 전체 (<code class="language-plaintext highlighter-rouge">\n</code>)를 일고 문자열 타입으로 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.Scanner;
Scanner scan = new Scanner(System.in);
String name = scan.nextLine();
</code></pre></div></div>

<blockquote>
  <p>자바 표준 입력 스트림 <code class="language-plaintext highlighter-rouge">system.in</code> : 입력되는 키 값을 바이트 정보로 반환 (문자 정보로 변환)</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>InputSteamReader rd = new InputSteamReader(System.in); // 키보드 입력 스트림 생성
int s = rd.read(); // 키보드로부터 문자 하나를 읽고 이를 s에 저장
</code></pre></div>  </div>
</blockquote>

<h2 id="예외-처리-exception-handling--발생한-예외에-대해-작성한-프로그램-내에서-대응하는-것">예외 처리 (<code class="language-plaintext highlighter-rouge">Exception handling</code>) : 발생한 예외에 대해 작성한 프로그램 내에서 대응하는 것</h2>

<ul>
  <li>예외 (<code class="language-plaintext highlighter-rouge">Exception</code>) : 프로그램 실행 중에 발생하는 런타임 오류 (<code class="language-plaintext highlighter-rouge">Runtime error</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Checked Exception</code> : 컴파일러에 의해 예외 발생을 인지 (컴파일 오류)</li>
      <li><code class="language-plaintext highlighter-rouge">Unchecked Exception</code> : <code class="language-plaintext highlighter-rouge">JVM</code>에서 예외 발생을 인지 (예외 객체 생성 후 처리)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자바에서 자주 발생하는 예외</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">NullPointerException</code> : <code class="language-plaintext highlighter-rouge">Null</code> 래퍼런스를 참조할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">ClassCastException</code> : 변환할 수 없는 타입응로 객체를 변환할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">IOException</code> : 입출력 동작 중에 인터럽트가 발생할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">NumberFormatException</code> : 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> : 잘못된 인자를 전달할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">ArrayIndexOutOfBoundsException</code> : 배열의 범위를 벗어나 접근할 때 발생</li>
    <li><code class="language-plaintext highlighter-rouge">NoSuchMethodException</code> : 런타임 시점에 존재하지 않는 메소드를 호출할 때 발생</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">try-catch-finally</code> : 발생한 예외에 대한 예외처리를 하는 구문
    <ul>
      <li><code class="language-plaintext highlighter-rouge">try</code> : 오류가 발생할 것으로 예상되는 부분</li>
      <li><code class="language-plaintext highlighter-rouge">catch</code> : 발생할 오류에 관련된 예외에 대해 대응할 부분</li>
      <li><code class="language-plaintext highlighter-rouge">finally</code> : 예외 발생 여부에 상관없이 반드시 실행되어야 하는 부분</li>
      <li><code class="language-plaintext highlighter-rouge">throws</code>: 예외 처리의 의무를 현재 예외가 발생한 메소드에서 그 메소드를 호출한 메소드로 전달</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void funcA() {
    try {
        ...
    } catch (Exception e) { // 예외가 발생할 때 생성된 예외 객체와 타입이 일치하면, 래퍼런스 변수가 생성된 예외 객체를 가리킴
        ...
    } finally {
        ...
    }
}

public void funcB() throws Exception { // throws로 예외 처리를 Exception로 전달
    ...
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Java" /><summary type="html"><![CDATA[변수 (variable) : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름]]></summary></entry></feed>