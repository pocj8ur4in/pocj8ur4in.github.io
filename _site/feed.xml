<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-15T12:43:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[MicroService] 2. MSA</title><link href="http://localhost:4000/microservice2/" rel="alternate" type="text/html" title="[MicroService] 2. MSA" /><published>2023-12-14T00:00:00+09:00</published><updated>2023-12-14T00:00:00+09:00</updated><id>http://localhost:4000/microservice2</id><content type="html" xml:base="http://localhost:4000/microservice2/"><![CDATA[<h2 id="마이크로서비스-아키텍처-msa--마이크로서비스를-접목한-아키텍처-구조">마이크로서비스 아키텍처 (<code class="language-plaintext highlighter-rouge">MSA</code>) : 마이크로서비스를 접목한 아키텍처 구조</h2>

<ul>
  <li>클라우드 인프라와 접목해 아마존, 넷플릭스에 의해 구체화 → 비즈니스 성공 사례</li>
  <li>각 서비스는 개별 프로세스에서 실행되며, <code class="language-plaintext highlighter-rouge">HTTP API</code>를 통해 통신</li>
  <li>각 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용해 독립적으로 배포</li>
</ul>

<blockquote>
  <p>마이크로서비스 아키텍처 (<code class="language-plaintext highlighter-rouge">MSA</code>)와 서비스 지향 아키텍처 (<code class="language-plaintext highlighter-rouge">SOA</code>)의 비교</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">SOA</code> : 컴포넌트를 모아 비즈니스적으로 의미있고 완결적인 서비스 단위로 모듈화
      <ul>
        <li><code class="language-plaintext highlighter-rouge">SOA</code>와 <code class="language-plaintext highlighter-rouge">MSA</code>의 공통점 : 비즈니스 서비스의 집합으로 시스템을 개발</li>
        <li><code class="language-plaintext highlighter-rouge">SOA</code>와 <code class="language-plaintext highlighter-rouge">MSA</code>의 차이점 : 이론적인 <code class="language-plaintext highlighter-rouge">SOA</code>와 달리, <code class="language-plaintext highlighter-rouge">MSA</code>는 클라우드 인프라와 접목해 구체화</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MSA</code> 내부 아키텍처 : <code class="language-plaintext highlighter-rouge">API</code>, 비즈니스 로직, 이벤트 발행, 데이터 처리의 구조화 등 <code class="language-plaintext highlighter-rouge">MSA</code> 내부 구조를 정의한 것</li>
  <li><code class="language-plaintext highlighter-rouge">MSA</code> 외부 아키텍처 : 인프라, 플랫폼, 어플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것</li>
</ul>

<h3 id="리액티브-선언-the-reactive-manifesto--어플리케이션이-요청에-즉각-응답하고-가동되길-기대">리액티브 선언 (<code class="language-plaintext highlighter-rouge">The Reactive Manifesto</code>) : 어플리케이션이 요청에 즉각 응답하고 가동되길 기대</h3>
<ul>
  <li>응답성 (<code class="language-plaintext highlighter-rouge">Responsive</code>) : 사용자에게 신뢰성 있는 응답을 빠르고 적절히 제공하는 능력</li>
  <li>탄력성 (<code class="language-plaintext highlighter-rouge">Resilient</code>) : 장애가 발생하더라도 시스템 전체에 영향을 주지 않고 복구하는 능력</li>
  <li>유연성 (<code class="language-plaintext highlighter-rouge">Elastic</code>) : 사용량에 변화가 있더라도 그에 비례해 자원을 조절해 균일한 응답성을 제공하는 능력</li>
  <li>메시지 기반 (<code class="language-plaintext highlighter-rouge">Message Driven</code>) : 비동기 메시지로 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향</li>
</ul>

<p>→ 4가지 요건을 만족하는 시스템을, 급변하는 상황을 적응할 수 있는 리엑티브 시스템 (<code class="language-plaintext highlighter-rouge">Reactive System</code>)이라 정의</p>

<h3 id="강결합에서-약결합의-아키텍처로의-변화">강결합에서 약결합의 아키텍처로의 변화</h3>
<ul>
  <li>소프트웨어 아키텍처 : 소프트웨어를 구성하는 요소와 그 구성 요소 간의 관계를 정의한 것
    <ul>
      <li>아키텍처를 정의하는 과정 : 시스템 구축을 위한 여러 비기능 요건들을 만족하는 해결 방법을 찾는 과정
        <ul>
          <li>비기능 요건 : 시스템 성능, 시스템 가용성, 보안, 유지보수성, 확장성 등</li>
        </ul>
      </li>
      <li>마이크로서비스 아키텍처는 ‘클라우드’라는 가상화된 인프라를 활용한 것이므로, 이를 고려해 설계해야 함</li>
    </ul>
  </li>
  <li>아키텍처 유연성 (<code class="language-plaintext highlighter-rouge">Architecture Flexibility</code>) : 시스템 자체가 변화 및 확장에 언제든지 대응할 수 있는 능력
    <ul>
      <li>시스템을 구성하는 구성 요소 간의 관계들이 느슨하게 결합되어 언제든지 대체되거나 확장될 수 있음</li>
      <li>리액티브 시스템이 리액티브하기 위해서 반드시 갖춰야 할 특성 중 하나</li>
      <li>클라우드 인프라 자체가 유연성과 확장성을 갖추므로, 어플리케이션 아키텍처 또한 아키텍처 유연성이 필요</li>
    </ul>
  </li>
</ul>

<iframe width="90%" height="350" style="border:none" src="https://landscape.cncf.io/?category=automation-configuration&amp;grouping=category&amp;fullscreen=yes"></iframe>

<ul>
  <li>과거 : 아키텍처 구성 요소들이 특정 벤더의 제품에 전적으로 의존
    <ul>
      <li>유명한 제품군을 사용함으로 품질이 보장될 수 있음</li>
      <li>특정 기술에 락인 (<code class="language-plaintext highlighter-rouge">lock-in</code>)되어 시스템을 쉽게 변경하거나 확장하기 어려움</li>
    </ul>
  </li>
  <li>현재 : 클라우드 환경 아래에서 사용하는 오픈 소스 기반 제품들이 충분한 기능, 품질, 호환성을 제공
    <ul>
      <li>아키텍처 설계가 필요한 레이어에서 적절한 솔루션을 선택하고 이를 조합하는 개방적 방식으로 변화</li>
      <li>클라우드 기반 어플리케이션의 구축에 필요한 인프라 및 어플리케이션 영역에 다양한 제품들이 등장</li>
    </ul>
  </li>
</ul>

<h2 id="msa-패턴--msa의-문제-영역에-대해-여러-사람들에-의해-검증되어-정리된-스타일-혹은-패턴"><code class="language-plaintext highlighter-rouge">MSA</code> 패턴 : <code class="language-plaintext highlighter-rouge">MSA</code>의 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 스타일 혹은 패턴</h2>
<ul>
  <li>인프라 구성 요소 : 마이크로서비스를 지탱하는 인프라스트럭처를 구축하는 데에 필요한 구성 요소</li>
  <li>플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴</li>
  <li>어플리케이션 패턴 : 마이크로서비스 어플리케이션을 구성하는 데에 필요한 패턴</li>
</ul>

<h3 id="인프라-구성-요소를-서비스-유형별로-나누어-해당되는-제품-중-하나를-의사결정--클라우드-인프라">인프라 구성 요소를 서비스 유형별로 나누어 해당되는 제품 중 하나를 의사결정 → 클라우드 인프라</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IaaS</code> (<code class="language-plaintext highlighter-rouge">Infrastructure as a Service</code>) : 가상 머신, 스트리지, 네트워크 등 인프라 제공
    <ul>
      <li>고객이 관리할 수 있는 범위가 가장 넓은 클라우드 컴퓨팅 서비스</li>
      <li><code class="language-plaintext highlighter-rouge">AWS</code> 등 퍼플릭 클라우드 공급 업체 (<code class="language-plaintext highlighter-rouge">CSP</code>)가 준비한 환경을 고객이 선택할 수 있음</li>
      <li>가상화된 물리적 자원을 <code class="language-plaintext highlighter-rouge">UI</code> 형태의 대시보드 혹은 <code class="language-plaintext highlighter-rouge">API</code> 형태로 제공</li>
      <li>고객은 서버와 스트리지에 접근할 수 있지만, 클라우드 내 가상 데이터 센터를 통해 리소스를 전달받는 형태</li>
      <li>개발자는 운영체제와 어플리케이션을 직접 관리해야 함 : 개발자와 인프라 관리자의 역할이 분담</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">AWS EC2</code>, <code class="language-plaintext highlighter-rouge">AWS S3</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CaaS</code> (<code class="language-plaintext highlighter-rouge">Container as a Service</code>) : 업로드, 구성, 실행, 확장, 중지할 수 있는 컨테이너 제공
    <ul>
      <li>가상 머신이 아닌 컨테이너를 기본 리소스로 활용해 어플리케이션을 개발, 실행, 관리</li>
      <li>컨테이너화된 어플리케이션을 빌드하고 배포하는 개발 환경은 퍼플릭 클라우드 공급 업체 (<code class="language-plaintext highlighter-rouge">CSP</code>)가 제공</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">Kubernetes Service</code>, <code class="language-plaintext highlighter-rouge">AWS ECS</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PaaS</code> (<code class="language-plaintext highlighter-rouge">Platform as a Service</code>) : 어플리케이션에 미들웨어, 런타임까지 탑재한 플랫폼을 제공
    <ul>
      <li>가상화된 클라우드 위에 원하는 서비스를 개발할 수 있도록 개발 환경을 미리 구축해 서비스 형태로 제공</li>
      <li>고객은 개발 환경을 고려할 필요 없이 어플리케이션 자체에 집중할 수 있음</li>
      <li>어플리케이션이 플랫폼에 종속되어 개발되므로, 다른 플랫폼으로의 이식이 어려울 수도 있음</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">Lambda</code>, <code class="language-plaintext highlighter-rouge">AWS Elastic Beanstalk</code></li>
    </ul>
  </li>
</ul>

<h3 id="시스템의-기반이-되는-인프라-레이어의-구축--베어메탈-장비-혹은-가상-인프라-환경을-통한-구축">시스템의 기반이 되는 인프라 레이어의 구축 → 베어메탈 장비 혹은 가상 인프라 환경을 통한 구축</h3>
<ul>
  <li>가상 인프라 환경 : 하이퍼바이저 (<code class="language-plaintext highlighter-rouge">Hypervisor</code>)의 사용 여부 및 게스트 OS 유무에 따라 나뉨
    <ul>
      <li>가상 머신 (<code class="language-plaintext highlighter-rouge">VM</code>) : 하이퍼바이저를 통해 하나의 시스템에서 여러 운영체제를 사용
        <ul>
          <li>운영체제 패치 및 관련 라이브러리 설치로 인한 오버헤드가 지속적으로 발생</li>
        </ul>
      </li>
      <li>컨테이너 (<code class="language-plaintext highlighter-rouge">Container</code>) : 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성
        <ul>
          <li>도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 제어
            <ul>
              <li>이식성 : 도커만 실행할 수 있으면 호스트 커널에 상관없이 동일하게 사용</li>
              <li>신속성 : 크기가 작고 가벼워 빠른 배포가 가능 + 문제 발생 시 다시 가동하면 됨</li>
              <li>재사용성 : 동일한 환경을 재사용해 쉽게 설정 가능 → 서버 환경 구축이 쉬워짐</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>컨테이너 오케스트레이션 (<code class="language-plaintext highlighter-rouge">Container Orchestration</code>) : 컨테이너 관리 기술
        <ul>
          <li>컨테이너 배치 및 복제, 확장 및 축소, 장애 복구 컨테이너 간 통신, 로드밸런싱 등</li>
          <li>쿠버네티스 (<code class="language-plaintext highlighter-rouge">Kubernetes</code>) : <code class="language-plaintext highlighter-rouge">Pod</code>, <code class="language-plaintext highlighter-rouge">Deployment</code>, <code class="language-plaintext highlighter-rouge">Replica Sets</code> 정보 확인 가능
            <ul>
              <li>각 컨테이너가 요구하는 자원을 쿠버네티스에 요청하면 노드에 맞춰 자동 배치</li>
              <li>컨테이너 이상을 점검해, 실패하면 컨테이너를 자동으로 교체하고 리스케줄링</li>
              <li>일정량의 <code class="language-plaintext highlighter-rouge">CPU</code> 및 메모리 사용량을 초과하면 자동으로 수평 확장</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="마이크로서비스의-운영과-관리를-지원할-클라우드-플랫폼-미들웨어의-구축--플랫폼-패턴">마이크로서비스의 운영과 관리를 지원할 클라우드 플랫폼 (미들웨어)의 구축 → 플랫폼 패턴</h3>
<ul>
  <li>데비옵스 (<code class="language-plaintext highlighter-rouge">DevOps</code>) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화
    <ul>
      <li>소프트웨어를 빠르게 개발하게끔 지원하는 빌드, 테스트, 배포를 위한 자동화 환경</li>
      <li>지속적 제공 (<code class="language-plaintext highlighter-rouge">CI</code>) : 빌드된 소스 코드의 실행 파일을 실행 환경에 반영하기 전에 진행</li>
      <li>지속적 배포 (<code class="language-plaintext highlighter-rouge">CD</code>) : 저장소에 빌드한 소스 코드의 실행 파일을 실행 환경까지 자동으로 배포</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자동 빌드 및 배포 절차</p>
  <ol>
    <li>매일 자신이 작성한 소스 코드와 이를 테스트할 테스트 코드를 형상관리 시스템에 보낸다. (<code class="language-plaintext highlighter-rouge">Push</code>)</li>
    <li>매일 빌드 도구에서 형상관리 서버의 코드를 가져와 (<code class="language-plaintext highlighter-rouge">Pull</code>) 통합하고, 자동으로 빌드하고 테스트를 수행한다.</li>
    <li>테스트 수행 결과를 리포트에 기록하고, 빌드된 소스 코드를 스테이징 환경에 자동으로 배포한다.</li>
    <li>테스터가 스테이징 환경에서 테스트를 수행할 때 혹은 리포트 결과에 문제가 있으면, 소스 코드를 수정한다.</li>
  </ol>
</blockquote>

<ul>
  <li>빌드·배포 파이프라인의 설계 : 빌드·배포 과정동안 수행해야 할 업무 (<code class="language-plaintext highlighter-rouge">task</code>)를 정의한 것
    <ul>
      <li>리포지토리에서 소스 코드를 가져와 빌드해 실행 파일을 만드는 작업</li>
      <li>이전 작업이 성공하면, 다음 작업이 자동으로 수행히게끔 위의 작업들을 관리하는 작업</li>
      <li>실행할 어플리케이션을 실행 환경에 배포하는 작업</li>
    </ul>

    <p>→ <code class="language-plaintext highlighter-rouge">IaaS</code>를 통해 빌드·배포 파이프라인의 절차를 완벽하게 자동화할 수 있음</p>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[마이크로서비스 아키텍처 (MSA) : 마이크로서비스를 접목한 아키텍처 구조]]></summary></entry><entry><title type="html">[JPA] 1. JPA</title><link href="http://localhost:4000/jpa1/" rel="alternate" type="text/html" title="[JPA] 1. JPA" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/jpa1</id><content type="html" xml:base="http://localhost:4000/jpa1/"><![CDATA[<h2 id="개발자가-sql을-직접-다룰-때의-문제">개발자가 <code class="language-plaintext highlighter-rouge">SQL</code>을 직접 다룰 때의 문제</h2>

<ol>
  <li>
    <h3 id="db는-객체-구조와는-다른-데이터-중심의-구조를-가져-객체를-db에서-직접-저장하거나-조회할-수-없음"><code class="language-plaintext highlighter-rouge">DB</code>는 객체 구조와는 다른 데이터 중심의 구조를 가져 객체를 DB에서 직접 저장하거나 조회할 수 없음</h3>
    <ul>
      <li>개발자가 객체지향 어플리케이션과 <code class="language-plaintext highlighter-rouge">DB</code> 중간에서 <code class="language-plaintext highlighter-rouge">SQL</code>과 <code class="language-plaintext highlighter-rouge">JDBC API</code>를 이용해 변환해야 함</li>
      <li>객체를 DB에 CRUD하기 위해서 너무 많은 <code class="language-plaintext highlighter-rouge">SQL</code>과 <code class="language-plaintext highlighter-rouge">JDBC API</code>를 코드로 작성해야 함</li>
    </ul>
  </li>
  <li>
    <h3 id="dao를-이용해-sql를-은닉해도-결국엔-sql에-의존적인-개발이-될-수-밖에-없음"><code class="language-plaintext highlighter-rouge">DAO</code>를 이용해 <code class="language-plaintext highlighter-rouge">SQL</code>를 은닉해도 결국엔 <code class="language-plaintext highlighter-rouge">SQL</code>에 의존적인 개발이 될 수 밖에 없음</h3>
    <ul>
      <li>개발자가 엔티티를 신뢰하고 사용할 수 없음… 이게 진정한 계층 분할?</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>그럼, <code class="language-plaintext highlighter-rouge">JPA</code>는 어떻게 문제를 해결하였는가?</p>

  <ul>
    <li>객체를 <code class="language-plaintext highlighter-rouge">DB</code>에 저장하고 관리할 때 <code class="language-plaintext highlighter-rouge">JPA</code>가 제공하는 <code class="language-plaintext highlighter-rouge">API</code> 사용
      <ul>
        <li>저장 → <code class="language-plaintext highlighter-rouge">persist()</code> : 객체를 DB에 저장하면, <code class="language-plaintext highlighter-rouge">INSERT SQL</code>를 생성해서 <code class="language-plaintext highlighter-rouge">DB</code>에 전달</li>
        <li>조회 → <code class="language-plaintext highlighter-rouge">find()</code> : 객체 하나를 DB에서 조회하면, <code class="language-plaintext highlighter-rouge">SELECT SQL</code>를 생성해서 <code class="language-plaintext highlighter-rouge">DB</code>에 전달</li>
        <li>수정 → 객체를 조회해 값을 변경하면, 트랜잭션을 커밋할 때 <code class="language-plaintext highlighter-rouge">UPDATE SQL</code>를 생성해 <code class="language-plaintext highlighter-rouge">DB</code>에 전달</li>
        <li>연관 객체 조회 → 연관된 객체를 사용하는 시점에 <code class="language-plaintext highlighter-rouge">SELECT SQL</code>를 실행</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="객체와-관계형-데이터베이스의-패러다임-불일치">객체와 관계형 데이터베이스의 패러다임 불일치</h2>
<ul>
  <li>객체지향 프로그래밍 : 추상화, 캡슙화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치 제공</li>
  <li>비즈니스 요구사항을 정의한 도메인 모델 또한 객체로 모델링 → 객체와 관계형 데이터베이스는 지향하는 바가 다르다!</li>
</ul>

<ol>
  <li>
    <h3 id="상속--객체는-상속이라는-기능을-가지지만-테이블은-상속이라는-기능이-없음">상속 : 객체는 상속이라는 기능을 가지지만, 테이블은 상속이라는 기능이 없음</h3>
    <ul>
      <li>데이터베이스 모델링의 슈퍼타입-서브타입 관계를 이용한다고 해도, 매번 2가지 <code class="language-plaintext highlighter-rouge">SQL</code>를 만들어야 함</li>
    </ul>
  </li>
  <li>
    <h3 id="연관관계--객체는-참조를-사용해-다른-객체와-연관관계를-가지고-참조에-접근해서-조회">연관관계 : 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조에 접근해서 조회</h3>
    <ul>
      <li>그러나 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 이용해서 연관된 테이블을 조회</li>
      <li>그럼 객체를 테이블에 맞추어 모델링하면? : 외래 키와 참조의 예 → 객체지향의 장점을 잃어버릴 수 있다!</li>
    </ul>
  </li>
  <li>
    <h3 id="객체-그래프-탐색--객체에서-회원이-소속된-팀을-조회할-때에는-참조를-사용해-연관된-팀을-탐색">객체 그래프 탐색 : 객체에서 회원이 소속된 팀을 조회할 때에는 참조를 사용해 연관된 팀을 탐색</h3>
    <ul>
      <li>그런데 참조를 통해 팀을 탐색할 수 있을지 없을지 알 수 없음 → 너무나 큰 제약사항
        <ul>
          <li>결국 <code class="language-plaintext highlighter-rouge">DAO</code>를 통해 <code class="language-plaintext highlighter-rouge">SQL</code>을 직접 확인하기 위해 상황에 따른 여러 메소드를 만들어야 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h3 id="비교--데이터베이스는-기본-키의-값으로-각-row를-구분하지만-객체는-동일성-비교-동등성-비교를-활용">비교 : 데이터베이스는 기본 키의 값으로 각 <code class="language-plaintext highlighter-rouge">row</code>를 구분하지만, 객체는 동일성 비교, 동등성 비교를 활용</h3>
    <ul>
      <li>동일성 비교 (<code class="language-plaintext highlighter-rouge">==</code>) : 객체 인스턴스의 주소 값을 비교, 동등성 비교 (<code class="language-plaintext highlighter-rouge">equals()</code>) : 객체 내부의 값을 비교
        <ul>
          <li>기본 키 값이 같은 객체를 2번 조회했을 때, 이 객체들이 다른 인스턴스면 동등하되 동일하지 않다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>그럼, <code class="language-plaintext highlighter-rouge">JPA</code>는 어떻게 문제를 해결하였는가?</p>

  <ul>
    <li>상속 → 자바 컬렉션에 객체를 저장하듯이 <code class="language-plaintext highlighter-rouge">JPA</code>에 객채를 저장하면 이를 두 테이블에 나눠 저장</li>
    <li>연관관계 → 개발자가 관계를 설정해 객체를 저장하면, 참조를 외래 키로 변환해 <code class="language-plaintext highlighter-rouge">INSERT SQL</code> 전달</li>
    <li>객체 그래프 탐색 : 실제 객체를 사용하는 시점까지 <code class="language-plaintext highlighter-rouge">DB</code> 조회를 미루는 지연 로딩 이용</li>
    <li>비교 : 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장</li>
  </ul>
</blockquote>

<h2 id="jpa-java-persistence-api--자바-진영의-orm-기술-표준"><code class="language-plaintext highlighter-rouge">JPA</code> (<code class="language-plaintext highlighter-rouge">Java Persistence API</code>) : 자바 진영의 <code class="language-plaintext highlighter-rouge">ORM</code> 기술 표준</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ORM</code> (<code class="language-plaintext highlighter-rouge">Object-Relational Mapping</code>) : 객체와 관계형 <code class="language-plaintext highlighter-rouge">DB</code>를 매핑</li>
</ul>

<h3 id="왜-jpa를-사용해야-하는가">왜 <code class="language-plaintext highlighter-rouge">JPA</code>를 사용해야 하는가?</h3>
<ol>
  <li>생산성 : 반복되는 <code class="language-plaintext highlighter-rouge">CRUD</code>용 <code class="language-plaintext highlighter-rouge">SQL</code> 코드를 작성하는 대신, 자바 컬렉션에 객체를 저장하듯 <code class="language-plaintext highlighter-rouge">JPA</code>에 객체를 전달하면 됨</li>
  <li>유지보수 : 매번 <code class="language-plaintext highlighter-rouge">SQL</code>과 <code class="language-plaintext highlighter-rouge">JDBC API</code> 코드를 변경할 필요 없음</li>
  <li>패러다임의 불일치 해결 : <code class="language-plaintext highlighter-rouge">ORM</code> 프레임워크가 상속, 연관관계, 객체 그래프 탐색, 비교 등의 문제를 대신 해결</li>
  <li>성능 : 어플리케이션과 <code class="language-plaintext highlighter-rouge">DB</code> 사이에서 동작하면서 다양한 성능 최적화 기회를 제공</li>
  <li>데이터 접근 추상화 및 벤더 독립성 : <code class="language-plaintext highlighter-rouge">DB</code> 접근 계층을 제공해서 특정 <code class="language-plaintext highlighter-rouge">DB</code> 기술에 종속되지 않음</li>
</ol>

<blockquote>
  <p>References</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62681446">자바 ORM 표준 JPA 프로그래밍</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JPA" /><summary type="html"><![CDATA[개발자가 SQL을 직접 다룰 때의 문제]]></summary></entry><entry><title type="html">[MicroService] 1. MicroService</title><link href="http://localhost:4000/microservice1/" rel="alternate" type="text/html" title="[MicroService] 1. MicroService" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-14T00:00:00+09:00</updated><id>http://localhost:4000/microservice1</id><content type="html" xml:base="http://localhost:4000/microservice1/"><![CDATA[<h2 id="비즈니스-민첩성--자신의-특화된-서비스를-빠르게-제공하고-피드백을-반영해-서비스를-빠르게-개선">비즈니스 민첩성 : 자신의 특화된 서비스를 빠르게 제공하고, 피드백을 반영해 서비스를 빠르게 개선</h2>

<ul>
  <li>빠른 배포 주기 : 비즈니스 민첩성을 간접적으로 보여주는 지표 → 어떻게 빠른 비즈니스 속도를 가질 수 있을까?</li>
</ul>

<h3 id="클라우드-인프라-cloud-infra의-등장--아마존의-aws-구글의-구글-클라우드-플랫폼">클라우드 인프라 (<code class="language-plaintext highlighter-rouge">Cloud Infra</code>)의 등장 : 아마존의 <code class="language-plaintext highlighter-rouge">AWS</code>, 구글의 구글 클라우드 플랫폼</h3>
<ul>
  <li>비용 측면 : 클라우드의 사용량에 따라 비용을 유연하게 조정할 수 있음 → 사용한 만큼만 비용을 지불</li>
  <li>어플리케이션 측면 : 어플리케이션을 여러 개의 블록처럼 관리해 효율성을 극대화
    <ul>
      <li>사용량 증가에 따른 성능 및 가용성을 <code class="language-plaintext highlighter-rouge">Scale-up</code>, <code class="language-plaintext highlighter-rouge">Scale-out</code> → 특정 부분만 탄력성 있게 확장 가능</li>
    </ul>
  </li>
</ul>

<h3 id="어떤-서비스가-클라우드-인프라에-적합할까--클라우드-프랜들리-클라우드-네이티브">어떤 서비스가 클라우드 인프라에 적합할까 : 클라우드 프랜들리? 클라우드 네이티브?</h3>
<ul>
  <li>클라우드 프렌들리 (<code class="language-plaintext highlighter-rouge">Cloud Friendly</code>) : 시스템을 하나의 큰 덩어리로 만들어 클라우드 인프라에 올리는 것</li>
  <li>클라우드 네이티브 (<code class="language-plaintext highlighter-rouge">Cloud Native</code>) : 시스템을 여러 개의 블록 단위로 나누어 클라우드 인프라에 올리는 것</li>
</ul>

<h2 id="마이크로서비스-microservice--여러-서비스-인스턴스가-하나의-비즈니스-어플리케이션-구성">마이크로서비스 (<code class="language-plaintext highlighter-rouge">MicroService</code>) : 여러 서비스 인스턴스가 하나의 비즈니스 어플리케이션 구성</h2>
<ul>
  <li>서비스가 갖는 저장소가 각각 다르므로 업무 단위로 모듈 경계가 명확하게 구분
    <ul>
      <li>확장하거나 변경할 때에는 특정 기능별로 독립적으로 작업한 뒤에 빌드해서 배포하면 됨</li>
      <li>각 서비스가 독립적이기에 서로 다른 언어, 데이터, 기술로도 개발 가능 → 폴리글랏 (<code class="language-plaintext highlighter-rouge">Polyglot</code>)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>마이크로서비스 이전에는? : 모노리스 (<code class="language-plaintext highlighter-rouge">Monolith</code>)</p>
  <ul>
    <li>전체 시스템이 하나의 단위로 개발되는 일체식 어플리케이션</li>
    <li>일반적으로 클라이언트, 어플리케이션, 데이터베이스의 <code class="language-plaintext highlighter-rouge">3-tier</code> 시스템으로 구성</li>
    <li>아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 함</li>
    <li>단일 프로세스에서 실행되므로, 확장이 필요할 경우에 전체 어플리케이션을 동시에 확장해야 함
      <ul>
        <li>로드밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 스케일 아웃</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="마이크로서비스를-위한-조건은-무엇인가">마이크로서비스를 위한 조건은 무엇인가?</h3>

<ol>
  <li>
    <h4 id="업무-기능-중심-팀">업무 기능 중심 팀</h4>
    <ul>
      <li>콘웨이 법칙 (<code class="language-plaintext highlighter-rouge">Conway’s law</code>) : 시스템을 개발할 때 항상 시스템의 모양이 팀 의사소통 구조를 반영
        <ul>
          <li>마이크로서비스를 만드는 팀은 역할이나 기술이 아닌, 업무 기능을 중심으로 한 팀이 되어야 함</li>
        </ul>
      </li>
      <li>기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자, 테스터 등 다양한 역할의 인원으로 구성
        <ul>
          <li>서비스를 처음부터 끝까지 만들기 위한 모든 단계의 역할을 갖추고 있음</li>
          <li>같은 공간, 같은 시간을 공유하기에 의사소통이 원활하고 빠르게 진행할 수 있음</li>
          <li>여러 기능들이 모여 있다는 의미에서 다기능 팀 (<code class="language-plaintext highlighter-rouge">Cross-Functional Team</code>)이라고도 부름</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="자율적인-분권-거버넌스">자율적인 분권 거버넌스</h4>
    <ul>
      <li>각 마이크로서비스 팀은 빠르게 서비스를 만드는 것을 최우선 목적으로 함
        <ul>
          <li>중앙의 강력한 표준이나 절차 준수를 강요받지 않음</li>
          <li>스스로 효율적인 방법론과 도구, 기술을 찾아 적용 → 폴리글랏 프로그래밍, 폴리글랏 저장소</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="제품-중심의-생명-주기">제품 중심의 생명 주기</h4>
    <ul>
      <li>개발 모델이 프로젝트 단위가 아니라 제품 단위로 구성됨 → 개발 조직과 운영 조직이 결합</li>
      <li>소프트웨어를 완성해야 할 기능들의 집합이 아닌, 비즈니스를 제공하는 제품 (<code class="language-plaintext highlighter-rouge">Product</code>)로 봄
        <ul>
          <li>우선 빠르게 개발한 뒤에 반응을 보고 개선하는 방식으로 개발</li>
          <li>프로젝트 형태의 워터풀 (<code class="language-plaintext highlighter-rouge">WaterFall</code>) 개발 방식이 아닌, 제품 중심의 에자일 (<code class="language-plaintext highlighter-rouge">Agile</code>) 개발 방식 채용</li>
          <li>2~3주 단위의 스프린트 (<code class="language-plaintext highlighter-rouge">Sprint</code>)를 통해 소프트웨어에 피드백을 즉각적으로 반영</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="cicd-파이프라인의-자동화"><code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인의 자동화</h4>
    <ul>
      <li>개발과 운영을 동시에 수행하는 데비옵스 (<code class="language-plaintext highlighter-rouge">DevOps</code>)를 궁극적으로 가능하게 함</li>
      <li>각각의 <code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인 프로세스는 <code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인 도구를 통해 자동화가 이루어짐
        <ul>
          <li>‘<code class="language-plaintext highlighter-rouge">Infrastructure as Code</code>’ : 코드를 이용해 인프라 구성부터 어플리케이션 빌드 및 배포를 정의</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="분권-데이터-관리">분권 데이터 관리</h4>
    <ul>
      <li>폴리글랏 저장소 (<code class="language-plaintext highlighter-rouge">Polyglot Persistence</code>) 접근법 : 서비스별로 데이터베이스를 갖도록 설계
        <ul>
          <li>각각의 저장소가 서비스별로 분산되어 있으며, 다른 서비스에 <code class="language-plaintext highlighter-rouge">API</code>를 통해 접근함</li>
        </ul>
      </li>
      <li>결과적 일관성 (<code class="language-plaintext highlighter-rouge">Eventual Consistency</code>) : 일시적으로 다른 두 서비스의 데이터가 결국엔 동일해짐
        <ul>
          <li>여러 트랜잭션을 하나로 묶지 않고, 별도의 로컬 트랙잭션을 수행</li>
          <li>각 저장소 내 데이터의 비즈니스 정합성을 위해 데이터 일관성이 다른 부분을 보상 트랙잭션으로 맞춤</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="내결함성을-고려한-설계">내결함성을 고려한 설계</h4>
    <ul>
      <li>내결함성 (<code class="language-plaintext highlighter-rouge">Fault Tolerance</code>) : 시스템은 언제든 실패할 수 있는 가능성이 존재한다.
        <ul>
          <li>시스템이 실패해서 더는 진행할 수 없을 때에도, 자연스럽게 대응할 수 있도록 설계하여야 함</li>
        </ul>
      </li>
      <li>다양한 실패에 대비해 완벽히 테스트할 수 있는 환경을 마련해야 함</li>
      <li>시스템의 실패를 감지하고 대응하기 위한 실시간 모니터링 체계 또한 갖춰야 함</li>
      <li>장애를 일부러 발생시키는 카오스 몽키 (<code class="language-plaintext highlighter-rouge">Chaos Monkey</code>)를 만들어 아키텍처 동작을 점검하기도 함</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[비즈니스 민첩성 : 자신의 특화된 서비스를 빠르게 제공하고, 피드백을 반영해 서비스를 빠르게 개선]]></summary></entry><entry><title type="html">[Docker] 4. Docker File</title><link href="http://localhost:4000/docker4/" rel="alternate" type="text/html" title="[Docker] 4. Docker File" /><published>2023-12-08T00:00:00+09:00</published><updated>2023-12-08T00:00:00+09:00</updated><id>http://localhost:4000/docker4</id><content type="html" xml:base="http://localhost:4000/docker4/"><![CDATA[<h2 id="도커-파일-dockerfile--서버-운영-기록을-코드로-저장한-파일을-특정-시점의-도커-이미지로-빌드">도커 파일 (<code class="language-plaintext highlighter-rouge">Dockerfile</code>) : 서버 운영 기록을 코드로 저장한 파일을 특정 시점의 도커 이미지로 빌드</h2>

<blockquote>
  <ul>
    <li>눈송이 서버 (<code class="language-plaintext highlighter-rouge">Snowflakes Server</code>) : 각 서버마다 운영 기록이 달라 서로 모양이 다른 서버들이 공존하는 상황</li>
  </ul>

  <p>… 서버 간의 운영체제, 컴파일러, 설치된 패키지 등의 차이로 발생하는 문제 개선을 위해 서버 운영 기록을 저장하자!</p>
</blockquote>

<h3 id="도커-파일을-생성하는-과정은-테스트-주도-개발의-순환에-부합하다고-볼-수-있다">도커 파일을 생성하는 과정은 테스트 주도 개발의 순환에 부합하다고 볼 수 있다.</h3>
<ul>
  <li>테스트 주도 개발 (<code class="language-plaintext highlighter-rouge">Test Driven Development</code>) : 선 테스트 후 개발 사이클을 반복하는 개발 방법론</li>
</ul>

<div style="color: white; padding: 2% 1% 1% 1%; background-color: black;">
<ol>
  <li>테스트를 작성한다. → 도커 파일을 만든다.</li>
  <li>테스트에 실패하고 코드를 수정한다. → 도커 이미지의 빌드에 실패하고 도커 파일을 수정한다.</li>
  <li>테스트에 성공한다면, 코드를 리펙터링한다. → 도커 이미지의 빌드에 성공한다면, 도커 파일의 내용을 리펙터링한다.</li>
  <li>처음으로 되돌아간다.</li>
</ol>
</div>

<h3 id="dsl-domain-specific-language--도커-파일을-작성할-때-쓰는-언어-도커-이미지의-생성-과정-표현"><code class="language-plaintext highlighter-rouge">DSL</code> (<code class="language-plaintext highlighter-rouge">Domain-Specific Language</code>) : 도커 파일을 작성할 때 쓰는 언어 (도커 이미지의 생성 과정 표현)</h3>
<blockquote>
  <p>생성 과정을 표현? : 도커 파일은 일련의 인스트럭션을 실행된 결과로 도커 이미지를 생성한다.</p>
  <ul>
    <li>도커 파일의 인스트럭션과 이미지 레이어는 <code class="language-plaintext highlighter-rouge">1:1</code>의 관계를 가진다.</li>
  </ul>
</blockquote>

<iframe width="80%" height="700" style="border:none" src="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#what-is-a-dockerfile"></iframe>

<ul>
  <li>
    <h4 id="from--다른-컨테이너-이미지를-빌드의-시작점으로-지정"><code class="language-plaintext highlighter-rouge">FROM</code> : 다른 컨테이너 이미지를 빌드의 시작점으로 지정</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">AS</code>: 컨테이너에 이름을 붙일 수 있음</li>
    </ul>
  </li>
  <li>
    <h4 id="env--컨테이너-내에서-사용될-환경-변수를-지정"><code class="language-plaintext highlighter-rouge">ENV</code> : 컨테이너 내에서 사용될 환경 변수를 지정</h4>
  </li>
  <li>
    <h4 id="workdir--컨테이너-이미지의-파일-시스템에-디렉터리를-만들고-해당-디렉터리를-작업-디렉터리로-지정"><code class="language-plaintext highlighter-rouge">WORKDIR</code> : 컨테이너 이미지의 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정</h4>
  </li>
  <li>
    <h4 id="copy--로컬의-파일-시스템-내-파일-디렉터리를-컨테이너-이미지로-복사"><code class="language-plaintext highlighter-rouge">COPY</code> : 로컬의 파일 시스템 내 파일, 디렉터리를 컨테이너 이미지로 복사</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">--from=</code> : 해당 파일이 호스트 컴퓨터가 아닌 다른 컨테이너의 파일임을 알려줌</li>
    </ul>
  </li>
  <li>
    <h4 id="cmd--도커가-이미지로부터-컨테이너를-실행했을-때-실행할-명령을-지정"><code class="language-plaintext highlighter-rouge">CMD</code> : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정</h4>
  </li>
  <li>
    <h4 id="run--빌드-과정에서-컨테이너-안에서-명령을-실행한-다음에-그-결과를-이미지-레이어에-저장"><code class="language-plaintext highlighter-rouge">RUN</code> : 빌드 과정에서 컨테이너 안에서 명령을 실행한 다음에 그 결과를 이미지 레이어에 저장</h4>
  </li>
</ul>

<h3 id="q-도커-파일을-쓰는-이유">Q. 도커 파일을 쓰는 이유?</h3>

<h4 id="a1-동일한-환경에서-어플리케이션을-실행-가능하게-한다">A1. 동일한 환경에서 어플리케이션을 실행 가능하게 한다.</h4>
<ul>
  <li>모든 빌드 과정은 도커 컨테이너 내부에서 이루어지며, 각 컨테이너는 모든 도구를 정확한 버전으로 갖추고 있다.
    <ul>
      <li>신규 개발자의 적응 기간, 빌드 서버의 관리 부담, 개발자 간의 도구 버전의 차이로 인한 빌드 실패를 줄일 수 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="a2-멀티-스테이지-환경에서-각-단계는-자신만의-캐시를-가져-성능을-향상시킬-수-있다">A2. 멀티 스테이지 환경에서 각 단계는 자신만의 캐시를 가져 성능을 향상시킬 수 있다.</h4>
<ul>
  <li>도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.
    <ul>
      <li>만약 해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당하는 단계 안으로 국한된다.</li>
      <li>이어지는 다음 단계는 캐시를 재사용하면서 시작되므로, 캐시 재사용을 통해 빌드 단계에서 시간 절약이 가능하다.</li>
    </ul>
  </li>
</ul>

<h4 id="a3-멀티-스테이지-스크립트를-통해-최종-산출물의-크기를-가능한-한-작게-유지할-수-있다">A3. 멀티 스테이지 스크립트를 통해 최종 산출물의 크기를 가능한 한 작게 유지할 수 있다.</h4>
<ul>
  <li>최종 산출물인 도커 이미지에 불필요한 도구를 제외하여 어플리케이션의 의존 모듈 자체를 줄일 수 있다.</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 파일 (Dockerfile) : 서버 운영 기록을 코드로 저장한 파일을 특정 시점의 도커 이미지로 빌드]]></summary></entry><entry><title type="html">[Docker] 3. Docker Container</title><link href="http://localhost:4000/docker3/" rel="alternate" type="text/html" title="[Docker] 3. Docker Container" /><published>2023-12-07T00:00:00+09:00</published><updated>2023-12-08T00:00:00+09:00</updated><id>http://localhost:4000/docker3</id><content type="html" xml:base="http://localhost:4000/docker3/"><![CDATA[<h2 id="도커-컨테이너-docker-container--도커에서-제공하는-컨테이너-기술">도커 컨테이너 (<code class="language-plaintext highlighter-rouge">Docker Container</code>) : 도커에서 제공하는 컨테이너 기술</h2>

<blockquote>
  <p><a href="https://pocj8ur4in.github.io//docker1/#컨테이너-container--소프트웨어-패키지-software-package의-추상화">해당 부분</a>에서 이어지는 내용입니다. 이전 내용에서는 가상화의 한 종류인 컨테이너 기술에 대해 서술하였다면, 이번에는 도커를 중심으로 하여 컨테이너에 대해 다뤄보겠습니다.</p>
</blockquote>

<h3 id="도커-컨테이너는-도커가-관리하는-독립적인-가상-리소스를-가진다">도커 컨테이너는 도커가 관리하는 독립적인 가상 리소스를 가진다.</h3>
<ul>
  <li>컨테이너 안에는 어플리케이션과 그 어플리케이션의 실행 환경 (호스트명, <code class="language-plaintext highlighter-rouge">IP</code> 주소, 디스크 드라이브 등)이 들어있음
    <ul>
      <li>각 컨테이너는 독립적인 환경을 가지되, 실행되는 컴퓨터의 <code class="language-plaintext highlighter-rouge">CPU</code>, 메모리, 운영체제를 공유함
        <ul>
          <li>격리 (<code class="language-plaintext highlighter-rouge">isolation</code>)와 밀집 (<code class="language-plaintext highlighter-rouge">density</code>)의 조건을 동시에 충족</li>
          <li>빌드 - 공유 - 실행의 <code class="language-plaintext highlighter-rouge">workflow</code>으로 소프트웨어 배포를 단순화하기에 적합</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/29e20ccf-68e2-417e-82aa-deffbab42585" /></p>

<ol>
  <li>컨테이너 내부 어플리케이션이 실행중이여야 컨테이너의 상태도 실행 중이 된다.
    <ul>
      <li>컨테이너가 <code class="language-plaintext highlighter-rouge">Existed</code>인 상태에서는 <code class="language-plaintext highlighter-rouge">CPU</code> 자원이나 메모리를 사용하지 않는다.</li>
    </ul>
  </li>
  <li>컨테이너가 종료되어도, 컨테이너는 사라지지 않고 그대로 남아있다.
    <ul>
      <li>나중에 다시 컨테이너를 실행하거나, 내부 파일이나 로그를 확인해볼 수 있다.</li>
      <li>컨테이너를 백그라운드에서 계속 동작하도록 하려면, <code class="language-plaintext highlighter-rouge">-d</code> (<code class="language-plaintext highlighter-rouge">--detach</code>)</li>
    </ul>
  </li>
  <li>컨테이너는 기본적으로 외부 환경에 노출되지 않는다.
    <ul>
      <li>도커는 호스트 컴퓨터의 네트워크 계층에 끼어들어 네트워크 트래픽 중 필요한 것을 컨테이너에 전달</li>
      <li>컨테이너의 포트를 호스트 컴퓨터에 공개하려면, <code class="language-plaintext highlighter-rouge">--publish</code>
        <ul>
          <li>도커가 호스트 컴퓨터를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너에 전달</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="도커-컨테이너-또한-별도의-환경-변수-environment-variable를-가질-수-있다">도커 컨테이너 또한 별도의 환경 변수 (<code class="language-plaintext highlighter-rouge">Environment variable</code>)를 가질 수 있다.</h3>
<ul>
  <li>호스트 운영체제의 것을 가져오는 것이 아닌, <code class="language-plaintext highlighter-rouge">IP</code> 주소나 호스트 이름처럼 도커로부터 부여받음</li>
</ul>

<h2 id="도커-이미지-docker-image--컨테이너의-실행에-필요한-모든-파일과-설정값-정보를-포함">도커 이미지 (<code class="language-plaintext highlighter-rouge">Docker Image</code>) : 컨테이너의 실행에 필요한 모든 파일과 설정값 정보를 포함</h2>
<ul>
  <li>상태값을 가지지 않음 (변하지 않는 값들을 저장) ↔ 컨테이너 : 이미지가 실행된 살태 (변하는 값들을 저장)</li>
  <li>이미지 레이어 : 도커 이미지는 여러 <code class="language-plaintext highlighter-rouge">Read-Only</code> 레이어로 구성되고, 파일 추가 및 생성 시 새로운 레이어 생성
    <ul>
      <li>이미지 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일로, 여러 이미지와 컨테이너에서 공유함</li>
      <li>유니온 파일 시스템 (<code class="language-plaintext highlighter-rouge">Union File Systems</code>)읕 통해 여러 개의 레이어를 하나의 파일 시스템으로 활용</li>
    </ul>
  </li>
</ul>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">docker image ls</code>에서 도커 이미지의 <code class="language-plaintext highlighter-rouge">SIZE</code>는 논리적 용량이지 실제로 차지하는 디스크 용량이 아니다!</li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9ea0b979-d07d-4a66-900a-e3ecd0c3142b" /></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">docker system df</code>를 통해 이미지 전체 용량의 총합을 볼 수 있다.</li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7c554710-303b-4e28-81df-e699a9fbbe89" /></p>
</blockquote>

<ul>
  <li>컨테이너 레이어 : 컨테이너가 실행되면 이미지 레이어 위에 읽기-쓰기 (<code class="language-plaintext highlighter-rouge">Read-Write</code>) 레이어를 추가
    <ul>
      <li>컨테이너를 실행하면서 생성되거나 변경된 내용을 저장</li>
    </ul>
  </li>
  <li>이미지 경로 : <code class="language-plaintext highlighter-rouge">URL</code> 방식으로 관리 -&gt; 뒤에 태그 (<code class="language-plaintext highlighter-rouge">/tag</code>)를 붙임</li>
</ul>

<h3 id="q-도커-이미지를-쓰는-이유--도커-이미지와-도커-컨테이너들을-클래스나-인스턴스처럼-활용한다">Q. 도커 이미지를 쓰는 이유? : 도커 이미지와 도커 컨테이너들을 클래스나 인스턴스처럼 활용한다.</h3>
<ul>
  <li>도커는 해시 값 (= 컨테이너 ID)과 임의의 이름 (= 컨테이너 이름)를 통해 컨테이너를 구분하고 이들을 환경변수로 관리</li>
</ul>

<div style="color: white; padding: 3% 2% 2% 2%; background-color: black;">
운영자가 지금까지 운영한 서버를 도커 이미지로 배포하고 도커 컨테이너에 설치한다면,
<ul>
  <li>도커 파일 : 지금까지 서버를 운영한 기록</li>
  <li>도커 이미지 (도커 파일 + 실행 시점) : 지금부터 설치된 서버가 가질 초기값</li>
  <li>도커 컨테이너 (도커 파일 + 환경 변수) : 지금부터 설치된 서버가 운영될 장소</li>
</ul>
</div>
<ul>
  <li>도커 안에서는 서버 역시 하나의 소프트웨어처럼 사용할 수 있고, 생성할 수 있는 컨테이너의 개수에도 제한이 없다.</li>
</ul>

<h3 id="도커-허브-docker-hub--도커-이미지를-서버에-공유하는-도커-레지스트리-서비스"><a href="https://hub.docker.com">도커 허브 (<code class="language-plaintext highlighter-rouge">Docker Hub</code>)</a> : 도커 이미지를 서버에 공유하는 도커 레지스트리 서비스</h3>

<ul>
  <li>도커 허브 계정을 생성한 후, 터미널을 통해 도커 허브에 접속</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker login --username pocj8ur4in
Password:
Login Succeeded
</code></pre></div></div>

<ul>
  <li>도커 이미지의 다운로드를 위한 이미지 참조 (<code class="language-plaintext highlighter-rouge">Image Reference</code>)는 네 개의 요소로 구성
    <ol>
      <li>이미지가 저장된 레지스트리 도메인 (기본값은 도커 허브)</li>
      <li>이미지 작성자 계정 <code class="language-plaintext highlighter-rouge">ID</code></li>
      <li>이미지 레포지토리 <code class="language-plaintext highlighter-rouge">ID</code></li>
      <li>이미지 태그 (기본값은 <code class="language-plaintext highlighter-rouge">latest</code>)</li>
    </ol>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker.io/diamol/golang:latest
</code></pre></div></div>

<ul>
  <li>이미지에 새로운 이미지 참조를 부여하여, 한 이미지에 여러 개의 참조를 갖게 할 수도 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image tag new-tag pocj8ur4in/vw-api:latest
</code></pre></div></div>

<h3 id="사설-도커-레지스트리-private-docker-registry--로컬에-전용-레지스트리를-설치-및-운영"><a href="https://waspro.tistory.com/532">사설 도커 레지스트리 (<code class="language-plaintext highlighter-rouge">Private Docker Registry</code>) : 로컬에 전용 레지스트리를 설치 및 운영</a></h3>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 컨테이너 (Docker Container) : 도커에서 제공하는 컨테이너 기술]]></summary></entry><entry><title type="html">[Docker] 2. Docker</title><link href="http://localhost:4000/docker2/" rel="alternate" type="text/html" title="[Docker] 2. Docker" /><published>2023-12-05T00:00:00+09:00</published><updated>2023-12-05T00:00:00+09:00</updated><id>http://localhost:4000/docker2</id><content type="html" xml:base="http://localhost:4000/docker2/"><![CDATA[<h2 id="도커-docker--컨테이너-기반-가상화-container-based-virtualization">도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 컨테이너 기반 가상화 (<code class="language-plaintext highlighter-rouge">Container-based Virtualization</code>)</h2>

<p><img src="https://pyrasis.com/assets/images/Docker-HOWTO/docker-containerized-appliction-blue-border_2.png.webp" width="50%" /></p>

<h3 id="q-도커를-쓰는-이유--비교적-효율적인-가상화-방식--통일된-개발-환경--배포의-동시성">Q. 도커를 쓰는 이유? : 비교적 효율적인 가상화 방식 + 통일된 개발 환경 + 배포의 동시성</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Virtualization</code> : 응용 프로그램 실행 시 운영체제 수준 가상화 방식이 성능 손실이 더 적고 빠르게 동작한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Development</code> : 운영체제에 상관없이 같은 환경에서 개발할 수 있게 해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">Deployment</code> : 서비스 환경과 응용 프로그램을 같이 배포할 수 있게 한다.</li>
</ol>

<blockquote>
  <ul>
    <li>분산 어플리케이션을 클라우드 환경으로 이주한다고 가정하면,
      <ul>
        <li><code class="language-plaintext highlighter-rouge">IaaS</code> : 서비스로서의 인프라
          <ul>
            <li>어플리케이션을 구성하는 각 컴포넌트가 모두 가상 머신에서 독립적으로 동작</li>
            <li>이주 과정은 쉽지만, 가상 머신의 성능을 모두 활용하지 못하며 운영비가 비쌈</li>
          </ul>
        </li>
        <li><code class="language-plaintext highlighter-rouge">PaaS</code> : 서비스로서의 플랫폼
          <ul>
            <li>어플리케이션을 구성하는 각 컴포넌트가 클라우드 서비스 제공자의 매니지드 서비스에 종속</li>
            <li>운영비가 저렴하고 관리가 쉬우나, 이주 과정이 복잡함</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <p>… 도커를 활용한다면? : 각 컴포넌트를 컨테이너로 이주하고, 쿠버네티스 등으로 전체 어플리케이션 관리 가능</p>
</blockquote>

<ul>
  <li><a href="https://www.docker.com">공식 홈페이지</a>에서 <code class="language-plaintext highlighter-rouge">.dmg</code> 파일을 다운로드 후 설치</li>
  <li>터미널 창에 다음 명령어를 입력해 도커가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker version // 현재 도커의 버전 확인

Client:
 Cloud integration: ~
 Version:           ~
 API version:       ~
 Go version:        ~

Server: ~
 Engine:
  Version:          ~
  API version:      ~
  Go version:       ~
</code></pre></div></div>
<blockquote>
  <p>Q. 클라이언트와 서버의 버전 정보가 따로 구성되어 있는 이유?</p>
  <ul>
    <li>도커가 클라이언트와 서버의 역할을 각각 수행할 수 있음
      <ul>
        <li>리눅스 터미널에 도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 출력</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="도커-컴포넌트-docker-component--도커-엔진을-중심으로-여러-컴포넌트를-조합해-구성">도커 컴포넌트 (<code class="language-plaintext highlighter-rouge">Docker Component</code>) : 도커 엔진을 중심으로 여러 컴포넌트를 조합해 구성</h2>

<ul>
  <li>
    <h3 id="도커-엔진-docker-engine--도커-이미지를-생성하고-컨테이너를-관리">도커 엔진 (<code class="language-plaintext highlighter-rouge">Docker Engine</code>) : 도커 이미지를 생성하고 컨테이너를 관리</h3>
    <ul>
      <li>로컬 이미지 캐시 담당 : 새로운 이미지가 필요할 때 이미지를 다운로드하거나, 기존 이미지를 사용</li>
      <li><code class="language-plaintext highlighter-rouge">Docker API</code>을 통해 맡은 기능 수행 → 도커 명령행 인터페이스 (<code class="language-plaintext highlighter-rouge">Docker CLI</code>)에서 도커 <code class="language-plaintext highlighter-rouge">API</code> 호출</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-레지스트리-docker-registry--도커-이미지를-공개하고-공유">도커 레지스트리 (<code class="language-plaintext highlighter-rouge">Docker REgistry</code>) : 도커 이미지를 공개하고 공유</h3>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Docker</code> 공식 레지스트리 서비스로 <code class="language-plaintext highlighter-rouge">Docker Hub</code>가 있음</li>
      <li>클라우드 사업자 또한 <code class="language-plaintext highlighter-rouge">AWS ECR</code>, <code class="language-plaintext highlighter-rouge">GCP Artifact Registry</code> 등의 컨테이너 레지스트리 제공</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-컴포즈-docker-compose--여러-컨테이너를-하나의-서비스로-정의해-컨테이너의-묶음으로-관리">도커 컴포즈 (<code class="language-plaintext highlighter-rouge">Docker Compose</code>) : 여러 컨테이너를 하나의 서비스로 정의해 컨테이너의 묶음으로 관리</h3>
    <ul>
      <li>여러 개의 컨테이너 구성 정보를 코드로 정의한 파일을 읽어 컨테이너를 순차적으로 생성</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-머신-docker-machine--가상-호스트에-도커-엔진을-설치하여-호스트를-관리">도커 머신 (<code class="language-plaintext highlighter-rouge">Docker Machine</code>) : 가상 호스트에 도커 엔진을 설치하여 호스트를 관리</h3>
    <ul>
      <li>여러 운영체제나 클라우드 환경에서 도커를 동일하게 실행하기 위해 도커의 실행 환경을 자동으로 생성</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-스왐-docker-swarm--여러-도커-호스트를-클러스터화해-관리">도커 스왐 (<code class="language-plaintext highlighter-rouge">Docker Swarm</code>) : 여러 도커 호스트를 클러스터화해 관리</h3>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Manger</code>가 클러스트를 관리하거나 <code class="language-plaintext highlighter-rouge">API</code>를 제공하고, <code class="language-plaintext highlighter-rouge">Node</code>가 컨테이너를 실행</li>
    </ul>
  </li>
</ul>

<h2 id="도커-명령어-docker-command--docker-command-형식으로-구성">도커 명령어 (<code class="language-plaintext highlighter-rouge">Docker Command</code>) : <code class="language-plaintext highlighter-rouge">docker &lt;command&gt;</code> 형식으로 구성</h2>
<ul>
  <li>리눅스 터미널에 도커 명령어를 입력하면 도커 서버에서 이에 해당되는 작업 수행</li>
  <li>항상 <code class="language-plaintext highlighter-rouge">root</code> 권한으로 실행되기에 <code class="language-plaintext highlighter-rouge">$ sudo</code>를 앞에 붙어야 함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo usermod -aG docker $USER # 현재 사용자를 docker 그룹에 추가
</code></pre></div></div>

<div style="text-align: center;">
    <table>
        <thead>
            <tr>
                <td>docker 명령어</td>
                <td>명령어 형식</td>
                <td>명령어 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>docker search</td>
                <td>$ docker search [이미지]</td>
                <td>도커 허브에서 이미지 검색</td>
            </tr>
            <tr>
                <td>docker pull</td>
                <td>$ docker pull [사용자명/] 이미지 [:태그]</td>
                <td>도커 허브에서 이미지 다운로드<br />사용자명을 지정해 도커 허브에서 해당 사용자가 올린 이미지을 다운로드<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker images</td>
                <td>$ docker images</td>
                <td>사용 가능한 모든 이미지 목록 확인</td>
            </tr>
            <tr>
                <td>docker rmi</td>
                <td>$ docker rmi 이미지 [:태그]</td>
                <td>다운로드한 이미지 삭제<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker run</td>
                <td>$ docker run [옵션] [실행할 이미지]</td>
                <td>이미지를 컨테이너로 생성한 뒤 컨테이너 실행<br />입력받은 이미지가 현재 없다면, 해당 이미지를 도커 허브에서 다운로드<br />실행할 파일을 지정해 직접 실행 가능 (여기서 빠져나오면 컨테이너가 정지)<br /><div style="text-align: center; font-size: 120%; padding: 2% 0% 0% 0%">
    <table>
        <thead>
            <tr>
                <td>docker run 옵션</td>
                <td>옵션 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>-d</td>
                <td>백그라운드 모드 (detached mode)</td>
            </tr>
            <tr>
                <td>-p [호스트 포트:컨테이너 포트]</td>
                <td>호스트와 컨테이너의 포트를 연결 (port forwarding)<br />http://호스트 IP:호스트 포트로 컨테이너의 포트 접속</td>
            </tr>
            <tr>
                <td>-v [호스트의 디렉터리]</td>
                <td>호스트의 디렉터리를 컨테이너의 디렉터리에 연결 (mount)</td>
            </tr>
            <tr>
                <td>-e [환경변수]</td>
                <td>컨테이너 내에서 사용할 환경변수 설정 (environment variable)</td>
            </tr>
            <tr>
                <td>--name [컨테이너 이름]</td>
                <td>컨테이너 이름 설정 (container name)</td>
            </tr>
            <tr>
                <td>-rm</td>
                <td>프로세스 종료 시 컨테이너 자동으로 제거 (remove container)</td>
            </tr>
            <tr>
                <td>-link [컨테이너 이름:주소]</td>
                <td>컨테이너와 컨테이너 연결 (link container)<br />[주소:포트번호]로 컨테이너에 접속</td>
            </tr>
            <tr>
                <td>-it</td>
                <td>리눅스 터미널 입력을 위한 옵션 (interactive / Pseudo-tty)</td>
            </tr>
         </tbody>
    </table>
</div></td>
            </tr>
            <tr>
              <td>docker ps</td>
              <td>$ docker ps [옵션]</td>
              <td>실행중인 모든 컨테이너 목록 확인<br />-a 옵션으로 정지된 컨테이너까지 모두 검색</td>
            </tr>
            <tr>
              <td>docker start</td>
              <td>$ docker start [컨테이너 이름 | 컨테이너 ID]</td>
              <td>정지된 컨테이너 재시작</td>
            </tr>
            <tr>
              <td>docker stop</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너 정지</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker exec</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]<br />[명령] [매개 변수]</td>
              <td>컨테이너 외부에서 컨테이너 내의 명령 실행</td>
            </tr>
            <tr>
              <td>docker diff</td>
              <td>$ docker diff [컨테이너 이름 | 컨테이너 ID]</td>
              <td>컨테이너가 실행되면서 변경된 파일 목록 확인<br />A : 추가된 파일<br />C : 변경된 파일<br />D : 삭제된 파일</td>
            </tr>
            <tr>
              <td>docker cp</td>
              <td>$ docker cp [컨테이너 이름 | 컨테이너 ID]<br />[:컨테이너 경로] [호스트 경로]</td>
              <td>컨테이너의 파일을 호스트의 디렉토리로 복사</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker rm</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>생성된 컨테이너 삭제</td>
            </tr>
            <tr>
              <td>docker commit</td>
              <td>$ docker commit [옵션] [컨테이너 이름 | 컨테이너 ID]<br />[이미지 이름] [:태그]</td>
              <td>컨테이너를 이미지 파일로 생성</td>
            </tr>
            <tr>
              <td>docker build</td>
              <td>$ docker build [옵션] [도커 파일 경로]<br />[--tag 이미지 이름 : 이미지 태그] </td>
              <td>도커 파일에 설정된 내용대로 도커 이미지 생성<br />--tag 뒤에 이미지 이름와 이미지 태그를 설정할 수 있음</td>
            </tr>
            <tr>
              <td>docker history</td>
              <td>$ docker history [이미지 이름 | 이미지 ID] [:태그]</td>
              <td>도커 파일에 설정된 내용대로 이미지 히스토리 생성</td>
            </tr>
            <tr>
              <td>docker inspect</td>
              <td>$ docker inspect<br />[이미지나 컨테이너 이름 | 이미지나 컨테이너 ID]</td>
              <td>이미지나 컨테이너의 세부 정보 출력</td>
            </tr>
         </tbody>
    </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 (Docker) : 컨테이너 기반 가상화 (Container-based Virtualization)]]></summary></entry><entry><title type="html">[vocawik] 7. 07/21 진행 내용</title><link href="http://localhost:4000/vcw7/" rel="alternate" type="text/html" title="[vocawik] 7. 07/21 진행 내용" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/vcw7</id><content type="html" xml:base="http://localhost:4000/vcw7/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #19. feat(domain): BaseDateTime 엔티티 추가 ~ #23. fix(domain): User 도메인 제약조건 추가에 대한 내용입니다.</p>
</blockquote>

<h2 id="19-featdomain-basedatetime-엔티티-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/bb68e72e418610d6edb4b13449c3cf90973a2cb1">#19</a>. feat(domain): BaseDateTime 엔티티 추가</h2>

<ul>
  <li>JPA Auditing을 User 엔티티에 적용하고자 생성 시간 (<code class="language-plaintext highlighter-rouge">CreatedDate</code>)과 수정 시간 (<code class="language-plaintext highlighter-rouge">LastModifiedDate</code>)을 칼럼으로 갖는 <code class="language-plaintext highlighter-rouge">BaseDateTime</code> 엔티티를 생성하였다. 이 때 MappedSuperclass를 통해 JPA Entity 클래스들이 BaseTimeEntity를 상속할 때 내부 필드도 컬럼으로 인식하도록 설정하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.model;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import java.time.LocalDateTime;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

@Getter
@MappedSuperclass // JPA Entity 클래스들이 BaseTimeEntity를 상속할 때 내부 필드도 컬럼으로 인식하도록 설정
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseDateTime { // 생성 및 수정 시간 엔티티
    @Column(name = "baseDateTime_created", updatable = false)
    @CreatedDate
    private LocalDateTime created; // 생성 시간

    @Column(name = "baseDateTime_lastModified")
    @LastModifiedDate
    private LocalDateTime lastModified; // 수정 시간
}
</code></pre></div></div>

<h2 id="20-featinfra-feign-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/54a5c95f7c8e58db5439558db99bb672f6d8c85d">#20</a>. feat(infra): feign 적용</h2>

<p>페인 (Feign) 클라이언트는 REST 호출을 도와주는 Http 클라이언트 바인더 (Client Binder)이다. JPA가 인터페이스만으로 DB에 접근하는 방식을 축소시키는 것처럼, Feign을 적용하면 번거로운 RestTemplate과 같은 호출 방식을 인터페이스 하나만으로 축소시킬 수 있다.</p>

<ul>
  <li>페인 클라이언트는 REST 호출 방식에 영향을 주므로 <code class="language-plaintext highlighter-rouge">Api</code>, <code class="language-plaintext highlighter-rouge">Domain</code> 모듈 모두에 영향을 준다고 생각하였다. 그래서 <code class="language-plaintext highlighter-rouge">Infra</code> 모듈에 의존성을 추가해 양 측 모두에서 사용할 수 있게끔 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springframework.cloud:spring-cloud-starter-openfeign' : 클라이언트 사이드 HTTP 요청을 쉽게 작성할 수 있도록 도와줌
    api 'org.springframework.cloud:spring-cloud-starter-openfeign'

    // 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8' : Optional, LocalDate 등의 JDK 8 추가 데이터 유형들을 지원
    api 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8'

    // 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310' : Java 8에 추가된 날짜 및 시간 API를 JSON 형식으로 직렬화 및 역직렬화하는 JSR-310 지원
    api 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'

    // 'io.github.openfeign:feign-jackson' : OpenFeign을 사용할 때 JSON 데이터를 직렬화하고 역직렬화에 활용되는 Jackson 지원
    api 'io.github.openfeign:feign-jackson:12.2'

    implementation project(':vw-core')
}
</code></pre></div></div>

<ul>
  <li>그리고 Feign 클라이언트가 응답을 디코딩할 때 사용할 디코더를 정의하기 위해 Feign 클라이언트에 대한 설정 클래스 <code class="language-plaintext highlighter-rouge">FeignConfig</code>를 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.infra.config.feign;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import feign.Logger;
import feign.Retryer;
import feign.codec.Decoder;
import feign.jackson.JacksonDecoder;
import java.util.concurrent.TimeUnit;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import vw.infra.outer.api.BaseFeignClientPackage;

@Configuration
@EnableFeignClients(
        basePackageClasses = BaseFeignClientPackage.class) // 해당 클래스가 위치한 패키지 밑에서 Feign 클라이언트를 탐색
public class FeignConfig { //  Feign 클라이언트가 응답을 디코딩할 때 사용할 디코더 정의
    @Bean
    public Decoder feignDecoder() {
        return new JacksonDecoder(
                customObjectMapper()); // JSON 응답을 객체로 디코딩하기 위한 JacksonDecoder를 사용하도록 설정
    }

    public ObjectMapper customObjectMapper() { // ObjectMapper 객체를 커스터마이징 (객체 직렬화/역직렬화 설정을 변경)
        ObjectMapper objectMapper = new ObjectMapper();

        objectMapper.registerModule(
                new JavaTimeModule()); // 시간 관련 클래스들을 JSON으로 변환하고, JSON 데이터를 해당 클래스들로 역직렬화 가능하게 함

        // JSON 직렬화 시에, Java Date나 Calendar 객체를 타임스탬프 형태로 출력하지 않음 -&gt; 일반적인 문자열 형태로 날짜를 표시
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

        // JSON 역직렬화 시에, 알 수 없는 필드가 포함되어 있을 경우에도 역직렬화 작업을 진행시킴 -&gt; 해당 필드를 무시하고 나머지 필드들을 역직렬화
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        // JSON 역직렬화 시에, 날짜와 시간을 JSON 데이터에 포함된 그대로의 타임존으로 유지
        objectMapper.configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false);

        // JSON 역직렬화 시에, 알 수 없는 enum 값을 null로 처리함
        objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, true);

        return objectMapper; // 커스텀마이징한 ObjectMapper 객체를 반환
    }

    @Bean
    Retryer.Default retryer() { // 재시도 (Retry) 설정
        return new Retryer.Default(
                100L,
                TimeUnit.SECONDS.toMillis(3L),
                5); // 0.1초의 간격으로 시작해 최대 3초의 간격으로 점점 증가하며, 최대5번 재시도
    }

    @Bean
    Logger.Level feignLoggerLevel() { // Feign의 로그 레벨을 설정
        return Logger.Level.FULL; // FULL 레벨로 설정해 모든 요청과 응답에 대한 자세한 로그를 출력
    }
}
</code></pre></div></div>

<ul>
  <li>이때 <code class="language-plaintext highlighter-rouge">FeignConfig</code> 클래스의 <code class="language-plaintext highlighter-rouge">feignLoggerLevel()</code>에서 eign의 로그 레벨을 설정하고 있는데, Feign은 DEBUG 레벨로만 로그를 남길 수 있다. 그러므로 반드시 로그 레벨이 아래처럼 DEBUG로 설정이 되어 있어야 한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logging:
  level:
    com.mangkyu.openfeign.app.openfeign: DEBUG # feign에 대한 로깅 수준을 DEBUG로 설정 (가장 상세한 로그를 출력)
</code></pre></div></div>

<h2 id="21-featinfra-redis-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/5fa4efde8f32f1327dd89bdb9cd85b6be71d26d9">#21</a>. feat(infra): redis 적용</h2>

<p>레디스 (<code class="language-plaintext highlighter-rouge">redis</code>)는  “키-값” 구조의 비정형 데이터를 저장하고 관리하는 비관계형 데이터베이스 관리 시스템이다. 레디스는 인메모리 데이터베이스이면서 다양한 자료구조를 갖고 있어 다른 DBMS에 비해 더 빠르고 간단한 방법으로 데이터를 정렬할 수 있다. 이는 우리가 구현하고자 하는 회원가입의 인증 이메일 전송에서 필요한 정보들 (이메일, 인증 키)를 저장하기에 적합하다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">redis</code>는 아마 서비스를 담당하는 <code class="language-plaintext highlighter-rouge">Domain</code> 모듈에서만 활용될 것으로 추측되지만, 우리 어플리케이션 외부에 존재하는 DBMS이다. 그러므로 외부 서비스를 담당할 <code class="language-plaintext highlighter-rouge">Infra</code> 모듈에 의존성을 추가하고 <code class="language-plaintext highlighter-rouge">Redis</code> 설정 클래스 또한 여기에 위치시키되, 이를 통해 구현될 레포지토리는 <code class="language-plaintext highlighter-rouge">Domain</code> 모듈에 위치시킬 생각이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    dependencies {
        // 'org.springframework.boot:spring-boot-starter-data-redis' : Redis에 필요한 모든 의존성들을 관리
        api 'org.springframework.boot:spring-boot-starter-data-redis'
    }
</code></pre></div></div>

<ul>
  <li>레디스에 대한 설정 클래스인 <code class="language-plaintext highlighter-rouge">RedisConfig</code>를 작성하였다. 여기에서는 Redis 연결 설정을 위한 Bean인 <code class="language-plaintext highlighter-rouge">redisConnectionFactory</code>와 Redis 데이터를 처리하는 데 사용될 RedisTemplate에 대한 Bean인 <code class="language-plaintext highlighter-rouge">redisTemplate</code>을 추가하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.infra.config.redis;

import java.time.Duration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.repository.configuration.EnableRedisRepositories;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@EnableRedisRepositories( // redis와 관련된 Spring Data Repositories 활성화
        basePackages = "vw")
public class RedisConfig {
    @Value("${spring.data.redis.host}")
    private String redisHost; // redis 호스트 주소

    @Value("${spring.data.redis.port}")
    private int redisPort; // redis 포트 번호

    @Value("${spring.data.redis.password}")
    private String redisPassword; // redis 비밀번호

    @Bean // Redis 연결 설정을 위한 Bean 생성
    public RedisConnectionFactory
            redisConnectionFactory() { // RedisConnectionFactory : redis와의 연결을 관리하는 인터페이스
        RedisStandaloneConfiguration redisStandaloneConfiguration =
                new RedisStandaloneConfiguration(redisHost, redisPort);

        if (redisPassword != null &amp;&amp; !redisPassword.isBlank()) // redis에 비밀번호가 설정되어 있지 않으면 비밀번호를 설정
        redisStandaloneConfiguration.setPassword(redisPassword);

        // LettuceClientConfiguration을 생성하여 Redis 연결 설정 구성
        LettuceClientConfiguration lettuceClientConfiguration =
                LettuceClientConfiguration.builder() // LettuceClientConfiguration의 builder 패턴 생성
                        .commandTimeout(Duration.ofSeconds(1)) // redis 명령의 최대 실행 시간을 1초로 설정
                        .shutdownTimeout(Duration.ZERO) // Redis 클라이언트의 종료 시간을 0초로 설정 (무한 대기)
                        .build();

        // LettuceConnectionFactory를 생성하여 Redis 연결 수립
        return new LettuceConnectionFactory(
                redisStandaloneConfiguration, lettuceClientConfiguration); // 내장 혹은 외부의 redis 연결
    }

    @Bean // RedisTemplate을 Bean으로 생성
    public RedisTemplate&lt;?, ?&gt; redisTemplate() { // RedisTemplate : Redis 데이터를 처리하는 데 사용
        RedisTemplate&lt;byte[], byte[]&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory());

        // 일반적인 key:value일 경우에 직렬화
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());

        // Hash를 사용할 경우에 직렬화
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new StringRedisSerializer());

        return redisTemplate; // RedisConnection에서 넘겨준 byte 값 객체 직렬화
    }
}
</code></pre></div></div>

<ul>
  <li>앞서 내가 필요로 하는 기능인 회원가입 인증 이메일 전송에 필요한 데이터들은 휘발성이 강하면서도 빠른 접근을 요한다. 그러므로 레디스를 캐시로 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">redisCacheManager</code> 클래스를 통해 캐시 기능을 활성화하고 이에 대한 설정을 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.infra.config.redis;

import java.time.Duration;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@EnableCaching // 캐시 기능 활성화
@Configuration
public class RedisCacheConfig {
    @Bean
    @Primary
    public CacheManager redisCacheManager(RedisConnectionFactory cf) { // 기본 CacheManager를 설정
        // redis 캐시의 기본 설정을 구성
        RedisCacheConfiguration redisCacheConfiguration =
                RedisCacheConfiguration.defaultCacheConfig()
                        .serializeKeysWith( // redis에서 키를 String으로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new StringRedisSerializer()))
                        .serializeValuesWith( // redis에서 값을 JSON 형태로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new GenericJackson2JsonRedisSerializer()))
                        .entryTtl( // Cache의 기본 TTL (Time-To-Live)을 1시간으로 설정
                                Duration.ofHours(1L));

        // RedisConnectionFactory를 사용하여 RedisCacheManager를 생성
        return RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(cf)
                .cacheDefaults(
                        redisCacheConfiguration) // redis 캐시의 기본 설정을 지정한 RedisCacheConfiguration으로
                // 설정
                .build();
    }

    // OIDC (OpenID Connect) : 인증 및 권한 부여를 위한 프로토콜
    @Bean
    public CacheManager oidcCacheManager(RedisConnectionFactory cf) { // OIDC CacheManager를 설정
        // OIDC Cache의 redis 캐시 설정을 구성
        RedisCacheConfiguration redisCacheConfiguration =
                RedisCacheConfiguration.defaultCacheConfig()
                        .serializeKeysWith( // redis에서 키를 String으로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new StringRedisSerializer()))
                        .serializeValuesWith( // redis에서 값을 JSON 형태로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new GenericJackson2JsonRedisSerializer()))
                        .entryTtl( // OIDC Cache의 기본 TTL을 7일로 설정
                                Duration.ofDays(7L));

        // RedisConnectionFactory를 사용하여 RedisCacheManager를 생성
        return RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(cf)
                .cacheDefaults(
                        redisCacheConfiguration) // OIDC Cache 설정을 지정한 RedisCacheConfiguration으로 설정
                .build();
    }
}
</code></pre></div></div>

<ul>
  <li>그리고 레디스가 캐시 타입으로 지정될 수 있도록, 그리고 레디스에 대한 설정을 Github Secret을 통해 넣을 수 있게끔 yml 파일을 수정하자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring:
  cache:
    type:
      redis # 캐시 타입을 redis로 지정
    redis:
      cache-null-values: true # 캐시에 null 값도 저장
  data:
    redis:
      host: ${REDIS_HOST:localhost} # Redis 호스트 주소 설정 (환경 변수가 설정되지 않은 경우 기본값 localhost)
      port: ${REDIS_PORT:6379} # Redis 포트 번호 설정 (환경 변수가 설정되지 않은 경우 기본값 6379)
      password: ${REDIS_PASSWORD:} # Redis에 접속할 때 사용할 비밀번호 설정 (환경 변수가 설정되지 않은 경우 기본값 빈 문자열)
</code></pre></div></div>

<p>당연히 레디스를 설정하는 것만으로 끝나면 안된다! Redis 자체는 우리 어플리케이션 외부에 존재하므로, 실제로 개발을 진행중인 로컬 환경과 원격에 올라가 있는 AWS 환경에 Redis를 설치하고 이를 실행시켜 Redis를 우리 서비스에서 사용할 수 있게 하자.</p>

<h2 id="22-fix-illegalargumentexception-at-propertyplaceholderhelper-해결"><a href="https://github.com/pocj8ur4in/vw-backend/commit/5abda3e95557a613fe29f69688b864bc8df14964">#22</a>. fix: IllegalArgumentException at PropertyPlaceholderHelper 해결</h2>

<p><code class="language-plaintext highlighter-rouge">IllegalArgumentException at PropertyPlaceholderHelper</code>는 사실 로컬에서 발생하는 오류는 아니다. Github Actions를 통해 돌리다 보면 어느 시점에서 어플리케이션이 죽었는데, 이때 발생한 오류다. gradle의 빌드 시에 application의 properties를 참조하지 못하는 부분이 있는 것 같았는데 알고 보니 하위 서비스를 scanBasePackages에 넣으면 안되는 것이었다… (같은 이름의 파일을 중복해서 읽어서 문제가 생기는 것? 으로 보인다.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@SpringBootApplication( // '@SpringBootApplication' : 스프링 부트 애플리케이션의 주요 구성 요소들을 자동으로 설정
        scanBasePackages = { // 'scanBasePackages={}' : Spring이 Component Scan을 수행할 패키지들을 지정
            "vw.api"
            // , "vw.domain", "vw.infra" // 제외한 부분
        })
</code></pre></div></div>

<p>그리고 멀티모듈 프로젝트에서 자주 발생하는 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성 문제를 이때 같이 해결하였다. 매번 멀티모듈 프로젝트를 진행할 때마다 발생하는 부분인데, <code class="language-plaintext highlighter-rouge">Core</code>나 <code class="language-plaintext highlighter-rouge">Infra</code> 모듈처럼 어플리케이션이 없는 모듈은 순수 Jar 파일을 생성해야 하는 것 같다…?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 멀티모듈 프로젝트에서 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성
    bootJar.enabled = false
    jar.enabled = tru
</code></pre></div></div>

<h2 id="23-fixdomain-user-도메인-제약조건-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/4f3cf5b6505cdb037c0a5e4edb69c77bf55affa0">#23</a>. fix(domain): User 도메인 제약조건 추가</h2>

<p>원래 제약 조건은 DB 단에서 직접 설정해주곤 했었는데, JPA에서 엔티티를 자동으로 생성해주는 것을 보고 직접 코드로 넣어두는 것이 더 효율적으로 보여 이를 추가하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- nullable // 빈 값 금지
- unique // 중복된 값 금지
- length // 길이 제한
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #19. feat(domain): BaseDateTime 엔티티 추가 ~ #23. fix(domain): User 도메인 제약조건 추가에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 6. 07/19, 07/20 진행 내용</title><link href="http://localhost:4000/vcw6/" rel="alternate" type="text/html" title="[vocawik] 6. 07/19, 07/20 진행 내용" /><published>2023-07-19T00:00:00+09:00</published><updated>2023-07-20T00:00:00+09:00</updated><id>http://localhost:4000/vcw6</id><content type="html" xml:base="http://localhost:4000/vcw6/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #16. init: Exception 및 ErrorCode 추가 ~ #18. feat(domain): User 도메인 설정에 대한 내용입니다.</p>
</blockquote>

<h2 id="16-init-exception-및-errorcode-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/d877198b2b27cc6e48c30c2ac77a524d0d8a56ed">#16</a>. init: Exception 및 ErrorCode 추가</h2>
<p>만약 사용자가 잘못된 방식이나 접근을 하였을 때, 서버에서는 이에 대한 예외 처리를 할 것이다. 하지만 표준으로 명시된 예외 처리 메시지를 띄우는 것은 사용자 친화적인 방식이 아닐 뿐더러, 우리 서비스의 취약점을 노출시킬 수 있다. 예를 들어 사용자가 회원가입을 할 때 서버 내에 중복된 아이디를 제출하였다고 가정하자. 그렇다면 JDBC API는 SQLException을 발생시킬 것인데, 이를 그대로 사용자에게 전달한다면 예외 발생만 알 수 있을 뿐, 왜 발생했는지 알 수 없는 상황이 발생한다. 그러므로 예외 (Exception) 및 이에 대한 에러 코드 (ErrorCode)를 커스텀마이징할 필요성이 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void register() throws SQLException {
    ...
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BaseCodeException</code>는 런타임 오류를 처리하는 RuntimeException를 상속해 어떤 클래스가 실행 중일 때 발생할 수 있는 Exception를 처리할 클래스이다. 만약 어떤 예외가 발생한다면 이에 대한 원인 (baseErrorCode의 ErrorReason)을 반환한다 (getErrorReason).</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.exception;

import vw.core.dto.BaseErrorReason;

public class BaseCodeException extends RuntimeException { // 실행 시 발생하는 예외를 나타냄 (RuntimeException 상속)
    private BaseErrorCode baseErrorCode; // 예외 발생 시에 해당 예외의 원인을 BaseErrorCode 객체에 저장

    public BaseErrorReason getErrorReason() { // 해당 예외의 원인을 반환
        return this.baseErrorCode.getErrorReason();
    }
}
</code></pre></div></div>

<ul>
  <li>이를 위해 오류의 원인을 나타내는 DTO 클래스 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code>를 작성하였다. 앞으로는 <code class="language-plaintext highlighter-rouge">public enum GlobalErrorCode implements BaseErrorReason { ... }</code>와 같이 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code>를 주입받아 오류의 원인을 커스텀마이징할 것이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.dto;

import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class BaseErrorReason { // 오류의 원인을 나타내는 DTO
    private final Integer status; // HTTP 상태 코드
    private final String code; // HTTP 상태 코드 (문자열)
    private final String reason; // 오류의 원인
}
</code></pre></div></div>

<ul>
  <li>에러의 원인을 반환할 인터페이스인 <code class="language-plaintext highlighter-rouge">BaseErrorCode</code>를 작성하였다. 추가로 예외에 대한 설명을 문자열 형태로도 반환할 수 있게끔 <code class="language-plaintext highlighter-rouge">getExplainError()</code>를 작성하였는데, 이는 다음에 설명할 부분인 <code class="language-plaintext highlighter-rouge">ExplainError</code>라는 커스텀 어노테이션을 생성하는 것과 이어져 그때 한번에 설명하겠다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.exception;

import vw.core.dto.BaseErrorReason;

public interface BaseErrorCode {
    public BaseErrorReason getErrorReason(); // 에러의 원인을 반환

    String getExplainError() throws NoSuchFieldException; // 예외에 대한 설명을 문자열로 반환
    // NoSuchFieldException : Reflection을 사용하여 Field를 접근하려고 할 때, 해당 필드가 존재하지 않는 경우에 발생
}
</code></pre></div></div>

<ul>
  <li>오류에 대한 응답을 나타내는 DTO 클래스 <code class="language-plaintext highlighter-rouge">BaseErrorResponse</code>를 작성하였다. 근데 사실 이를 활용해서 프론트에 응답을 하는 게 맞는데, 이에 대한 생각이 못해버려 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code>으로만 처리하는 방식으로 다 구현해놓았다. 지금 다시 생각해보면 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code> 객체와 오류가 발생한 시간 및 경로를 포함하는 <code class="language-plaintext highlighter-rouge">BaseErrorResponse</code>를 활용하는 게 맞고, 이를 처리할 핸들러 클래스르 나중에 변경해두어야 겠다…</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.dto;

import java.time.LocalDateTime;
import lombok.Getter;

@Getter
public class BaseErrorResponse { // 오류에 대한 응답을 나타내는 DTO
    private final boolean success = false;

    private final Integer status; // HTTP 상태 코드
    private final String code; // HTTP 상태 코드 (문자열)
    private final String reason; // 오류의 원인
    private final LocalDateTime timeStamp; // 오류가 발생한 시간
    private final String path; // 오류가 발생한 경로

    public BaseErrorResponse(BaseErrorReason baseErrorReason, String path) {
        this.status = baseErrorReason.getStatus();
        this.code = baseErrorReason.getCode();
        this.reason = baseErrorReason.getReason();
        this.timeStamp = LocalDateTime.now();
        this.path = path;
    }

    public BaseErrorResponse(int status, String code, String reason, String path) {
        this.status = status;
        this.code = code;
        this.reason = reason;
        this.timeStamp = LocalDateTime.now();
        this.path = path;
    }
}
</code></pre></div></div>

<h2 id="17-init-jpa-auditing-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/b21e88c86f0b54352a94d629125f544464b54537">#17</a>. init: JPA Auditing 추가</h2>

<p>JPA를 사용하여 도메인을 관계형 데이터베이스 테이블에 매핑하다 보면, 도메인들이 공통으로 가지는 필드 및 칼럼들 (ex. 생성자, 수정자, 생성일자, 수정일자, 식별자 등)이 존재한다. 특히 생성자, 수정자, 생성일자, 수정일자는 우리가 DB에 create나 update할 때마다 시간 데이터를 넣어주어야 하는데 이에 대한 코드를 따로 작성할 필요 없이 자동으로 사람이나 시간을 매핑하여 데이터베이스의 테이블에 넣어주는 기능이 바로 JPA Auditing이다.</p>

<ul>
  <li>사실 <code class="language-plaintext highlighter-rouge">spring-boot-starter-data-jpa</code>만 추가해도 Auditing에는 문제는 없다. 정확히 말하면 <code class="language-plaintext highlighter-rouge">@CreatedDateTime</code>, <code class="language-plaintext highlighter-rouge">@LastModifiedDateTime</code> 어노테이션만 추가하면 된다. 그렇지만 <code class="language-plaintext highlighter-rouge">@CreatedBy</code>, <code class="language-plaintext highlighter-rouge">LastModifiedBy</code>와 같이 생성자, 수정자를 저장하려면 <code class="language-plaintext highlighter-rouge">AuditorAware</code>를 스프링 빈으로 등록해야 된다. 이를 위해 JPA를 설정하는 데 활용할 클래스인 <code class="language-plaintext highlighter-rouge">JpaConfig</code>를 미리 만들어두자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.config;

import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import vw.domain.DomainPackageLocation;

@Configuration
@EnableJpaAuditing
@EntityScan(basePackageClasses = DomainPackageLocation.class) // // Entity 스캔을 위한 기본 패키지 위치를 설정
@EnableJpaRepositories(
        basePackageClasses = DomainPackageLocation.class) // JPA 저장소를 활성화하기 위한 기본 패키지 위치를 설정
public class JpaConfig { // JPA 설정
    // JPA Auditing 활성화
}
</code></pre></div></div>

<ul>
  <li>추가로 JPA 저장소를 활성화하기 위해 <code class="language-plaintext highlighter-rouge">DomainPackageLocation</code> 클래스를 엔티티를 스캔할 위치에 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain;

public class DomainPackageLocation {}
</code></pre></div></div>

<h2 id="18-featdomain-user-도메인-설정"><a href="https://github.com/pocj8ur4in/vw-backend/commit/bb68e72e418610d6edb4b13449c3cf90973a2cb1">#18</a>. feat(domain): User 도메인 설정</h2>

<p>회원에 관련된 정보를 저장하고 이를 활용한 서비스를 구현하기 위한 회원 (User) 도메인을 구현하였다. 회원 도메인에서는 회원가입, 회원정보 조회/수정, 회원탈퇴, 로그인 등의 기능을 구현할 것이고, 이를 위해 먼저 회원 엔티티와 회원 레포지토리를 설계하였다.</p>

<ul>
  <li>엔티티 클래스는 각 엔티티에 대한 식별자 및 여러 개의 칼럼들을 기본으로 갖되, 하나의 객체로 묶을 수 있으면 임베디드 타입 (<code class="language-plaintext highlighter-rouge">@Embedded</code>, <code class="language-plaintext highlighter-rouge">@Embeddable</code>) 혹은 Enum 타입을 활용할 것이고, 회원 엔티티 클래스 <code class="language-plaintext highlighter-rouge">User</code>는 이에 기반해 작성되었다. 그리고 Builder 패턴을 통해 각 객체를 생성 가능하게 하여 필요한 데이터를 동적으로 설정할 수 있게 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.user.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Getter
@Entity
@Table(name = "tbl_user")
@Slf4j
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User { // 회원 엔티티
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_index")
    private int index; // 회원 식별자

    @Enumerated(EnumType.STRING)
    @Column(name = "user_userType")
    private UserType userType = UserType.TYPE_NORMAL; // 회원 유형 정보

    @Enumerated(EnumType.STRING)
    @Column(name = "user_userState")
    private UserState userState = UserState.STATE_NORMAL; // 회원 상태 정보

    @Embedded private UserAuth userAuth; // 회원 인증 정보

    @Embedded private UserProfile userProfile; // 회원 프로필 정보

    @Embedded private UserToogle userToogle; // 회원 토글 정보

    @Builder
    public User(
            UserAuth userAuth,
            UserProfile userProfile,
            UserToogle userToogle) { // Builder 패턴으로 User 객체를 생성 가능하게 함
        this.userAuth = userAuth;
        this.userProfile = userProfile;
        this.userToogle = userToogle;
    }
}

</code></pre></div></div>

<ul>
  <li>그리고 <code class="language-plaintext highlighter-rouge">User</code> 엔티티 객체들을 관리할 레포지토리 클래스로 <code class="language-plaintext highlighter-rouge">UserRepository</code>을 작성하였다. 인터페이스를 생성한 후 <code class="language-plaintext highlighter-rouge">JpaRepository&lt;Entity 클래스, PK 타입&gt;</code>을 상속시키면 된다. 또한 <code class="language-plaintext highlighter-rouge">@EnableJpaRepositories</code>으로 JPA Repository 빈을 활성화해 JPA CRUD를 활용할 수 있게끔 하고 JPA를 사용하기 위한 설정을 자동으로 처리할 수 있게 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.user.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import vw.domain.user.entity.User;

@EnableJpaRepositories
public interface UserRepository extends JpaRepository&lt;User, Long&gt; { // 회원 레포지토리
	Optional&lt;User&gt; findUserByUserAuth_Id(String id); // 아이디로 회원을 조회

	Boolean existsUserByUserAuth_Id(String id); // 아이디로 회원 존재 여부를 조회

	Boolean existsUserByUserProfile_Nickname(String nickname); // 닉네임으로 회원 존재 여부를 조회

	Boolean existsUserByUserProfile_Email(String email); // 이메일로 회원 존재 여부를 조회
}

</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #16. init: Exception 및 ErrorCode 추가 ~ #18. feat(domain): User 도메인 설정에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 5. 07/18 진행 내용</title><link href="http://localhost:4000/vcw5/" rel="alternate" type="text/html" title="[vocawik] 5. 07/18 진행 내용" /><published>2023-07-18T00:00:00+09:00</published><updated>2023-07-18T00:00:00+09:00</updated><id>http://localhost:4000/vcw5</id><content type="html" xml:base="http://localhost:4000/vcw5/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #14. init: 멀티모듈 infra 모듈 추가 ~ #15. init: domain 이벤트 publisher 및 aop 추가에 대한 내용입니다.</p>
</blockquote>

<h2 id="14-init-멀티모듈-infra-모듈-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/65a75da78ca574165f3ff1341b08bbe14f1b1e41">#14</a>. init: 멀티모듈 infra 모듈 추가</h2>

<p>현재 <code class="language-plaintext highlighter-rouge">api</code>, <code class="language-plaintext highlighter-rouge">core</code>, <code class="language-plaintext highlighter-rouge">domain</code>의 멀티모듈 구조에 <code class="language-plaintext highlighter-rouge">infra</code> 영역에 해당하는 모듈을 추가하기로 하였다. <code class="language-plaintext highlighter-rouge">core</code> 모듈에서 실제 구현 기술에 해당하는 부분을 분리시켜 <code class="language-plaintext highlighter-rouge">core</code> 모듈에 최대한 논리적인 개념만 남겨 <code class="language-plaintext highlighter-rouge">core</code> 모듈로의 과도한 의존성을 줄이고, <code class="language-plaintext highlighter-rouge">domain</code>, <code class="language-plaintext highlighter-rouge">api</code> 모듈에 중복될 수 있는 구현 기술들을 <code class="language-plaintext highlighter-rouge">infra</code> 모듈에서 제공하는 기술로 도메인 혹은 프레젠테이션 영역에 필요한 기능을 개발하도록 하였다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setting.gradle</code>로 <code class="language-plaintext highlighter-rouge">infra</code> 모듈을 빌드하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rootProject.name = 'vw-backend'

// - include : 하위 프로젝트의 디렉토리 이름을 지정해 해당 디렉토리 안에 있는 빌드 스크립트를 실행
include 'vw-api'
include 'vw-core'
include 'vw-domain'
include 'vw-infra' // 추가된 부분
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">build.gradle</code>에 <code class="language-plaintext highlighter-rouge">infra</code>의 의존성을 추가하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    ...
    implementation project(':vw-domain')
    implementation project(':vw-core')
    implementation project(':vw-infra') // 추가된 부분
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">domain</code>, <code class="language-plaintext highlighter-rouge">api</code> 모듈에서 해당 기술을 사용할 수 있도록 각 모듈에 의존성을 추가하고, <code class="language-plaintext highlighter-rouge">core</code> 모듈에 존재하는 논리적인 개념을 사용할 수 있도록 해당 모듈에 <code class="language-plaintext highlighter-rouge">core</code> 모듈의 의존성을 추가하였다.</li>
</ul>

<h2 id="15-init-domain-이벤트-publisher-및-aop-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/ca773e108bdecacdbab20b7377c6fba8abbd3253">#15</a>. init: domain 이벤트 publisher 및 aop 추가</h2>

<ul>
  <li>도메인 이벤트는 바운디드 컨텐스트 간에 정보를 주고받는 수단으로 활용되면서, Aggregate 간의 일괄성을 유지하는 데에 사용되는 방법이다. 이를 적용할 수 있도록 먼저 스프링 비동기 처리를 활성화하자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;

@EnableAsync // 스프링 비동기 처리 활성화
@Configuration // 해당 클래스를 스프링의 설정 클래스로 지정
public class EnableAsyncConfig implements AsyncConfigurer {
    // 'AsyncConfigurer' : 비동기 처리에 필요한 구성 요소를 제공
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code>를 활용해 도메인 이벤트를 발행 및 처리할 수 있는 <code class="language-plaintext highlighter-rouge">BaseEventPublisher</code> 클래스를 생성하였다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">raise</code> : 도메인 이벤트를 발행</li>
      <li><code class="language-plaintext highlighter-rouge">set</code> : 도메인 이벤트를 설정</li>
      <li><code class="language-plaintext highlighter-rouge">reset</code> : 도메인 이벤트를 제거</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.event;

import org.springframework.context.ApplicationEventPublisher;

public class BaseEventPublisher { // ApplicationEventPublisher를 활용하여 도메인 이벤트를 발행 및 처리
    private static ThreadLocal&lt;ApplicationEventPublisher&gt; publisherLocal = new ThreadLocal&lt;&gt;();

    public static void raise(DomainEvent event) { // 도메인 이벤트를 발행
        // 이벤트가 null인 경우에는 종료
        if (event == null) return;

        // 현재 스레드의 ApplicationEventPublisher를 사용하여 이벤트를 발행
        if (publisherLocal.get() != null) {
            publisherLocal.get().publishEvent(event);
        }
    }

    public static void set(
            ApplicationEventPublisher publisher) { // 현재 스레드의 ApplicationEventPublisher를 설정
        publisherLocal.set(publisher);
    }

    public static void reset() { // 현재 스레드의 ApplicationEventPublisher를 제거
        publisherLocal.remove();
    }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ApplicationEventPublisherAware</code>으로 트랜잭션과 관련된 메서드 실행 시 도메인 이벤트 처리하는 <code class="language-plaintext highlighter-rouge">BaseEventPublisherAspect</code> 클래스를 생성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.event;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.stereotype.Component;

@Aspect //  해당 클래스가 AOP의 Aspect 역할을 수행함을 표시
@Component // 해당 클래스를 스프링의 컴포넌트로 등록
@ConditionalOnExpression(
        "${ableDomainEvent:true}") // 지정된 표현식 ${ableDomainEvent:true}이 true인 경우에만 해당 Aspect가 활성화
public class BaseEventPublisherAspect
        implements ApplicationEventPublisherAware { // AOP를 사용해 트랜잭션과 관련된 메서드 실행 시 도메인 이벤트 처리

    private ApplicationEventPublisher publisher;
    private ThreadLocal&lt;Boolean&gt; threadLocal = new ThreadLocal&lt;&gt;();

    @Around(
            "@annotation(org.springframework.transaction.annotation.Transactional)")
                    // @Transactional이 적용된 메서드를 감싸는 Aspect를 정의
    public Object handleEvent(ProceedingJoinPoint joinPoint)
            throws Throwable { // @Transactional이 적용된 메서드를 감싸는 방식으로 도메인 이벤트를 처리하는 Aspect 클래스

        Boolean appliedValue = threadLocal.get();
        boolean nested;

        if (appliedValue != null &amp;&amp; appliedValue) { // 중첩된 트랙잭션이 있는지 확인
            nested = true;
        } else {
            nested = false;
            threadLocal.set(Boolean.TRUE);
        }

        // 중첩된 트랜잭션에 속하지 않으면, 이벤트 발행을 위한 ApplicationEventPublisher를 설정
        if (!nested) BaseEventPublisher.set(publisher);

        try {
            // 원본 메서드 실행
            return joinPoint.proceed();
        } finally {
            // 중첩된 트랜잭션에 속하지 않은 경우, 설정을 초기화
            if (!nested) {
                BaseEventPublisher.reset();
                threadLocal.remove();
            }
        }
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        // Spring으로부터 ApplicationEventPublisher를 주입받아 멤버 변수에 할당
        this.publisher = eventPublisher;
    }
}
</code></pre></div></div>
<ul>
  <li>추상 클래스인 <code class="language-plaintext highlighter-rouge">DomainEvent</code>를 통해 이벤트가 발행되었을 때 이벤트가 발생한 시간을 기록할 수 있도록 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.event;

import java.time.LocalDateTime;
import lombok.Getter;

@Getter
public abstract class DomainEvent {
    private final LocalDateTime timestamp; // 이벤트 발생 시간

    public DomainEvent() {
        this.timestamp = LocalDateTime.now();
    }
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #14. init: 멀티모듈 infra 모듈 추가 ~ #15. init: domain 이벤트 publisher 및 aop 추가에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 4. 07/13, 07/17 진행 내용</title><link href="http://localhost:4000/vcw4/" rel="alternate" type="text/html" title="[vocawik] 4. 07/13, 07/17 진행 내용" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-17T00:00:00+09:00</updated><id>http://localhost:4000/vcw4</id><content type="html" xml:base="http://localhost:4000/vcw4/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #11. init: Thymeleaf 적용 ~ #13. init: lombok.config 파일 추가에 대한 내용입니다.</p>
</blockquote>

<h2 id="11-init-thymeleaf-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/c283ce8e7734c2810b459ba053f6a144f3e4143b">#11</a>. init: Thymeleaf 적용</h2>

<p>서버에서 클라이언트에게 응답할 브라우저 화면을 만들어줄 차례이다. MVC 구조에서 뷰 (View) 에 해당되는 역할인데, 대다수의 웹 사이트들이 JSP나 Thymeleaf를 사용하는 것으로 알고 있어 이에 대해 정리하고자 한다.</p>

<p>JSP (JavaServer Pages)는 HTML 코드에 Java 코드를 넣어 동적인 웹 페이지를 생성하는 Java 기반 서버 사이드 템플릿 엔진 (Server Side Template Engine)이다. 확장자는 .jsp를 사용한다. 파일을 보면 HTML 문서 내에 <code class="language-plaintext highlighter-rouge">&lt;% ... %&gt;</code>에 둘러싸인 부분이 있는데 이를 서블릿 클래스로 변환하고 컴파일해 실행한다. 이때 JSP 파일을 서블릿 클래스로 변환하고 실행시켜 주는 역할을 하는 것이 바로 Tomcat과 같은 서블릿 컨테이너 (Servlet Container)이다. 말로 적으면 난해하니 아래 순서대로 하나씩 보자.</p>

<ol>
  <li>웹 클라이언트 : 웹 서버에 웹 페이지 요청</li>
  <li>웹 서버 : 요청받은 웹 페이지에 해당되는 JSP 실행</li>
  <li>JSP : JSP를 서블릿 코드 (.java)로 변환</li>
  <li>웹 서버 : 서블릿 코드를 컴파일해 실행 가능한 bytecode (.class)로 변환</li>
  <li>웹 서버 : 실행 결과로 생성된 HTML 문서를 웹 클라이언트에 응답</li>
  <li>웹 클라이언트 : 브라우저에서 HTML 문서를 웹 페이지 형태로 출력</li>
</ol>

<p><a href="https://www.thymeleaf.org">Thymeleaf</a>은 html, xml, js, css 등을 처리할 수 있는 Java 템플릿 엔진이다. Thymeleaf의 주요 목적은 유지관리가 수월한 템플릿을 작성하는 것인데, html 태그에 속성 (th:~)을 직접 추가하면 Thymeleaf가 html 파일을 파싱하여 웹 페이지에 동적으로 값을 추가하거나 처리할 수 있다. 이런 템플릿은 Natural Template을 통해 제공되는데, 이는 서버 사이드 렌더링에 필요한 데이터가 없어도 프로토타입을 볼 수 있도록 해주는 것을 의미한다. 그래서 JSP와 달리 서버의 도움 없이도 뷰를 볼 수도 있다. 또한 thymeleaf는 .war로만 export가 가능한 JSP와 달리 .jar로 export가 가능해 이 역시 서버의 도움 없이 브라우저에 화면을 띄워볼 수 있다.</p>

<ul>
  <li>Thymeleaf은 Gradle를 통해 의존성을 추가하면 따로 설정할 부분 없이 바로 적용해볼 수 있다. (아무래도 Thymeleaf는 처음 사용해본 거라 Thymeleaf의 기본 문법이나 내부 동작 과정까지는 쓰지 못했는데 추후에 이 부분은 별개의 포스트로 추가해야겠다…)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springframework.boot:spring-boot-starter-thymeleaf' : Java 기반 서버 사이드 렌더링 템플릿 엔진
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf:3.1.1'
    ...
}
</code></pre></div></div>

<h2 id="12-init-spring-security-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/d8addffa614a6344f102af84ff3f036169d15060">#12</a>. init: Spring Security 적용</h2>

<p>Spring Security는 인증과 권한에 대한 기능을 제공하는 Java Spring의 하위 프레임워크이다. 개발을 하면서 보안 분야는 시간이 많이 소요되는 활동 중 하나인데, Spring Security를 통해 미리 구현된 내부 로직으로 인증 및 권한에 필요한 기능과 옵션들을 제공받아 사용할 수 있다.</p>

<blockquote>
  <ul>
    <li>인증 (Authentication) : 해당 사용자가 본인이 맞는지를 확인하는 절차</li>
    <li>인가 (Authorization) : 인증된 사용자가 요청된 자원에 접근 가능한지 결정하는 절차</li>
  </ul>
</blockquote>

<ul>
  <li>여기서는 프로젝트에 적용 및 간단한 설정만 하고 추후 필요한 기능이 생갈 때 필요한 로직을 가져오겠다. 사용할 모듈에 의존성을 추가해주자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springframework.boot:spring-boot-starter-security'
    // : 사용자 인증 및 권한 부여를 처리하여 보안 설정의 커스텀마이징을 가능하게 함
    implementation 'org.springframework.boot:spring-boot-starter-security'
}
</code></pre></div></div>

<ul>
  <li>그리고 <code class="language-plaintext highlighter-rouge">SecurityConfig</code> 클래스를 생성해 기본적인 설정을 해주자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.api.config;

import lombok.AllArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@AllArgsConstructor
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                // HTTP 기본 인증을 비활성화
                .httpBasic()
                .disable()
                // CORS (Cross-Origin Resource Sharing) 설정을 비활성화
                .cors()
                .disable()
                // CSRF (Cross-Site Request Forgery) 공격 방어를 비활성화
                .csrf()
                .disable()
                // 세션 관리를 상태 없음 (STATELESS)로 설정
                .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        // 구성된 HttpSecurity 객체 반환
        return httpSecurity.build();
    }
}

</code></pre></div></div>

<h2 id="13-init-lombokconfig-파일-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/9cb184acf937a1b779806475a4d7a65549411cd3">#13</a>. init: lombok.config 파일 추가</h2>

<p>jacoco에서 Lombok의 <code class="language-plaintext highlighter-rouge">@Data</code> 주석이 달린 도메인 클래스의 코드 커버리지가 0%로 나온다. 이는 lombok에서 생성한 코드에 <code class="language-plaintext highlighter-rouge">@lombok.Generated</code>를 붙이면 되는데 이를 <code class="language-plaintext highlighter-rouge">lombok.config</code> 파일로 할 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Lombok이 자동으로 생성한 코드에 @Generated 어노테이션을 자동으로 추기
lombok.addLombokGeneratedAnnotation = true
</code></pre></div></div>

<hr />

<p>추가로 이렇게 직접 하나씩 작업해보다가 몇 가지 의문이 든 부분이 있는데, 이를 여기에 적어둘까 한다.</p>

<p>먼저 현재까지 내가 작업한 배포 과정이 정말 사이트를 운영하는 데에 정말 적합한지? 에 대한 고찰이다. 일단 내 처음 계획은, master 브랜치에 작업한 내용을 병합하기 위한 PR이 종료될 때 -&gt; github action에서 도커 허브로 이미지를 올리고 -&gt; AWS 인스턴스 내의 도커에서 올라간 이미지에 대한 컨테이너를 실행하는 것이다. 원래는 난 내 로직이 괜찮다고 생각했는데, 내가 간과한 부분이 하나 있었다.</p>

<p>AWS 인스턴스 내에서 도커를 설치하고 이미지에 대한 컨테이너를 실행하는 것은 괜찮은데, 새로운 이미지에 대한 컨테이너를 실행해야 할 때가 문제이다. 이전 이미지에 대한 컨테이너를 종료하고 이를 삭제한 다음에 새로운 이미지에 대한 컨테이너를 실행하는 과정에서 약간의 소요 시간이 생기지 않을까?</p>

<p>약간의 딜레이가 뭐가 문제인건데?, 라고 생각할 수도 있겠지만, 구글이나 아마존 같이 세계를 대상으로 실시간으로 동작하는 사이트들이 이러면 어마어마한 손실이 날 것이다. 그래서 이들은 무중단 배포 (Zero-downtime Deployment) 전략을 통해 서비스를 중단되지 않는 상태로 유지하려 한다. (개념에 대한 자세한 내용과 세부 전략은 <a href="https://hudi.blog/zero-downtime-deployment/">이 포스트</a>를 참고해주길 바란다.) 여기서 등장하는 게 로드밸런서 (LoadBalancer)인데,  nginx나 HAProxy와 같은 제품들이 존재하고, AWS 역시 이를 지원하니 실제 운영 서버를 만들 때 이를 적용해볼 생각이다.</p>

<p>그리고 또 든 생각은, 내가 앞으로 만들 프로젝트가 모놀리식이 아닌 마이크로 서비스에 가깝게 구현되려면 어떻게 해야 하는가? 에 대한 고찰이다. 뜬금없지만 문득 그런 생각이 든 이유는, “마이크로서비스는 작은 서비스들을 많이 만들자는 거 아냐? 그러면 서비스 단위로 모듈을 나눠야 하는 게 맞는 거 아닌가?” 라는 의문이 들었기 때문이다.</p>

<p>응용 계층은 어쩔 수 없다고 하더라도, 그 아래는 서비스 단위로 <code class="language-plaintext highlighter-rouge">UserService</code>, <code class="language-plaintext highlighter-rouge">WikiService</code> 이런 식으로 존재해도 되는 거 아닌가? 라고 생각을 했는데, 이러면 공통으로 사용 가능한, Common 코드가 불필요하게 반복될 수 있을 것 같았다. 예를 들어 사용자가 원하는 이미지를 클라우드에 업로드하는 기능이 있다고 가정하면, 사용자 프로필로도 사용될 수 있을 것이고, 게시물에도 사용될 수 있을 것이고… 암튼 많이 사용될 건데 이를 일일이 넣는 것은 전혀 객체지향적이지 않다. 그러므로 이미지를 클라우드에 업로드하는 기능과 같이 중복될 수 있는 코드들은 초기 설계 및 구현할 때나 리팩토링할 때 무조건 분리해서 재사용하는 식으로 해야 할 필요성을 느끼게 되었다.</p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #11. init: Thymeleaf 적용 ~ #13. init: lombok.config 파일 추가에 대한 내용입니다.]]></summary></entry></feed>