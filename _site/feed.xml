<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-27T19:58:58+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[React] 3. 리액트 컴포넌트 스타일링 (React Component Styling)</title><link href="http://localhost:4000/react4/" rel="alternate" type="text/html" title="[React] 3. 리액트 컴포넌트 스타일링 (React Component Styling)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react4</id><content type="html" xml:base="http://localhost:4000/react4/"><![CDATA[]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[React] 3. 리액트 라우팅 (React Routing)</title><link href="http://localhost:4000/react5/" rel="alternate" type="text/html" title="[React] 3. 리액트 라우팅 (React Routing)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react5</id><content type="html" xml:base="http://localhost:4000/react5/"><![CDATA[]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[React] 3. 함수 컴포넌트 (Functional Component)</title><link href="http://localhost:4000/react3/" rel="alternate" type="text/html" title="[React] 3. 함수 컴포넌트 (Functional Component)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react3</id><content type="html" xml:base="http://localhost:4000/react3/"><![CDATA[<h2 id="함수-컴포넌트-functional-component--리액트-훅을-통한-상태와-생명주기-관리">함수 컴포넌트 (<code class="language-plaintext highlighter-rouge">Functional Component</code>) : 리액트 훅을 통한 상태와 생명주기 관리</h2>

<blockquote>
  <p>클래스 컴포넌트의 한계?</p>

  <ul>
    <li>데이터의 흐름을 추적하기 어려움 : 서로 다른 여러 메소드에서, 작성 순서에 상관없이 상태의 업데이트 발생 가능</li>
    <li>어플리케이션 내부 로직의 재사용이 어려움 : 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트나 속성이 많아짐</li>
    <li>기능이 많아질수록 컴포넌트의 크기가 커짐 : 내부에서 처리하는 데이터 흐름이 복잡해짐</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState, useEffect } from 'react';

const MyFunctionalComponent = () =&gt; {
  // useState 훅을 사용하여 상태 정의
  const [count, setCount] = useState(0);

  // useEffect 훅을 사용하여 부수 효과(라이프사이클 작업 등) 처리
  useEffect(() =&gt; {
    console.log('Component mounted or count updated:', count);
    // componentWillUnmount 역할을 하는 함수 (클린업 함수)
    return () =&gt; {
      console.log('Component will unmount');
    };
  }, [count]); // count가 업데이트될 때만 실행

  const handleIncrement = () =&gt; {
    // setCount를 사용하여 상태 업데이트
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default MyFunctionalComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useContext</code>와 같은 리액트 훅을 사용하여 상태를 관리</li>
  <li><code class="language-plaintext highlighter-rouge">useEffect</code> 훅을 통해 라이프사이클 메소드와 유사한 동작을 수행 가능</li>
  <li><code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용하지 않고, 클래스 컴포넌트보다 간결하고 명료하게 작성 가능</li>
</ul>

<h3 id="리액트-훅-react-hook--함수형-컴포넌트에서-상태와-생명주기-메서드를-사용할-때-사용">리액트 훅 (<code class="language-plaintext highlighter-rouge">React Hook</code>) : 함수형 컴포넌트에서 상태와 생명주기 메서드를 사용할 때 사용</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c4f6fd02-e4fd-4f86-bd52-e4eed847cc3c" width="50%" /></p>

<ul>
  <li>상태 관리 훅 : <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">userContext</code>, <code class="language-plaintext highlighter-rouge">useReducer</code></li>
  <li>시점 훅 : <code class="language-plaintext highlighter-rouge">useLayoutEffect</code>, <code class="language-plaintext highlighter-rouge">useEffect</code></li>
  <li>메모이제이션 (<code class="language-plaintext highlighter-rouge">Memo</code>) 훅 : <code class="language-plaintext highlighter-rouge">useMemo</code>, <code class="language-plaintext highlighter-rouge">useCallback</code>, <code class="language-plaintext highlighter-rouge">memo</code></li>
</ul>

<blockquote>
  <p>리액트 훅의 3원칙?</p>

  <ol>
    <li>컴포넌트의 영역 안에서만 작동한다! : 컴포넌트 혹은 커스텀 훅 내부에서만 호출해야 함</li>
    <li>기능을 여러 훅으로 나누면 가독성에 좋다! :  여러 훅으로 나눠져 있어도 컴포넌트에서 한번에 순차 호출</li>
    <li>컴포넌트의 최상위 레이어(스코프)에서만 호출해야 한다! : 블록 내부에서는 호출할 수 없음</li>
  </ol>
</blockquote>

<ul>
  <li>훅의 규칙 (<code class="language-plaintext highlighter-rouge">Rules-of-Hooks</code>) : 관련 <code class="language-plaintext highlighter-rouge">ESLint</code> 규칙으로 <code class="language-plaintext highlighter-rouge">react-hooks/rules-of-hooks</code> 또한 존재
    <ol>
      <li>최상위에서만 훅을 호출해야 한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 그래야 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.</li>
      <li>훅을 호출할 수 있는 것은 함수 컴포넌트, 혹은 커스텀 훅만 가능하다.</li>
    </ol>
  </li>
</ul>

<h4 id="usestate--함수형-컴포넌트-내부에서-상태를-정의하고-관리할-때-사용"><code class="language-plaintext highlighter-rouge">useState</code> : 함수형 컴포넌트 내부에서 상태를 정의하고 관리할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react'
const [state, setState] = useState(initState)
</code></pre></div></div>

<ul>
  <li>인수로 사용할 상태의 초기값을 받음</li>
  <li>첫번째 값에 현재 상태의 값, 두번째 값에 상태를 업데이트하는 함수가 담긴 배열을 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const [state, setState] = useState(() =&gt; Number.praseInt(window.localStorage.getItem(cacheKey)));
</code></pre></div></div>

<ul>
  <li>게으른 초기화 (<code class="language-plaintext highlighter-rouge">Lazy Initialization</code>) : <code class="language-plaintext highlighter-rouge">useState</code> 등 리액트 훅의 인자에 변수 대신 함수 자체를 넘기는 것
    <ul>
      <li><code class="language-plaintext highlighter-rouge">useState</code>의 초기값이 복잡하거나 무거운 연산을 포함하는 경우에 사용</li>
      <li>오직 상태가 처음 만들어질 때만 사용 → 리렌더링이 발생하면 이 함수의 실행은 무시</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react';

const Component = () =&gt; {
  // useState를 사용하여 counter라는 상태를 정의하고 초기값을 0으로 설정
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1)
  }

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<h4 id="useeffect--어플리케이션-내-컴포넌트의-여러-값들을-통해-부수-효과를-만들-때-사용"><code class="language-plaintext highlighter-rouge">useEffect</code> : 어플리케이션 내 컴포넌트의 여러 값들을 통해 부수 효과를 만들 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Component = () =&gt; {
  useEffect(
    () =&gt; {},
    [props, state]
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 콜백 함수, 두번째 인수로 의존성 배열을 받음 : 의존성 배열의 값이 변경되면 콜백 실행
    <ul>
      <li><code class="language-plaintext highlighter-rouge">componentDidMount</code> 시점에 비동기로 실행 → <code class="language-plaintext highlighter-rouge">rendering</code> 이후, <code class="language-plaintext highlighter-rouge">mount</code> 이후</li>
    </ul>
  </li>
  <li>클래스 컴포넌트의 생명주기와 비슷한 동작을 구현 가능 : 의존성 배열에 빈 배열을 넣으면 컴포넌트가 마운트될 때만 실행</li>
  <li>렌더링이 실행될 때마다 의존성에 있는 값을 보면서 값 (<code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">props</code>)이 변경되면 부수 효과를 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Component = () =&gt; {
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1)
  }

  const counter = 1

  useEffect(
    () =&gt; {
      console.log(count) // 1, 2, 3, 4...
    }
  )

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>클린업 함수를 반환 가능 : 컴포넌트가 언마운트될 때 실행 (<code class="language-plaintext highlighter-rouge">componentWillUnMount</code>)
    <ul>
      <li>함수 컴포넌트가 리렌더링되었을 때 의존성 변화가 있었을 당시의 값 기준으로 실행되어 이전 상태를 청소</li>
      <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useEffect</code>는 콜백이 실행될 때마다 이전 클린업 함수가 존재하면 그 클린업 함수를 실행한 뒤 콜백 실행
        <ul>
          <li>특정 이벤트 핸돌러가 무한히 생성되는 것을 방지</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState, useEffect } from 'react'

export default function App() {
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  }

  useEffect(() =&gt; {
    const addMouseEffect = () =&gt; {
      console.log(counter)
    }

    window.addEventListener('click', addMouseEffect);

    return () =&gt; {
      console.log('클린업 함수', counter);
      window.removeEventListener('click', addMouseEffect);
    }
  }, [counter]);

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onclick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}

// 클린업 함수 0
// 1
// 클린업 함수 1
// 2
// ...
</code></pre></div></div>

<ul>
  <li>의존성 배열 (<code class="language-plaintext highlighter-rouge">dependency arra</code>) : 내부의 특정 값이 변경될 때에만 <code class="language-plaintext highlighter-rouge">useEffect</code> 콜백이 실행되도록 제어
    <ul>
      <li>의존성 배열에 사용자가 원하는 값을 넣는 경우 : 해당 값이 변경될 따마다 실행</li>
      <li>의존성 배열에 빈 배열을 두는 경우 : 최초 렌더링 직후에 한번 실행하고 더 이상 실행하지 않음</li>
      <li>의존성 배열에 아무런 값을 두지 않는 경우 : 렌더링이 발생할 때마다 매번 실행
        <ul>
          <li><code class="language-plaintext highlighter-rouge">vs</code> 직접 실행? : 클라이언트 사이드에서 실행 보장, 컴포넌트 렌더링 완료 이후에 실행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useEffect(() =&gt; {
  // 실행될 코드
}, [dependency1, dependency2, ...]); // 의존성 배열
</code></pre></div></div>

<h4 id="usememo--큰-연산에-대한-결과를-메모이제이션-memoization할-때-사용"><code class="language-plaintext highlighter-rouge">useMemo</code> : 큰 연산에 대한 결과를 메모이제이션 (<code class="language-plaintext highlighter-rouge">Memoization</code>)할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useMemo, useState } from 'react'

const ExpensiveComponent = ({ value }) =&gt; {
  useEffect(() =&gt; {
    console.log('rendering')
  })

  return &lt;span{value + 10000}&gt;&lt;/span&gt;
}

const App = () =&gt; {
  const [value, setValue] = useState(10);
  const [, triggerRendering] = useState(false);

  const MemoizedComponent = useMemo(
    () =&gt; &lt;ExpensiveComponent value={value}&gt;, [value]
  )

  const handleChange = (e) =&gt; {
    setValue(Number(e.target.value))
  }

  const handleClick = () =&gt; {
    setValue(Number(e.target.value))
  }

  return (
    &lt;&gt;
      &lt;input value={value} onChange={handleChange}&gt;&lt;/input&gt;
      &lt;button = onClick={handleClick}&gt;렌더링 발생&lt;/button&gt;
      {MemoizedComponent}
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 생성 함수, 두번째 인수로 해당 함수가 의존하는 값의 배열을 전달
    <ul>
      <li>렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면, 함수를 재실행하지 않고 이전의 값을 반환</li>
      <li>렌더링 발생 시 의존성 배열의 값이 변경되었으면, 첫번째 인수의 함수를 실행한 후에 그 값을 반환 및 메모이제이션</li>
    </ul>
  </li>
</ul>

<h4 id="reactmemo--외부-상태나-컨텍스트에-의존하지-않고-순수-함수형-컴포넌트를-메모이제이션할-때-사용"><code class="language-plaintext highlighter-rouge">React.Memo</code> : 외부 상태나 컨텍스트에 의존하지 않고 순수 함수형 컴포넌트를 메모이제이션할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const CreateUser = React.memo(({ username, email, onChange, onCreate }) =&gt; {
  return (
    &lt;div&gt;
      &lt;input
        name="username"
        placeholder="계정명"
        onChange={onChange}
        value={username}
      /&gt;
      &lt;input
        name="email"
        placeholder="이메일"
        onChange={onChange}
        value={email}
      /&gt;
      &lt;button onClick={onCreate}&gt;등록&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre></div></div>

<ul>
  <li>컴포넌트의 속성 (<code class="language-plaintext highlighter-rouge">props</code>)이 바뀔 때에만 리렌더링을 수행</li>
</ul>

<h4 id="usecallback--인수로-넘겨받은-콜백-자체를-저장해-재성성-대신-재사용할-때-사용"><code class="language-plaintext highlighter-rouge">useCallback</code> : 인수로 넘겨받은 콜백 자체를 저장해, 재성성 대신 재사용할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const ChildComponent = memo(({name, value, onChange}) =&gt; {
  useEffect(
    () =&gt; {
      console.log('rendering', name)
    }
  )

  return(
    &lt;&gt;
      &lt;h1&gt;{name} (value ? '켜짐' : '꺼짐')&lt;/h1&gt;
      &lt;button onClick={onChange}&gt;toggle&lt;/button&gt;
    &lt;/&gt;
  )
})

const App = () =&gt; {
  const [status1, setStatus1] = useState(false)
  const [status2, setStatus2] = useState(false)

  const toggle1 = useCallback(
    function toggle1() {
      setStatus(!status1)
    }, [status1],
  )

  const toggle2 = useCallback(
    function toggle2() {
      setStatus(!status2)
    }, [status2],
  )

  return (
    &lt;&gt;
      &lt;ChildComponent name="1" value={status1} onChange={toggle1}&gt;&lt;/ChildComponent&gt;
      &lt;ChildComponent name="2" value={status2} onChange={toggle2}&gt;&lt;/ChildComponent&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 함수, 두번째 인수로 해당 함수가 의존하는 값의 배열을 전달</li>
  <li>값의 메모이제이션을 위해 <code class="language-plaintext highlighter-rouge">useMemo</code>를 사용했다면, 함수의 메모이제이션을 위해 사용하는 것이 <code class="language-plaintext highlighter-rouge">useCallback</code>!
    <ul>
      <li>해당 의존성이 변경되었을 때만 함수가 재생성 : 불필요한 리소스 및 리렌더링 방지 가능</li>
      <li><code class="language-plaintext highlighter-rouge">useMemo</code>을 통해 <code class="language-plaintext highlighter-rouge">useCallback</code>를 구현할 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="useref--함수형-컴포넌트-내에서-참조를-생성하고-관리할-때-사용"><code class="language-plaintext highlighter-rouge">useRef</code> : 함수형 컴포넌트 내에서 참조를 생성하고 관리할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, useEffect } from 'react';

function MyComponent() {
  const myInputRef = useRef(null);

  useEffect(() =&gt; {
    // 컴포넌트가 마운트된 후, input 요소에 포커스를 줌
    myInputRef.current.focus();
  }, []);

  return &lt;input ref={myInputRef} /&gt;;
}
</code></pre></div></div>

<ul>
  <li>반환값인 객체 내부에 있는 <code class="language-plaintext highlighter-rouge">.current</code>로 값에 접근 혹은 변경이 가능</li>
  <li>컴포넌트의 렌더링과 관계없이 변수를 저장 가능 → <code class="language-plaintext highlighter-rouge">useState</code>와 달리, 매번 리렌더링이 일어나지 않음</li>
  <li>주로 <code class="language-plaintext highlighter-rouge">DOM</code> 요소에 접근하거나 컴포넌트의 생명주기와 독립적으로 값을 유지하는 상황에서 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, useState, useEffect } from 'react';

function MyComponent() {
  const countRef = useRef(0);
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    // countRef는 렌더링과 무관하게 유지되는 변수
    countRef.current = count;
  }, [count]);

  const handleClick = () =&gt; {
    setCount(count + 1);
    console.log(countRef.current); // 항상 가장 최근 값 출력
  };

  return &lt;button onClick={handleClick}&gt;증가&lt;/button&gt;;
}
</code></pre></div></div>

<h4 id="usecontext--react-context를-통해-전역으로-상태를-공유하거나-전달할-때-사용"><code class="language-plaintext highlighter-rouge">useContext</code> : <code class="language-plaintext highlighter-rouge">React Context</code>를 통해 전역으로 상태를 공유하거나 전달할 때 사용</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prop</code> 내려주기 : <code class="language-plaintext highlighter-rouge">A</code> 컴포넌트가 제공하는 데이터를 <code class="language-plaintext highlighter-rouge">D</code> 컴포넌트에서 사용하려면, …
    <ul>
      <li>하위 컴포넌트로 필요한 위치까지 계속해서 넘겨주어야 함 → 제공하는 쪽, 제공받는 쪽 모두 번거로운 작업!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;A props={props}&gt;
  &lt;B props={props}&gt;
    &lt;C props={props}&gt;
      &lt;D props={props}&gt;
        ...
      &lt;/D&gt;
    &lt;/C&gt;
  &lt;/B&gt;
&lt;/A&gt;
</code></pre></div></div>

<ul>
  <li>리액트 컨텍스트 (<code class="language-plaintext highlighter-rouge">React Context</code>) : 컴포넌트 트리 안에서 전역적으로 데이터를 공유
    <ul>
      <li>중첩 컴포넌트 간에 데이터를 명시적으로 전달하지 않아도 되므로, <code class="language-plaintext highlighter-rouge">Props</code>를 여러 단계에 걸쳐 전달하지 않아도 됨</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1. Context 객체 생성
const MyContext = React.createContext(defaultValue);

// 2. Context를 제공하는 컴포넌트 작성
const MyContextProvider = ({ children }) =&gt; {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
};

// 3. useContext를 사용하여 값에 접근
import { useContext } from 'react';

const MyComponent = () =&gt; {
  const contextValue = useContext(MyContext); // 이때, 리액트가 아닌 자비스크립트가 반환된다.

  // contextValue를 사용하여 렌더링 또는 다른 로직 수행
};
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Context.Provider</code> : 컨텍스트 값을 하위 컴포넌트에 제공
    <ul>
      <li><code class="language-plaintext highlighter-rouge">value</code> 속성을 통해 전달할 값을 설정</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const MyContextProvider = ({ children }) =&gt; {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
};
</code></pre></div></div>

<h4 id="usereducer--복잡한-상태-로직을-다룰-때-사용"><code class="language-plaintext highlighter-rouge">useReducer</code> : 복잡한 상태 로직을 다룰 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// useReducer가 사용할 State 정의
type State = {
  count: number
}

// State의 변화를 발생시킬 Action의 타입과 넘겨줄 payload 정의
type Action = {
  type: 'up' | 'down' | 'reset';
  payload?: State;
}

// 무거운 연산이 포함된 게으른 초기화 함수 init 정의
const init = (count: State) =&gt; {
  return count
}

const initState: State = { count: 0 }

const reducer = ((state: State, action: Action): State) =&gt; {
  switch (action.type) {
    case 'up':
      return { count: state.count + 1 }
    case 'down':
      return { count: state.count - 1 &gt; 0 ? state.count - 1 : 0 }
    case 'down':
      return init(action.payload || { count: 0 })
    default:
      throw new Error(`Unexpected Action type: ${action.type}`)
  }
}

const export default App = () =&gt; {
  const [state, dispatcher] = useReducer(reducer, initialState, init)

  const handleUpButtonClick = () =&gt; {
    dispatcher({ type: 'up' })
  }

  const handleDownButtonClick = () =&gt; {
    dispatcher({ type: 'down' })
  }

  const handleResetButtonClick = () =&gt; {
    dispatcher({ type: 'reset', payload: { count: 1 } })
  }

  return {
    &lt;div className="App"&gt;
      &lt;button onclick={handleUpButtonClick}&gt;+&lt;/button&gt;
      &lt;button onclick={handleDownButtonClick}&gt;-&lt;/button&gt;
      &lt;button onclick={handleResetButtonClick}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre></div></div>

<ul>
  <li>반환값은 <code class="language-plaintext highlighter-rouge">useState</code>와 동일하게 길이가 <code class="language-plaintext highlighter-rouge">2</code>인 배열
    <ul>
      <li><code class="language-plaintext highlighter-rouge">state</code> : 현재 <code class="language-plaintext highlighter-rouge">useReducer</code>가 갖고 있는 값</li>
      <li><code class="language-plaintext highlighter-rouge">dispatcher</code> : <code class="language-plaintext highlighter-rouge">state</code>를 업데이트하는 함수. 값만 넘겨주는 <code class="language-plaintext highlighter-rouge">setState</code>와 달리, <code class="language-plaintext highlighter-rouge">state</code>를 변경할 수 있는 액션 (<code class="language-plaintext highlighter-rouge">action</code>)을 반환</li>
    </ul>
  </li>
  <li>인수는 <code class="language-plaintext highlighter-rouge">useState</code>와 달리 2~3개의 인수를 필요로 함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">reducer</code> :</li>
      <li><code class="language-plaintext highlighter-rouge">initialState</code> :</li>
      <li><code class="language-plaintext highlighter-rouge">init</code> :</li>
    </ul>
  </li>
</ul>

<h4 id="forwardref--부모-컴포넌트에서-자식-컴포넌트로-ref를-전달할-수-있게-함"><code class="language-plaintext highlighter-rouge">forwardRef</code> : 부모 컴포넌트에서 자식 컴포넌트로 <code class="language-plaintext highlighter-rouge">ref</code>를 전달할 수 있게 함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, forwardRef } from 'react';

// 자식 컴포넌트
const ChildComponent = forwardRef((props, ref) =&gt; {
  const internalState = useRef(null);

  // 부모 컴포넌트에서 전달한 ref에 직접 접근
  // ref.current를 통해 부모 컴포넌트의 ref를 참조할 수 있음
  const handleButtonClick = () =&gt; {
    console.log('자식 컴포넌트에서 버튼 클릭');
    console.log('내부 상태:', internalState.current);
  };

  return (
    // 여기에 컴포넌트 JSX를 작성
    &lt;div&gt;
      &lt;button onClick={handleButtonClick}&gt;자식 컴포넌트에서 클릭&lt;/button&gt;
    &lt;/div&gt;
  );
});

// 부모 컴포넌트
const ParentComponent = () =&gt; {
  // ref를 생성하여 자식 컴포넌트에 전달
  const childRef = useRef();

  // 부모 컴포넌트에서 ref를 자식 컴포넌트에 전달
  return (
    &lt;div&gt;
      {/* forwardRef를 사용하여 자식 컴포넌트에 ref 전달 */}
      &lt;ChildComponent ref={childRef} /&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useRef</code>로 컴포넌트 외부 (자식)의 <code class="language-plaintext highlighter-rouge">DOM</code>에 접근
    <ul>
      <li>부모에서 선언 → 자식에게 전달 → 자식에서 참조 걸기 → 부모에서 컨트롤</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">But</code>, 외부 <code class="language-plaintext highlighter-rouge">DOM</code>을 참조하는 <code class="language-plaintext highlighter-rouge">ref</code>를 갖는 것은 <code class="language-plaintext highlighter-rouge">Coupling</code>이 강해지므로 좋지 않다!</p>
</blockquote>

<h4 id="useimperativehandle-with-forwardref--부모-컴포넌트가-자식-컴포넌트를-컨트롤할-수-있게-함"><code class="language-plaintext highlighter-rouge">useImperativeHandle (with forwardRef)</code> : 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있게 함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { forwardRef, useRef, useImperativeHandle } from 'react';

const ChildComponent = forwardRef((props, ref) =&gt; {
  // useImperativeHandle을 사용하여 부모 컴포넌트에 특정 함수나 값들을 노출
  useImperativeHandle(ref, () =&gt; ({
    // 부모 컴포넌트에서 입력 엘리먼트에 포커스를 맞추기 위해 함수를 노출
    focusInput: () =&gt; {
      inputRef.current.focus();
    }
  }));

  const inputRef = useRef(null);

  return &lt;input ref={inputRef} /&gt;;
});

const ParentComponent = () =&gt; {
  const childRef = useRef(null);

  const handleClick = () =&gt; {
    // 자식 컴포넌트에서 노출한 함수를 호출하여 입력 엘리먼트에 포커스를 맞춤
    childRef.current.focusInput();
  };

  return (
    &lt;div&gt;
      &lt;ChildComponent ref={childRef} /&gt;
      &lt;button onClick={handleClick}&gt;입력에 포커스 맞추기&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useImperativeHandle</code>을 통해 부모 컴포넌트에 함수 및 기능을 노출시킴
    <ul>
      <li>부모에게 참조값을 전달 → 자식은 객체를 반환</li>
    </ul>
  </li>
</ul>

<h4 id="uselayouteffect--rendering-이후-mount-이전에-실행"><code class="language-plaintext highlighter-rouge">useLayoutEffect</code> : <code class="language-plaintext highlighter-rouge">rendering</code> 이후, <code class="language-plaintext highlighter-rouge">mount</code> 이전에 실행</h4>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/db687861-6983-4eac-8615-a144ef0efb3c" width="90%" /></p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[함수 컴포넌트 (Functional Component) : 리액트 훅을 통한 상태와 생명주기 관리]]></summary></entry><entry><title type="html">[React] 2. 클래스 컴포넌트 (Class Component)</title><link href="http://localhost:4000/react2/" rel="alternate" type="text/html" title="[React] 2. 클래스 컴포넌트 (Class Component)" /><published>2024-02-16T00:00:00+09:00</published><updated>2024-02-16T00:00:00+09:00</updated><id>http://localhost:4000/react2</id><content type="html" xml:base="http://localhost:4000/react2/"><![CDATA[<h2 id="클래스-컴포넌트-class-component--생성자와-생명주기-메소드를-통한-상태와-생명주기-관리">클래스 컴포넌트 (<code class="language-plaintext highlighter-rouge">Class Component</code>) : 생성자와 생명주기 메소드를 통한 상태와 생명주기 관리</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { Component } from 'react';

class MyClassComponent extends Component {
  constructor(props) {
    super(props);
    // 초기 상태 설정
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    // 컴포넌트가 마운트된 후 실행되는 코드
    console.log('Component mounted');
  }

  componentDidUpdate(prevProps, prevState) {
    // 상태 또는 속성이 업데이트된 후 실행되는 코드
    console.log('Component updated', prevState.count, '-&gt;', this.state.count);
  }

  componentWillUnmount() {
    // 컴포넌트가 언마운트되기 전 실행되는 코드
    console.log('Component will unmount');
  }

  handleIncrement = () =&gt; {
    // 상태 업데이트 예시
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={this.handleIncrement}&gt;Increment&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default MyClassComponent;
</code></pre></div></div>

<h3 id="생성자-constructor--메소드-내에서-컴포넌트-자체를-참조--this">생성자 (<code class="language-plaintext highlighter-rouge">Constructor</code>) : 메소드 내에서 컴포넌트 자체를 참조 → <code class="language-plaintext highlighter-rouge">this</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constructor(props) {
  super(props);
  console.log("constructor");
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this.state</code> : 컴포넌트의 상태를 저장 (<code class="language-plaintext highlighter-rouge">setState</code> 메소드를 사용하여 업데이트)</li>
  <li><code class="language-plaintext highlighter-rouge">this.props</code> : 컴포넌트에서 사용되는 속성에 접근</li>
</ul>

<h3 id="생명주기-메소드-lifecycle-methods--클래스-컴포넌트의-생명주기에-따라-메소드를-실행">생명주기 메소드 (<code class="language-plaintext highlighter-rouge">Lifecycle Methods</code>) : 클래스 컴포넌트의 생명주기에 따라 메소드를 실행</h3>

<blockquote>
  <p>클래스 컴포넌트의 생명주기 메소드가 실행되는 시점?</p>

  <ul>
    <li>마운트 (<code class="language-plaintext highlighter-rouge">Mount</code>) : 컴포넌트가 생성되는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Constructor</code>, <code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code>, <code class="language-plaintext highlighter-rouge">render</code>, <code class="language-plaintext highlighter-rouge">componentDidMount</code></li>
      </ul>
    </li>
    <li>업데이트 (<code class="language-plaintext highlighter-rouge">Update</code>) : 이미 생성된 컴포넌트의 내용이 변경되는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code>, <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code>, <code class="language-plaintext highlighter-rouge">render</code>, <code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code>, <code class="language-plaintext highlighter-rouge">componentDidUpdate</code></li>
      </ul>
    </li>
    <li>언마운트 (<code class="language-plaintext highlighter-rouge">Unmount</code>) : 컴포넌트가 더 이상 존재하지 않는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">componentWillUnmount</code></li>
      </ul>
    </li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/aec795ea-ff51-4f9d-ada3-ebca3616178f" width="80%" /></p>
</blockquote>

<h4 id="render--컴포넌트가-ui를-렌더링하기-위해-사용-마운트-업데이트-과정에서-실행"><code class="language-plaintext highlighter-rouge">render</code> : 컴포넌트가 <code class="language-plaintext highlighter-rouge">UI</code>를 렌더링하기 위해 사용 (마운트, 업데이트 과정에서 실행)</h4>

<ul>
  <li>리액트 클래스 컴포넌트의 유일한 필수 값으로 사용</li>
  <li>항상 순수해야 하며 부수 효과가 없어야 함 → <code class="language-plaintext highlighter-rouge">render</code> 내에서 <code class="language-plaintext highlighter-rouge">this.setState</code>를 호출하면 안됨</li>
</ul>

<h4 id="getderivedstatefromprops--속성에-가져온-값을-상태에-넣을-때-속성이나-상태가-변화했을-때-실행"><code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code> : 속성에 가져온 값을 상태에 넣을 때, 속성이나 상태가 변화했을 때 실행</h4>

<h4 id="componentdidmount--클래스-컴포넌트가-마운트된-이후에-실행"><code class="language-plaintext highlighter-rouge">componentDidMount</code> : 클래스 컴포넌트가 마운트된 이후에 실행</h4>

<h4 id="shouldcomponentupdate--클래스-컴포넌트가-리렌더링을-할지-안할지-결정"><code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> : 클래스 컴포넌트가 리렌더링을 할지 안할지 결정</h4>

<h4 id="getsnapshotbeforeupdate--클래스-컴포넌트가-엄데이트되기-직전의-dom-내의-특정-값을-반환하면-그-다음의-componentdidupdate-반환"><code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code> : 클래스 컴포넌트가 엄데이트되기 직전의 <code class="language-plaintext highlighter-rouge">DOM</code> 내의 특정 값을 반환하면, 그 다음의 <code class="language-plaintext highlighter-rouge">componentDidUpdate</code> 반환</h4>

<h4 id="componentdidupdate--컴포넌트-업데이트가-일어난-이후에-실행"><code class="language-plaintext highlighter-rouge">componentDidUpdate</code> : 컴포넌트 업데이트가 일어난 이후에 실행</h4>

<h4 id="componentwillunmount--컴포넌트가-언마운트되거나-더-이상-사용되지-않기-직전에-실행"><code class="language-plaintext highlighter-rouge">componentWillUnmount</code> : 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 실행</h4>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[클래스 컴포넌트 (Class Component) : 생성자와 생명주기 메소드를 통한 상태와 생명주기 관리]]></summary></entry><entry><title type="html">[React] 1. 리액트 (React)</title><link href="http://localhost:4000/react1/" rel="alternate" type="text/html" title="[React] 1. 리액트 (React)" /><published>2024-02-16T00:00:00+09:00</published><updated>2024-02-16T00:00:00+09:00</updated><id>http://localhost:4000/react1</id><content type="html" xml:base="http://localhost:4000/react1/"><![CDATA[<h2 id="리액트-react--사용자-인터페이스를-만들기-위한-javascript-라이브러리">리액트 (<code class="language-plaintext highlighter-rouge">React</code>) : 사용자 인터페이스를 만들기 위한 <code class="language-plaintext highlighter-rouge">JavaScript</code> 라이브러리</h2>

<ul>
  <li>가상 <code class="language-plaintext highlighter-rouge">DOM</code> : 실제 <code class="language-plaintext highlighter-rouge">DOM</code>가 상호 작용하면서 웹 어플리케이션의 빠른 렌더링이 가능</li>
  <li>선언형 뷰 (<code class="language-plaintext highlighter-rouge">Declarative View</code>) : 사용자 인터페이스를 어떻게 보일지 명시적으로 선언하고, 개발자가 그 명세를 작성</li>
  <li>컴포넌트 기반 구조 : 부모-자식 관계 및 상태 (<code class="language-plaintext highlighter-rouge">State</code>)를 갖는 재사용 가능한 모듈들로 어플리케이션 구성</li>
  <li>단방향 데이터 바인딩 : 데이터의 흐름이 단일 방향으로 진행하여 디버깅 용이 → 명시적인 상태 변경이 가능</li>
  <li><code class="language-plaintext highlighter-rouge">JSX</code> : 자바스크립트 코드 내에 마크업을 작성해 가독성 향상 및 명확한 표현 가능</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ca8780dc-5a83-45cb-972d-e66b4fea19e4" width="90%" /></p>

<blockquote>
  <p>리액트에서 자주 쓰이는 <code class="language-plaintext highlighter-rouge">JS</code> 문법?</p>

  <ul>
    <li>구조 분해 할당 (<code class="language-plaintext highlighter-rouge">Destructuring Assignment</code>) : 배열 또는 객체의 값을 분해해서 할당하는 것</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 객체 구조 분해 할당
const person = { name: 'John', age: 30 };
const { name, age } = person;

console.log(name); // 'John'
console.log(age);  // 30
</code></pre></div>  </div>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 배열 구조 분해 할당
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
</code></pre></div>  </div>

  <ul>
    <li>전개 구문 (<code class="language-plaintext highlighter-rouge">Spread Syntax</code>) : 배열이나 객체를 확장하여 개별 요소로 분리하거나 복사</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 배열의 전개 구문을 사용하여 두 배열을 병합
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const mergedArray = [...arr1, ...arr2];
console.log(mergedArray); // [1, 2, 3, 4, 5, 6]
</code></pre></div>  </div>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 객체의 전개 구문을 사용하여 두 객체를 병합
const obj1 = { x: 1, y: 2 };
const obj2 = { z: 3, w: 4 };

const mergedObject = { ...obj1, ...obj2 };
console.log(mergedObject); // { x: 1, y: 2, z: 3, w: 4 }
</code></pre></div>  </div>

  <ul>
    <li>객체 초기자 (<code class="language-plaintext highlighter-rouge">Object Shorthand Assignment</code>) : 객체를 간결히 생성하고 초기값을 설정</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 일반적인 객체 생성 방법
const person1 = new Object();
person1.name = 'Alice';
person1.age = 25;

// 객체 초기자를 사용한 방법
const person2 = {
  name: 'Alice',
  age: 25
};

console.log(person1); // { name: 'Alice', age: 25 }
console.log(person2); // { name: 'Alice', age: 25 }

</code></pre></div>  </div>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Array</code> 프로토타입 메소드 : <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">reduce</code>, <code class="language-plaintext highlighter-rouge">forEach</code></li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const numbers = [1, 2, 3, 4];

// map 메소드: 각 숫자를 두 배로 만듭니다.
const doubledNumbers = numbers.map((num) =&gt; num * 2);

// filter 메소드: 짝수만을 걸러냅니다.
const evenNumbers = numbers.filter((num) =&gt; num % 2 === 0);

// reduce 메소드: 모든 숫자의 합을 계산합니다.
const sum = numbers.reduce((acc, num) =&gt; acc + num, 0);

// forEach 메소드: 각 숫자를 콘솔에 출력합니다.
numbers.forEach((num) =&gt; console.log(num));

console.log('Doubled Numbers:', doubledNumbers);
console.log('Even Numbers:', evenNumbers);
console.log('Sum:', sum);
</code></pre></div>  </div>
</blockquote>

<h3 id="jsx-javascript-xml--기존-js에-html-css를-더해-리액트-컴포넌트-작성"><code class="language-plaintext highlighter-rouge">JSX</code> (<code class="language-plaintext highlighter-rouge">JavaScript XML</code>) : 기존 <code class="language-plaintext highlighter-rouge">JS</code>에 <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>를 더해 리액트 컴포넌트 작성</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JSXElement</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 엘리먼트<br />(<code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello, World!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">JSXAttribute</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 엘리먼트의 속성<br />(<code class="language-plaintext highlighter-rouge">&lt;div className="container"&gt;Hello, World!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">className="container"</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">JSXChildren</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 엘리먼트의 자식 요소<br />(<code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello, &lt;span&gt;React&lt;/span&gt;!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">Hello, &lt;span&gt;React&lt;/span&gt;!</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">JSXString</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 문자열<br />(<code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello, World!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">"Hello, World!"</code>)</li>
</ul>

<h3 id="가상-dom-virtual-dom--실제-dom-document-object-model-에-대한-가벼운-복사본">가상 <code class="language-plaintext highlighter-rouge">DOM</code> (<code class="language-plaintext highlighter-rouge">Virtual DOM</code>) : 실제 <code class="language-plaintext highlighter-rouge">DOM</code> (<code class="language-plaintext highlighter-rouge">Document Object Model</code>) 에 대한 가벼운 복사본</h3>

<ul>
  <li>리액트 파이버 (<code class="language-plaintext highlighter-rouge">React Fiber</code>) : 가상 <code class="language-plaintext highlighter-rouge">DOM</code>과 실제 <code class="language-plaintext highlighter-rouge">DOM</code>을 비교해 변경 사항을 수집
    <ul>
      <li>동기성 : 렌더링 작업을 여러 프레임에 나눠 렌더링 작업이 한 번에 실행되지 않더라도 앱이 반응적으로 유지 가능</li>
      <li>우선순위 관리 : 각 작업에 우선순위를 할당하고, 중요한 작업을 먼저 처리하여 사용자 인터랙션에 빠르게 응답 가능</li>
      <li>종료 및 재시작 가능 : 사용자 인터랙션에 우선순위를 두면서도 작업을 중단하고 다시 시작 가능</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DOM</code>과 <code class="language-plaintext highlighter-rouge">CSSOM</code>으로 렌더링 트리가 만들어지는 과정?</p>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/95ef558e-965b-4525-873f-140e4292b29e" width="90%" /></p>

  <ol>
    <li>브라우저가 사용자가 요청한 주소를 방문해 <code class="language-plaintext highlighter-rouge">HTML</code> 파일을 다운로드</li>
    <li>브라우저의 렌더링 엔진은 <code class="language-plaintext highlighter-rouge">HTML</code>을 파싱해 <code class="language-plaintext highlighter-rouge">DOM</code> 노드로 구성된 트리를 생성</li>
    <li><code class="language-plaintext highlighter-rouge">CSS</code> 파일을 만나면, 해당 <code class="language-plaintext highlighter-rouge">CSS</code> 파일도 다운로드</li>
    <li><code class="language-plaintext highlighter-rouge">CSS</code> 파일을 파싱하여 <code class="language-plaintext highlighter-rouge">CSS</code> 노드로 구성된 트리 (<code class="language-plaintext highlighter-rouge">CSSOM</code>)를 생성</li>
    <li>사용자의 눈에 보일 <code class="language-plaintext highlighter-rouge">DOM</code> 노드만을 순회</li>
    <li>눈에 보이는 노드를 대상으로 해당 노드에 대한 <code class="language-plaintext highlighter-rouge">CSSOM</code> 정보를 찾고 <code class="language-plaintext highlighter-rouge">CSS</code> 스타일 정보를 적용
      <ul>
        <li>레이아웃 (<code class="language-plaintext highlighter-rouge">Layout</code>) : 각 노드가 브라우저 화면에 어느 좌표에 나타날지 계산하는 과정</li>
        <li>페인팅 (<code class="language-plaintext highlighter-rouge">Painting</code>) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정</li>
      </ul>
    </li>
  </ol>

  <p>… 모든 <code class="language-plaintext highlighter-rouge">DOM</code>의 변경보다 결과적으로 만들어질 <code class="language-plaintext highlighter-rouge">DOM</code>의 최종 결과물만을 제공하자!</p>
</blockquote>

<ol>
  <li>초기 렌더링 : 초기 상태에서 가상 <code class="language-plaintext highlighter-rouge">DOM</code>은 실제 <code class="language-plaintext highlighter-rouge">DOM</code>과 동일한 구조를 가짐</li>
  <li>상태 변화 감지 : 사용자 상호 작용이나 데이터 변경 등의 이벤트가 발생하면, 렌더링 엔진은 새로운 가상 <code class="language-plaintext highlighter-rouge">DOM</code> 생성</li>
  <li>가상 <code class="language-plaintext highlighter-rouge">DOM</code> 비교 : 새로운 가상 <code class="language-plaintext highlighter-rouge">DOM</code>과 이전의 가상 <code class="language-plaintext highlighter-rouge">DOM</code>을 비교하여 변경된 부분 탐색</li>
  <li>실제 <code class="language-plaintext highlighter-rouge">DOM</code> 업데이트 : 변경된 부분만을 실제 <code class="language-plaintext highlighter-rouge">DOM</code>에 적용</li>
</ol>

<h2 id="컴포넌트-component--리액트-애플리케이션에서-ui를-구성하고-재사용-가능한-모듈을-표현">컴포넌트 (<code class="language-plaintext highlighter-rouge">Component</code>) : 리액트 애플리케이션에서 <code class="language-plaintext highlighter-rouge">UI</code>를 구성하고 재사용 가능한 모듈을 표현</h2>

<ul>
  <li>속성 (<code class="language-plaintext highlighter-rouge">Props</code>) 을 받고, 상태 (<code class="language-plaintext highlighter-rouge">state</code>)와 메소드 (<code class="language-plaintext highlighter-rouge">Method</code>)를 가짐</li>
  <li>반복되는 <code class="language-plaintext highlighter-rouge">UI</code> 단위 (<code class="language-plaintext highlighter-rouge">JS Code</code> 또는 <code class="language-plaintext highlighter-rouge">HTML-JSX</code>) → 재사용성과 가독성을 위한 도구</li>
  <li>가능한 독립적으로 실행되도록 작성하고, 데이터 영역과 <code class="language-plaintext highlighter-rouge">UI</code>를 분리</li>
</ul>

<h3 id="상태-state---사용자-상호작용에-응답하거나-컴포넌트의-생명주기에-변경되는-정보를-저장하는-데에-사용">상태 (<code class="language-plaintext highlighter-rouge">State</code>) :  사용자 상호작용에 응답하거나 컴포넌트의 생명주기에 변경되는 정보를 저장하는 데에 사용</h3>

<ul>
  <li>부모의 상태가 변경되면, 그 상태를 참조하는 모든 자식 컴포넌트가 <code class="language-plaintext highlighter-rouge">Re-Rendering</code>
    <ul>
      <li>상태를 통합하면 <code class="language-plaintext highlighter-rouge">Re-Rendering</code>이 많이 일어나므로, 상태를 연관성에 맞게 분리해 좁게 사용해야 함</li>
      <li><code class="language-plaintext highlighter-rouge">Setter</code>로 값을 수신하면 <code class="language-plaintext highlighter-rouge">Dispatcher</code> 값이 세팅 → <code class="language-plaintext highlighter-rouge">re-rendering</code>을 <code class="language-plaintext highlighter-rouge">trigger</code> (<code class="language-plaintext highlighter-rouge">DOM</code> 갱신)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState('안녕하세요!');

  return (
    &lt;div&gt;
      &lt;p&gt;{message}&lt;/p&gt;
      &lt;p&gt;카운트: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre></div></div>

<blockquote>
  <p>초기화는 동기 방식이면 오래 걸리더라도 가능, <code class="language-plaintext highlighter-rouge">Promise</code>는 <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>로 처리해도 <code class="language-plaintext highlighter-rouge">Promise</code>가 세팅</p>
</blockquote>

<h3 id="속성-prop--부모-컴포넌트로부터-자식-컴포넌트로-데이터를-전달하는-데에-사용">속성 (<code class="language-plaintext highlighter-rouge">Prop</code>) : 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달하는 데에 사용</h3>

<ul>
  <li>변수나 함수와 같은 속성들을 부모에서 자식으로 전달 (<code class="language-plaintext highlighter-rouge">MyComponent.defaultProps = { ... }</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Read-Only</code> : 속성이 변경되도 <code class="language-plaintext highlighter-rouge">Re-Rendering</code>하지 않음! (값은 바꿔도 화면엔 아무런 영향 없음!)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 부모 컴포넌트
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const dataToPass = "안녕하세요!";
  
  return (
    &lt;ChildComponent message={dataToPass} /&gt;
  );
}

// 자식 컴포넌트
function ChildComponent(props) {
  return (
    &lt;div&gt;
      &lt;p&gt;{props.message}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre></div></div>

<h3 id="컴포넌트-개발-원칙--코드의-가독성-유지보수성-재사용성을-향상하여-구성-요소를-생성">컴포넌트 개발 원칙 : 코드의 가독성, 유지보수성, 재사용성을 향상하여 구성 요소를 생성</h3>

<ul>
  <li><b>가급적 순수 함수 컴포넌트 (<code>Pure Functional Component</code>)를 활용할 것!</b>
    <ul>
      <li>상태나 생명주기 메서드 없이 단순히 <code class="language-plaintext highlighter-rouge">props</code>를 받아 렌더링하는 컴포넌트 → 간결하고 재사용성이 높힐 수 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Container Component</code>와 <code class="language-plaintext highlighter-rouge">Presentational Component</code>를 분리할 것
    <ul>
      <li>데이터를 가져오는 로직과 <code class="language-plaintext highlighter-rouge">UI</code>를 그리는 로직을 분리하여 관리</li>
    </ul>
  </li>
  <li>상태를 공유하는 단위로 분리할 것
    <ul>
      <li>관련된 상태를 함께 관리하고, 필요한 경우 <code class="language-plaintext highlighter-rouge">useContext</code>를 사용하여 상태 공유를 구현</li>
    </ul>
  </li>
  <li>아주 깊은 구조로 중첩되는 <code class="language-plaintext highlighter-rouge">Container</code> 컴포넌트는 피할 것
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Context</code>를 남발하는 대신, 상태 관리 등의 용도로 필요한 경우에만 적절히 사용할 것</li>
    </ul>
  </li>
  <li>각 컴포넌트는 독립적으로 작성할 것
    <ul>
      <li>컴포넌트 간의 결합도를 최소화해 재사용성을 높이고 유지보수를 용이하게 만들어야 함</li>
    </ul>
  </li>
</ul>

<h2 id="렌더링-rendering--html-css-리소스로-웹-페이지의-ui를-그리는-과정">렌더링 (<code class="language-plaintext highlighter-rouge">Rendering</code>) : <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code> 리소스로 웹 페이지의 <code class="language-plaintext highlighter-rouge">UI</code>를 그리는 과정</h2>

<ul>
  <li>리액트의 렌더링 : 리액트 어플리케이션 트리 내의 모든 컴포넌트들이 갖고 있는 현재 상태와 속성의 값을 기반하여 어떻게<code class="language-plaintext highlighter-rouge">UI</code>를 구성하고 어떤 <code class="language-plaintext highlighter-rouge">DOM</code> 결과를 브라우저에 제공할지 계산하는 일련의 과정
    <ul>
      <li>초기 렌더링 : 사용자가 처음 어플리케이션이 진입할 때 최초로 수행</li>
      <li>리렌더링 (<code class="language-plaintext highlighter-rouge">Re-rendering</code>) : 처음 어플리케이션 이후에 발생하는 모든 렌더링들을 총칭
        <ul>
          <li>클래스 컴포넌트의 <code class="language-plaintext highlighter-rouge">setState()</code>나 <code class="language-plaintext highlighter-rouge">forceUpdate()</code>가 실행되는 경우</li>
          <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useState()</code>의 두번째 배열 요소인 <code class="language-plaintext highlighter-rouge">setter</code>가 실행되는 경우</li>
          <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useReducer()</code>의 두번째 배열 요소인 <code class="language-plaintext highlighter-rouge">dispatch</code>가 실행되는 경우</li>
          <li>컴포넌트의 <code class="language-plaintext highlighter-rouge">key props</code>가 변경되는 경우</li>
          <li>부모 컴포넌트로부터 전달받는 값인 <code class="language-plaintext highlighter-rouge">props</code>가 변경되거나 부모 컴포넌트가 리렌더링될 경우</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="렌더링-프로세스-rendering-process--리액트의-재조정을-위해-변경-사항을-탐색-비교-수집하는-과정">렌더링 프로세스 (<code class="language-plaintext highlighter-rouge">Rendering Process</code>) : 리액트의 재조정을 위해 변경 사항을 탐색, 비교, 수집하는 과정</h3>

<ol>
  <li>리액트가 컴포넌트의 루트에서부터 업데이트가 필요한 모든 컴포넌트를 탐색</li>
  <li>클래스 컴포넌트는 클래스 내 <code class="language-plaintext highlighter-rouge">render()</code> 함수를, 함수 컴포넌트는 <code class="language-plaintext highlighter-rouge">FunctionComponent()</code> 자체를 호출</li>
  <li><code class="language-plaintext highlighter-rouge">JSX</code>로 구성된 렌더링 결과물을 자바스크립트로 컴파일하면 <code class="language-plaintext highlighter-rouge">React.createElement()</code>를 반환</li>
  <li><code class="language-plaintext highlighter-rouge">React.createElement()</code>가 브라우저 <code class="language-plaintext highlighter-rouge">UI</code> 구조를 설명하는 자바스크립트 객체를 반환</li>
</ol>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9ce93fdd-ed10-4a4a-84c4-58234265ffb2" width="80%" /></p>

<h4 id="1-렌더-단계-render-phase--컴포넌트를-렌더링하고-변경-사항을-계산하는-모든-작업"><code class="language-plaintext highlighter-rouge">(1)</code> 렌더 단계 (<code class="language-plaintext highlighter-rouge">Render Phase</code>) : 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업</h4>

<ol>
  <li>렌더링 프로세스에서 컴포넌트를 실행 (<code class="language-plaintext highlighter-rouge">render()</code> 또는 <code class="language-plaintext highlighter-rouge">return</code>)</li>
  <li>이전 가상 <code class="language-plaintext highlighter-rouge">DOM</code>과 결과 가상 <code class="language-plaintext highlighter-rouge">DOM</code>를 비교</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>, <code class="language-plaintext highlighter-rouge">props</code>, <code class="language-plaintext highlighter-rouge">key</code>를 비교하여, 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크</li>
</ol>

<h4 id="2-커밋-단계-commit-phase--렌더-단계의-변경-사항을-실제-dom에-적용해-사용자에게-표현"><code class="language-plaintext highlighter-rouge">(2)</code> 커밋 단계 (<code class="language-plaintext highlighter-rouge">Commit Phase</code>) : 렌더 단계의 변경 사항을 실제 <code class="language-plaintext highlighter-rouge">DOM</code>에 적용해 사용자에게 표현</h4>

<ol>
  <li>리액트가 먼저 <code class="language-plaintext highlighter-rouge">DOM</code>을 커밋 단계에서 업데이트</li>
  <li>생성된 모든 <code class="language-plaintext highlighter-rouge">DOM</code> 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트</li>
  <li>클래스 컴포넌트는 <code class="language-plaintext highlighter-rouge">componentDidMount</code>, <code class="language-plaintext highlighter-rouge">componentDidUpdate</code> 메소드를,<br />함수 컴포넌트는 <code class="language-plaintext highlighter-rouge">useLayoutEffect</code> 훅을 호출</li>
</ol>

<ul>
  <li>리액트의 렌더링이 일어난다고 무조건 <code class="language-plaintext highlighter-rouge">DOM</code> 업데이트가 일어나지 않음! (커밋 단계 생략 가능)
    <ul>
      <li>리액트의 렌더링은 가시적 변경 없이 발생 가능!! (커밋 단계가 생략되어 <code class="language-plaintext highlighter-rouge">DOM</code> 업데이트가 발생하지 않음)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>렌더링 시나리오 - 어플리케이션의 숫자 증가 버튼</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react'

export default function A() {
  return (
  &lt;div className="App"&gt;
    &lt;h1&gt;Hello React!&lt;/h1&gt;
    &lt;B /&gt;
  &lt;/div&gt;
  )
}

function B() {
  const [counter, setCounter] = useState(0)

  function handleButtonClick() {
    setCounter((previous) =&gt; previous + 1)
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        &lt;C number={counter}/&gt;
      &lt;/label&gt;
      &lt;button onClick={handleButtonClick}&gt;&lt;/button&gt;
    &lt;/&gt;
  )
}

function C({number}: {number: number}) {
  return (
    &lt;div&gt;
      {number} &lt;D/&gt;
    &lt;/div&gt;
  )
}

function D() {
  return (
    &lt;&gt;
      안녕 리액트!
    &lt;/&gt;
    );
}
</code></pre></div>  </div>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트의 <code class="language-plaintext highlighter-rouge">setState</code> 호출</li>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트의 리렌더링 작업이 큐에 들어감</li>
    <li>리액트는 트리 최상단에서부터 렌더링 경로를 갱신</li>
    <li><code class="language-plaintext highlighter-rouge">A</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있지 않으므로, 커밋 단계를 생략</li>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있으므로, <code class="language-plaintext highlighter-rouge">B</code>를 리렌더링</li>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트가 <code class="language-plaintext highlighter-rouge">C</code> 컴포넌트를 반환</li>
    <li><code class="language-plaintext highlighter-rouge">C</code> 컴포넌트의 <code class="language-plaintext highlighter-rouge">props</code>인 <code class="language-plaintext highlighter-rouge">number</code>가 업데이트</li>
    <li><code class="language-plaintext highlighter-rouge">C</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있으므로, <code class="language-plaintext highlighter-rouge">C</code>를 리렌더링</li>
    <li><code class="language-plaintext highlighter-rouge">C</code> 컴포넌트가 <code class="language-plaintext highlighter-rouge">D</code> 컴포넌트를 반환</li>
    <li><code class="language-plaintext highlighter-rouge">D</code> 컴포넌트의 부모인 <code class="language-plaintext highlighter-rouge">C</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있으므로, <code class="language-plaintext highlighter-rouge">D</code>를 리렌더링</li>
  </ol>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[리액트 (React) : 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리]]></summary></entry><entry><title type="html">[TS] 1. 타입스크립트 (TypeScript)</title><link href="http://localhost:4000/ts1/" rel="alternate" type="text/html" title="[TS] 1. 타입스크립트 (TypeScript)" /><published>2024-02-07T00:00:00+09:00</published><updated>2024-02-07T00:00:00+09:00</updated><id>http://localhost:4000/ts1</id><content type="html" xml:base="http://localhost:4000/ts1/"><![CDATA[<h2 id="타입스크립트-typescript--javascript을-확장하여-정적-타입을-지원하는-프로그래밍-언어">타입스크립트 (<code class="language-plaintext highlighter-rouge">TypeScript</code>) : <code class="language-plaintext highlighter-rouge">JavaScript</code>을 확장하여 정적 타입을 지원하는 프로그래밍 언어</h2>

<ul>
  <li>정적 타입 (<code class="language-plaintext highlighter-rouge">Static Type</code>) : 변수, 매개변수, 함수 반환 값 등에 대한 타입을 명시적으로 지정 가능</li>
  <li>컴파일 언어 (<code class="language-plaintext highlighter-rouge">Compile Language</code>) : <code class="language-plaintext highlighter-rouge">TypeScript</code> 컴파일러는 <code class="language-plaintext highlighter-rouge">TypeScript</code> 코드를 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드로 변환</li>
  <li>타입 검사 (<code class="language-plaintext highlighter-rouge">Type Checking</code>) : 타입을 명시하지 않아도 코드에서 사용된 패턴과 값에 기반해 타입을 추론</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm init -y
npm install -g typescript ts-node
tsc -v
tsc --init
cat tsconfig.json
ts-node temp.ts
</code></pre></div></div>

<h3 id="타입스크립트-컴파일러-tsc--typescript-코드를-javascript-코드로-변환하는-도구">타입스크립트 컴파일러 (<code class="language-plaintext highlighter-rouge">TSC</code>) : <code class="language-plaintext highlighter-rouge">TypeScript</code> 코드를 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드로 변환하는 도구</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">tsconfig.json</code> 조회 : 프로그램 설정 및 파일 실행</li>
  <li>사용 가능한 모든 파일들을 임포트 (<code class="language-plaintext highlighter-rouge">import</code>) (→ 파일들을 하나의 모듈 내에 있는 것처럼 관리)</li>
  <li>추상 구문 트리 (<code class="language-plaintext highlighter-rouge">AST; Abstract Syntax Tree</code>)를 토큰화 (<code class="language-plaintext highlighter-rouge">Tokenize</code>) 및 파싱 (<code class="language-plaintext highlighter-rouge">Parse</code>)</li>
  <li>바인더 (<code class="language-plaintext highlighter-rouge">Binder</code>)가 추상 구문 트리의 식별자를 <code class="language-plaintext highlighter-rouge">Symbol</code>로 변환</li>
  <li>바인더와 추상 구문 트리로 타입 검사를 실행</li>
  <li>프로그램에 설정한 옵션에 기반하여 추상 구문 트리를 <code class="language-plaintext highlighter-rouge">*.js</code>, <code class="language-plaintext highlighter-rouge">*.d.ts</code>의 형태로 변환</li>
</ol>

<h2 id="타입-시스템-type-system--프로그램에서-가질-수-있는-타입을-이해하는-방법에-대한-규칙-집합">타입 시스템 (<code class="language-plaintext highlighter-rouge">Type system</code>) : 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합</h2>

<ol>
  <li>코드를 읽고 존재하는 모든 타입과 값을 이해한다.</li>
  <li>각 값이 초기 선언에서 가질 수 있는 타입을 확인하고, 각 값이 추후 코드에서 어떻게 사용될 수 있는지 확인한다.</li>
  <li>모든 방법을 확인했을 때, 값의 사용법이 타입과 일치하지 않으면 사용자에게 타입 오류로 표시한다.</li>
</ol>

<blockquote>
  <p>타입 오류 vs 구문 오류?</p>

  <ul>
    <li>타입 오류 (<code class="language-plaintext highlighter-rouge">Type Error</code>) : 타입 검사기에 따라 일치하지 않는 것이 감지된 경우
      <ul>
        <li>타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생</li>
      </ul>
    </li>
    <li>구문 오류 (<code class="language-plaintext highlighter-rouge">Syntax Error</code>) : 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
      <ul>
        <li>타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="할당-가능성-assignability--함수-호출이나-변수에-값을-제공할-수-있는지-여부를-확인-가능">할당 가능성 (<code class="language-plaintext highlighter-rouge">Assignability</code>) : 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인 가능</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TypeScript</code>에선 변수나 속성에 값을 할당할 때 해당 값의 타입이 변수나 속성의 타입과 호환 가능해야함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let firstName = "Noah";
firstName = "Tom";
</code></pre></div></div>

<h3 id="타입-어노테이션-type-annotation--초기값을-할당하지-않고도-타입을-명시적으로-지정-가능">타입 어노테이션 (<code class="language-plaintext highlighter-rouge">Type Annotation</code>) : 초기값을 할당하지 않고도 타입을 명시적으로 지정 가능</h3>

<blockquote>
  <p>메모리 사이즈가 변하지 않는 변수는 타입 어노테이션을 추가하지 않는 것이 좋으나, 코드를 명확하게 문서화하거나 실수로 변수 타입이 변경되지 않도록 타입스크립트를 보호하기 위해 변수에 명시적으로 타입 어노테이션을 포함하는 것이 경우에 따라서는 유용할 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let variable: Type; // 변수의 이름 : 값의 타입
</code></pre></div></div>

<h3 id="타입-형태-type-shape--타입을-정의할-때-객체의-형태를-명시적으로-지정-가능">타입 형태 (<code class="language-plaintext highlighter-rouge">Type Shape</code>) : 타입을 정의할 때 객체의 형태를 명시적으로 지정 가능</h3>

<ul>
  <li>인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 객체의 구조를 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Person {
    name: string;
    age: number;
}

let person: Person = {
    name: "John",
    age: 25
};
</code></pre></div></div>

<ul>
  <li>타입 (<code class="language-plaintext highlighter-rouge">Type</code>) : 객체의 타입을 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Point = {
    x: number;
    y: number;
};

let point: Point = {
    x: 10,
    y: 20
};
</code></pre></div></div>

<h2 id="타입-별칭-alias--자주-사용할-타입에-이름을-붙이는-것">타입 별칭 (<code class="language-plaintext highlighter-rouge">Alias</code>) : 자주 사용할 타입에 이름을 붙이는 것</h2>

<blockquote>
  <p>타입 별칭은 타입 어노테이션과 마찬가지로 자바스크립트로 컴파일되지 않으므로, 런타임 코드에서는 참조할 수 없다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Age = number;
type Name = string;

type Person = {
    name: Name;
    age: Age;
};


let person: Person = { name: "John", age: 25 };
</code></pre></div></div>

<h3 id="리터럴-타입-literal-type--원시-타입보다-더-구체적인-원시-값-자체를-타입으로-활용하는-것">리터럴 타입 (<code class="language-plaintext highlighter-rouge">Literal Type</code>) : 원시 타입보다 더 구체적인 원시 값 자체를 타입으로 활용하는 것</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c9e566fc-2985-4d75-aba6-0f42082c8ab1" width="80%" /></p>

<ul>
  <li>특정 값들을 타입으로 정의하고, 해당 값들만이 유효한 값으로 간주
    <ul>
      <li>리터럴 할당 가능성 : 서로 다른 리터럴 타입은 서로 할당될 수 없음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let isString = '문자열';
let isLiteral: 'LITERAL';

isLiteral = isString;
// Error type 'string' is not assignable to type '"LITERAL"'.
</code></pre></div></div>

<h3 id="유니언-타입-union-type--값에-허용되는-타입을-두-개-이상의-가능한-타입으로-확장하는-것">유니언 타입 (<code class="language-plaintext highlighter-rouge">Union Type</code>) : 값에 허용되는 타입을 두 개 이상의 가능한 타입으로 확장하는 것</h3>

<ul>
  <li>둘 이상의 타입으로 확장된 타입에서, 일부 속성들의 조합이 하나의 타입에 할당 가능하면 유니온 타입으로 사용 가능
    <ul>
      <li>유니언으로 선언한 모든 타입에 존재하는 속성에만 접근 가능!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Person = {
   name: string;
   age: number;
   phone: number | string; // number 또는 string 타입을 가질 수 있음
   addr?: string; // 선택적으로 사용할 수 있음
};
</code></pre></div></div>

<h3 id="내로잉-narrowing--값이-더-구체적인-타입임을-코드에서-유추하는-것">내로잉 (<code class="language-plaintext highlighter-rouge">narrowing</code>) : 값이 더 구체적인 타입임을 코드에서 유추하는 것</h3>

<ul>
  <li>타입스크립트에서 변수의 타입을 조건문을 통해 줄여나가는 것
    <ul>
      <li>값 할당 <code class="language-plaintext highlighter-rouge">ex) x = 1</code></li>
      <li><code class="language-plaintext highlighter-rouge">typeof</code> 검사 <code class="language-plaintext highlighter-rouge">ex) typeof(value)</code></li>
      <li>조건 검사 : <code class="language-plaintext highlighter-rouge">ex) if x === 'stringValue'</code></li>
      <li><code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">instanceof</code>, <code class="language-plaintext highlighter-rouge">Array.isArray</code>를 활용</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>내로잉을 수행하는 함수 또는 구문을 타입 가드 (<code class="language-plaintext highlighter-rouge">Type guard</code>)라 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Member = {
  name: string;
  address: string;
}

function inFunc (user: Member) {
  if ('name' in user) // cf. user.hasOwnProperty('name')로는 불가능
    console.log('user.name); 
}
</code></pre></div></div>

<h3 id="strictnullchecks--엄격한-null-검사-활성화-옵션"><code class="language-plaintext highlighter-rouge">strictNullChecks</code> : 엄격한 <code class="language-plaintext highlighter-rouge">null</code> 검사 활성화 옵션</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code> 값을 참조 및 할당 했을 때, 타입 에러를 발생시킬지 여부</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// tsconfig.json 
//  {
//    "compilerOptions": {
//      "strictNullChecks": true
//    }
//  }

let un: string | undefined;
un.toLowerCase(); // Type 'undefined' is not assigned to type 'string'
un?.toLowerCase();
</code></pre></div></div>

<h2 id="객체-타입-object-type--객체의-형태를-정의하고-객체의-할당-가능성을-확인">객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>) : 객체의 형태를 정의하고, 객체의 할당 가능성을 확인</h2>

<ul>
  <li>타입스크립트의 타입 시스템은 타입을 구조화하여 정의하고 있음 → <code class="language-plaintext highlighter-rouge">Structured Type Definition</code>
    <ul>
      <li>타입 체크 시스템 (<code class="language-plaintext highlighter-rouge">Type Check System</code>) 을 통해 구조화된 형식을 검사</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x_user: {id: number, name: string};
x_user = {id: 1, name: 'xx'}; // OK
x_user = {id: 1}; // Error (Property 'name' missing in type)
x_user = {id: 1, name: 'xx', age: 30}; // Error ({id, name, age} is not assignable to type {id,name} )

// 타입 별칭(type alias)
type T_User = {
  id: number;
  name: string;
};

let hong: T_User;
hong = {id: 1, name: 'Hong'}; // OK
hong = {id: 1}; // Error (name property missing)
hong = {id: 1, name: 'Hong', addr: 'Pusan'}; // Error(not assignable) 
hong = {id: 1, name: 'Hong', addr: 'Pusan'} as T_User;
</code></pre></div></div>

<h3 id="타입스트립트는-covariance--contravariance를-원칙으로-하는-언어">타입스트립트는 <code class="language-plaintext highlighter-rouge">CoVariance | ContraVariance</code>를 원칙으로 하는 언어?</h3>

<ul>
  <li>공변성 (<code class="language-plaintext highlighter-rouge">CoVariance</code>) : 원래 지정된 것보다 더 파생된 형식을 사용 가능한 것<br />→ 타입 간의 계층 구조가 유지되면 변환을 허용 <code class="language-plaintext highlighter-rouge">ex)</code> 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let baseArray: Animal[] = [];
let derivedArray: Dog[] = [];

// Covariant: 하위 타입인 Dog[]가 상위 타입인 Animal[]로 할당 가능
baseArray = derivedArray;
</code></pre></div></div>

<ul>
  <li>반변성 (<code class="language-plaintext highlighter-rouge">ContraVariance</code>) : 원래 지정된 것보다 덜 파생적인 형식을 사용 가능한 것<br />→ 하위 타입이 하위 타입으로 할당될 수 있음 <code class="language-plaintext highlighter-rouge">ex)</code> 함수의 매개변수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type AnimalHandler = (animal: Animal) =&gt; void;
type DogHandler = (dog: Dog) =&gt; void;

// Contravariant: 상위 타입인 AnimalHandler가 하위 타입인 DogHandler로 할당 가능
let animalHandler: AnimalHandler = (animal: Animal) =&gt; { /*...*/ };
let dogHandler: DogHandler = animalHandler;
</code></pre></div></div>

<blockquote>
  <p>타입스크립트는 <code class="language-plaintext highlighter-rouge">CoVariance</code>를 원칙이나, 함수의 매개변수처럼 <code class="language-plaintext highlighter-rouge">ContraVariance</code>가 적용되는 경우 또한 존재한다.</p>
</blockquote>

<h3 id="신선도-freshness--구조적으로-타입-호환성이-있는-객체-리터럴의-타입-검사">신선도 (<code class="language-plaintext highlighter-rouge">Freshness</code>) : 구조적으로 타입 호환성이 있는 객체 리터럴의 타입 검사</h3>

<ul>
  <li>신선도로 인한 오류는 ‘객체 리터럴을 사용한 경우에만’ 발생한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function logName(something: { name: string }) {
    console.log(something.name);
}

var person = { name: 'John', job: 'cowboy' };
var animal = { name: 'cow', description: 'element who hate John' };
var event = { note: `random` };

logName(person);
logName(animal);
logName(event); // 오류: 속성 `name` 누락 (신선도로 인한 오류 O)

function logName(something: { name: string }) {
  console.log(something.name);
}

logName({ name: 'John' });
logName({ name: 'John', job: 'cowboy' }); // 오류: 객체 리터럴은 정의된 속성만 지정해야 함. (신선도로 인한 오류 X)
</code></pre></div></div>

<blockquote>
  <p>신선도를 끄는 방법?</p>

  <ol>
    <li>변수에 할당한다.</li>
    <li>강제로 타입 캐스팅 (<code class="language-plaintext highlighter-rouge">type casting</code>)을 한다.</li>
    <li><code class="language-plaintext highlighter-rouge">union</code> 타입으로 제외시킨다.</li>
    <li><code class="language-plaintext highlighter-rouge">suppressExcessPropertyError</code>를 활성화한다.</li>
  </ol>
</blockquote>

<h2 id="함수-타입-function-type--함수가-가져야-하는-매개변수와-반환-타입을-명시">함수 타입 (<code class="language-plaintext highlighter-rouge">Function Type</code>) : 함수가 가져야 하는 매개변수와 반환 타입을 명시</h2>

<ul>
  <li>변수에 할당되거나 매개변수로 전달되는 함수의 타입을 정의
    <ul>
      <li>필수 매개변수 : 함수에 선언된 모든 매개변수를 필수라고 가정 → 타입 안정성이 강화</li>
      <li>선택 매개변수 : 타입 애너테이션의 : 앞에 <code class="language-plaintext highlighter-rouge">?</code>를 추가하여, 매개변수가 선택적이란 것을 표시</li>
      <li>기본 매개변수 : 기본적으로 값을 제공되므로, 함수 내부에 암묵적으로 <code class="language-plaintext highlighter-rouge">| undefined union type</code>이 추가<br />→ 타입스크립트는 함수의 매개변수에 대해 인수를 누락하거나 <code class="language-plaintext highlighter-rouge">undefined</code> 인수를 사용한 호출을 허용</li>
      <li>나머지 매개변수 : 함수 선언의 마지막 매개 변수에 위치한 <code class="language-plaintext highlighter-rouge">...</code> 스프레드 연산자로 표현<br />→ 해당 매개변수에서 시작해 함수에 전달된 나머지 인수가 모두 단일 배열에 저장<br />(인수 배열을 나타내기 위해 끝에 <code class="language-plaintext highlighter-rouge">[]</code> 구문이 추가)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(a: number, b: number) {
   return a + b;
}

type ANY = any;
function addY (a: ANY, b: ANY) {
  return a + b;
}

function addZ (a: ANY, b?: ANY) {
  return a + (b ?? 0);
}

addX(1, 0); addY(1, 0); addZ(1, 0);
addZ(1); // addX(1); addY(1);

const getSum = (...rest:number[]) =&gt;{
 let sum = 0;
 rest.forEach((el) =&gt; sum += el);
 return console.log(sum);
}
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">?</code>으로 표시된 선택 매개변수가 아닌 필수 매개변수는 값이 명시적으로 <code class="language-plaintext highlighter-rouge">undefined</code>이라도 항상 제공되어야 한다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const introduce2 = (name:string, 

height : number|undefined ) =&gt; {
   console.log(`이름 : ${name}`);

if(typeof height === 'number'){
   	console.log(`키 : ${height + 10}`)   
 	}
}

introduce2("김군"); // Error : Expected 2 arguments, but got 1.
introduce2("김군", undefined);
introduce2("김군", 170);
</code></pre></div>  </div>
</blockquote>

<ul>
  <li>함수의 반환 타입 : 함수가 반환할 수 있는 가능한 모든 값을 이해하면 함수가 반환하는 타입을 알 수 있음
    <ul>
      <li>그러나, 함수에서 반환 타입을 명시적으로 선언하는 방식이 유용할 때가 종종 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function singSongRecursive(songs : string[], count = 0) : number {
    return songs.length ? singSongRecursive(songs.slice(1), count + 1) : count;
}

const singSongsRecursive = (songs : string[], count=0) : number =&gt;
 songs.length ? singSongsRecursive(songs.slice(1), 
count + 1) : count;
</code></pre></div></div>

<ul>
  <li>함수 매개변수 타입 : 함수를 가지기 위한 매개변수 또는 변수의 타입을 선언하는 방법
    <ul>
      <li>함수 타입 구문은 화살표 함수와 유사하지만 함수 본문 대신 타입이 존재</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let nothingGivesString : () =&gt; string;

let inputAndOutput : (songs: string[], count?: number) =&gt; number;
</code></pre></div></div>

<ul>
  <li>함수 타입 괄호 : 함수 타입은 다른 타입이 사용되는 모든 곳에 배치할 수 있음 (유니온 타입 포함)
    <ul>
      <li>유니언 타입의 애너테이션에서 함수 반환 위치를 나타내거나 타입을 감싸는 부분을 표시할 때 괄호 사용</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 타입은 string | undefined 유니언을 반환하는 함수
let returnsStringOrUndefined : () =&gt; string | undefined;

// 타입은 undefined나 string 을 반환하는 함수
let maybeReturnsString : (() =&gt; string) | undefined;
</code></pre></div></div>

<ul>
  <li>매개변수 타입 추론 : 선언된 타입의 위치에 제공된 함수의 매개변수 타입을 유추할 수 있음
    <ul>
      <li>또한, 함수를 매개변수로 갖는 함수에 인수로 전달된 함수는 해당 매개변수 타입도 유추할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let singer : (song : string) =&gt; string;

singer = function(song){
    // song : string의 타입
    return `Singing : ${song.toUpperCase()}!`; // OK
}

const songs = ["One More Time", "I AM", "Cry"];

// song : string
// index : number

songs.forEach((song, index) =&gt; {
    console.log(`${song} is at index ${index}`);
});
</code></pre></div></div>

<h3 id="함수-오버로딩-function-overloading--동일한-이름에-매개-변수만-다른-함수를-여러-개-만드는-것">함수 오버로딩 (<code class="language-plaintext highlighter-rouge">Function Overloading</code>) : 동일한 이름에 매개 변수만 다른 함수를 여러 개 만드는 것</h3>

<ul>
  <li>매개변수의 형태가 다양한 여러 케이스에 대응하는 같은 이름의 함수를 만드는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 서로 다른 버전의 함수들 -&gt; `오버로드 시그니처`
function func(a : number): void;
function func(a : number, b : number, c : number) : void;

// 실제 구현부 -&gt; `구현 시그니처`
function func(a:number, b?: number, c?:number) {
  if(typeof b === 'number' &amp;&amp; typeof c === 'number') {
    console.log(a + b + c);
  } else {
    console.log(a + b + c);
  }
}

func(1); func(1, 2, 3);
</code></pre></div></div>

<h2 id="인터페이스-interface--타입을-정의할-때-객체의-구조를-명시적으로-지정-가능">인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 타입을 정의할 때 객체의 구조를 명시적으로 지정 가능</h2>

<h3 id="호출-시그니처-call-signature--함수-호출-방법에-대한-타입-시스템을-설명">호출 시그니처 (<code class="language-plaintext highlighter-rouge">Call Signature</code>) : 함수 호출 방법에 대한 타입 시스템을 설명</h3>

<ul>
  <li>매개변수의 목록 (<code class="language-plaintext highlighter-rouge">with type</code>)과 반환 타입을 포함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type FunctionAlias = (input: string) =&gt; number;

interface CallSignature {
    (input: string): number;
}

const typedFunctionAlias: FunctionAlias = (input) =&gt; input.length;

const typedCallSignature: CallSignature = (input) =&gt; input.length;
</code></pre></div></div>

<blockquote>
  <p>호출 시그니처는 사용자 정의 속성을 추가로 갖는 함수를 설명하는 데에도 사용할 수 있다.</p>
</blockquote>

<h3 id="인덱스-시그니처-index-signature--임의의-키를-받고-해당-키에-대한-값의-타입을-지정">인덱스 시그니처 (<code class="language-plaintext highlighter-rouge">Index Signature</code>) : 임의의 키를 받고, 해당 키에 대한 값의 타입을 지정</h3>

<blockquote>
  <p>인덱스 시그니처를 사용하면, 프로퍼티의 존재 유무를 알 수 없다!</p>
</blockquote>

<h3 id="중첩-시그니처-nested-interface--속성의-타입이-다른-인터페이스나-객체-타입을-가질-수-있음">중첩 시그니처 (<code class="language-plaintext highlighter-rouge">Nested Interface</code>) : 속성의 타입이 다른 인터페이스나 객체 타입을 가질 수 있음</h3>

<h2 id="클래스-속성-class-attribute--클래스의-속성을-읽거나-쓰려면-명시적으로-선언해야-함">클래스 속성 (<code class="language-plaintext highlighter-rouge">Class Attribute</code>) : 클래스의 속성을 읽거나 쓰려면 명시적으로 선언해야 함</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class FieldTrip{
    destination  : string; // 불필요

    constructor(destination : string){
        this.destination = destination;
        console.log(`We're going to ${destination}!`);

    this.nonexistent = destination;
    //Error: Property 'nonexistent' does not exist on type 'FieldTrip'
    }
}
</code></pre></div></div>

<h3 id="클래스-메소드-class-method">클래스 메소드 (<code class="language-plaintext highlighter-rouge">Class Method</code>)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Greeted {
    constructor(message : string){
        console.log(`As I always say : ${message}!`);
    }
}
//Greeted 클래스의 생성자는 message:string으로 매개변수가 제공되어야 함
new Greeted("Practice makes perfect.");
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TS" /><summary type="html"><![CDATA[타입스크립트 (TypeScript) : JavaScript을 확장하여 정적 타입을 지원하는 프로그래밍 언어]]></summary></entry><entry><title type="html">[JS] 9. 비동기 처리 (Asynchronous Processing)</title><link href="http://localhost:4000/js9/" rel="alternate" type="text/html" title="[JS] 9. 비동기 처리 (Asynchronous Processing)" /><published>2024-02-05T00:00:00+09:00</published><updated>2024-02-05T00:00:00+09:00</updated><id>http://localhost:4000/js9</id><content type="html" xml:base="http://localhost:4000/js9/"><![CDATA[<h2 id="비동기-처리-asynchronous-processing--프로세스의-완료를-기다리지-않고-다른-작업을-진행">비동기 처리 (<code class="language-plaintext highlighter-rouge">Asynchronous Processing</code>) : 프로세스의 완료를 기다리지 않고 다른 작업을 진행</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a3f7aa41-e708-45b7-8397-068980fc6f3c" width="70%" /></p>

<ul>
  <li>싱글 쓰레드 (<code class="language-plaintext highlighter-rouge">Single Thread</code>) : 한번에 하나의 함수만 실행 → 동기 처리 (<code class="language-plaintext highlighter-rouge">Synchronous Processing</code>)과 동일
    <ul>
      <li>자바스크립트는 콜 스택이 하나 → 콜 스택에 쌓인 함수나 코드를 위에서 아래로 차례대로 실행</li>
    </ul>
  </li>
  <li>논블로킹 (<code class="language-plaintext highlighter-rouge">Non-Blocking</code>) : <code class="language-plaintext highlighter-rouge">I/O</code>를 수행하는 비동기 함수는 백그라운드에 넘김</li>
  <li>멀티 프로세스 (<code class="language-plaintext highlighter-rouge">Multi Processes</code>) : 백그라운드는 <code class="language-plaintext highlighter-rouge">OS</code> 프로세스에 의존</li>
</ul>

<blockquote>
  <p>비동기 처리의 순서?</p>

  <ol>
    <li>런타임 (<code class="language-plaintext highlighter-rouge">Runtime</code>) → 실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) → 콜 스택 (<code class="language-plaintext highlighter-rouge">CallStack</code>)</li>
    <li>백그라운드 (<code class="language-plaintext highlighter-rouge">Background</code>) → 운영체제 (<code class="language-plaintext highlighter-rouge">OS</code>)</li>
    <li>테스크 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>) → 콜 스택 (<code class="language-plaintext highlighter-rouge">Call Stack</code>)</li>
  </ol>
</blockquote>

<h3 id="자바스크립트-런타임-javascript-runtime--자바스크립트가-실행되는-환경">자바스크립트 런타임 (<code class="language-plaintext highlighter-rouge">JavaScript Runtime</code>) : 자바스크립트가 실행되는 환경</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c9726e-4743-4b62-aa15-5a5cde2cdef9" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Web API</code> : 브라우저에서 제공하는 <code class="language-plaintext highlighter-rouge">API</code> (<code class="language-plaintext highlighter-rouge">setTimeout</code>, <code class="language-plaintext highlighter-rouge">HTTP</code> 요청 메소드, <code class="language-plaintext highlighter-rouge">DOM</code> 이벤트)</li>
  <li>테스트 큐 (<code class="language-plaintext highlighter-rouge">Task Queue</code>) : 이벤트가 발생한 뒤에 호출되어야 할 콜백 함수들이 대기하는 공간</li>
  <li>이벤트 루프 (<code class="language-plaintext highlighter-rouge">Event Loop</code>) : 이벤트 발생 시 콜백 함수들을 관리, 호출된 콜백 함수의 실행 순서 결정</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1ebeb0a1-a9fc-4234-ab64-f4b720b9cc43" width="80%" /></p>

<h3 id="비동기-콜백-패턴-asynchronous-callback-pattern--비동기-작업의-완료를-다루는-전통적인-방식">비동기 콜백 패턴 (<code class="language-plaintext highlighter-rouge">Asynchronous Callback Pattern</code>) : 비동기 작업의 완료를 다루는 전통적인 방식</h3>

<ul>
  <li>현재 실행되고 있는 함수가 끝난 뒤에 실행되는 콜백 함수를 통해 실행 순서를 지정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(function() {
  console.log('task1', new Date());
  setTimeout(function() {
    console.log('task2', new Date());
    setTimeout(function() {
      console.log('task3', new Date());
      console.log('END&gt;&gt;', new Date());
    }, 1000 );
  }, 2000);
}, 3000);
console.log('START', new Date());
</code></pre></div></div>

<blockquote>
  <p>콜백 함수를 여러 개 중첩하면, 코드의 가독성이 떨어지는 콜백 지옥 (<code class="language-plaintext highlighter-rouge">Callback Hell</code>)이 발생!</p>
</blockquote>

<h2 id="프로미스-promise--비동기-작업의-성공-및-실패에-대한-완료-결과를-처리하는-객체">프로미스 (<code class="language-plaintext highlighter-rouge">Promise</code>) : 비동기 작업의 성공 및 실패에 대한 완료 결과를 처리하는 객체</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/6acaa363-7157-4636-9f62-1da04e7a6a9c" width="90%" /></p>

<ul>
  <li>콜백 지옥을 피하고 비동기 처리를 쉽게 처리할 수 있도록 <code class="language-plaintext highlighter-rouge">ES6</code>부터 <code class="language-plaintext highlighter-rouge">then</code> 도입</li>
  <li>프로미스를 호출하면 프로미스 인스턴스 (<code class="language-plaintext highlighter-rouge">Promise Instance</code>)를 반환한 후 <code class="language-plaintext highlighter-rouge">Resolve</code> &amp; <code class="language-plaintext highlighter-rouge">Reject</code></li>
</ul>

<blockquote>
  <p>프로미스의 3가지 상태 (<code class="language-plaintext highlighter-rouge">Status</code>)</p>

  <ul>
    <li>대기 (<code class="language-plaintext highlighter-rouge">Pending</code>) : 비동기 처리 로직이 미완료된 초기 상태, 성공 또는 실패할 때까지 대기</li>
    <li>이행 (<code class="language-plaintext highlighter-rouge">Fulfilled</code> ): 비동기 처리가 완료되어, 프로미스가 결과 값을 반환한 상태</li>
    <li>거부 (<code class="language-plaintext highlighter-rouge">Rejected</code>) : 비동기 처리가 실패하거나 오류가 발생한 상태</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        const now = Date.now();
        
        if (now % 2 === 0) {
            resolve(console.log('[Fulfilled]'), now);    
        } else reject('Rejected');
    }, 1000);

    setTimeout(() =&gt; {
        reject(new Error('[TimeExceeded]'),);
    }, 1001);
});

promise.then(
    success =&gt; console.log('[Resolved]'),
    fail =&gt; console.log('[Rejected]')
)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로미스를 클래스로 표현한다면?
class Promise {
  constructor(callback) {
    console.log('[Promise 생성자]')
    callback (this.resolve.bind(this), this.reject.bind(this));
}

  then(resolve) {
    console.log('[then 메소드 실행]')
    this.success = callback;
  }

  catch(x) {
    console.log('[catch 메소드 실행]')
    this.failure = callback;
  }

  success(x) {
    console.log('[success 메소드 실행] ' + x)
  }

  failure(x) {
    console.log('[failure 메소드 실행] ' + x)
  }

  resolve(x) { 
    console.log('[resolve 메소드 실행]')
    return this.success(x);
  }

  reject(x) {
    console.log('[reject 메소드 실행]')
    return this.failure(x);
  }

  callback(resolve, reject) {
    console.log('[callback 메소드 실행]')
  }
};

let promise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            const now = Date.now();
            console.log('이행 :', now)

            if (now % 2 === 0)
                resolve(now)
            else
                reject(new Error("실패"))

            console.log("[setTimeout 메소드 실행]")
        }, 1000)
    }
);
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/71628456-0e58-4bbb-b1f7-45cff3e5b96a" width="90%" /></p>

<h3 id="프로미스-클래스-메소드-promise-class-method--프로미스에서-비동기-작업을-다루기-위해-제공">프로미스 클래스 메소드 (<code class="language-plaintext highlighter-rouge">Promise Class Method</code>) : 프로미스에서 비동기 작업을 다루기 위해 제공</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Promise.resolve</code> : 주어진 값을 성공 상태의 프로미스로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.resolve(x).then(val =&gt; console.log(val));</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.reject</code> : 주어진 값을 실패 상태의 프로미스로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.reject(new Error('...')).catch(console.error);</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.all</code> : 여러 프로미스가 모두 성공 시 <b>시간과 무관하게 순서를 보장하여</b> 프로미스들을 모두 반환, 하나라도 실패하면 첫번째로 실패한 프로미스 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.all(iterables).then().catch(...)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.race</code> : 여러 프로미스 중에서 가장 빠른 것을 반환, 하나라도 실패하면 첫번째로 실패한 프로미스 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.race(iterables).then().catch(...)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Promise.any</code> : 여러 프로미스 중에서 제일 빨리 성공한 것을 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Promise.any(iterables).then().catch(...)</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Node.js</code> 모듈의 <code class="language-plaintext highlighter-rouge">util.promisify</code> : 콜백 함수 기반의 비동기 함수를 프로미스 기반으로 변환</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function promisify(fn) {
  return new Promise( (resolve, reject) =&gt; {
    try {
      const ret = fn();
      resolve(ret);
    } catch(err) {
      reject(err);
    }
  })
}

const exec = util.promisify(execute);
exec.then(...).catch(...)
</code></pre></div>  </div>
</blockquote>

<h2 id="async-await--프로미스를-생성하고-소비하기-위한-문법적-설탕"><code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> : 프로미스를 생성하고 소비하기 위한 문법적 설탕</h2>

<blockquote>
  <p>문법적 설탕 (<code class="language-plaintext highlighter-rouge">Syntax Sugar</code>) : 문법적 기능은 그대로인데, 사람이 직관적으로 읽을 수 있게끔 만드는 것</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4297057d-9df5-4864-aaf9-1fa77598e056" width="40%" /></p>

<ul>
  <li>비동기 함수에서 콜백을 사용하는 대신에, 단순한 논리적 흐름을 작성
    <ul>
      <li>프로미스의 <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">catch</code>, <code class="language-plaintext highlighter-rouge">finally</code>를 사용할 필요 없음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">async</code>는 프로미스를 반환하고, <code class="language-plaintext highlighter-rouge">await</code>는 <code class="language-plaintext highlighter-rouge">resolve</code> 및 <code class="language-plaintext highlighter-rouge">reject</code>와 매핑
    <ul>
      <li>성공 : <code class="language-plaintext highlighter-rouge">return</code> → <code class="language-plaintext highlighter-rouge">resolve</code> → <code class="language-plaintext highlighter-rouge">result</code></li>
      <li>실패 : <code class="language-plaintext highlighter-rouge">error</code> → <code class="language-plaintext highlighter-rouge">reject</code> → <code class="language-plaintext highlighter-rouge">throw</code></li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// const fn = async() =&gt; {...}
async function fn() {   // Promise 반환
  ...
  result = await fetch(url);  // fetch.then().catch()
}
console.log(await fn());
</code></pre></div></div>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Promise</code> &amp; <code class="language-plaintext highlighter-rouge">then</code> : 각각이 별도의 쓰레드로 실행되므로 <b>병렬</b></li>
    <li><code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> : 단일 쓰레드를 차례로 실행하므로 <b>직렬</b></li>
  </ul>

  <p>→ 연관이 없는 비동기 함수 실행에 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code>을 남발하지 말자!</p>

</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// promise, async, await을 활용하여 페치한 뒤에 2초간 sleep 구현
const f = async () =&gt; {
  const res = await fetch("https://jsonplaceholder.typicode.com/users/1");  
  if (!res.ok) throw new Error("Fail to Fetch!!");
  console.log(Date.now())
  await new Promise((resolve) =&gt; {setTimeout(resolve, 2000)});
  const data = await res.json();
  return data.name;
};

console.log(await f());
console.log(Date.now())
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// promise, async, await을 활용하여 1초 간격으로 3번 출력하는 depthTimer 구현
let depthTimer = async (str) =&gt; {
  console.log(str, new Date());
  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));
};
  
(async function () {
  await depthTimer('START!');
  await depthTimer('depth1');
  await depthTimer('depth2');
  await depthTimer('depth3');
  console.log('Already 3-depth!!');
})();
</code></pre></div></div>

<h3 id="for-await-of--비동기적으로-이터레이터-iterator를-반복하는-문법"><code class="language-plaintext highlighter-rouge">for-await-of</code> : 비동기적으로 이터레이터 (<code class="language-plaintext highlighter-rouge">Iterator</code>)를 반복하는 문법</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async</code> 함수에서 비동기적으로 값을 가져와 처리할 때 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const afterTime = sec =&gt; new Promise(
    resolve =&gt; setTimeout(resolve, sec * 1000, sec
  ));
  console.time('for-await-of ');
  const arr = [afterTime(1), afterTime(2)];
  
  for (const fo of arr.values()) {
    console.log('fo =', fo);
  }
  
  for await (const fao of arr.values()) {
    console.log('fao =', fao);
  }
  
  console.timeEnd('for-await-of ');

// &gt; fo = Promise { &lt;pending&gt; }
// &gt; fo = Promise { &lt;pending&gt; }
// &gt; fao = 1
// &gt; fao = 2
// &gt; for-await-of : 2.003s
</code></pre></div></div>
<hr />]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[비동기 처리 (Asynchronous Processing) : 프로세스의 완료를 기다리지 않고 다른 작업을 진행]]></summary></entry><entry><title type="html">자바스크립트 프록시 (2024.02.04)</title><link href="http://localhost:4000/digital_hanaro_6/" rel="alternate" type="text/html" title="자바스크립트 프록시 (2024.02.04)" /><published>2024-02-04T00:00:00+09:00</published><updated>2024-02-05T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_6</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_6/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 6일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부한-이유">공부한 이유</h2>

<p>프록시 (<code class="language-plaintext highlighter-rouge">Proxy</code>)를 번역하면 어떤 일을 대신 수행하는 대리자, 대변인의 의미를 갖고 있다. 디자인패턴에서도 어떤 객체를 사용하고자 할 때, 객체를 직접 참조하는 것이 아니라 해댱 객체를 대행할 수 있는 프록시 객체를 통해 대상하고자 하는 객체에 접근하는 방식을 프록시 패턴 (<code class="language-plaintext highlighter-rouge">Proxy Pattern</code>)이라고 부른다. 자바스크립트에서도 프록시 객체가 있다는 것을 이번 수업을 통해 알게 되어 이에 대해 정리하고자 하였다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9a0c5c88-3e49-43f9-a2e1-55ae60429d27" width="60%" /></p>

<ul>
  <li>프록시 객체 (<code class="language-plaintext highlighter-rouge">Proxy Object</code>) : 원본 객체의 어떤 작업을 가로채 대신 처리하는 객체
    <ul>
      <li>타겟 (<code class="language-plaintext highlighter-rouge">target</code>) : 프록시 객체가 감쌀 (<code class="language-plaintext highlighter-rouge">wrapping</code>) 원본 객체</li>
      <li>핸들러 (<code class="language-plaintext highlighter-rouge">handler</code>) : 동작을 가로채는 ‘트랩 (<code class="language-plaintext highlighter-rouge">trap</code>)’이 담겨 타겟의 동작을 제어하는 메소드를 정의한 객체</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let target = {};
let proxy = new Proxy(target, handler)

proxy.test = 5;
alert(proxy.test); // 5
</code></pre></div></div>

<blockquote>
  <p>특정 객체를 감싸 해당 객체에 작업이 가해지고, 핸들러에 상응하는 트랩이 있다면 중간에서 작업을 트랩</p>
</blockquote>

<ul>
  <li>프록시는 일반 객체와 달리 프로퍼티가 없는 ‘특수 객체’
    <ul>
      <li>핸들러가 비어 있으면 프록시에 가해지는 작업은 원본 객체인 타겟으로 바로 전달</li>
    </ul>
  </li>
  <li>프록시의 트랩은 원본 객체에 수행하는 동작을 수행하는 내부 메소드의 호출을 가로챔</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4c6317c5-a2b0-4643-994f-ba45f073239b" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let numbers = [0, 1, 2];

numbers = new Proxy(numbers, {
  get(target, prop) {
    if (prop in target) return target[prop];
    return 0;
  }
});

alert( numbers[1] ); // 1
alert( numbers[123] ); // 0
</code></pre></div></div>

<blockquote>
  <p>프록시가 <code class="language-plaintext highlighter-rouge">Reflect</code>와 다른 점?</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Reflect</code>는 타겟 객체의 상태를 <code class="language-plaintext highlighter-rouge">Boolean</code>으로 반환하는 여러 메소드를 가진 자바스크립트 기본 객체
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Reflect</code>의 메소드가 프록시와 연동하여, <code class="language-plaintext highlighter-rouge">Reflect</code>의 메소드를 통해 검증하는 값을 프록시에도 핸들러에 할당해 처리 가능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#1</code>. 프록시는 비싼 함수 호출을 캐싱 (<code class="language-plaintext highlighter-rouge">Caching</code>)할 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function calculateCost(price, taxRate) {
  console.log('계산 : ');
  return price * (1 + taxRate);
}

const cache = new Map();

const proxy = new Proxy(calculateCost, {
  apply(target, thisArg, args) {
    const key = args.join('-');
    if (cache.has(key)) {
      console.log('캐시된 결과 반환 : ');
      return cache.get(key);
    } else {
      const result = Reflect.apply(target, thisArg, args);
      cache.set(key, result);
      return result;
    }
  },
});

console.log(proxy(10, 0.2)); // 계산 : 12
console.log(proxy(10, 0.2)); // 캐시된 결과 반환 : 12
console.log(proxy(20, 0.2)); // 계산 : 24
console.log(proxy(20, 0.3)); // 계산 : 26
console.log(proxy(20, 0.3)); // 캐시된 결과 반환 : 26
</code></pre></div></div>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#2</code>. 프록시는 데이터 검증에 활용하는 유효성 검사기 (<code class="language-plaintext highlighter-rouge">Validator</code>)로 활용될 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = {
  name: 'John',
  password: '',
};

const proxy = new Proxy(user, {
  set(target, prop, value) {
    if (prop === 'password' &amp;&amp; value.length &lt; 8) {
      throw new Error('Password must be at least 8 characters long');
    }
    target[prop] = value;
    return true;
  },
});

console.log(proxy.name); // John
console.log(proxy.password); // 

proxy.password = '12345678';
console.log(proxy.password); // 12345678

proxy.password = '123'; // 'Password must be at least 8 characters long' 에러 반환
</code></pre></div></div>

<ul>
  <li>프록시 응용 <code class="language-plaintext highlighter-rouge">#3</code>. 프록시는 데이터 변화를 감지하는 로거 (<code class="language-plaintext highlighter-rouge">logger</code>)로 활용될 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const user = {
  name: 'John',
  email: 'john@example.com',
};

const proxy = new Proxy(user, {
  get(target, prop) {
    console.log(`Getting ${prop} property`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} property to ${value}`);
    target[prop] = value;
    return true;
  },
});

console.log(proxy.name); // Getting name property -&gt; John
proxy.email = 'bob@example.com'; // Setting email property to bob@example.com
console.log(proxy.email); // Getting email property -&gt; bob@example.com
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 6일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[vocawik] 2. vocawik 프로젝트 설계</title><link href="http://localhost:4000/vocawik2/" rel="alternate" type="text/html" title="[vocawik] 2. vocawik 프로젝트 설계" /><published>2024-02-03T00:00:00+09:00</published><updated>2024-02-03T00:00:00+09:00</updated><id>http://localhost:4000/vocawik2</id><content type="html" xml:base="http://localhost:4000/vocawik2/"><![CDATA[<h2 id="프로젝트-목표-project-goal--프로젝트-진행-과정에서-이루고자-하는-사항들을-정리">프로젝트 목표 (<code class="language-plaintext highlighter-rouge">Project Goal</code>) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">목표</td>
        <td nowrap="">설명</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">도메인 정의<br />(<code>Domain Definition</code>)</td>
        <td><ul>
          <li>사이트에서 제공하고자 하는 기능 및 책임들이 도메인별로 명확히 분리되어야 한다.</li>
        </ul></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="아키텍처-구조도-architecture-structure--사이트의-아키텍처를-설계">아키텍처 구조도 (<code class="language-plaintext highlighter-rouge">Architecture Structure</code>) : 사이트의 아키텍처를 설계</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<h2 id="유저-프로필-user-profile--사이트의-이용자들을-정의하여-분류">유저 프로필 (<code class="language-plaintext highlighter-rouge">User Profile</code>) : 사이트의 이용자들을 정의하여 분류</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="">관리자<br />(<code>Manager; MA</code>)</td>
        <td>사이트 및 사이트 내부 기능들의 기획, 설계, 개발, 운영, 관리를 담당하는 사람들을 총칭한다.</td>
      </tr>
      <tr>
        <td nowrap="">회원<br />(<code>Member; ME</code>)</td>
        <td>사이트 이용자들 중에 회원 데이터베이스에 등록된 사람들을 총칭한다.</td>
      </tr>
      <tr>
        <td nowrap="">비회원<br />(<code>NonMember; NE</code>)</td>
        <td>사이트 이용자들 중에 회원 데이터베이스에 등록되지 않은 사람들을 총칭한다.</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="기능-명세서-functional-specification--사이트에서-구현할-기능들을-정리">기능 명세서 (<code class="language-plaintext highlighter-rouge">Functional Specification</code>) : 사이트에서 구현할 기능들을 정리</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="">분류</td>
        <td nowrap="">ID</td>
        <td nowrap="">이름</td>
        <td nowrap="">설명</td>
        <td nowrap="">상태</td>
        <td nowrap="">우선<br />순위</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="32">회원<br />(<code>Member</code>)</td>
        <td nowrap=""><code>ME-001</code></td>
        <td nowrap="">회원 <code>ID</code> 로그인<br />(<code>MemberIdLogin</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '아이디' 또는 '이메일'과 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 때, '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되면 '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-002</code></td>
        <td nowrap="">회원 <code>OAuth</code> 로그인<br />(<code>MemberOAuthLogin</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 로그인 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-003</code></td>
        <td nowrap="">회원 <code>OTP</code> 로그인<br />(<code>MemberLoginCertifyByOTP</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (<code>OTP</code>) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행할 경우에 (즉 로그인이 정상적으로 수행되었다면), '일회용 비밀번호'를 확인할 수 있는 '<code>OTP</code> 키'를 발급하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-004</code></td>
        <td nowrap="">회원 로그인 이메일 인증<br />(<code>MemberLoginCertifyByEmail</code>)</td>
        <td>'회원'인 상태에서 '2단계 로그인 (이메일 인증) 옵션'을 활성화시켰다면, '비회원'이 '유효성 검사' 및 회원에 대한 '인증'이 정상적으로 수행되는 경우에 (즉 로그인이 정상적으로 수행되었다면), '일회용 비밀번호'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고, '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '일회용 비밀번호'과 일치하면, '회원'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-005</code></td>
        <td nowrap="">회원 자동 로그인 방지<br />(<code>MemberLoginCAPTCHA</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 5회 이상 '로그인'에 실패할 경우, <code>google reCAPTCHA</code>를 통해 보안 문자를 입력한 다음에 로그인을 시도할 수 있도록 한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-006</code></td>
        <td nowrap="">회원 로그인 유지<br />(<code>MemberCreateRememberMe</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '로그인 유지 옵션'을 활성화한 상태로 로그인을 성공하였을 때, '회원'이 브라우저를 끄고 다시 접속하더라도 로그인 상태를 2주간 유지한다.</td>
        <td nowrap="">비회원<br />↓<br />회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-007</code></td>
        <td nowrap="">회원 비밀번호 재설정 이메일 인증<br />(<code>MemberResetPasswordCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '비밀번호 재설정' 버튼을 누르면, '비밀번호 재설정 아이디/이메일 입력 화면'으로 이동한다. 입력받은 값과 일치하는 회원 정보가 존재한다면, '임시 비밀번호'를 생성하여 30분간 유효한 '임시 비밀번호'를 포함한 '비밀번호 재설정 이메일'을 생성 및 전송한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-008</code></td>
        <td nowrap="">회원 비밀번호 재설정<br />(<code>MemberResetPassword</code>)</td>
        <td>'비회원'이 '회원 로그인 화면'에서 '로그인'을 시도할 때 '비밀번호 재설정'에서 생성된 '임시 비밀번호'를 입력받았거나, '회원'이 '회원정보 갱신 화면'에서 '비밀번호 재설정' 버튼을 누른 경우, '비밀번호 재설정' 화면으로 이동한다. 입력받은 '비밀번호' 및 '비밀번호 확인'이 이전에 사용된 적이 있는 '중복된 비밀번호'가 아니면서 유효성 검사가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였다면, 입력한 값을 포함하여 회원 정보를 갱신한다. 그리고 이전에 이루어진 '회원 로그인 유지'를 모두 해제한 다음에 '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-009</code></td>
        <td nowrap="">회원 로그아웃<br />(<code>MemberLogout</code>)</td>
        <td>'회원'이 어떤 화면에서 '로그아웃 버튼'을 누르면, (만약 '회원 로그인 유지'가 이루어지고 있다면 이를 해제한 다음에) '회원'에 대한 인가를 비활성화하고 '홈 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-010</code></td>
        <td nowrap="">회원가입<br />(<code>MemberRegister</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 바탕으로 서버 내 데이터베이스에 '회원'을 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-011</code></td>
        <td nowrap=""><code>OAuth</code> 회원가입<br />(<code>MemberOAuthRegister</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 회원가입 버튼'을 눌렀을 때, 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원가입 화면'으로 이동한다. '회원가입' 화면에서 '회원가입' 버튼을 눌렀을 때, 필수 정보 ('아이디', '비밀번호', '비밀번호 확인', '이메일' 등)이 입력되어 '유효성 검사'가 정상적으로 이루어지고, <code>google reCAPTCHA</code>를 통과하였으며, '이메일 인증'이 정상적으로 수행되었다면, 입력한 값들을 포함한 '회원 정보'를 바탕으로 데이터베이스에 '회원'을 생성한 다음 '홈 화면'으로 이동한다.</td>
        <td nowrap="">비회원<br />↓<br />비회원 (인증)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-012</code></td>
        <td nowrap="">회원가입 이메일 인증<br />(<code>MemberRegisterCertifyByEmail</code>)</td>
        <td>'비회원'이 '회원가입 화면'에서 '이메일'을 입력하고 '이메일 인증 버튼'을 눌렀을 때, '유효성 검사'가 정상적으로 이루어진다면, '인증 문자열'를 확인할 수 있는 '인증 이메일'을 생성 및 전송하고 '인증 화면'을 제공한다. 만약 '인증 화면'에서 입력받은 값이 '인증 문자열'과 일치한다면, 인증에 성공하였다는 것을 알린다.</td>
        <td nowrap="">비회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-013</code></td>
        <td nowrap="">회원 개인정보 조회<br />(<code>MemberReadMyInfo</code>)</td>
        <td>'회원'이 어떤 화면에 존재하는 '회원 개인정보 조회' 버튼을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '비밀번호 확인 화면'으로 이동한다. 입력한 값이 해당 회원의 '비밀번호'와 일치하고 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '개인정보 조회 화면'을 제공한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-014</code></td>
        <td nowrap="">회원 개인정보 갱신<br />(<code>MemberUpdateMyInfo</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인정보를 수정하고 '개인정보 갱신 버튼'을 눌렀을 때, 각각의 '개인정보'에 대한 유효성 검사가 정상적으로 이루어지고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원'의 '개인정보'에 해당하는 값들을 데이터베이스에 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-015</code></td>
        <td nowrap="">회원 개인정보 갱신 이메일 인증<br />(<code>MemberUpdateMyInfoCertifyByEmail</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인정보 중에 '이메일'을 수정하고 '이메일 인증' 버튼을 눌렀을 때, '이메일'에 대한 유효성 검사가 정상적으로 이루어지고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '인증 주소'를 생성하여 30분간 유효한 '인증 주소'를 포함한 '인증 이메일'을 생성 및 전송한다. 만약 해당 '인증 주소'을 열람한다면, 인증이 성공하였다는 것을 알린다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-016</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동<br />(<code>MemberUpdateMyOAuth</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인 정보 중에 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 연동 버튼'을 눌렀을 때 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 외부 사이트에서 '인증'을 진행하도록 한다. 해당 외부 사이트에서 '인증'이 정상적으로 수행됨을 알린다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '<code>OAuth</code>'에 대한 정보를 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-017</code></td>
        <td nowrap="">회원 <code>OAuth</code> 연동 해제<br />(<code>MemberDeleteMyOAuth</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 개인 정보 중에 '특정 외부 사이트 (<code>Google</code>, <code>Kakao</code>, <code>Naver</code>, <code>Apple</code>, <code>X</code>)로 연동 해제 버튼'을 눌렀을 때 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '<code>OAuth</code>'에 대한 정보를 삭제한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-018</code></td>
        <td nowrap="">회원 탈퇴 (회원 개인정보 삭제)<br />(<code>MemberDeleteMyAccount</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 탈퇴 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '비밀번호 재확인 화면'을 제공한다. 입력한 값이 해당 회원의 '비밀번호'와 일치하고 '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원 탈퇴 안내 화면'을 제공한다. 만약 '회원 탈퇴 안내 화면'에서 '회원 탈퇴 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 해당하는 '개인정보'를 삭제한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-019</code></td>
        <td nowrap="">회원 로그인 기록 조회<br />(<code>MemberReadLoginHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '로그인 기록 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '로그인 기록' ('로그인 일시', '로그인 <code>IP</code>', '로그인 국가', '로그인 기기')을 제공하는 '로그인 기록 화면'으로 이동한다. (이때 '로그인 기록'은 최근 3개월까지의 기록을 한정해 제공하며, 최대 1,000건까지 한정해 제공한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-020</code></td>
        <td nowrap="">회원 비밀번호 재설정 기록 조회<br />(<code>MemberReadResetPasswordHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '비밀번호 재설정 기록 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 '비밀번호 재설정 기록' ('비밀번호 재설정 일시', '비밀번호 재설정 <code>IP</code>', '비밀번호 재설정 국가')을 제공하는 '비밀번호 재설정 기록 화면'으로 이동한다. (이때 '비밀번호 재설정 기록'은 최근 6개월까지의 기록을 한정해 제공하며, 최대 1,000건까지 한정해 제공한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-021</code></td>
        <td nowrap="">회원 중복 로그인 설정<br />(<code>MemberSetDuplicateLogin</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 중복 로그인 설정 옵션'을 비활성화할 때, 팝업 창을 통해 비활성화가 이루어질 때 수행될 작업에 대해 안내한다. 만약 팝업 창에 참인 값이 반환되었다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원이 로그인을 유지하고 있는 기기가 모두 해제되고, 회원이 앞으로 로그인 유지를 활성화한 상태로 로그인을 시도하더라도 로그인 유지가 이루어지지 않는다. '회원 중복 로그인 설정 옵션'을 활성화하면, 활성화가 이루어질 때 수행될 작업에 대해 안내한다. 만약 팝업 창에 참인 값이 반환되었다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원이 앞으로 로그인 유지를 활성화한 상태로 로그인을 시도한다면 로그인 유지가 이루어진다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-022</code></td>
        <td nowrap="">회원 로그인 유지 기기 조회<br />(<code>MemberReadRememberMeHistory</code>)</td>
        <td>'회원'이 해당 회원에 대한 '개인정보 조회 화면'에서 '회원 로그인 유지 기기 조회 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 '회원 로그인 유지 기기 기록' ('운영체제', '브라우저', '로그인 <code>IP</code>', '최근 접속 일시', '최초 로그인 일시')를 제공하는 '로그인 유지 기기 화면'으로 이동한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-023</code></td>
        <td nowrap="">회원 로그인 유지 기기 해제<br />(<code>MemberDeleteRememberMe</code>)</td>
        <td>'회원'이 '로그인 유지 기기 화면'에서 특정 기기에 대한 '로그아웃 버튼'을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 특정 기기에 대한 로그인 유지 기록을 삭제한다. (이때, 현재 접속 중인 기기는 삭제할 수 없도록 한다.)</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-024</code></td>
        <td nowrap="">회원 프로필 조회<br />(<code>MemberReadMyProfile</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '프로필'을 조회해야 할 때, 해당 '회원'에 대한 프로필 정보를 제공하는 '프로필 화면'을 제공한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-025</code></td>
        <td nowrap="">회원 프로필 갱신<br />(<code>MemberUpdateMyProfile</code>)</td>
        <td>'회원'이 해당 회원에 대한 '프로필 화면'에서 '프로필 갱신' 버튼을 눌렀을 때, 해당 '회원'에 대한 인가가 정상적으로 수행될 경우에 프로필 정보를 갱신할 수 있는 '프로필 갱신 화면'을 제공한다. 만약 '프로필 갱신 화면'에서 '프로필 갱신 버튼'을 누른다면 '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 프로필 정보를 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-026</code></td>
        <td nowrap="">회원 인터페이스 설정 조회<br />(<code>MemberReadMyInterface</code>)</td>
        <td>'회원'이 어떤 화면에 존재하는 특정 회원에 대한 '인터페이스 설정 조회' 버튼을 눌렀을 때, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 '회원'에 대한 인터페이스 정보를 제공하는 '인터페이스 설정 화면'을 제공한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-027</code></td>
        <td nowrap="">회원 인터페이스 설정 갱신<br />(<code>MemberUpdateMyInterface</code>)</td>
        <td>'회원'이 '인터페이스 설정 화면'에 존재하는 특정 정보를 갱신한다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 이를 반영한 화면을 즉각적으로 표현한다. 만약 '인터페이스 화면'에 존재하는 '인터페이스 설정 저장 버튼'을 누른다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 해당 회원에 대한 인터페이스 설정 정보를 갱신한다. 또한 '인터페이스 화면'에 존재하는 '인터페이스 설정 초기화' 버튼을 누르거나 '인터페이스 설정 저장 버튼'을 누르지 않고 다른 화면을 이동한다면, 기존 값을 반영한 화면을 표현한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-028</code></td>
        <td nowrap="">회원 상태 조회<br />(<code>MemberReadMyStatus</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '상태'를 조회해야 할 때, 해당 '회원'에 대한 상태 정보를 제공하는 '상태 화면'을 제공한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-029</code></td>
        <td nowrap="">회원 상태 갱신<br />(<code>MemberUpdateMyStatus</code>)</td>
        <td>특정 '회원'이 사이트 내에서 어떤 작업을 실행할 때, 해당 '회원'에 대한 상태 정보가 '오프라인'이라면, 이를 '오프라인'에서 '온라인'으로 갱신한다. 만약 '회원'이 어떤 화면에서 '방해 금지 활성화 버튼'을 눌렀다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원의 상태 정보를 '방해 금지'으로 갱신한다. ('방해 금지'가 활성화된 상태에서는 중요한 알림을 제외한 모든 알림들을 전달받지 않늗다.) 만약 '회원'이 어떤 화면에서 '방해 금지 비활성화 버튼'을 눌렀다면, '회원'에 대한 인가가 정상적으로 수행될 경우에 회원의 상태 정보를 '온라인'으로 갱신한다. 만약 로그인 유지 기기가 하나일 때 로그아웃을 실행하거나 1시간 이상 사이트 내에서 작업이 이루어지지 않는다면, 해당 '회원'에 대한 상태 정보가 '온라인'에서 '오프라인'으로 갱신한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-030</code></td>
        <td nowrap="">회원 권한 조회<br />(<code>MemberReadAuth</code>)</td>
        <td>'회원'이 어떤 화면으로 이동할 때, 특정 작업에 대한 '권한'을 갖고 있다면 '회원'에 대한 인가가 정상적으로 수행될 경우에 특정 작업의 실행을 위해 이를 다른 도메인 서비스에 요청할 수 있는 '권한 버튼'을 표시한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-031</code></td>
        <td nowrap="">회원 권한 요청<br />(<code>MemberPublishAuth</code>)</td>
        <td>'회원'이 어떤 화면에서 특정 작업에 대한 '권한 버튼'을 눌렀을 때, 특정 작업의 실행을 위해 이를 다른 도메인 서비스에 요청하여 요청에 대한 응답을 반환한다.</td>
        <td nowrap="">회원</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>ME-032</code></td>
        <td nowrap="">회원 권한 기록 조회<br />(<code>MemberReadAuthHistory</code>)</td>
        <td>어떤 화면에서 특정 회원에 대한 '권한 기록 버튼'을 눌렀을 때, 해당 회원이 다른 도메인에 권한을 요청하여 응답받은 '권한 기록' ('권한 요청 일시', '권한 응답 일시', '권한 이름', '권한 내용', '권한 응답 결과', '권한 요청자', '권한 실행자')를 제공하는 '권한 기록 화면'으로 이동한다.</td>
        <td nowrap="">-</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="7">관리자<br />(<code>Manager</code>)</td>
        <td nowrap=""><code>MA-001</code></td>
        <td nowrap="">관리자 보안 로그인<br />(<code>ManagerSecureLogin</code>)</td>
        <td>지정된 <code>IP</code>에서 접속한 '비회원'이 '관리자 로그인 화면'에서 '아이디'와 '비밀번호'를 입력하고 '로그인 버튼'을 눌렀을 대, '유효성 검사' 및 관리자에 대한 '인증'이 정상적으로 수행되면 '관리자'에 대한 '인가'를 수행한다.</td>
        <td nowrap="">비회원 (보안)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-002</code></td>
        <td nowrap="">관리자 보안 로그아웃<br />(<code>ManagerSecureLogout</code>)</td>
        <td>'관리자'가 어떤 화면에서 '로그아웃 버튼'을 누를 때, 관리자에 대한 '인증'이 정상적으로 수행되면 '관리자'에 대한 '인가'를 비활성화하고 '관리자 로그인 화면'으로 이동한다.</td>
        <td nowrap="">관리자</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-003</code></td>
        <td nowrap="">관리자 과도한 로그인 시도 제한<br />(<code>ManagerLimitExcessiveLogin</code>)</td>
        <td>지정된 <code>IP</code>에서 접속한 '비회원'이 '관리자 로그인 화면'에서 5회 이상 '로그인'에 실패할 경우에 해당 <code>IP</code>에서 접속하는 것을 30분간 금지한다.</td>
        <td nowrap="">비회원 (보안)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-004</code></td>
        <td nowrap="">관리자 회원 권한 갱신<br />(<code>ManagerUpdateAuthOnUser</code>)</td>
        <td>'관리자'가 '관리자 콘솔 화면'에서 '회원 권한 갱신 버튼'을 누르면, 관리자에 대한 '인증'이 정상적으로 수행되면 회원 <code>ID</code>를 검색할 수 있는 '(관리자) 회원 검색 화면'을 제공한다. 입력한 값과 일치하는 회원 <code>ID</code>이 존재할 때, 관리자에 대한 '인증'이 정상적으로 수행되면 회원 프로필 정보를 제공하고 회원 권한을 갱신할 수 있는 '(관리자) 회원 권한 갱신 화면'을 제공한다. '회원 권한 갱신 버튼'을 눌렀을 때, 관리자에 대한 '인증'이 정상적으로 수행되면 '회원 서비스'에 존재하는 해당 회원의 권한 정보를 갱신한다. (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-005</code></td>
        <td nowrap="">관리자 권한 실행 기록 조회<br />(<code>ManagerReadAuthRequestHistory</code>)</td>
        <td>'관리자'가 '관리자 콘솔 화면'에서 '권한 실행 기록 조회 버튼'을 누르면, 관리자에 대한 '인증'이 정상적으로 수행되면 모든 '회원'이 '관리자 서비스'에 권한을 요청하여 응답받은 '권한 기록' ('권한 요청 일시', '권한 응답 일시', '권한 이름', '권한 내용', '권한 응답 결과', '권한 요청자', '관한 실행자') (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-006</code></td>
        <td nowrap="">관리자 IP 차단<br />(<code>ManagerBlockIP</code>)</td>
        <td> (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>MA-007</code></td>
        <td nowrap="">관리자 회원 제재<br />(<code>ManagerPenaltyMember</code>)</td>
        <td> (이 기능은 해당 권한을 가진 회원 또한 '회원 권한 요청'을 통해 실행 가능하다.)</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="19">위키<br />(<code>Wiki</code>)</td>
        <td nowrap=""><code>WI-001</code></td>
        <td nowrap="">카테고리 생성<br />(<code>~CreateCategory</code>)</td>
        <td>'관리자'나 해당 권한을 가진 회원이 '위키 메인 화면'에서 '카테고리 생성 버튼'을 누를 때, 각각의 '인증'이 정상적으로 수행되면 카테고리의 구성 요소들을 입력할 수 있는 '카테고리 생성 화면'으로 이동한다. '카테고리 생성 화면'에서 '카테고리 생성 버튼'을 눌렀다면, 카테고리의 구성 요소들 중에 필수 항목들이 모두 입력되고 입력한 값들에 대한 '유효성 검사'가 정상적으로 수행되었을 때, 각각의 '인증'이 정상적으로 수행되면 데이터베이스에 '카테고리'를 생성한 다음 '위키 메인 화면'으로 이동한다.</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-002</code></td>
        <td nowrap="">카테고리 갱신<br />(<code>~UpdateCategory</code>)</td>
        <td>'관리자'나 해당 권한을 가진 회원이 특정한 '카테고리 메인 화면'에서 '카테고리 갱신 버튼'을 누를 때, 각각의 '인증'이 정상적으로 수행되면 해당 카테고리의 구성 요소들을 수정할 수 있는 '카테고리 수정 화면'으로 이동한다. '카테고리 갱신 화면'에서 '카테고리 갱신 버튼'을 눌렀다면, 카테고리의 구성 요소들 중에 필수 항목들이 모두 입력되고 입력한 값들에 대한 '유효성 검사'가 정상적으로 수행되었을 때, 각각의 '인증'이 정상적으로 수행되면 데이터베이스에 해당 '카테고리'를 생성한 다음에 생성된 '카테고리 메인 화면'으로 이동한다.</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-003</code></td>
        <td nowrap="">카테고리 읽기<br />(<code>~ReadCategory</code>)</td>
        <td>어떤 화면에서 특정한 '카테고리 이동 버튼'을 누르면, 해당 카테고리의 정보와 하위 문서들을 볼 수 있는 '카테고리 메인 화면'으로 이동한다.</td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-004</code></td>
        <td nowrap="">카테고리 삭제<br />(<code>~DeleteCategory</code>)</td>
        <td>'관리자'나 해당 권한을 가진 회원이 특정한 '카테고리 메인 화면'에서 '카테고리 삭제 버튼'을 누를 때, 각각의 '인증'이 정상적으로 수행되면 해당 카테고리를 삭제할 수 있는 '카테고리 삭제 화면'으로 이동한다. '카테고리 삭제 화면'에서 '카테고리 삭제 버튼'을 눌렀다면, 각각의 '인증'이 정상적으로 수행되면 데이터베이스에 '카테고리'를 생성한 다음 '위키 메인 화면'으로 이동한다.</td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-005</code></td>
        <td nowrap="">문서 생성<br />(<code>~CreateDocument</code>)</td>
        <td>어떤 화면에서 '문서 생성 버튼'을 누르면, 문서의 구성 요소들을 작성할 수 있는 '문서 생성 화면'으로 이동한다. '문서 생성 화면'에서 '문서 생성 버튼'을 눌렀다면, 문서의 구성 요소들 중에 필수 항목들이 모두 입력되고 입력한 값들에 대한 '유효성 검사'가 정상적으로 수행되었을 때, 데이터베이스에 해당 '문서' </td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-006</code></td>
        <td nowrap="">문서 갱신<br />(<code>~UpdateDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-007</code></td>
        <td nowrap="">문서 읽기<br />(<code>~ReadDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-008</code></td>
        <td nowrap="">문서 삭제<br />(<code>~DeleteDocument</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-009</code></td>
        <td nowrap="">특정 카테고리에서 문서 검색<br />(<code>~SearchDocumentOnCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-010</code></td>
        <td nowrap="">모든 카테고리에서 문서 검색<br />(<code>~SearchDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-011</code></td>
        <td nowrap="">카테고리 검색<br />(<code>~SearchCategory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DO-012</code></td>
        <td nowrap="">특정 카테고리 기록 조회<br />(<code>~ReadCategoryHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-013</code></td>
        <td nowrap="">특정 문서 기록 조회<br />(<code>~ReadDocumentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-014</code></td>
        <td nowrap="">템플릿 생성<br />(<code>~CreateTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-015</code></td>
        <td nowrap="">템플릿 갱신<br />(<code>~UpdateTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-016</code></td>
        <td nowrap="">템플릿 읽기<br />(<code>~ReadTemplate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-017</code></td>
        <td nowrap="">템플릿 삭제<br />(<code>~DeleteTemplate</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-018</code></td>
        <td nowrap="">템플릿 검색<br />(<code>~SearchTemplate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>WI-019</code></td>
        <td nowrap="">문서에 템플릿 가져오기<br />(<code>~AddTemplateOnDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">토론<br />(<code>Debate</code>)</td>
        <td nowrap=""><code>DE-001</code></td>
        <td nowrap="">문서에 토론 생성<br />(<code>CreateDebateOnDocument</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-002</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-003</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-004</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>DE-005</code></td>
        <td nowrap=""><br />(<code>Debate</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="15">게시판<br />(<code>Board</code>)</td>
        <td nowrap=""><code>BO-001</code></td>
        <td nowrap="">게시판 생성<br />(<code>~CreateBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-002</code></td>
        <td nowrap="">게시판 조회<br />(<code>~ReadBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-003</code></td>
        <td nowrap="">게시판 갱신<br />(<code>~UpdateBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-004</code></td>
        <td nowrap="">게시판 삭제<br />(<code>~DeleteBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-005</code></td>
        <td nowrap="">특정 게시판에서 게시글 조회<br />(<code>~ReadPostOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-006</code></td>
        <td nowrap="">특정 게시판에서 게시글 갱신<br />(<code>~UpdatePostOnBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />작성자 (게시글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-007</code></td>
        <td nowrap="">특정 게시판에서 게시글 삭제<br />(<code>~DeletePostOnBoard</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />작성자 (게시글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-008</code></td>
        <td nowrap="">특정 게시판에서 게시글 목록 조회<br />(<code>~ReadPostHistoryOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-009</code></td>
        <td nowrap="">게시판 검색<br />(<code>~SearchBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-010</code></td>
        <td nowrap="">특정 게시판에서 게시글 검색<br />(<code>~SearchPostOnBoard</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-011</code></td>
        <td nowrap="">모든 게시판에서 게시글 검색<br />(<code>~SearchPost</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-012</code></td>
        <td nowrap="">회원이 작성한 게시글 기록 조회<br />(<code>~ReadUserPostHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-013</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-014</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>BO-015</code></td>
        <td nowrap=""><br />(<code></code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="6">댓글<br />(<code>Comment</code>)</td>
        <td nowrap=""><code>CO-001</code></td>
        <td nowrap="">댓글 생성<br />(<code>~CreateComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-002</code></td>
        <td nowrap="">댓글 조회<br />(<code>~ReadComment</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-003</code></td>
        <td nowrap="">댓글 갱신<br />(<code>~UpdateComment</code>)</td>
        <td></td>
        <td nowrap="">작성자 (댓글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-004</code></td>
        <td nowrap="">댓글 삭제<br />(<code>~DeleteComment</code>)</td>
        <td></td>
        <td nowrap="">관리자,<br />회원 (권한),<br />작성자 (댓글)</td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-005</code></td>
        <td nowrap="">회원이 작성한 댓글 기록 조회<br />(<code>~ReadUserCommentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CO-006</code></td>
        <td nowrap="">최근에 등록된 댓글 기록 조회<br />(<code>~ReadCreateCommentHistory</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">알림<br />(<code>Notice</code>)</td>
        <td nowrap=""><code>NO-001</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-002</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-003</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-004</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>NO-005</code></td>
        <td nowrap=""><br />(<code>Notice</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td rowspan="5">채팅<br />(<code>Chat</code>)</td>
        <td nowrap=""><code>CH-001</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-002</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-003</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-004</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
      <tr>
        <td nowrap=""><code>CH-005</code></td>
        <td nowrap=""><br />(<code>Chat</code>)</td>
        <td></td>
        <td nowrap=""><code>-</code></td>
        <td nowrap=""><code></code></td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="래퍼런스-references--프로젝트-설계-과정에-참고한-자료">래퍼런스 (<code class="language-plaintext highlighter-rouge">References</code>) : 프로젝트 설계 과정에 참고한 자료</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ver-0.0.1</code> (<code class="language-plaintext highlighter-rouge">2024-02-03</code>) : 최초 작성</p>
</blockquote>

<div style="text-align: center;">
  <table>
    <thead>
      <tr>
        <td nowrap="" style="padding-left: 4%; padding-right: 4%;">분류</td>
        <td nowrap="">이름</td>
        <td nowrap="">저자</td>
        <td nowrap="">주소</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td nowrap="" rowspan="2">논문</td>
        <td>보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼 (2018)</td>
        <td nowrap="">김도희</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td>보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문. (2012)</td>
        <td nowrap="">임현정</td>
        <td nowrap=""></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="1">기사</td>
        <td>한국 보컬로이드는 어떻게 나아가야할까?</td>
        <td nowrap="">안태춘</td>
        <td nowrap=""><a href="https://www.newslight.kr/news/655301">더뉴스라이트</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">도서</td>
        <td>서비스를 성공시키는 기획자의 비법 노트</td>
        <td nowrap="">조이</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=295601741">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>사례로 배우는 언어 전환 프로젝트 관리</td>
        <td nowrap="">남경호</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td>도메인 주도 설계로 시작하는 마이크로서비스 개발</td>
        <td nowrap="">한정헌, 유해식, 최은정, 이주영</td>
        <td nowrap=""><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">알라딘 전자책</a></td>
      </tr>
      <tr>
        <td nowrap="" rowspan="3">문서</td>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말">문서</a></td>
      </tr>
      <tr>
        <td nowrap="">나무위키</td>
        <td>나무위키:문법 도움말/심화</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:문법%20도움말/심화">문서</a></td>
      </tr>
      <tr>
        <td>공공기관 웹사이트 구축·운영 가이드</td>
        <td nowrap="">행정안전부</td>
        <td nowrap=""><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj204K9zoKEAxWtLUQIHQsyB4AQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.mois.go.kr%2Fcmm%2Ffms%2FFileDown.do%3FatchFileId%3DFILE_00084689_1WeMtZ%26fileSn%3D1&amp;usg=AOvVaw1TqMgiQXNjFgQfouwTtQh2&amp;opi=89978449">문서</a></td>
      </tr>
            <tr>
        <td nowrap="" rowspan="2">사이트</td>
        <td nowrap="" colspan="2">나무위키</td>
        <td nowrap=""><a href="https://namu.wiki/w/나무위키:대문">홈페이지</a></td>
      </tr>
      <tr>
        <td nowrap="" colspan="2">openNAMU</td>
        <td nowrap=""><a href="https://github.com/openNAMU/openNAMU">깃허브 저장소</a></td>
      </tr>
    </tbody>
  </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[프로젝트 목표 (Project Goal) : 프로젝트 진행 과정에서 이루고자 하는 사항들을 정리]]></summary></entry><entry><title type="html">[JS] 8. 모듈 (Module)</title><link href="http://localhost:4000/js8/" rel="alternate" type="text/html" title="[JS] 8. 모듈 (Module)" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/js8</id><content type="html" xml:base="http://localhost:4000/js8/"><![CDATA[<h2 id="모듈-module--코드를-재사용-가능한-파일-단위의-조각으로-나눈-것">모듈 (<code class="language-plaintext highlighter-rouge">Module</code>) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것</h2>

<ul>
  <li>자신만의 모듈 스코프를 갖고, 어플리케이션과 독립적으로 자체 컴파일한 단위</li>
  <li>코드의 변수, 상수, 함수, 클래스 등을  선택적으로 공개 (<code class="language-plaintext highlighter-rouge">Export</code>)</li>
  <li>이름 충돌, 종속성 등 문제 해결 및 엄격 모드 자동 적용</li>
  <li><code class="language-plaintext highlighter-rouge">Read-Only</code>로 로드되며 동일 영역에 중복 <code class="language-plaintext highlighter-rouge">import</code> 가능</li>
</ul>

<h3 id="모듈-시스템-module-system--현재는-esm-ecmascript-module이-표준">모듈 시스템 (<code class="language-plaintext highlighter-rouge">Module System</code>) → 현재는 <code class="language-plaintext highlighter-rouge">ESM</code> (<code class="language-plaintext highlighter-rouge">ECMAScript Module</code>)이 표준!</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">package.json</code>에 <code class="language-plaintext highlighter-rouge">"type": "module",</code> 추가</li>
  <li>모든 파일의 확장자를 <code class="language-plaintext highlighter-rouge">mjs</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm i esm → $&gt; node -r esm mod.js</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "name": "js",
  "version": "1.0.0",
  "description": "package.json for test",
  "main": "npm.js",
  "author": "pocj8ur4in",
  "type": "module", 
  "license": "ISC"
}
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/76d1a998-c16d-4823-8f8b-18e7c9399904" width="50%" /></p>

<h3 id="임포트-import--익스포트-export--특정-모듈에서-export한-것을-import">임포트 (<code class="language-plaintext highlighter-rouge">Import</code>) &amp; 익스포트 (<code class="language-plaintext highlighter-rouge">Export</code>) : 특정 모듈에서 <code class="language-plaintext highlighter-rouge">Export</code>한 것을 <code class="language-plaintext highlighter-rouge">Import</code></h3>

<ul>
  <li>모듈을 찾을 위치를 문자열로 지정하는 모듈 지정자 (<code class="language-plaintext highlighter-rouge">Module Specifier</code>) 사용</li>
  <li>중복으로 임포트하더라도 실행 컨텍스트 단위 하나당 한번만 로드 (<code class="language-plaintext highlighter-rouge">Module Map</code>/<code class="language-plaintext highlighter-rouge">Tree</code>)</li>
  <li>임포트 및 익스포트 선언은 최상위 스코프에서만 가능, 표현식이 아니라 선언이므로 호이스팅</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export function fn() { ... }
export const value = 1;
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import {} from './mod.js';
import '.mod.js'; // side-effect only! → 임포트로 실행만 할 경우에 선언
</code></pre></div></div>

<h4 id="간접-익스포트-indirect-export--aggregating--다른-모듈의-일부-혹은-전체를-받아-다시-익스포트">간접 익스포트 (<code class="language-plaintext highlighter-rouge">Indirect Export &amp; Aggregating</code>) : 다른 모듈의 일부 혹은 전체를 받아 다시 익스포트</h4>

<ul>
  <li>필요한 모듈만 모아놓은 또 다른 모듈을 만들 때에 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export { xxx } from './mod1.js';
export { yyy } from './mod2.js';
export { zzz } from './mod3.js'; // 사용하려면 명시적으로 import한 후 export해야 함

→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

// import 후 export
import { xxx } from './mod3.js';
export { xxx };

→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

// 개선된 방법 with Aggregating
import { xxx, yyy, zzz } from './agg.js';

export * from './mod1.js';
export * from './mod2.js';
export * from './mod3.js';

import * as agg from './agg.js';
</code></pre></div></div>

<h3 id="동적-임포트-dynamic-import--코드-실행-중에-모듈을-비동기적으로-불러옴">동적 임포트 (<code class="language-plaintext highlighter-rouge">Dynamic Import</code>) : 코드 실행 중에 모듈을 비동기적으로 불러옴</h3>

<ul>
  <li>어플리케이션 초기 로딩 시 모든 모듈을 불러오지 않고, 필요한 모듈만 필요한 시점에 불러와서 성능을 최적화</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 동적 임포트
import('./path/to/module')
  .then((module) =&gt; {
    // 모듈을 사용
    console.log(module);
  })
  .catch((error) =&gt; {
    // 에러 처리
    console.error('모듈을 불러오는 동안 에러 발생:', error);
  });
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 조건에 따라 모듈 동적으로 로드
const condition = true;

if (condition) {
  import('./path/to/someModule')
    .then((someModule) =&gt; {
      someModule.doSomething();
    })
    .catch((error) =&gt; {
      console.error('모듈을 불러오는 동안 에러 발생:', error);
    });
}
</code></pre></div></div>

<h3 id="모듈-로더-module-loader--내부에서-임포트-및-익스포트를-관리">모듈 로더 (<code class="language-plaintext highlighter-rouge">Module Loader</code>) : 내부에서 임포트 및 익스포트를 관리</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[ImportEntries]</code>와 <code class="language-plaintext highlighter-rouge">[ExportEntries]</code>라는 내장 슬롯으로 관리
    <ol>
      <li>임포트 &amp; 파싱 (구문 분석) : 모듈 레코드, 모듈 맵을 생성</li>
      <li>인스턴스화 : 모듈의 바인딩 및 환경 레코드를 생성</li>
      <li>모듈 실행 : 모듈 코드를 실행, 모듈이 ‘평가됨’으로 표시</li>
    </ol>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/fbced0dc-3bf5-4cd8-83f1-c98863730512" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { a } from './A.js'

Name: 'a'
Type: identifier
Value: 100
Mutable: false
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d48c71cd-d17e-4267-93f8-41aff403005f" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/19645c89-cbc7-4c04-a114-99a01716f725" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/07c4ee10-d19f-44d9-8170-9df928164a5b" /></p>

<h3 id="npm-모듈-생성-및-업로드-httpswwwnpmjscom"><code class="language-plaintext highlighter-rouge">npm</code> 모듈 생성 및 업로드 (<a href="https://www.npmjs.com"><code class="language-plaintext highlighter-rouge">https://www.npmjs.com</code></a>)</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">npm</code> : <code class="language-plaintext highlighter-rouge">Node.js</code>의 패키지를 관리할 수 있는 도구</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Node.js</code>에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 <code class="language-plaintext highlighter-rouge">CLI</code> 제공</li>
    <li><code class="language-plaintext highlighter-rouge">npx</code> (<code class="language-plaintext highlighter-rouge">node package execute</code>)을 통해 패키지를 설치 및 실행</li>
    <li>국내에서는 패키지 중복 문제를 링크 방식으로 해결한 <code class="language-plaintext highlighter-rouge">yarn</code>을 많이 사용하는 추세</li>
  </ul>
</blockquote>

<ol>
  <li>패키지 이름 정하기 (<code class="language-plaintext highlighter-rouge">npm info &lt;pkg&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">npm init</code>으로 <code class="language-plaintext highlighter-rouge">package.json</code> 작성</li>
  <li>의존 관계가 있으면 <code class="language-plaintext highlighter-rouge">npm install</code></li>
  <li><code class="language-plaintext highlighter-rouge">npm login</code> 후 배포 <code class="language-plaintext highlighter-rouge">npm publish --access public</code></li>
</ol>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[모듈 (Module) : 코드를 재사용 가능한 파일 단위의 조각으로 나눈 것]]></summary></entry></feed>