<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-31T09:37:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[JS] 5. 함수 (Function)</title><link href="http://localhost:4000/js5/" rel="alternate" type="text/html" title="[JS] 5. 함수 (Function)" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/js5</id><content type="html" xml:base="http://localhost:4000/js5/"><![CDATA[<h2 id="함수-function--일련의-과정을-코드-블록으로-감싸-하나의-단위로-정의한-것">함수 (<code class="language-plaintext highlighter-rouge">Function</code>) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것</h2>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c6d16c9b-7b9c-4340-bbab-88b15bfd53db" width="80%" /></p>

<ul>
  <li>자바스크립트의 함수는 객체 타입의 값 → 함수 또한 함수 리터럴 (<code class="language-plaintext highlighter-rouge">functional literal</code>)로 생성할 수 있음</li>
  <li>일반 객체와 달리, 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 가짐</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/05176279-d1d8-4756-8bb3-5186474aa123" width="80%" /></p>

<h3 id="함수-정의-function-definition--함수-호출-이전에-인수를-전달받을-매개변수-문-반환값을-지정">함수 정의 (<code class="language-plaintext highlighter-rouge">Function Definition</code>) : 함수 호출 이전에 인수를 전달받을 매개변수, 문, 반환값을 지정</h3>

<blockquote>
  <p>함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되므로, 함수는 정의된다고 할 수 있다.</p>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0b6c992d-5608-47a8-b2bc-0af11c3c9b24" width="80%" /></p>

<h4 id="함수-선언문-function-declaration">함수 선언문 (<code class="language-plaintext highlighter-rouge">Function Declaration</code>)</h4>

<ul>
  <li>함수 선언문은 함수 리터럴과 형태가 동일</li>
  <li>함수 리터럴은 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음</li>
</ul>

<h4 id="함수-표현식-function-expression">함수 표현식 (<code class="language-plaintext highlighter-rouge">Function Expression</code>)</h4>

<h4 id="function-생성자-함수"><code class="language-plaintext highlighter-rouge">Function</code> 생성자 함수</h4>

<h4 id="화살표-함수-arrow-function">화살표 함수 (<code class="language-plaintext highlighter-rouge">Arrow Function</code>)</h4>

<h3 id="함수-매개변수-argument--값-parameter--변수">함수 매개변수 (<code class="language-plaintext highlighter-rouge">Argument</code> : 값, <code class="language-plaintext highlighter-rouge">Parameter</code> : 변수)</h3>

<h3 id="즉시-호출-함수-iife">즉시 호출 함수 <code class="language-plaintext highlighter-rouge">IIFE</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function() { ... })();
</code></pre></div></div>

<h3 id="함수의-호출-방식과-this">함수의 호출 방식과 <code class="language-plaintext highlighter-rouge">this</code></h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/b706b06f-966b-458a-a6f5-22131c6681ff" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code>를 바인딩하는 방법 : <code class="language-plaintext highlighter-rouge">call</code>, <code class="language-plaintext highlighter-rouge">apply</code>, <code class="language-plaintext highlighter-rouge">bind</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(id) {
  console.log(this, id, this.name);
}

const obj = { name: 'Kim' };

// bind
const bf1 = func.bind(obj);
bf1(1, '서울');

// apply
func.apply(obj, [ 2, '부산' ]);

// call
func.call(obj, 3, '대구');
</code></pre></div></div>

<h3 id="순수-함수-pure-function--함수로서의-함수">순수 함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>) : 함수로서의 함수</h3>

<ul>
  <li>입력이 같으면 결과도 같다! → <code class="language-plaintext highlighter-rouge">Side Effect</code>가 없다. 즉, 외부의 값을 변경시키지 않아야 한다!</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const weeks = ['일', '월', '화', '수', '목', '금', '토'];

const getWeekName = function(weekNo) {
  return `${weeks[weekNo]}요일`;
};

const day = new Date().getDay();
console.log(`오늘은 ${getWeekName(day)}입니다!`);
</code></pre></div></div>

<p>→ 외부에 값을 두지 않고 내부에 값을 두는 클로저를 활용해야 한다!</p>

<h3 id="콜백-함수-callback-function---다른-함수에-인자로-전달되는-함수">콜백 함수 (<code class="language-plaintext highlighter-rouge">Callback Function</code>) :  다른 함수에 인자로 전달되는 함수</h3>

<ul>
  <li>주로 비동기적인 상황에서 사용되며, 특정 이벤트 발생 시 호출되도록 등록</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="고차-함수-higher-order-function--함수를-인자로-받거나-함수를-반환하는-함수">고차 함수 (<code class="language-plaintext highlighter-rouge">Higher-Order Function</code>) : 함수를 인자로 받거나 함수를 반환하는 함수</h3>

<blockquote>
  <ul>
    <li>인수 (매개변수)로서의 함수</li>
    <li>반환 값으로서의 함수 (클로저)</li>
    <li>식별자로서의 함수 (1급 객체)</li>
    <li>
      <p>배열 및 객체 내의 함수 (원소)</p>

      <p>→ 즉, 고차 함수는 <b>1급 객체로서의 함수</b>를 의미한다.</p>
    </li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[함수 (Function) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것]]></summary></entry><entry><title type="html">[JS] 3. 호이스팅 (Hoisting) &amp;amp; 동적 타이핑 (Type Conversion)</title><link href="http://localhost:4000/js3/" rel="alternate" type="text/html" title="[JS] 3. 호이스팅 (Hoisting) &amp;amp; 동적 타이핑 (Type Conversion)" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/js3</id><content type="html" xml:base="http://localhost:4000/js3/"><![CDATA[<h2 id="호이스팅-hoisting--선언문을-코드-맨-위에-올려진-것처럼-동작시키는-것">호이스팅 (<code class="language-plaintext highlighter-rouge">Hoisting</code>) : 선언문을 코드 맨 위에 올려진 것처럼 동작시키는 것</h2>

<blockquote>
  <p>평가 (<code class="language-plaintext highlighter-rouge">evaluation</code>) : 표현식을 해석해서 값을 생성하거나 참조하는 것</p>

  <ul>
    <li>평가 <code class="language-plaintext highlighter-rouge">=</code> 인터프리터로서의 컴파일 (선언문 실행 + 호이스팅)</li>
    <li>인터프리터로서의 실행 순서 : 전역 코드 평가 → 전역 코드 실행 → 함수 코드 평가 → 함수 코드 실행 → 복귀</li>
  </ul>
</blockquote>

<ul>
  <li>변수, 함수, 클래스와 같이 키워드를 사용해서 선언하는 모든 식별자는 호이스팅이 이루어짐</li>
  <li>스코프 별로 평가가 이루어지면서 호이스팅이 일어남 → 해당 스코프의 상단으로 올려 메모리 선점 (<code class="language-plaintext highlighter-rouge">Linking</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code>도 호이스팅되지만, 초기화되기 전에 접근하면 안됨 (<code class="language-plaintext highlighter-rouge">notInitializedYey</code> 상태로 호이스팅)</li>
      <li>선언문이 없는 변수는 호이스팅되지 않으며, 평가한 다음에 코드를 실행할 때 정의</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log(a);
var a = 10;
&gt; undefined

let v;
console.log(v); // 에러

z = 9; // 암묵적으로 var로 정의
console.log(z);
&gt; 9

console.log(globalThis['z']);

let z = 11; // 에러 (암묵적 정의 → 호이스팅)
</code></pre></div></div>

<ul>
  <li>코드 평가 시점에 호이스팅이 일어나 선언부와 구현부로 구분 → 선언부는 스택 영역에, 구현부는 힙 영역에 저장</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/75425564-29bc-4aaa-8014-63a7d3b3a435" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8e05cc2f-b9d6-45be-b681-73d0f6b98229" width="80%" /></p>

<ul>
  <li>선언문의 실행 시점 : 선언문은 런타임 (<code class="language-plaintext highlighter-rouge">Runtime</code>)이 아닌 그 이전인 평가 과정에 실행
    <ul>
      <li>소스 코드를 한 줄씩 순차적으로 실행하기 앞서, 먼저 소스 코드의 평가 과정에서 선언문을 먼저 실행</li>
      <li>즉, 식별자를 선언하는 선언문과 값을 할당하는 할당문의 실행 시점은 서로 다름</li>
    </ul>
  </li>
</ul>

<h2 id="동적-타이핑-dynamic-typing--변수를-선언할-때-데이터-타입을-사전에-선언하지-않음">동적 타이핑 (<code class="language-plaintext highlighter-rouge">Dynamic Typing</code>) : 변수를 선언할 때 데이터 타입을 사전에 선언하지 않음</h2>

<blockquote>
  <p>정적 타입 (<code class="language-plaintext highlighter-rouge">Static Typing</code>) : 변수를 선언할 때 데이터 타입을 사전에 선언</p>

  <ul>
    <li>변수에 선언한 타입에 해당하는 값만 할당할 수 있음</li>
    <li>컴파일 시점에 타입 체크 (<code class="language-plaintext highlighter-rouge">Type Check</code>)를 수행하고, 통과하지 못하면 에러를 발생시킴</li>
    <li>타입의 일관성을 강제해 안정ㅇ적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임</li>
  </ul>
</blockquote>

<ul>
  <li>자바스크립트는 <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드를 통해 변수만 선언할 수 있음
    <ul>
      <li>자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론 (<code class="language-plaintext highlighter-rouge">Type Inference</code>)이 이루어짐</li>
      <li>재할당에 의해 변수의 타입은 언제든지 동적으로 변화할 수 있음 (<code class="language-plaintext highlighter-rouge">loosely data</code>)</li>
    </ul>
  </li>
  <li>동적 타이핑 및 동적 타입 언어의 단점 : 유연성 (<code class="language-plaintext highlighter-rouge">Flexibility</code>)은 높지만 신뢰성 (<code class="language-plaintext highlighter-rouge">Reliability</code>) 이 떨어진다.
    <ul>
      <li>동적 타입 언어의 변수 값은 언제든지 변할 수 있음
        <ul>
          <li>복잡한 프로그램에서는 변수 값을 추적하기 어려울 수 있음</li>
        </ul>
      </li>
      <li>동적 타입 언어의 변수는 값의 변경에 의해 타입 또한 언제든지 변경될 수 있음
        <ul>
          <li>값을 확인하기 전에는 타입을 확신할 수 없음</li>
          <li>자바스크립트 엔진에 의해 타입이 자동으로 변환될 수도 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자비스크립트에서 변수를 사용할 때 지켜면 좋은 규칙!</p>

  <ul>
    <li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.</li>
    <li>변수의 유효 범위인 스코프는 최대한 좁게 만들어 변수의 부작용을 억제한다.</li>
    <li>전역 변수는 최대한 자제한다.</li>
    <li>변수보다는 상수를 사용해 값의 변경을 억제한다.</li>
    <li>변수 이름은 목적 및 의미를 파악할 수 있도록 네이밍하고, 특히 스코프가 넓을수록 명확하게 명명한다.</li>
  </ul>
</blockquote>

<h2 id="타입-변환-type-conversion--값의-타입이-다른-자료형으로-변환되는-것">타입 변환 (<code class="language-plaintext highlighter-rouge">Type Conversion</code>) : 값의 타입이 다른 자료형으로 변환되는 것</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">typeof()</code> 연산자를 통해 피연산자의 데이터 타입을 문자열로 반환할 수 있음</li>
</ul>

<h3 id="암묵적-타입-변환--자바스크립트-엔진에서-에러를-발생시키지-않도록-타입을-바꿔-표현식을-평가하는-것">암묵적 타입 변환 : 자바스크립트 엔진에서 에러를 발생시키지 않도록 타입을 바꿔 표현식을 평가하는 것</h3>

<ul>
  <li>문자열 타입 변환 : <code class="language-plaintext highlighter-rouge">+</code>의 피연산자 중 하나가 문자열이면, 문자열 연결 연산자로 동작하므로 다른 것을 문자열로 변환</li>
  <li>숫자 타입 변환 : 산술 및 비교 연산자의 피연산자 중에 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환</li>
  <li>불리언 타입 변환 : 논리적 참/거짓을 평가하는 경우에 불리언 타입이 아닌 피연산자를 불리언 타입으로 변환</li>
</ul>

<h3 id="명시적-타입-변환--의도적으로-값의-타입을-변환하는-것--타입-캐스팅-type-casting">명시적 타입 변환 : 의도적으로 값의 타입을 변환하는 것 → 타입 캐스팅 (<code class="language-plaintext highlighter-rouge">type casting</code>)</h3>

<ul>
  <li>문자열 타입으로 변환 : <code class="language-plaintext highlighter-rouge">String()</code>, <code class="language-plaintext highlighter-rouge">toString()</code>, 문자열 연결 연산자 <code class="language-plaintext highlighter-rouge">+</code></li>
  <li>숫자 타입으로 변환 : <code class="language-plaintext highlighter-rouge">Number()</code>, <code class="language-plaintext highlighter-rouge">parseInt()/parseFloat()</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code></li>
  <li>불리언 타입으로 변환 : <code class="language-plaintext highlighter-rouge">Boolean()</code>, 부정 논리 연산자 <code class="language-plaintext highlighter-rouge">!</code>를 2번</li>
</ul>

<blockquote>
  <p>기존 원시 타입을 사용해 다른 타입의 새로운 원시 타입을 생성하는 것!</p>

  <ul>
    <li>원시 타입은 변경 불가능한 값 (<code class="language-plaintext highlighter-rouge">immutable value</code>) → 기존 원시 타입을 직접 변경할 수 없음</li>
    <li>자바스크립트 엔진에서 표현식을 평가하기 위해 피연산자의 값을 암묵적 타입 변환으로 새로운 타입의 값을 만듬</li>
  </ul>
</blockquote>

<h2 id="단축-평가-short-circuit-evaluation--표현식을-평가하는-중에-결과가-확정되면-평가-생략">단축 평가 (<code class="language-plaintext highlighter-rouge">Short-Circuit Evaluation</code>) : 표현식을 평가하는 중에 결과가 확정되면, 평가 생략</h2>

<ul>
  <li>논리 평가 : 논리 연산자를 이용한 단축 평가 (좌항에서 우항으로 평가)
    <ul>
      <li>논리곱 연산자 <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>는 두 피연산자가 모두 <code class="language-plaintext highlighter-rouge">true</code>일 때, <code class="language-plaintext highlighter-rouge">true</code> 반환
        <ul>
          <li>논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 반환</li>
        </ul>
      </li>
      <li>논리합 연산자 <code class="language-plaintext highlighter-rouge">||</code>는 두 피연산자 중 하나만  <code class="language-plaintext highlighter-rouge">true</code>이여도, <code class="language-plaintext highlighter-rouge">true</code> 반환
        <ul>
          <li>논리 연산의 결과를 결정하는 첫번째 피연사자를 그대로 반환</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'Cat' &amp;&amp; 'Dog' // true &amp;&amp; 'Dog' → 'Dog'
'Cat' || 'Dog' // 'Cat'... → 'Cat'
</code></pre></div></div>

<blockquote>
  <p>논리 평가를 사용하는 경우?</p>

  <ul>
    <li>객체를 가리키기 기대하는 변수가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>가 아닌지 확인하고 프로퍼티를 참조할 때</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var elem = null;
// var value = elem.value; // TypeError
var value = elem &amp;&amp; elem.value; // null
</code></pre></div>  </div>

  <ul>
    <li>함수 매개변수에 <code class="language-plaintext highlighter-rouge">undefined</code>가 할당되지 않도록 기본값을 설정할 때</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getStringLength() {
str = str || '';
return str.length;
}
getStringLength(); // 0
getStringLength('hello'); // 5
</code></pre></div>  </div>
</blockquote>

<ul>
  <li>옵셔널 체이닝 (<code class="language-plaintext highlighter-rouge">Optional Chaining</code>) 연산자 <code class="language-plaintext highlighter-rouge">?</code> : 좌항의 피연산자가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이면 <code class="language-plaintext highlighter-rouge">undefined</code>를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 그대로 진행함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var elem = null;
var str = '';

var value1 = elem?.value; console.log(value1); // undefined
var value2 = elem &amp;&amp; elem.value; console.log(value2); // null
var value3 = str &amp;&amp; str.length; console.log(value3); // ''
var value4 = str?.length; console.log(value4); // 0
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 병합 연산자 <code class="language-plaintext highlighter-rouge">??</code> : 좌항의 피연산자가 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환 → 변수에 기본값을 설정할 때 사용
    <ul>
      <li>논리 연산자 <code class="language-plaintext highlighter-rouge">||</code>를 사용한 단축 평가와 달리, 피연산자가  <code class="language-plaintext highlighter-rouge">false</code>로 평가받는 <code class="language-plaintext highlighter-rouge">Falsy</code> 값이라도 <code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code>이 아니면, 좌항의 피연산자를 반환함</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo = null ?? 'default'; // 'default'
</code></pre></div></div>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">Falsy</code> 값 : 피연산자가 <code class="language-plaintext highlighter-rouge">false</code>로 평가받는 값 (<code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">undefined</code>, <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">-0</code>, <code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">''</code>)</li>
    <li><code class="language-plaintext highlighter-rouge">Truthy</code> 값 : 피연산자가 <code class="language-plaintext highlighter-rouge">True</code>로 평가받는 값 (<code class="language-plaintext highlighter-rouge">true</code>, …)</li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[호이스팅 (Hoisting) : 선언문을 코드 맨 위에 올려진 것처럼 동작시키는 것]]></summary></entry><entry><title type="html">[JS] 2. 변수 (Variable) &amp;amp; 객체 (Object)</title><link href="http://localhost:4000/js2/" rel="alternate" type="text/html" title="[JS] 2. 변수 (Variable) &amp;amp; 객체 (Object)" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/js2</id><content type="html" xml:base="http://localhost:4000/js2/"><![CDATA[<h2 id="변수-variable--하나의-값을-저장할-수-있는-메모리-공간">변수 (<code class="language-plaintext highlighter-rouge">Variable</code>) : 하나의 값을 저장할 수 있는 메모리 공간</h2>

<blockquote>
  <p>변수 = 선언 + 식별자 + 타입 + 값 + 소코프</p>
</blockquote>

<ul>
  <li>자바스크립트는 개발자가 메모리 주소를 통해 값에 직접 접근하는 메모리 제어를 허용하지 않음</li>
  <li>변수 이름을 어떤 값을 구별해 식별 가능한 고유한 이름이란 의미에서, 식별자 (<code class="language-plaintext highlighter-rouge">Identifier</code>) 라고도 함
    <ul>
      <li>식별자는 값이 아닌 메모리 주소를 기억하고 있어, 식별자로 메모리 공간에 저장된 값에 접근</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var userId = 1;
var userName = 'John';

var user = { id: 1, name: 'John' };

var users = {
    { id: 1, name: 'John' }
}
</code></pre></div></div>

<ul>
  <li>변수 선언 (<code class="language-plaintext highlighter-rouge">variable declaration</code>)을 통해 변수를 생성 → <code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code> 키워드
    <ul>
      <li>변수에 값을 할당하지 않았으면, 자바스크립트 엔진에 의해 <code class="language-plaintext highlighter-rouge">undefined</code> 값이 할당되어 초기화</li>
      <li>선언하지 않은 식별자에 접근하면 참조 에러 (<code class="language-plaintext highlighter-rouge">ReferenceError</code>)가 발생</li>
    </ul>
  </li>
</ul>

<h3 id="리터럴-literal--사람이-이해할-수-있는-문자나-기호를-통해-값을-생성하는-표기법">리터럴 (<code class="language-plaintext highlighter-rouge">literal</code>) : 사람이 이해할 수 있는 문자나 기호를 통해 값을 생성하는 표기법</h3>

<ul>
  <li>값 (<code class="language-plaintext highlighter-rouge">value</code>) : 표현식이 평가되어 생성된 결과</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 + 20; // 30
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/21a03922-1820-4bdd-82e9-844443ccedf3" width="80%" /></p>

<ul>
  <li>표현식 (<code class="language-plaintext highlighter-rouge">expression</code>) : 값으로 평가될 수 있는 구문
    <ul>
      <li>구문 (<code class="language-plaintext highlighter-rouge">statement</code>) : 프로그램을 이루는 기본 단위이자 최소 실행 단위 (선언문, 할당문, 조건문, 반복문 등)
        <ul>
          <li>토큰 (<code class="language-plaintext highlighter-rouge">token</code>) : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="데이터-타입-date-type--값의-종류">데이터 타입 (<code class="language-plaintext highlighter-rouge">Date Type</code>) : 값의 종류</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c2d012-dc6b-418d-919f-b9dfa828448a" width="80%" /></p>

<ul>
  <li>숫자 타입 : 정수 및 실수를 모두 포함하는 타입으로 존재 (<b>모든 수를 실수로 처리</b>)<br />→ 큰 수를 위한 <code class="language-plaintext highlighter-rouge">BigInt</code> 타입과는 다름! (<code class="language-plaintext highlighter-rouge">BigInt</code>는 객체 타입으로, 모든 수를 정수로 처리)</li>
  <li>문자열 타입 : ‘’, “”, ``로 문자열을 감싼 텍스트 데이터
    <ul>
      <li>템플릿 (<code class="language-plaintext highlighter-rouge">template</code>) 리터럴 : <code class="language-plaintext highlighter-rouge">로 감싼 문자열 (</code><code class="language-plaintext highlighter-rouge">ES6</code>``부터 도입)
        <ul>
          <li>멀티라인 문자열 : 백슬레시 (<code class="language-plaintext highlighter-rouge">\n</code>) 없이 개행 가능</li>
          <li>표현식 삽입 : <code class="language-plaintext highlighter-rouge">+</code>으로 <code class="language-plaintext highlighter-rouge">${}</code>로 감싼 표현식을 문자열로 변환해 삽입할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>불리언 타입 : 참 (<code class="language-plaintext highlighter-rouge">true</code>)과 거짓 (<code class="language-plaintext highlighter-rouge">false</code>) → 제일 작은 값 (<code class="language-plaintext highlighter-rouge">1bit</code>)</li>
  <li>심볼 (<code class="language-plaintext highlighter-rouge">symbol</code>) 타입 : 변경 불가능한 원시 타입 (다른 값과 중복되지 않는 유일무이한 값)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Symbol</code> 함수를 호출해 생성되며, 값은 외부에 노출되지 않음 (<code class="language-plaintext highlighter-rouge">var key = Symbol('key');</code>)</li>
      <li>프로퍼티 값에 고유한 값을 저장하고 싶을 때 사용될 수 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">undefined</code> 타입 : 변수 선언에 의해 확보된 메모리 공간은 쓰레기 값이 아닌 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">null</code> 타입 : 변수에 값이 없다는 것을 의도적으로 명시 (<code class="language-plaintext highlighter-rouge">intentional absence</code>)하기 위해 사용</li>
</ul>

<h2 id="객체-object--소프트웨어에서-속성과-기능을-가지는-프로그램의-단위">객체 (<code class="language-plaintext highlighter-rouge">Object</code>) : 소프트웨어에서 속성과 기능을 가지는 프로그램의 단위</h2>

<blockquote>
  <p>자바스크립트에서 원시 타입을 제외한 나머지 값들 (객체, 함수, 배열, 정규 표현식)은 객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>)이다.</p>

  <p>→ 객체 타입은 프로퍼티 및 메소드를 모두 포함하고 있어, 상태와 동작을 하나의 단위로 구조화할 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John', // "name: 'John'"은 프로퍼티, 
  age: 21       // "name"은 프로퍼티 키, "'John'"은 프로퍼티 값
};
</code></pre></div></div>

<ul>
  <li>객체 타입은 변경 가능한 값 (<code class="language-plaintext highlighter-rouge">mutable</code>)</li>
  <li>객체 타입을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값 (<code class="language-plaintext highlighter-rouge">Reference value</code>)에 접근</li>
  <li>원시 타입과 다르게, 객체 타입은 여러 개의 식별자들이 하나의 객체를 공유할 수 있음</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/66b574d8-6033-47c4-ac56-47dfd0440077" width="80%" /></p>

<h3 id="원시-타입과-객체-타입의-차이점--메모리-공간에-저장되는-위치에서-비롯된-차이">원시 타입과 객체 타입의 차이점? → 메모리 공간에 저장되는 위치에서 비롯된 차이!</h3>

<ul>
  <li>원시 타입 (<code class="language-plaintext highlighter-rouge">Primitive</code>) : 값이 스택 영역에 들어감 (<code class="language-plaintext highlighter-rouge">Call-By-Value</code>) (<code class="language-plaintext highlighter-rouge">cf.</code> 변수의 주소는 별도로 관리됨)<br />→ (자바스크립트 엔진에 따라) 힙 영역 내의 <code class="language-plaintext highlighter-rouge">Symbol Table</code>이나 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 들어갈 수 있음</li>
  <li>객체 타입 (<code class="language-plaintext highlighter-rouge">Object/Reference</code>) : 값이 힙 영역에 들어감 (<code class="language-plaintext highlighter-rouge">Call-By-Reference</code>)</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8dd9f8c1-57e3-4dda-8ea5-1358ef9db7dc" width="90%" /></p>

<ul>
  <li>원시 값은 변경 불가능한 값 (<code class="language-plaintext highlighter-rouge">immutable</code>)이지만, 객체 값은 변경 가능한 값 (<code class="language-plaintext highlighter-rouge">mutable</code>)</li>
  <li>원시 값을 변수에 할당하면 변수에는 실제 값이 저장되나, 객체를 변수에 할당하면 변수에는 참조 값이 저장</li>
  <li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 (<code class="language-plaintext highlighter-rouge">Pass-By-Value</code>)되나, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 (<code class="language-plaintext highlighter-rouge">Pass-By-Reference</code>)</li>
</ul>

<blockquote>
  <p>변경 불가능하다는 것은 변수가 아니라 값에 대한 진술!</p>

  <ul>
    <li>상수 (재할당이 금지된 변수) != 변경 불가능한 값 (읽기 전용 값)</li>
    <li>처음 원시 값을 변수에 할당하면 실제 값이 저장되고, 값을 재할당하면 메모리 공간의 주소가 변경됨</li>
  </ul>

  <p>→ 원시 값은 상태 변경을 금지해 불변성 (<code class="language-plaintext highlighter-rouge">Immutability</code>)을 보장하여, 데이터의 신뢰성을 보장한다!</p>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/260dcc73-59bf-4cc7-93af-d24dea9d2518" /></p>

  <p>그러므로 <code class="language-plaintext highlighter-rouge">Call-By-Value</code> 또한 엄격히 표현하면, 변수에 메모리 주소가 전달되는 것을 말한다!</p>

  <p>→ 식별자는 메모리에 저장된 값을 식별해야 하므로, 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억한다.</p>
</blockquote>

<h3 id="constant-poll--스택-영역과-힙-영역-외에-리터럴을-저장하기-위해-자바스크립트-v8-엔진에서-도입"><code class="language-plaintext highlighter-rouge">Constant Poll</code> : 스택 영역과 힙 영역 외에 리터럴을 저장하기 위해 자바스크립트 <code class="language-plaintext highlighter-rouge">V8</code> 엔진에서 도입</h3>

<p><a href="https://hwan-shell.tistory.com/367"><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3d5b25eb-e794-444a-a999-6b9f3be49aee" width="80%" /></a></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Integer</code>가 저장되는 방식?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Integer</code>는 기본적으로 스택 영역의 <code class="language-plaintext highlighter-rouge">SMI</code> (<code class="language-plaintext highlighter-rouge">Small Integer</code>)에 저장</li>
      <li><code class="language-plaintext highlighter-rouge">32/64Bit OS</code>에서 <code class="language-plaintext highlighter-rouge">32/64Bit</code>를 넘어서면 힙 영역의 <code class="language-plaintext highlighter-rouge">Constant Poll</code>에 할당</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/67d4d968-9ee8-42b7-9de5-4e87a0c31823" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String</code>이 저장되는 방식?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">String</code>은 문자열으로 취급 → 모든 리터럴은 힙 영역의 <code class="language-plaintext highlighter-rouge">Constant Poll</code>에 할당</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/bf744728-8700-4846-b643-d076ca24712c" width="80%" /></p>

<h3 id="객체-리터럴에-의한-객체의-생성--중괄호--내에-0개-이상의-프로퍼티를-정의">객체 리터럴에 의한 객체의 생성 : 중괄호 (<code class="language-plaintext highlighter-rouge">{}</code>) 내에 0개 이상의 프로퍼티를 정의</h3>

<ul>
  <li>변수에 할당되는 시점에 자바스크립트 엔진이 객체 리터럴을 해석하여 객체를 생성</li>
  <li>객체 리터럴의 중괄호는 코드 블록을 의미하지 않음 → 중괄호 뒤에 세미콜론을 붙이지 않음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John',
  sayHello: function() {
    console.log('Hello');
  }
}
</code></pre></div></div>

<h2 id="프로퍼티-property--객체의-상태를-나타내는-값-data">프로퍼티 (<code class="language-plaintext highlighter-rouge">property</code>) : 객체의 상태를 나타내는 값 (<code class="language-plaintext highlighter-rouge">data</code>)</h2>

<ul>
  <li>객체는 0개 이상의 프로퍼티의 집합 → 프로퍼티는 키 (<code class="language-plaintext highlighter-rouge">key</code>)와 값 (<code class="language-plaintext highlighter-rouge">value</code>)으로 구성
    <ul>
      <li>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.</li>
      <li>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심볼 값 (<code class="language-plaintext highlighter-rouge">''</code>, <code class="language-plaintext highlighter-rouge">""</code>, 식별자)</li>
      <li>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John'
}
</code></pre></div></div>

<ul>
  <li>마침표 프로퍼티 접근 연산자 <code class="language-plaintext highlighter-rouge">.</code>나 대괄호 프로퍼티 접근 연산자 <code class="language-plaintext highlighter-rouge">[]</code>을 통해 프로퍼티 접근, 생성, 갱신, 삭제</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로퍼티 접근
console.log(person.name);
console.log(person[name]);
console.log(person[0]);

// 프로퍼티 갱신
person.name = 'Joo';

// 프로퍼티 동적 생성
person.age = 20;

// 프로퍼티 삭제
delete person.name;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ES6</code> 이후부터 객체 리터럴의 확장된 기능을 제공</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 프로퍼티 축약 표현
let name = 'Kim', age = 10;
const person = { name, age };

// 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const prefix = 'person';
let i = 0 ;
const obj = {
  [ ${prefix}-${++i} ] : i,
  [ ${prefix}-${++i} ] : i,
  [ ${prefix}-${++i} ] : i
};

// 메소드 축약 표현
const obj = {
  name: 'Lee',
  func() { console.log(this.name); }
};
</code></pre></div></div>

<blockquote>
  <p>자바스크립트 <code class="language-plaintext highlighter-rouge">V8</code> 엔진은 자바스크립트 객체의 프로퍼티에 접근하기 위해 동적 탐색 (<code class="language-plaintext highlighter-rouge">Dynamic Lookup</code>) 방식 대신, <a href="https://engineering.linecorp.com/ko/blog/v8-hidden-class">히든 클래스 (<code class="language-plaintext highlighter-rouge">Hidden Class</code>)</a> 방식으로 사용자 편의성과 일정한 성능을 모두 보장하고자 함</p>
</blockquote>

<h2 id="메소드-method--프로퍼티를-참조하고-조작할-수-있는-동작-behavior">메소드 (<code class="language-plaintext highlighter-rouge">method</code>) : 프로퍼티를 참조하고 조작할 수 있는 동작 (<code class="language-plaintext highlighter-rouge">behavior</code>)</h2>

<ul>
  <li>일반 함수와 달리, 메소드는 객체에 묶어 있는 함수를 의미
    <ul>
      <li>자바스크립트의 함수는 일급 객체이므로, 값으로 취급할 수 있어 프로퍼티 값으로 사용할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  name: 'John',
  getName: function() {
    return this.name;
  }
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[변수 (Variable) : 하나의 값을 저장할 수 있는 메모리 공간]]></summary></entry><entry><title type="html">[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)</title><link href="http://localhost:4000/js4/" rel="alternate" type="text/html" title="[JS] 4. 스코프 (Scope) &amp;amp; 실행 컨텍스트 (Execution Context)" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/js4</id><content type="html" xml:base="http://localhost:4000/js4/"><![CDATA[<h2 id="스코프-scope--변수에-접근할-수-있는-범위">스코프 (<code class="language-plaintext highlighter-rouge">Scope</code>) : 변수에 접근할 수 있는 범위</h2>

<ul>
  <li>변수가 선언되었을 때, 선언 위치에 의해 해당 변수에 접근할 수 있는 코드의 영역이 결정
    <ul>
      <li>자바스크립트 엔진은 스코프를 통해 참조 대상 식별자를 찾아 변수를 식별</li>
    </ul>
  </li>
</ul>

<h3 id="전역-스코프-global-level-scope--코드-어디에서나-참조-가능">전역 스코프 (<code class="language-plaintext highlighter-rouge">Global-level Scope</code>) → 코드 어디에서나 참조 가능</h3>

<ul>
  <li>전역에 선언된 전역 변수 (<code class="language-plaintext highlighter-rouge">Global variable</code>) 는 전역 객체 (<code class="language-plaintext highlighter-rouge">Global Object</code>)의 프로퍼티</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var global = 'global';

function main() {
  var local = 'local';
  console.log(global);
  console.log(local);
}

console.log(global);
console.log(local); // Uncaught ReferenceError: local is not defined
</code></pre></div></div>

<h3 id="함수-스코프-function-level-scope--함수-자신과-하위-함수에서만-참조-가능">함수 스코프 (<code class="language-plaintext highlighter-rouge">Function-level Scope</code>) → 함수 자신과 하위 함수에서만 참조 가능</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function () {
  var local = 'local';
  console.log(local);
})();
</code></pre></div></div>

<h3 id="블록-스코프-block-level-scope--블록-내에서만-참조-가능">블록 스코프 (<code class="language-plaintext highlighter-rouge">Block-level Scope</code>) → 블록 내에서만 참조 가능</h3>

<h3 id="렉시컬-스코프-lexical-level-scope">렉시컬 스코프 (<code class="language-plaintext highlighter-rouge">Lexical-level Scope</code>)</h3>

<h3 id="암묵적-전역-implicit-global">암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)</h3>

<h2 id="실행-컨텍스트-execution-context--실행할-코드에-제공할-환경-정보들을-모아놓은-객체">실행 컨텍스트 (<code class="language-plaintext highlighter-rouge">Execution Context</code>) : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;

function f1(x, y) {
  var gg = 11;   let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('first');
  { 
    const xx = 99;
    let lll = 0;
    f2('nest-first');
    var zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  function f2(t, u) { console.log(t, 'inner', xx, zz); }
  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); }
  var zz = 800;
  f2('second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f1(1,2);   console.log(kk, yy);

f2('third');
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/40dca0b0-9e4b-44d6-a36c-83aee24fc2e3" /></p>

<p><code class="language-plaintext highlighter-rouge">(1)</code> 전역 코드 평가 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg;  let bb;
function f1(x, y) { ... } // Function Object
function f2(g) { ... }    // Function Object
let xx;
var kk;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(2)</code> 전역 코드 실행 단계</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gg = 1;  let bb = 2;
let xx = 9;
if (gg &gt; 0) { ... }
f1(1,2);   console.log(kk, yy);
f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(3)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">if</code>문 코드 블록 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (gg &gt; 0) { // var gg = 1;
  var kk = 33; var yy = 9;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(4)</code> 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  var gg;   let bb;
  { ... }
  // function f2(t, u) { ... } // Function Object
  function f2(t, u, v) { ... } // Function Object
  var zz;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(5)</code> 함수 코드 평가 단계 내부의 블록 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">{ ... }</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  { 
    const xx;
    let lll;
    var zz;
    function f2(t) { ... } // Function Object
  }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(6)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length); // f1&gt; 11, 22, undefined, f2, 3
  f2('first');
  { ... }
  zz = 800;
  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(7)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  f2('first');

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(8)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  f2('first'); // first inner2 9 undefined

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(9)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  { 
    xx = 99;
    lll = 0;
    f2('nest-first');
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(10)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('nest-first')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;

  { 
    xx = 99;
    lll = 0;
    f2('nest-first'); // nest-first nested 99 undefined 0
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(11)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 호출</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }

  f2('second');
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(12)</code> 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f1(1,2)</code> 실행 → 함수 코드 실행 단계 : <code class="language-plaintext highlighter-rouge">f2('second')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  f2('second'); // second nested 99 800 0
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(13)</code> 전역 코드 실행 단계 (<code class="language-plaintext highlighter-rouge">console.log</code> 문 실행 및 종료)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1;  bb = 2;

console.log(kk, yy); // 33 9
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(14)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 평가</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third');
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(15)</code> 전역 코드 실행 단계 → 함수 코드 평가 단계 : <code class="language-plaintext highlighter-rouge">f2('third')</code> 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}

let xx = 9;
if (gg &gt; 0) { var kk = 33; var yy = 9; }

f2('third'); // third global f2&gt; 1 2 9 33
</code></pre></div></div>

<blockquote>
  <p><b>블록 코드 평가 및 실행</b></p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">Global</code>/<code class="language-plaintext highlighter-rouge">Function</code> 평가할 때 <code class="language-plaintext highlighter-rouge">Block scope</code>를 만나면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 생성한다.<br />(별도의 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>를 생성하지 않고 독립적인 <code class="language-plaintext highlighter-rouge">Lexical Environment</code>만을 생성한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block code</code>를 평가하여 이 <code class="language-plaintext highlighter-rouge">Block</code>에 대한 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>를 생성한다.</li>
    <li><code class="language-plaintext highlighter-rouge">const</code>/<code class="language-plaintext highlighter-rouge">let</code>은 <code class="language-plaintext highlighter-rouge">notInitializedYet</code> 상태로 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 등록되고, <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code> 선언식 등은 부모 <code class="language-plaintext highlighter-rouge">Function scope</code>의 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>에 <code class="language-plaintext highlighter-rouge">hoisting</code>한다.<br />(이때 <code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>가 아니라 <code class="language-plaintext highlighter-rouge">var</code>와 같이 <code class="language-plaintext highlighter-rouge">undefined</code>로 초기화한다.)</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 끝나면, 평가 종료 후 상위 <code class="language-plaintext highlighter-rouge">scope code</code>를 계속 평가한다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>이 실행되면, <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>를 만들고, 부모 <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 가져온다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code> 내의 <code class="language-plaintext highlighter-rouge">Function</code> 선언식은 무조건 <code class="language-plaintext highlighter-rouge">Block</code> 최상단에 <code class="language-plaintext highlighter-rouge">hoisting</code>되어 있으므로 먼저 실행한다.<br />(이 시점에 상위 <code class="language-plaintext highlighter-rouge">function-scope</code>에 함수를 정의해, <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>으로 인정된다!)</li>
    <li>그 외의 코드 (할당문 및 다른 함수 호출)를 한 줄씩 실행된다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>의 실행이 끝나면, <code class="language-plaintext highlighter-rouge">ExecutionContext</code>의 제어를 다시 부모로 돌려준다.</li>
    <li><code class="language-plaintext highlighter-rouge">Block</code>은 조건에 따라 실행 여부가 결정된다. 평가 시 블럭 내의 <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">function</code>은 <code class="language-plaintext highlighter-rouge">undefined</code>로 <code class="language-plaintext highlighter-rouge">hoisting</code>되고, 조건이 만족하여 호출 및 실행될 때에만 <code class="language-plaintext highlighter-rouge">Block Lexical Environment</code>와 <code class="language-plaintext highlighter-rouge">EnvironmentRecord</code>를 만들고 <code class="language-plaintext highlighter-rouge">&lt;function object&gt;</code>로 정의된다.</li>
  </ol>
</blockquote>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a69498fb-6f39-413d-8a75-ef547e4ba4b5" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1271743-b805-4040-9743-39e7b2cd5bda" /></p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5272ac93-d18b-4112-a45f-46d657839a3d" /></p>

<h2 id="엄격-모드-strict-mode--자바스크립트가-묵인한-에러를-발생시켜-엄격한-오류-검사를-적용">엄격 모드 (<code class="language-plaintext highlighter-rouge">Strict Mode</code>) : 자바스크립트가 묵인한 에러를 발생시켜 엄격한 오류 검사를 적용</h2>

<ul>
  <li>선언하지 않은 식별자는 접근할 수 없음</li>
  <li>암묵적 전역 (<code class="language-plaintext highlighter-rouge">Implicit Global</code>)은 허용하지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">Delete</code>로 선언된 변수, 함수, 매개변수를 삭제할 수 없음</li>
  <li>블록 내에서의 함수는 블록 스코프 (블록 내 함수는 볼록의 <code class="language-plaintext highlighter-rouge">DeclarativeEnvironmentRecord</code>에 존재)</li>
  <li>함수 내에서 매개변수의 이름이 동일해선 안됨</li>
  <li><code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">Infinite</code> 등의 전역 프로퍼티에 값을 할당해선 안됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'use strict';


var gg = 1;
let bb = 2;

function f1(x, y) {
  var gg = 11;
  let bb = 22;
  console.log('f1&gt;', gg, bb, zz, f2, f2.length);
  f2('* first');
  {
    const xx = 99;
    f2('* nest-first');
    var zz = 88;
    function f2(t) {
      console.log(t, '`nested`', xx, zz);
    }
  }
  function f2(t, u) {
    console.log(t, '`inner`', xx, zz);
  }
  function f2(t, u, v) {
    console.log(t, '`inner2`', xx, zz);
  }
  var zz = 800;
  console.log('gg:', gg);
  f2('* second');
}

function f2(g) {
  console.log(g, 'global f2&gt;', gg, bb, xx, kk);
}
let xx = 9;
if (gg &gt; 0) {
  var kk = 33;
  const yy = 9;
}
f1(1, 2); 
console.log('kkkkk&gt;&gt;', kk);
f2('* third');
</code></pre></div></div>

<h2 id="클로저-closure--함수가-특정-스코프에-접근할-수-있도록-의도적으로-그-스코프에서-정의한-것">클로저 (<code class="language-plaintext highlighter-rouge">Closure</code>) : 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의한 것</h2>

<ul>
  <li>상위 스코프의 식별자를 참조하는 하위 스코프 (함수, 메소드)가 외부에서 참조되어 상위 스코프보다 오래 살아있는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let user;
{
  const private = {
    id: 1,
    name: 'John'
  }
  user = private;
}

user.age = 30;

console.log(user); // { id: 1, name: 'John', age: 30 }
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func(x) {
  let clo = function (y) {
    console.log(y);
  }

  return clo(x);
}

func('a'); // a
</code></pre></div></div>

<blockquote>
  <p>클로저를 활용하여 외부변수로 인해 오염될 수 있는 비순수함수 (<code class="language-plaintext highlighter-rouge">Impure Function</code>)를, 함수 내부로 전달된 인수에게만 의존하여 반환값을 만드는 순수함수 (<code class="language-plaintext highlighter-rouge">Pure Function</code>)로 바꿀 수 있다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 비순수함수
let cnt1 = 0;

function func1(x) {
  cnt1 += 1;
  return cnt1;
}

console.log(func1()); // 1
console.log(func1()); // 2
console.log(func1()); // 3

// → 순수함수
function func2() {
  let cnt2 = 0;
  return function temp() {
    cnt2 += 1;
    return cnt2;
  };
}

const counter1 = func2();
const counter2 = func2();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
</code></pre></div>  </div>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[스코프 (Scope) : 변수에 접근할 수 있는 범위]]></summary></entry><entry><title type="html">[JS] 1. 자바스크립트 (JavaScript)</title><link href="http://localhost:4000/js1/" rel="alternate" type="text/html" title="[JS] 1. 자바스크립트 (JavaScript)" /><published>2024-01-24T00:00:00+09:00</published><updated>2024-01-29T00:00:00+09:00</updated><id>http://localhost:4000/js1</id><content type="html" xml:base="http://localhost:4000/js1/"><![CDATA[<h2 id="자바스크립트-javascript--동적-클라이언트-사이드-스크립트-언어">자바스크립트 (<code class="language-plaintext highlighter-rouge">JavaScript</code>) : 동적 클라이언트 사이드 스크립트 언어</h2>

<blockquote>
  <ul>
    <li>인터프리터 언어 (<code class="language-plaintext highlighter-rouge">Interpreter Language</code>) : 코드를 한 줄씩 읽어 해당 줄을 즉시 실행하는 프로그래밍 언어
      <ul>
        <li>런타임에 코드를 한 줄씩 해석해 실행 → 실행 단계에서 번역 (<code class="language-plaintext highlighter-rouge">Interpretation at Runtime</code>)</li>
        <li>변수의 타입을 런타임에 동적으로 결정 → 동적 타이핑 (<code class="language-plaintext highlighter-rouge">Dynamic Typing</code>)</li>
        <li>컴파일 언어에 비해 런타임은 비교적 느린 실행 속도를 갖고 있으나, 메모리를 비교적 작게 사용</li>
        <li>최근에는 브라우저가 실행된 시점에 필요한 부분을 동적으로 바로 컴파일하는 <code class="language-plaintext highlighter-rouge">Just-In-Time</code> 방식 채택</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li>웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 개발
    <ul>
      <li>초창기에는 웹 서버로부터 전달받은 <code class="language-plaintext highlighter-rouge">HTML/CSS</code>를 단순히 렌더링하는 수준에 머무름</li>
      <li>1999년, 비동기로 데이터를 교환하는 <code class="language-plaintext highlighter-rouge">Ajax</code> 기능이 도입돼, 필요한 데이터만 받아 렌더링하는 것이 가능해짐</li>
      <li>2006년, <code class="language-plaintext highlighter-rouge">DOM</code>을 쉽게 제어할 수 있는 <code class="language-plaintext highlighter-rouge">JQuery</code>가 등장</li>
      <li>2008년, 구글의 크롬 <code class="language-plaintext highlighter-rouge">V8</code> 자바스크립트 엔진으로 웹 서버에서 수행되던 로직이 브라우저로 이동</li>
      <li>2009년, <code class="language-plaintext highlighter-rouge">Node.js</code>로 브라우저 이외의 환경에서도 자바스크립트 엔진을 동작시킬 수 있게 됨
        <ul>
          <li>프런트엔드와 백엔드 모두에서 활용될 수 있는 동형성 (<code class="language-plaintext highlighter-rouge">isomorphic</code>)이 보장</li>
          <li>비동기 <code class="language-plaintext highlighter-rouge">I/O</code>를 지원하고 단일 스레드 이벤트 루프를 기반하여, 실시간 데이터 처리가 빈번한 <code class="language-plaintext highlighter-rouge">SPA</code>에 적합
            <ul>
              <li><code class="language-plaintext highlighter-rouge">SPA</code> (<code class="language-plaintext highlighter-rouge">Single Page Application</code>) : <code class="language-plaintext highlighter-rouge">React</code>, <code class="language-plaintext highlighter-rouge">Vue.js</code> 등</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>모든 브라우저에 내장된 브라우저 표준 프로그래밍 언어로 자리잡음
    <ul>
      <li>개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어 (<code class="language-plaintext highlighter-rouge">Interpreter Language</code>)</li>
      <li>모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해, 비교적 속도가 느린 인터프리터의 단점 해결</li>
      <li>명령형 (<code class="language-plaintext highlighter-rouge">imperative</code>), 함수형 (<code class="language-plaintext highlighter-rouge">functional</code>), 프로토타입 기반 (<code class="language-plaintext highlighter-rouge">prototype-based</code>), 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어</li>
    </ul>
  </li>
</ul>

<h3 id="브라우저-browser--웹-페이지를-서버에게-응답받은-html-css-javascript-파일로-표현">브라우저 (<code class="language-plaintext highlighter-rouge">Browser</code>) : 웹 페이지를 서버에게 응답받은 <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">JavaScript</code> 파일로 표현</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HTML</code>과 <code class="language-plaintext highlighter-rouge">CSS</code>는 브라우저 렌더링 엔진의 <code class="language-plaintext highlighter-rouge">HTML</code>와 <code class="language-plaintext highlighter-rouge">CSS</code> 파서에 의해 <code class="language-plaintext highlighter-rouge">DOM</code>과 <code class="language-plaintext highlighter-rouge">CSS Object Model</code> 트리로 파싱
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTML</code> 파서가 <code class="language-plaintext highlighter-rouge">Script</code> 태그를 만날 때, <code class="language-plaintext highlighter-rouge">DOM</code> 생성을 중단하고 <code class="language-plaintext highlighter-rouge">JavaScript</code> 엔진에게 제어권을 넘김</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Script</code> 태그의 위치에 따라 <code class="language-plaintext highlighter-rouge">DOM</code> 생성이 지연되므로, <code class="language-plaintext highlighter-rouge">DOM</code> 영역 아래에 스크립트 태그를 삽입하는 것을 권장한다.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Internal JavaScript</code> : <code class="language-plaintext highlighter-rouge">HTML</code> 태그의 속성 <code class="language-plaintext highlighter-rouge">script=""</code>에 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드를 넣는 방법</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
  alert ("Hello");
&lt;/script&gt;
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Linking JavaScript</code> : 별도의 <code class="language-plaintext highlighter-rouge">.js</code> 파일을 만들고 이를 <code class="language-plaintext highlighter-rouge">HTML</code> 문서와 연결하는 방법</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// hello.js
alert ("Hello");
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// index.html
&lt;script src="hello.js"&gt;&lt;/script&gt;
</code></pre></div></div>

<blockquote>
  <p>브라우저가 제공하는 개발자 도구 (<code class="language-plaintext highlighter-rouge">DevTools</code>) 기능</p>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c788a167-03a3-49c3-86b1-9340a67c688c" width="90%" /></p>
</blockquote>

<h3 id="nodejs--브라우저-밖에서-자바스크립트-코드를-실행하게-해주는-런타임-환경"><code class="language-plaintext highlighter-rouge">Node.js</code> : 브라우저 밖에서 자바스크립트 코드를 실행하게 해주는 런타임 환경</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>를 실행하여 웹 페이지를 브라우저 화면에 렌더링하는 브라우저와 달리, <code class="language-plaintext highlighter-rouge">Node.js</code> 는 브라우저 외부에서 자바스크립트를 실행할 수 있는 환경을 제공</p>

  <ul>
    <li>브라우저와 동일하게 자바스크립트의 코어인 <code class="language-plaintext highlighter-rouge">ECMScript</code>를 제공</li>
    <li>파싱된 <code class="language-plaintext highlighter-rouge">HTML</code> 요소를 선택 및 조작하는 <code class="language-plaintext highlighter-rouge">DOM API</code>이나 클라이언트 사이드 <code class="language-plaintext highlighter-rouge">Web API</code>를 제공되지 않음</li>
    <li>파일을 생성 및 수정할 수 있는 파일 시스템 및 <code class="language-plaintext highlighter-rouge">Node.js</code> 고유 <code class="language-plaintext highlighter-rouge">API</code> 제공</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">npm</code> : <code class="language-plaintext highlighter-rouge">Node.js</code>의 패키지를 관리할 수 있는 도구
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Node.js</code>에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 <code class="language-plaintext highlighter-rouge">CLI</code> 제공</li>
      <li><code class="language-plaintext highlighter-rouge">npx</code> (<code class="language-plaintext highlighter-rouge">node package execute</code>)을 통해 패키지를 설치 및 실행</li>
      <li>국내에서는 패키지 중복 문제를 링크 방식으로 해결한 <code class="language-plaintext highlighter-rouge">yarn</code>을 많이 사용하는 추세</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JS" /><summary type="html"><![CDATA[자바스크립트 (JavaScript) : 동적 클라이언트 사이드 스크립트 언어]]></summary></entry><entry><title type="html">자바스크립트 프로토타입 (2024.01.24)</title><link href="http://localhost:4000/digital_hanaro_study3/" rel="alternate" type="text/html" title="자바스크립트 프로토타입 (2024.01.24)" /><published>2024-01-24T00:00:00+09:00</published><updated>2024-01-26T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_study3</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_study3/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 3일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부하고자-한-이유">공부하고자 한 이유</h2>

<p>자바스크립트에서는 자바와 달리 클래스라는 개념이 없었고 대신 프로토타입을 통해 새로운 객체를 만드는 방식이라는 것을 알게 되었는데, 자바스크립트가 객체지향 프로그래밍을 하기 위해 어떻게 프로토타입이라는 개념을 사용하는지 궁금하였다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p>소프트웨어를 개발하는 과정에서 우리는 수많은 문제점들을 마주치고, 그에 대한 해결책을 찾아 문제를 해결하곤 한다. 소프트웨어 디자인 패턴은 이러한 수많은 문제점들에서 공통점을 가진 것들을 모아 여러 카테고리로 나누고, 이에 대한 해결책을 제시하여 이를 재사용이 가능하도록 한다. 소프트웨어 디자인 패턴은 크게 객체의 생성 방법과 클래스의 인스턴스화를 다루는 생성 패턴 (<code class="language-plaintext highlighter-rouge">Creational Pattern</code>), 클래스나 객체를 더 큰 구조로 합치는 구조 패턴 (<code class="language-plaintext highlighter-rouge">Structural Pattern</code>), 객체 간의 상호 작용 및 역할 분배를 다루는 행동 패턴 (<code class="language-plaintext highlighter-rouge">Behavioral Pattern</code>)으로 나뉜다. 프로토타입 패턴은 이들 중에 생성 패턴에 해당되며, 자신을 복제해서 인스턴스를 생성하는 방법에 대해 다룬다.</p>

<p>사전적인 의미의 프로토타입 (<code class="language-plaintext highlighter-rouge">Prototype</code>)이란, 원래의 형태 또는 전형적인 표준을 가리킨다. 소프트웨어 디자인 패턴에서는 생성한 객체들의 타입을 프로토타입인 인스턴스로부터 결정되도록 하고, 인스턴스는 새 객체를 만들기 위해 자신을 복제하는 프로토타입 패턴 (<code class="language-plaintext highlighter-rouge">Prototype Pattern</code>)의 개념으로 확장하였다.</p>

<p><code class="language-plaintext highlighter-rouge">Java</code>에서 클래스의 인스턴스를 만들기 위해서는, 우리는 일반적으로 <code class="language-plaintext highlighter-rouge">new()</code>를 통해 클래스 이름을 지정하고 인스턴스를 생성한다. 프로토타입 패턴은 <code class="language-plaintext highlighter-rouge">new()</code>를  통해 생성자로 인스턴스를 복제하는 것이 아닌, <code class="language-plaintext highlighter-rouge">clone()</code> 메소드를 선언하는 추상 베이스 클래스를 하나 만들어 생성자가 필요한 클래스가 있으면 이 클래스를 상속하고 <code class="language-plaintext highlighter-rouge">clone()</code> 메소드 내의 코드를 구현하게끔 한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Prototype</code> : 프로토타입을 만드려는 객체 클래스의 인터페이스
    <ul>
      <li>인터페이스를 통해서 <code class="language-plaintext highlighter-rouge">clone</code>을 상속받고, 프로토타입 객체들을 이 공통 타입으로 받음 (다형성 보장)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface Prototype {
    public Prototype clone();
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConcretePrototype</code> : 프로토타입의 인터페이스 구현
    <ul>
      <li><code class="language-plaintext highlighter-rouge">clone()</code> : 생성자에 자신의 타입을 가진 객체를 넘기고, 초기화를 위해 패러미터로 받는 생성자를 생성함</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Circle implements Prototype {
    private int x;
    private int y;

    public Circle(Circle prototype) {
        this.x = prototype.x;
        this.y = prototype.y;
    }

    public Circle(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public Prototype clone() {
        return new Circle(this);
    }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Sub-Class</code> : 상위 클래스에 값을 전달할 하위 클래스</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class RedCircle extends Circle {
    private String color;

    public RedCircle(RedCircle prototype) {
        super(prototype);
        this.color = prototype.color;
    }

    public RedCircle(Circle circle, String color) {
        super(circle);
        this.color = color;
    }

    public RedCircle(int x, int y, String color) {
        super(x, y);
        this.color = color;
    }

    public getColor() {
      return this.color;
    }

    public Prototype clone() {
        return new RedCircle(this);
    }
}
</code></pre></div></div>

<ul>
  <li>클라이언트 클래스 : 프로토타입 인터페이스를 통해 객체를 생성함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Client {
    Prototype circle = new Circle(3, 5);
    Prototype redCircle1 = new RedCircle(3, 5, "red");
    Prototype redCircle2 = new RedCircle((Circle) circle, "red");

    Prototype newCircle = circle.clone();
    Prototype newRedCircle = redCircle1.clone();

    newCircle.getColor(); // 에러
    newRedCircle.getColor();
}
</code></pre></div></div>

<p>위 예시는 자바에서 프로토타입 패턴을 적용한 사례이다. 프로토타입 패턴을 통해 객체를 복제하는 책임이 기존 클래스에서 복제하는 객체로 넘어가나, 이럴 경우에는 객체를 이용하려면 타입을 알아야 한다. 타입이 동적으로 변하는 자바스크립트의 경우에는 이 패턴을 객체를 생성하는 방식으로 활용한다. 자바스크립트는 기본 데이터 타입을 제외한 나머지는 모두 객체인데, 객체 안에 <code class="language-plaintext highlighter-rouge">__proto__</code> 속성이 존재한다. <code class="language-plaintext highlighter-rouge">__proto__</code> 속성은 객체가 만들어지기 위해 사용되는 원형인 프로토타입 객체를 숨은 경로로 참조하는 역할을 한다.</p>

<p>모든 객체는 프로토타입 객체에 접근할 수 있으며, 프로토타입 객체 역시 동적으로 런타임에 멤버를 추가할 수 있다. 또한 같은 원형을 복사로 생성된 모든 객체는 추가된 멤버를 사용할 수 있다. 코드 재사용의 대표적인 방식인 상속을 예시로 들어보자. 자바스크립트의 상속을 <code class="language-plaintext highlighter-rouge">classical</code>이 아닌 <code class="language-plaintext highlighter-rouge">prototypal</code> 방식으로 생성한다면, 리터럴 혹은 <code class="language-plaintext highlighter-rouge">Object.create()</code>를 이용해 객체를 생성하고 확장한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var person = {
  type: 'person',
  getType: function() { return this.type; },
  getValue: function () { return this.value; };
}

var pocj8ur4in = Object.create(person);
pocj8ur4in.type = "developer";
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 3일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[SpringBoot] 2. SpringBoot Common Task</title><link href="http://localhost:4000/springboot2/" rel="alternate" type="text/html" title="[SpringBoot] 2. SpringBoot Common Task" /><published>2024-01-22T00:00:00+09:00</published><updated>2024-01-22T00:00:00+09:00</updated><id>http://localhost:4000/springboot2</id><content type="html" xml:base="http://localhost:4000/springboot2/"><![CDATA[<h2 id="어플리케이션-설정-관리--여러-환경에-따른-설정-정보의-다중화">어플리케이션 설정 관리 : 여러 환경에 따른 설정 정보의 다중화</h2>

<ul>
  <li>개발 환경의 다중화 → 개발 (<code class="language-plaintext highlighter-rouge">dev</code>), 테스트 (<code class="language-plaintext highlighter-rouge">test</code>), 스테이징 (<code class="language-plaintext highlighter-rouge">staging</code>), 배포 (<code class="language-plaintext highlighter-rouge">prod</code>)
    <ul>
      <li>여러 환경에 배포할 때 설정 정보는 매번 변경되어야 하지만, 소스 코드는 변경되어선 안됨</li>
      <li>즉, 설정 정보를 외부화하여 관리할 필요성이 있음</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>어플리케이션 설정 관리 방법의 우선순위</p>

  <ol>
    <li>명령행 인자</li>
    <li>운영 체제의 환경 변수</li>
    <li>설정 정보 파일 (<code class="language-plaintext highlighter-rouge">application.properties</code> 혹은 <code class="language-plaintext highlighter-rouge">application.yml</code>)</li>
    <li><code class="language-plaintext highlighter-rouge">@PropertySource</code></li>
    <li><code class="language-plaintext highlighter-rouge">SpringApplication</code></li>
  </ol>
</blockquote>

<h3 id="springapplication-클래스-사용"><code class="language-plaintext highlighter-rouge">SpringApplication</code> 클래스 사용</h3>

<ul>
  <li>소스 코드로 정의하는 방식이므로 한 번 정의하면 나중에 바뀌지 않는 경우에 적합함</li>
  <li><code class="language-plaintext highlighter-rouge">java.util.Properties</code>나 <code class="language-plaintext highlighter-rouge">java.util.Map&lt;String, Object&gt;</code>가 인자인 <code class="language-plaintext highlighter-rouge">setDefaultProperties()</code> 메소드 호출
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Properties</code>나 <code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>를 통해 설정 정보를 어플리케이션에 적용</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/41016cdc-001c-4c27-bc87-3d366061017f" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application.properties</code> 파일은 다른 설정 파일들을 <code class="language-plaintext highlighter-rouge">spring.config.import</code> 프로퍼티를 통해 임포트해서 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">spring.config.import=classpath:additional-application.properties</code>를 추가하면 스프링부트는 <code class="language-plaintext highlighter-rouge">additional-application.properties</code> 파일에 있는 설정 정보를 읽어 사용할 수 있음
        <ul>
          <li>만약 클래스패스에 파일이 없으면, <code class="language-plaintext highlighter-rouge">ConfigDataLocationNotFoundException</code> 예외가 발생</li>
          <li><code class="language-plaintext highlighter-rouge">spring.config.on-not-found</code>에 <code class="language-plaintext highlighter-rouge">ignore</code>를 지정하면, 클래스파일에 설정 파일이 없을 때 예외 처리를 하고 종료하는 대신 어플리케이션 시동 작업을 계속 진행하게 할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="propertysource-사용"><code class="language-plaintext highlighter-rouge">@PropertySource</code> 사용</h3>

<ul>
  <li>설정 파일의 위치를 어노테이션을 사용해 지정 (자바 8 이후로는 동일한 어노테이션을 여러 번 사용할 수 있음)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">src/main/resources/</code>의 파일은 <code class="language-plaintext highlighter-rouge">JAR</code>로 패키징된 후 클래스패스에 위치하므로, 해당 디렉터리에 설정 파일 작성</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/080afe26-f960-4980-8551-1acc165c7d0e" width="80%" /></p>

<ul>
  <li>스프링이 제공하는 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스를 주입받으면, 설정 파일에 있는 정보를 읽을 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@SpringBootApplication
public class SpringBootApplication {
    public static final Logger log = Logger.getLogger(SpringBootApplication.class);

    public static void main(String[] args) {
        ConfigurableApplicationContext configurableApplicationContext
         = SpringApplication.run(SpringBootApplication.class, args);

        CustomConfiguration customConfiguration
         = applicationContext.getBean(CustomConfiguration.class);

        log.info(customConfiguration.toString());
    }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@PropertySource</code>로는 <code class="language-plaintext highlighter-rouge">.yml</code> 파일 지정해서 사용할 수 없으므로, 추가적인 작업이 필요</li>
</ul>

<h3 id="환경-설정-파일-applicationproperties-또는-applicationyml">환경 설정 파일 (<code class="language-plaintext highlighter-rouge">application.properties</code> 또는 <code class="language-plaintext highlighter-rouge">application.yml</code>)</h3>

<ul>
  <li>환경 설정 파일에 명시된 설정 프로퍼티 정보는 스프리의 <code class="language-plaintext highlighter-rouge">Environment</code> 객체에 로딩
    <ul>
      <li>어플리케이션 클래스에서 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스나 <code class="language-plaintext highlighter-rouge">@Value</code> 어노테이션을 통해 설정 정보를 읽을 수 있음</li>
      <li><code class="language-plaintext highlighter-rouge">spring.config.name</code> 프로퍼티로 환경 설정 파일의 이름을 지정할 수 있음</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>스프링부트가 기본적으로 읽는 환경 설정 파일의 위치는,</p>

  <ul>
    <li>클래스패스 루트</li>
    <li>클래스패스 <code class="language-plaintext highlighter-rouge">/config</code> 패키지</li>
    <li>현재 디렉터리</li>
    <li>현재 디렉터리 <code class="language-plaintext highlighter-rouge">/config</code> 디렉터리</li>
    <li><code class="language-plaintext highlighter-rouge">/config</code> 디렉터리의 바로 하위에 위치한 디렉터리</li>
  </ul>

  <p>추가로, <code class="language-plaintext highlighter-rouge">spring.config.location</code> 프로퍼티를 통해 상대 경로나 절대 경로의 환경 설정 파일을 읽을 수 있음<br />(<code class="language-plaintext highlighter-rouge">optional:</code> 접두어를 통해 해당된 경로에 환경 설정 파일이 없더라도, 예외 처리 없이 스프링부트 기본 설정값으로 실행할 수 있음)</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -jar target/config-data-file.jar --spring.config.location=optional:data/application.yml
</code></pre></div>  </div>

  <blockquote>
    <p><code class="language-plaintext highlighter-rouge">spring.config.name</code>과 <code class="language-plaintext highlighter-rouge">spring.config.properties</code>는 환경 설정 파일에 지정할 수 없음<br />→ <code class="language-plaintext highlighter-rouge">SpringApplication.setDefaultProperties()</code> 메소드나 환경 변수, 혹은 명령행 인자를 통해 지정</p>
  </blockquote>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application-{profile}.properties</code> : 프로파일 (<code class="language-plaintext highlighter-rouge">profile</code>)별로 프로퍼티 파일 지정 가능
    <ul>
      <li>환경 설정 파일의 <code class="language-plaintext highlighter-rouge">spring.profile.active</code> 프로퍼티를 통해 프로파일를 지정하면, 프로퍼티 파일의 내용이 로딩</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {
    // ...
}
</code></pre></div></div>

<blockquote>
  <p>설정 파일의 로딩 순서</p>

  <ol>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 안에 패키징되는 환경 설정 파일</li>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 안에 패키징되는 <code class="language-plaintext highlighter-rouge">profile</code>별 환경 설정 파일</li>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 밖에서 패키징되는 환경 설정 파일</li>
    <li>어플리케이션 <code class="language-plaintext highlighter-rouge">JAR</code> 파일 안에 패키징되는 <code class="language-plaintext highlighter-rouge">profile</code>별 환경 설정 파일</li>
  </ol>
</blockquote>

<h3 id="운영-체제의-환경-변수">운영 체제의 환경 변수</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application.properties</code> 파일에서 <code class="language-plaintext highlighter-rouge">app.timeout</code> 커스텀 프로퍼티를 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app.timeout=${APP_TIMEOUT}
</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c8c54862-d56a-43d8-b491-dc1251c7e0d1" width="80%" /></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ConfigurableApplicationContext</code> 인스턴스에 접근</li>
  <li><code class="language-plaintext highlighter-rouge">Environment</code> 빈을 가져옴</li>
  <li>프로퍼티 값을 <code class="language-plaintext highlighter-rouge">env.getProperty()</code> 메소드로 읽어 콘솔 로그로 출력</li>
</ol>

<h2 id="configurationproperties--커스텀-프로퍼티-생성"><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> : 커스텀 프로퍼티 생성</h2>

<blockquote>
  <p>스프링부트 빌트인 프로퍼티 전체 목록은 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html">공식 래퍼런스 문서</a>에서 확인 가능</p>
</blockquote>

<ul>
  <li>스프링 어플리케이션이 복잡해지고 기능이 많아질수록, 커스텀 프로퍼티의 필요성이 높아짐
    <ul>
      <li>외부 <code class="language-plaintext highlighter-rouge">REST</code> 웹 서비스 <code class="language-plaintext highlighter-rouge">URL</code>이나 특정 기능 활성화 여부를 지정할 <code class="language-plaintext highlighter-rouge">boolean</code> 플래그 등</li>
    </ul>
  </li>
</ul>

<h3 id="environment-인스턴스-주입을-통한-프로퍼티-값-사용"><code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스 주입을 통한 프로퍼티 값 사용</h3>

<ul>
  <li>스프링의 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스에 프로퍼티가 바인딩 → <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스를 주입받아 프로퍼티 값 사용 가능</li>
  <li>프로퍼티 값의 타입 안정성 (<code class="language-plaintext highlighter-rouge">Type-Safety</code>)이 보장되지 않아, 이로 인해 런타임 에러가 발생할 수 있음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">URL</code>이나 이메일 주소를 프로퍼티로 사용할 때 유효성 검증 (<code class="language-plaintext highlighter-rouge">Vadlidation</code>)을 수행할 수 없음</li>
    </ul>
  </li>
  <li>프로퍼티 값을 일정한 단위로 묶어서 읽을 수 없음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Value</code> 어노테이션이나 스프링의 <code class="language-plaintext highlighter-rouge">Environment</code> 인스턴스를 사용해서 하나하나 개별적으로만 읽을 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="configurationproperties-어노테이션을-사용한-커스텀-프로퍼티-정의"><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 어노테이션을 사용한 커스텀 프로퍼티 정의</h3>

<blockquote>
  <p>요구 사항 : 커스텀 프로퍼티에 대한 타입 안정성을 보장하고, 값의 유효성을 검증해야 한다.</p>
</blockquote>

<ul>
  <li>스프링부트 설정 처리기 (<code class="language-plaintext highlighter-rouge">Configuration Processor</code>)를 통해 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>이 붙은 클래스에 대한 메타데이터 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">spring-boot-configuration-processor</code> 의존 관계를 추가해 스프링부트 설정 처리기를 활성화</li>
      <li>생성된 메타데이터는 환경 설정 파일에 기술된 프로퍼티에 대한 자동 완성이나 문서화 지원</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring.config.import</code>와 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>을 함께 사용해, 연관된 프로퍼티들을 그룹화한 프로퍼티 파일로 관리 가능</li>
  <li><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 어노테이션을 클래스 안에서 빈을 생성하는 <code class="language-plaintext highlighter-rouge">@Bean</code> 메소드에도 붙일 수 있음</li>
  <li>아래처럼 생성자를 사용해서 바인딩하는 방식이 아닌, <code class="language-plaintext highlighter-rouge">setter</code> 메소드를 통해 바인딩하는 방식 또한 가능</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/264e5990-ee36-44a5-bfe3-420b68fd02d2" width="80%" /></p>

<ul>
  <li>커스텀 프로퍼티를 사용하려면 환경 설정 파일에 해당 프로퍼티에 대한 정보를 추가해야 함</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8f9f02c6-0ce3-4bb0-b9c4-a5534462fbc3" width="80%" /></p>

<ul>
  <li>프로퍼티를 정의하고 이를 담은 <code class="language-plaintext highlighter-rouge">AppProperties</code> 클래스를 통해 서비스 클래스에서 <code class="language-plaintext highlighter-rouge">AppProperties</code> 객체를 주입받을 수 있음</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ac00105a-cd9c-4b8c-8dfa-14bf4d1c49ed" width="80%" /></p>

<ul>
  <li>스프링부트 어플리케이션 클래스는 서비스 클래스를 사용해서 <code class="language-plaintext highlighter-rouge">AppProperties</code> 객체에 접근하여 프로퍼티 값을 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@EnableConfigurationProperties</code> 어노테이션은 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>이 붙은 클래스를 스프링 컨테이너에 등록</li>
      <li><code class="language-plaintext highlighter-rouge">@ConfigurationPropertiesScan</code> 어노테이션으로 기준 패키지을 지정하면, 지정 패키지 하위에 있는 <code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code>가 붙은 클래스를 모두 탐색해서 스프링 컨테이너에 등록</li>
      <li><code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 어노테이션이 붙은 클래스를 자동 탐색해서 등록하는 것이 아니라 직접 명시해야 함</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1975bd6-5a08-44eb-914e-572a5d539585" width="80%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConstructorBinding</code> 어노테이션을 <code class="language-plaintext highlighter-rouge">POJO</code> 클래스에 사용하면, 생성자를 통해 프로퍼티 정보값이 설정
    <ul>
      <li>생성자가 하나만 있으면 클래스에, 생성자가 여러 개라면 프로퍼티 정보값 설정에 사용할 생성자에 어노테이션을 붙이면 됨</li>
      <li>설정 정보 클래스의 불변성을 보장하기 위해선 세터 바인딩 대신 생성자 바인딩으로 프로퍼티 값을 설정해야 함</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3ae42b22-9e2e-47cb-a8fb-3d2f25357007" width="80%" /></p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="SpringBoot" /><summary type="html"><![CDATA[어플리케이션 설정 관리 : 여러 환경에 따른 설정 정보의 다중화]]></summary></entry><entry><title type="html">TailwindCSS란? (2024.01.22)</title><link href="http://localhost:4000/digital_hanaro_study2/" rel="alternate" type="text/html" title="TailwindCSS란? (2024.01.22)" /><published>2024-01-22T00:00:00+09:00</published><updated>2024-01-22T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_study2</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_study2/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 2일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부하고자-한-이유">공부하고자 한 이유</h2>

<p>토이 프로젝트를 만들 때 부트스트랩 (<code class="language-plaintext highlighter-rouge">Bootstrap</code>)을 많이 활용하여 화면을 구성하곤 하였는데, 오늘 강사님께서 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>라는 새로운 프론트엔드 프레임워크 기술에 대해 말씀해주시면서, 현재는 부트스트랩보다 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>를 사용한 사이트가 훨씬 다수임을 알려주셨다. 그래서 향후 토이 프로젝트에 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>를 적용할 수 있도록 부트스트랩과 차이점을 비교해보면서 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>에 대해 공부해보고자 한다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p>부트스트랩 (<code class="language-plaintext highlighter-rouge">BootStrap</code>)은 2011년에 트위터에서 시작된 오픈 소스 프론트엔드 프레임워크이다. 글자, 인용문, 목록, 표 등 자잘한 요소부터 메뉴, 바, 버튼 등까지 웹 페이지에서 자주 쓰이는 요소들을 모두 내장하고 있어, 부트스트랩의 <code class="language-plaintext highlighter-rouge">CSS</code>와 <code class="language-plaintext highlighter-rouge">JS</code>를 사이트에 반영만 하면 일정한 디자인을 빠른 시간 내에 제작할 수 있다. 그리고 데스크탑만이 아니라 모바일 화면 또한 비율에 맞게 반응형으로 지원하여 크로스 브라우저 (<code class="language-plaintext highlighter-rouge">Cross-Browser</code>) 환경에도 적합하다. 또한 해상도 크기에 맞게 자동으로 정렬되고 크기 조절이 가능한 그리드 시스템 (<code class="language-plaintext highlighter-rouge">Grid System</code>)이 내장되어 있어 화면에 특정한 요소를 배치하는 것에 대한 커스텀마이징 또한 매우 간단한 편이다. <a href="https://getbootstrap.com">부트스트랩 공식 웹 사이트</a>에서 여러 예시 화면들을 볼 수도 있다.</p>

<p>나 같은 경우에는 전문적인 프론트엔드 개발자가 아니라서, 부트스트랩을 처음 접했을 때에는 블로그를 운영하는 과정에서 배운 <code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>에 대한 지식들만 있는 상태였다. 그러나 예시 화면들의 각 요소들을 직접 뜯어보고 수정하는 과정에서 사용해본 내부 클래스들로만으로도 내가 필요로 한 화면들을 금방금방 구성해낼 수 있었다. 아래의 화면은 내가 기획하였던 사이트의 노래 검색 화면으로, 화면 구상에서 실제 구현까지 2~3일 정도 걸린 것으로 기억한다. <code class="language-plaintext highlighter-rouge">Header</code>와 <code class="language-plaintext highlighter-rouge">Footer</code> 부분은 템플릿 엔진을 통해 이전에 만든 요소를 그대로 사용하였고, 상세 검색 화면은 그리드 시스템과 내장된 글자 및 버튼 속성을 적절히 적용하여 구현하였다. 그리고 버튼을 눌렀을 때 나올 수 있는 동작들, 예를 들어 마우스 포커싱 기능들도 <code class="language-plaintext highlighter-rouge">CSS</code>로 구현되어 있어 따로 만들 필요가 없었다. 그리고 작년에 <code class="language-plaintext highlighter-rouge">7</code> 버전이 출시될 만큼 꾸준한 개발 및 지원이 이루어지고 있고, 또 부트스트랩을 사용하는 웹 사이트 및 래퍼런스들도 여전히 많이 존재한다.</p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/625ec1e6-55ec-48a3-9ae8-5b415405f4b1" /></p>

<p>그럼 부트스트랩 대신에 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>가 대세가 된 이유는 무엇일까? 내가 처음 떠올린 이유는 부트스트랩만으로는 생각보다 직접 커스텀마이징을 하는 데에 한계가 있다는 것이다. 물론 오픈 소스이므로 래퍼런스가 정말 많고, 원하는 페이지를 만드는 것도 얼마든지 가능한 것 또한 사실이다. 그런데 사실 이건 <code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>을 다룰 수 있으면 얼마든지 가능한 부분이고, 이젠 피그마 등을 활용해 원하는 화면을 빠르게 배치해 만드는 것도 가능하다. 오히려 부트스트랩 기반으로 한, 비슷한 디자인의 사이트들이 많아져서 타 사이트와의 차별성을 두기 어려운 부분 또한 맞는 말이라고 생각한다. 부트스트랩의 취지는 <code class="language-plaintext highlighter-rouge">HTML/CSS/JS</code>들을 미리 만들어 개발자가 사용할 수 있는 것인데, 내가 구현하지 않는 부분까지 빌트인 (<code class="language-plaintext highlighter-rouge">built-in</code>)되어 있다보니, 부트스트랩 자제 문법을 공부하는 데에도 시간이 꽤 걸린다.</p>

<p>그러면 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>에 대해 알아보자. <code class="language-plaintext highlighter-rouge">TailwindCSS</code>는 2017년에 <code class="language-plaintext highlighter-rouge">Tailwind Labs</code>에서 개발한 <code class="language-plaintext highlighter-rouge">CSS</code> 프레임워크이다. <code class="language-plaintext highlighter-rouge">TailwindCSS</code>는 <code class="language-plaintext highlighter-rouge">CSS</code>를 작성하지 않고 클래스 이름을 제공하여 <code class="language-plaintext highlighter-rouge">HTML</code>에 필요한 <code class="language-plaintext highlighter-rouge">CSS</code> 유틸리티만 입혀도 스타일이 완성되는 ‘유틸리티 우선 <code class="language-plaintext highlighter-rouge">CSS</code>‘를 지향한다. <a href="https://tailwindcss.com"><code class="language-plaintext highlighter-rouge">TailwindCSS</code> 공식 사이트</a>를 보면, 클래스 이름만 적어도 <code class="language-plaintext highlighter-rouge">CSS</code>가 적용되는 여러 예시들을 볼 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div&gt;
    &lt;style&gt;
    .rainbow-block {
      display: inline-block;
      width: 100%;
      height: 150px;
      background: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);
    }
  &lt;/style&gt;
  &lt;div class="rainbow-block"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre></div></div>

<div>
    <style>
    .rainbow-block {
      display: inline-block;
      width: 100%;
      height: 150px;
      background: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);
    }
  </style>
  <div class="rainbow-block"></div>
</div>

<p>무지개색 블록을 만들고자 할 때, 순수 <code class="language-plaintext highlighter-rouge">CSS</code>는 위의 스타일 코드를 적어야 한다. 반면 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>는 아래의 예시처럼 미리 정의된 유틸리티 클래스들을 활용하여 클래스 이름만으로 스타일을 적용할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

.rainbow-block {
  @apply inline-block w-32 h-32 bg-gradient-to-r from-violet to-red;
}
</code></pre></div></div>

<p>사실 이게 왜 장점이지? 할 수도 있다. 어쨌든 <code class="language-plaintext highlighter-rouge">HTML/CSS</code> 또한 기능 자체를 제공하기는 한다! 하지만 <code class="language-plaintext highlighter-rouge">TailwindCSS</code>가 제공하는 유틸리티 클래스는 부트스트랩의 장점인 일관성 있는 디자인을 가지면서, 기본 스타일 값을 직접 커스텀마이징할 수 있는 <code class="language-plaintext highlighter-rouge">key-value</code>를 제공한다. 그리고 로우 레벨의 스타일 또한 제공하므로, 미리보기, 자동완성, 신택스 하이라이팅 및 린팅을 지원하는 <code class="language-plaintext highlighter-rouge">IntelliSense</code> 플러그인을 활용하여 필요한 디자인을 세밀하게 구현할 수 있다. 무엇보다 프론트엔드 개발자가 가장 장점으로 꼽는 부분은 <b>클래스 이름을 고민하지 않아도 된다는 점</b>인데, 이건 함수의 이름을 잘 짓기 위해 프로젝트 시작 전에 매번 고민하는 시간을 갖는 나에게도 와닿는 문제라 공감이 가는 부분이 많다.</p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 2일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">프로그래밍 언어로서의 JavaScript와 TypeScript (2024.01.19)</title><link href="http://localhost:4000/digital_hanaro_study1/" rel="alternate" type="text/html" title="프로그래밍 언어로서의 JavaScript와 TypeScript (2024.01.19)" /><published>2024-01-19T00:00:00+09:00</published><updated>2024-01-19T00:00:00+09:00</updated><id>http://localhost:4000/digital_hanaro_study1</id><content type="html" xml:base="http://localhost:4000/digital_hanaro_study1/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/finance-dev-study">디지털하나路 스터디</a> 1일차 내용을 정리한 글입니다.</p>
</blockquote>

<h2 id="공부하고자-한-이유">공부하고자 한 이유</h2>

<p><code class="language-plaintext highlighter-rouge">JavaScript</code>와 <code class="language-plaintext highlighter-rouge">TypeScript</code>는 그동안 내가 주로 사용해온 <code class="language-plaintext highlighter-rouge">C</code>, <code class="language-plaintext highlighter-rouge">C++</code>, <code class="language-plaintext highlighter-rouge">Java</code>와 같은 컴파일 언어와는 많은 차이점이 있는 스크립트 언어이다. 오늘은 본격적으로 자바스크립트를 배우기 앞서 자바스크립트와 타입스크립트가 프로그래밍 언어로서 어떤 특성을 가지는지 알아보고자 한다.</p>

<h2 id="공부한-내용">공부한 내용</h2>

<p>프로그래밍 언어 (<code class="language-plaintext highlighter-rouge">Programming Language</code>)는 기계가 읽을 수 있고, 사람이 읽을 수 있는 형식으로, 계산을 서술하기 위한 표기 체계이다. 여기에서 주목할 점은 ‘사람이 읽을 수 있는 형식으로’이다. 사실 기계의 성능을 가장 높이는 방법은 기계의 방식을 그대로 따르는 것이지만, 프로그래밍 언어는 사람의 편의성을 위해 지속적으로 여러 개념들을 도입하였다. 대표적인 예시로 추상화 (<code class="language-plaintext highlighter-rouge">Abstraction</code>)이 있다. 추상화는 속성들의 일부분만으로, 주어진 작업이나 객체를 필요한 정도로만 묘사하는 것이다. 예를 들어 <code class="language-plaintext highlighter-rouge">int x;</code>라는 구문이 있을 때, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">;</code>는 해당 단어나 기호를 아는 사람들에게 있어 어떤 의미를 가진다는 것을 유추할 수 있게끔 한다. 그리고 컴퓨터 역시 예약어인 <code class="language-plaintext highlighter-rouge">int</code>나 <code class="language-plaintext highlighter-rouge">;</code>가 어떤 의미를 가질 때, 그리고 <code class="language-plaintext highlighter-rouge">x</code>라는 단어가 쓰였을 때 어떤 일련의 작업, 즉 명령의 순차적 실행, 위치를 표현할 변수의 사용, 그리고 변수의 값을 변경하는 배정문의 사용 등을 진행하면 되는지 알고 있다.</p>

<p>이 ‘사람이 읽을 수 있는 형식으로’라는 조건은 계산을 서술하는 방식에도 영향을 미쳤다. 앞서 설명한 일련의 흐름을 그대로 진행하는 언어는 절차 언어 (<code class="language-plaintext highlighter-rouge">Procedural Language</code>)라고 부른다. 하지만, 절차 언어는 계산이 순차적인 명령에 의하여 실행되어야 하기 때문에 공유 버스 (<code class="language-plaintext highlighter-rouge">Shared Bus</code>) 내에서 폰 노이만 병목 현상이 발생한다. <code class="language-plaintext highlighter-rouge">RAM</code>과 <code class="language-plaintext highlighter-rouge">CPU</code>의 속도 차이가 발생하는 하드웨어적 한계를 극복하지 못한 것이다. 또한 절차 언어는 많은 자료를 동시에 적용하는 연산, 아직 계산할 값이 아직 할당되지 않은 비결정적인 연산, 혹은 순서에 의존하지 않는 비절차적인 연산을 기술하는 데에 비효율적이다. 그래서 이 한계를 극복하기 위해 나온 방식이 바로 함수형 언어와 논리형 언어이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 절차형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램

// 단계 1: 사용자로부터 두 수를 입력받기
var num1 = parseFloat(prompt("첫 번째 숫자를 입력하세요:"));
var num2 = parseFloat(prompt("두 번째 숫자를 입력하세요:"));

// 단계 2: 입력받은 수를 더하기
var sum = addNumbers(num1, num2);

// 단계 3: 결과 출력
alert("두 수의 합은 " + sum + "입니다.");

// 함수: 두 수를 더하는 함수 정의
function addNumbers(a, b) {
  return a + b;
}
</code></pre></div></div>

<p>함수형 언어 (<code class="language-plaintext highlighter-rouge">Functional Language</code>)는 알려진 값들을 함수들에 적용하는 것을 기반에 둔다. 함수형 언어에서의 계산은 아래의 예시와 재귀적 함수를 활용해 기술된다. 함수형 언어에서의 함수는 함수에 변수를 할당하거나 인자로 전달할 수 있는 일급 객체 (<code class="language-plaintext highlighter-rouge">First-Class</code>)로 취급하면서, 주어진 입력에 대해 항상 동일한 출력을 생성하는 불변성 (<code class="language-plaintext highlighter-rouge">Immutability</code>)의 특성을 가진다. 실제로 함수형 언어는 변수나 변수에 대한 배정문이 존재하지 않는 대신 함수와 함수를 평가하고 호출하는 방법을 제공한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 함수형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램

// 단계 1: 사용자로부터 두 수를 입력받기
var num1 = parseFloat(prompt("첫 번째 숫자를 입력하세요:"));
var num2 = parseFloat(prompt("두 번째 숫자를 입력하세요:"));

// 단계 2: 두 수를 더하는 함수 정의
function addNumbers(a, b) {
  return a + b;
}

// 단계 3: 입력받은 수를 더하기
var sum = addNumbers(num1, num2);

// 단계 4: 결과 출력
alert("두 수의 합은 " + sum + "입니다.");
</code></pre></div></div>

<p>논리형 언어 (<code class="language-plaintext highlighter-rouge">Logical Language</code>)은 논리적인 규칙과 규칙 간의 관계를 정의해, 순서가 아닌 무엇을 하고자 하려는지 기술하는 방식으로, 계산의 내용만을 선언하듯이 기술한다. 그렇기 때문에 논리형 언어는 선언적 언어 (<code class="language-plaintext highlighter-rouge">Declarative Language</code>)로 불리기도 한다. 그래서 논리형 언어에서의 변수는 기억 장소의 위치보다는 계산 과정의 중간 결과 값에 대한 이름의 성격이 강하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 규칙 정의
function isHuman(animal) {
  return animal.species === 'Human';
}

function canSpeak(animal) {
  return animal.canSpeak === true;
}

// 사람 객체 생성
const person = {
  species: 'Human',
  canSpeak: true
};

// 규칙을 통한 논리적 추론
if (isHuman(person) &amp;&amp; canSpeak(person)) {
  console.log('This is a speaking human.');
} else {
  console.log('This is not a speaking human.');
}
</code></pre></div></div>

<p>객체 지향 (<code class="language-plaintext highlighter-rouge">Object-Oriented</code>) 언어는 여기서 한 발 더 나아가, 프로그램을 단순히 데이터와 이를 처리하는 방법으로 나누지 않고 수많은 객체들의 집합으로 보았다. 메소드와 변수를 가지는 객체라는 추상적인 개념을 프로그램에 도입하고 이를 객체의 상호 작용으로 봄으로써, 이전에 존재하던 지나치게 많은 이름의 생성으로 인한 네임스페이스 포화 문제를 해결하고 큰 문제를 작은 문제를 하기 위한 객체들로 해결하는 상향식 (<code class="language-plaintext highlighter-rouge">Bottom-up</code>) 해결 방식을 적용하는 것이 가능해졌다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 클래스 정의
class Animal {
  constructor(species, canSpeak) {
    this.species = species;
    this.canSpeak = canSpeak;
  }
}

// Human 클래스 정의, Animal 클래스를 상속받음
class Human extends Animal {
  constructor(canSpeak) {
    // Human은 species가 'Human'으로 고정된다고 가정
    super('Human', canSpeak);
  }

  isSpeakingHuman() {
    return this.species === 'Human' &amp;&amp; this.canSpeak === true;
  }
}

// 사람 객체 생성
const person = new Human(true);

// 객체지향 방식의 논리적 추론
if (person.isSpeakingHuman()) {
  console.log('This is a speaking human.');
} else {
  console.log('This is not a speaking human.');
}
</code></pre></div></div>

<p>이제 다시 자바스크립트가 탄생하던 시점으로 돌아오자. 자바스크립트가 탄생한 시점에는 이전에 정적으로만 존재하던 페이지가 브라우저를 통해 동적으로 페이지를 변경하는 방식이 공개되면서 브라우저에서 사용할 언어나 기술이 요구되고 있었다. <code class="language-plaintext highlighter-rouge">Java Applet</code>처럼 웹 브라우저에 <code class="language-plaintext highlighter-rouge">Java</code> 어플리케이션을 내장해 동적인 페이지를 제공하는 방식으로 동작하는 기술이 있었지만, 성능 및 보안 이슈가 존재하였다. 이때 자바스크립트는 강력한 추상화와 인터프리터 방식를 내세워 꾸준히 개발자들을 유입하였고, <code class="language-plaintext highlighter-rouge">Ajax</code>와 <code class="language-plaintext highlighter-rouge">JQuery</code>, <code class="language-plaintext highlighter-rouge">Node.js</code>를 통해 기존에 가진 문제점 또한 개선해나갔다.</p>

<p>자바스크립트의 강력한 추상화는 앞서 언급한 여러 언어들의 장점들을 채택하는 데에서 비롯되었다. 자바스크립트는 함수형 언어라고 부르지만, 객체나 함수를 통한 추상화를 지원하면서 변수를 선언할 때 타입을 명시적으로 지정할 필요가 없는 동적 타이핑 (<code class="language-plaintext highlighter-rouge">Dynamic Typing</code>) 또한 지원한다. 또한 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">Ajax</code>와 같은 비동기 이벤트의 처리를 위해 콜백 (<code class="language-plaintext highlighter-rouge">Callback</code>)과 프로미스 (<code class="language-plaintext highlighter-rouge">Promises</code>) 또한 지원한다.</p>

<p>인터프리터 방식은 소스 코드를 한 줄씩 기계어로 번역하는 방식이므로 컴파일 방식에 비해 속도는 느리지만, 어떤 코드를 작성한 다음 바로 실행하여 문제가 있으면 바로 수정할 수 있는 디버깅이 가능하다. 그리고 반복적으로 쓰이는 함수, 클래스의 기계어를 캐싱하는 <code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러를 인터프리터에 내장하여 속도 또한 이전에 비해 개선되었다. <code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러를 통해 오류가 있어도 그전까지 계속 실행되거나 오류를 오류로 처리하지 않는 경우 또한 줄어들었다.</p>

<blockquote>
  <ol>
    <li>파싱 (<code class="language-plaintext highlighter-rouge">Parsing</code>) : 소스 코드가 먼저 브라우저 엔진에 의해 파싱되어 코드의 문법적 구조를 이해하기 위한 토큰들이 생성</li>
    <li><code class="language-plaintext highlighter-rouge">AST</code> (<code class="language-plaintext highlighter-rouge">Abstract Syntax Tree</code>) 생성 : 파싱된 토큰들은 코드의 추상 구문을 나타내는 트리 구조인 <code class="language-plaintext highlighter-rouge">AST</code>로 변환</li>
    <li>바이트코드 생성 : 코드를 실행 가능한 형태로 변환하기 위한 중간 단계의 표현 생성</li>
    <li>(<code class="language-plaintext highlighter-rouge">JIT</code> 컴파일) 후 실행 : 변환된 코드는 런타임 환경에서 실행되거나, <code class="language-plaintext highlighter-rouge">JIT</code> 컴파일러에 의해 기계 코드로 컴파일되어 실행</li>
  </ol>
</blockquote>

<p>그리고 인터프리터 방식의 장점 중 하나는 프로그래밍 언어의 설계가 쉽다는 점이다. 컴파일 언어가 설계되려면 기계어에 대한 이해가 필요하지만, 스크립트 언어는 컴파일 언어나 심지어 스크립트 언어를 통해 구현될 수 있다. 타입스크립트가 바로 대표적인 예시로, 최근에는 앞서 정의한 타입스크립트 문법을 활용해 다시 문법을 만드는 것 또한 이루어지고 있다.</p>

<p>그렇다면 자바스크립트가 브라우저에서 어떻게 동작하는 걸까? 클라이언트 측에서 동작하는 자바스크립트는 브라우저가 웹 페이지를 로딩할 때 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 태그를 통해 위의 컴파일 과정이 이루어진 다음에 단일 스레드로 동작하며, 이벤트 기반 비동기 모델을 활용한다. 이런 비동기 작업을 위해 브라우저는 추가로 이벤트 큐와 이벤트 루프를 활용하고 자바스크르립트 또한 콜백 함수와 <code class="language-plaintext highlighter-rouge">Ajax</code> 처리를 지원한다.</p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Digital Hanaro Study" /><summary type="html"><![CDATA[디지털하나路 스터디 1일차 내용을 정리한 글입니다.]]></summary></entry><entry><title type="html">[MicroService] 5. MicroService Design</title><link href="http://localhost:4000/microservice5/" rel="alternate" type="text/html" title="[MicroService] 5. MicroService Design" /><published>2024-01-16T00:00:00+09:00</published><updated>2024-01-16T00:00:00+09:00</updated><id>http://localhost:4000/microservice5</id><content type="html" xml:base="http://localhost:4000/microservice5/"><![CDATA[<h2 id="마이크로서비스-설계--응집성-높게-high-cohesion-의존도-낮게-low-coupling">마이크로서비스 설계 : 응집성 높게 (<code class="language-plaintext highlighter-rouge">High Cohesion</code>), 의존도 낮게 (<code class="language-plaintext highlighter-rouge">Low Coupling</code>)</h2>

<ul>
  <li>마이크로서비스의 내부 구조를 구성하는 각 요소들은 역할별로 모듈화 (<code class="language-plaintext highlighter-rouge">Modulation</code>)되어야 함
    <ol>
      <li>자체적인 응집도가 높고, 서로 간의 의존성이 낮은 모듈들이 모여 하나의 마이크로서비스를 이룸</li>
      <li>하나의 마이크로서비스는 다른 마이크로서비스와 의존성이 낮아야 함</li>
    </ol>
  </li>
</ul>

<p>→ 마이크로서비스를 구성하는 각각의 요소들을 모두 유연해야 한다.</p>

<h3 id="마이크로서비스를-도출하는-방법">마이크로서비스를 도출하는 방법</h3>

<ul>
  <li></li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[마이크로서비스 설계 : 응집성 높게 (High Cohesion), 의존도 낮게 (Low Coupling)]]></summary></entry></feed>