<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-07T00:36:38+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[Docker] 2. Docker란?</title><link href="http://localhost:4000/docker2/" rel="alternate" type="text/html" title="[Docker] 2. Docker란?" /><published>2023-12-05T00:00:00+09:00</published><updated>2023-12-05T00:00:00+09:00</updated><id>http://localhost:4000/docker2</id><content type="html" xml:base="http://localhost:4000/docker2/"><![CDATA[<h2 id="도커-docker--컨테이너-기반-가상화-container-based-virtualization">도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 컨테이너 기반 가상화 (<code class="language-plaintext highlighter-rouge">Container-based Virtualization</code>)</h2>

<p><img src="https://pyrasis.com/assets/images/Docker-HOWTO/docker-containerized-appliction-blue-border_2.png.webp" width="50%" /></p>

<h3 id="q-도커를-쓰는-이유--비교적-효율적인-가상화-방식--통일된-개발-환경--배포의-동시성">Q. 도커를 쓰는 이유? : 비교적 효율적인 가상화 방식 + 통일된 개발 환경 + 배포의 동시성</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Virtualization</code> : 응용 프로그램 실행 시 운영체제 수준 가상화 방식이 성능 손실이 더 적고 빠르게 동작한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Development</code> : 운영체제에 상관없이 같은 환경에서 개발할 수 있게 해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">Deployment</code> : 서비스 환경과 응용 프로그램을 같이 배포할 수 있게 한다.</li>
</ol>

<blockquote>
  <ul>
    <li>분산 어플리케이션을 클라우드 환경으로 이주한다고 가정하면,
      <ul>
        <li><code class="language-plaintext highlighter-rouge">IaaS</code> : 서비스로서의 인프라
          <ul>
            <li>어플리케이션을 구성하는 각 컴포넌트가 모두 가상 머신에서 독립적으로 동작</li>
            <li>이주 과정은 쉽지만, 가상 머신의 성능을 모두 활용하지 못하며 운영비가 비쌈</li>
          </ul>
        </li>
        <li><code class="language-plaintext highlighter-rouge">PaaS</code> : 서비스로서의 플랫폼
          <ul>
            <li>어플리케이션을 구성하는 각 컴포넌트가 클라우드 서비스 제공자의 매니지드 서비스에 종속</li>
            <li>운영비가 저렴하고 관리가 쉬우나, 이주 과정이 복잡함</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <p>… 도커를 활용한다면? : 각 컴포넌트를 컨테이너로 이주하고, 쿠버네티스 등으로 전체 어플리케이션 관리 가능</p>
</blockquote>

<ul>
  <li><a href="https://www.docker.com">공식 홈페이지</a>에서 <code class="language-plaintext highlighter-rouge">.dmg</code> 파일을 다운로드 후 설치</li>
  <li>터미널 창에 다음 명령어를 입력해 도커가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker version // 현재 도커의 버전 확인

Client:
 Cloud integration: ~
 Version:           ~
 API version:       ~
 Go version:        ~

Server: ~
 Engine:
  Version:          ~
  API version:      ~
  Go version:       ~
</code></pre></div></div>
<blockquote>
  <p>Q. 클라이언트와 서버의 버전 정보가 따로 구성되어 있는 이유?</p>
  <ul>
    <li>도커가 클라이언트와 서버의 역할을 각각 수행할 수 있음
      <ul>
        <li>리눅스 터미널에 도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 출력</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="도커-파일-dockerfile--서버-운영-기록을-코드화해-저장한-파일을-해당-시점의-도커-이미지로-빌드">도커 파일 (<code class="language-plaintext highlighter-rouge">Dockerfile</code>) : 서버 운영 기록을 코드화해 저장한 파일을 해당 시점의 도커 이미지로 빌드</h2>

<blockquote>
  <p>눈송이 서버 (<code class="language-plaintext highlighter-rouge">Snowflakes Server</code>) : 각 서버마다 운영 기록이 달라 서로 모양이 다른 서버들이 공존하는 상황</p>
  <ul>
    <li>서버 간의 운영체제, 컴파일러, 설치된 패키지 등의 차이로 발생하는 문제 개선을 위해 서버 운영 기록 저장</li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DSL</code> (<code class="language-plaintext highlighter-rouge">Domain-Specific Language</code>) : 도커 파일을 작성할 때 쓰는 언어 (도커 이미지의 생성 과정 표현)</li>
</ul>

<h3 id="q-도커-파일을-쓰는-이유--테스트-주도-개발의-순환에-부합한다">Q. 도커 파일을 쓰는 이유? : 테스트 주도 개발의 순환에 부합한다.</h3>
<ul>
  <li>테스트 주도 개발 (<code class="language-plaintext highlighter-rouge">Test Driven Development</code>) : 선 테스트 후 개발 사이클을 반복하는 개발 방법론</li>
</ul>

<div style="color: white; padding: 2% 1% 1% 1%; background-color: black;">
<ol>
  <li>테스트를 작성한다. → 도커 파일을 만든다.</li>
  <li>테스트에 실패하고 코드를 수정한다. → 도커 이미지의 빌드에 실패하고 도커 파일을 수정한다.</li>
  <li>테스트에 성공한다면, 코드를 리펙터링한다. → 도커 이미지의 빌드에 성공한다면, 도커 파일의 내용을 리펙터링한다.</li>
  <li>처음으로 되돌아간다.</li>
</ol>
</div>

<h2 id="도커-이미지-docker-image--컨테이너의-실행에-필요한-모든-파일과-설정값-정보을-포함">도커 이미지 (<code class="language-plaintext highlighter-rouge">Docker Image</code>) : 컨테이너의 실행에 필요한 모든 파일과 설정값 정보을 포함</h2>
<ul>
  <li>상태값을 가지지 않음 (변하지 않는 값들을 저장) ↔ 컨테이너 : 이미지가 실행된 살태 (변하는 값들을 저장)</li>
  <li>이미지 레이어 : 도커 이미지는 여러 <code class="language-plaintext highlighter-rouge">Read-Only</code> 레이어로 구성되고, 파일 추가 및 생성 시 새로운 레이어 생성
    <ul>
      <li>유니온 파일 시스템 (<code class="language-plaintext highlighter-rouge">Union File Systems</code>)읕 통해 여러 개의 레이어를 하나의 파일 시스템으로 활용</li>
    </ul>
  </li>
  <li>컨테이너 레이어 : 컨테이너가 실행되면 이미지 레이어 위에 읽기/쓰기 (<code class="language-plaintext highlighter-rouge">Read-Write</code>) 레이어를 추가
    <ul>
      <li>컨테이너를 실행하면서 생성되거나 변경된 내용을 저장</li>
    </ul>
  </li>
  <li>이미지 경로 : <code class="language-plaintext highlighter-rouge">URL</code> 방식으로 관리 -&gt; 뒤에 태그 (<code class="language-plaintext highlighter-rouge">/tag</code>)를 붙임</li>
  <li><a href="https://hub.docker.com"> 도커 허브</a> (<code class="language-plaintext highlighter-rouge">Docker Hub</code>) : 도커 이미지를 서버에 무료로 공개하고 관리</li>
</ul>

<h3 id="q-도커-이미지를-쓰는-이유--도커-이미지와-도커-컨테이너들을-클래스나-인스턴스처럼-활용한다">Q. 도커 이미지를 쓰는 이유? : 도커 이미지와 도커 컨테이너들을 클래스나 인스턴스처럼 활용한다.</h3>
<ul>
  <li>도커는 해시 값 (= 컨테이너 ID)과 임의의 이름 (= 컨테이너 이름)를 통해 컨테이너를 구분하고 이들을 환경변수로 관리</li>
</ul>

<div style="color: white; padding: 3% 2% 2% 2%; background-color: black;">
운영자가 지금까지 운영한 서버를 도커 이미지로 배포하고 도커 컨테이너에 설치한다면,
<ul>
  <li>도커 파일 : 지금까지 서버를 운영한 기록</li>
  <li>도커 이미지 (도커 파일 + 실행 시점) : 지금부터 설치된 서버가 가질 초기값</li>
  <li>도커 컨테이너 (도커 파일 + 환경 변수) : 지금부터 설치된 서버가 운영될 장소</li>
</ul>
</div>
<ul>
  <li>도커 안에서는 서버 역시 하나의 소프트웨어처럼 사용할 수 있고, 생성할 수 있는 컨테이너의 개수에도 제한이 없다.</li>
</ul>

<h2 id="도커-명령어-docker-command--docker-command-형식으로-구성">도커 명령어 (<code class="language-plaintext highlighter-rouge">Docker Command</code>) : <code class="language-plaintext highlighter-rouge">docker &lt;command&gt;</code> 형식으로 구성</h2>
<ul>
  <li>리눅스 터미널에 도커 명령어를 입력하면 도커 서버에서 이에 해당되는 작업 수행</li>
  <li>항상 <code class="language-plaintext highlighter-rouge">root</code> 권한으로 실행되기에 <code class="language-plaintext highlighter-rouge">$ sudo</code>를 앞에 붙어야 함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo usermod -aG docker $USER # 현재 사용자를 docker 그룹에 추가
</code></pre></div></div>

<div style="text-align: center;">
    <table>
        <thead>
            <tr>
                <td>docker 명령어</td>
                <td>명령어 형식</td>
                <td>명령어 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>docker search</td>
                <td>$ docker search [이미지]</td>
                <td>도커 허브에서 이미지 검색</td>
            </tr>
            <tr>
                <td>docker pull</td>
                <td>$ docker pull [사용자명/] 이미지 [:태그]</td>
                <td>도커 허브에서 이미지 다운로드<br />사용자명을 지정해 도커 허브에서 해당 사용자가 올린 이미지을 다운로드<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker images</td>
                <td>$ docker images</td>
                <td>사용 가능한 모든 이미지 목록 확인</td>
            </tr>
            <tr>
                <td>docker rmi</td>
                <td>$ docker rmi 이미지 [:태그]</td>
                <td>다운로드한 이미지 삭제<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker run</td>
                <td>$ docker run [옵션] [실행할 이미지]</td>
                <td>이미지를 컨테이너로 생성한 뒤 컨테이너 실행<br />입력받은 이미지가 현재 없다면, 해당 이미지를 도커 허브에서 다운로드<br />실행할 파일을 지정해 직접 실행 가능 (여기서 빠져나오면 컨테이너가 정지)<br /><div style="text-align: center; font-size: 120%; padding: 2% 0% 0% 0%">
    <table>
        <thead>
            <tr>
                <td>docker run 옵션</td>
                <td>옵션 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>-d</td>
                <td>백그라운드 모드 (detached mode)</td>
            </tr>
            <tr>
                <td>-p [호스트 포트:컨테이너 포트]</td>
                <td>호스트와 컨테이너의 포트를 연결 (port forwarding)<br />http://호스트 IP:호스트 포트로 컨테이너의 포트 접속</td>
            </tr>
            <tr>
                <td>-v [호스트의 디렉터리]</td>
                <td>호스트의 디렉터리를 컨테이너의 디렉터리에 연결 (mount)</td>
            </tr>
            <tr>
                <td>-e [환경변수]</td>
                <td>컨테이너 내에서 사용할 환경변수 설정 (environment variable)</td>
            </tr>
            <tr>
                <td>--name [컨테이너 이름]</td>
                <td>컨테이너 이름 설정 (container name)</td>
            </tr>
            <tr>
                <td>-rm</td>
                <td>프로세스 종료 시 컨테이너 자동으로 제거 (remove container)</td>
            </tr>
            <tr>
                <td>-link [컨테이너 이름:주소]</td>
                <td>컨테이너와 컨테이너 연결 (link container)<br />[주소:포트번호]로 컨테이너에 접속</td>
            </tr>
            <tr>
                <td>-it</td>
                <td>리눅스 터미널 입력을 위한 옵션 (interactive / Pseudo-tty)</td>
            </tr>
         </tbody>
    </table>
</div></td>
            </tr>
            <tr>
              <td>docker ps</td>
              <td>$ docker ps [옵션]</td>
              <td>실행중인 모든 컨테이너 목록 확인<br />-a 옵션으로 정지된 컨테이너까지 모두 검색</td>
            </tr>
            <tr>
              <td>docker start</td>
              <td>$ docker start [컨테이너 이름 | 컨테이너 ID]</td>
              <td>정지된 컨테이너 재시작</td>
            </tr>
            <tr>
              <td>docker stop</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너 정지</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker exec</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]<br />[명령] [매개 변수]</td>
              <td>컨테이너 외부에서 컨테이너 내의 명령 실행</td>
            </tr>
            <tr>
              <td>docker diff</td>
              <td>$ docker diff [컨테이너 이름 | 컨테이너 ID]</td>
              <td>컨테이너가 실행되면서 변경된 파일 목록 확인<br />A : 추가된 파일<br />C : 변경된 파일<br />D : 삭제된 파일</td>
            </tr>
            <tr>
              <td>docker cp</td>
              <td>$ docker cp [컨테이너 이름 | 컨테이너 ID]<br />[:컨테이너 경로] [호스트 경로]</td>
              <td>컨테이너의 파일을 호스트의 디렉토리로 복사</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker rm</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>생성된 컨테이너 삭제</td>
            </tr>
            <tr>
              <td>docker commit</td>
              <td>$ docker commit [옵션] [컨테이너 이름 | 컨테이너 ID]<br />[이미지 이름] [:태그]</td>
              <td>컨테이너를 이미지 파일로 생성</td>
            </tr>
            <tr>
              <td>docker build</td>
              <td>$ docker build [옵션] [도커 파일 경로]<br />[--tag 이미지 이름 : 이미지 태그] </td>
              <td>도커 파일에 설정된 내용대로 도커 이미지 생성<br />--tag 뒤에 이미지 이름와 이미지 태그를 설정할 수 있음</td>
            </tr>
            <tr>
              <td>docker history</td>
              <td>$ docker history [이미지 이름 | 이미지 ID] [:태그]</td>
              <td>도커 파일에 설정된 내용대로 이미지 히스토리 생성</td>
            </tr>
            <tr>
              <td>docker inspect</td>
              <td>$ docker inspect<br />[이미지나 컨테이너 이름 | 이미지나 컨테이너 ID]</td>
              <td>이미지나 컨테이너의 세부 정보 출력</td>
            </tr>
         </tbody>
    </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 (Docker) : 컨테이너 기반 가상화 (Container-based Virtualization)]]></summary></entry><entry><title type="html">[vocawik] 7. 07/21 진행 내용</title><link href="http://localhost:4000/vcw7/" rel="alternate" type="text/html" title="[vocawik] 7. 07/21 진행 내용" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/vcw7</id><content type="html" xml:base="http://localhost:4000/vcw7/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #19. feat(domain): BaseDateTime 엔티티 추가 ~ #23. fix(domain): User 도메인 제약조건 추가에 대한 내용입니다.</p>
</blockquote>

<h2 id="19-featdomain-basedatetime-엔티티-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/bb68e72e418610d6edb4b13449c3cf90973a2cb1">#19</a>. feat(domain): BaseDateTime 엔티티 추가</h2>

<ul>
  <li>JPA Auditing을 User 엔티티에 적용하고자 생성 시간 (<code class="language-plaintext highlighter-rouge">CreatedDate</code>)과 수정 시간 (<code class="language-plaintext highlighter-rouge">LastModifiedDate</code>)을 칼럼으로 갖는 <code class="language-plaintext highlighter-rouge">BaseDateTime</code> 엔티티를 생성하였다. 이 때 MappedSuperclass를 통해 JPA Entity 클래스들이 BaseTimeEntity를 상속할 때 내부 필드도 컬럼으로 인식하도록 설정하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.model;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import java.time.LocalDateTime;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

@Getter
@MappedSuperclass // JPA Entity 클래스들이 BaseTimeEntity를 상속할 때 내부 필드도 컬럼으로 인식하도록 설정
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseDateTime { // 생성 및 수정 시간 엔티티
    @Column(name = "baseDateTime_created", updatable = false)
    @CreatedDate
    private LocalDateTime created; // 생성 시간

    @Column(name = "baseDateTime_lastModified")
    @LastModifiedDate
    private LocalDateTime lastModified; // 수정 시간
}
</code></pre></div></div>

<h2 id="20-featinfra-feign-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/54a5c95f7c8e58db5439558db99bb672f6d8c85d">#20</a>. feat(infra): feign 적용</h2>

<p>페인 (Feign) 클라이언트는 REST 호출을 도와주는 Http 클라이언트 바인더 (Client Binder)이다. JPA가 인터페이스만으로 DB에 접근하는 방식을 축소시키는 것처럼, Feign을 적용하면 번거로운 RestTemplate과 같은 호출 방식을 인터페이스 하나만으로 축소시킬 수 있다.</p>

<ul>
  <li>페인 클라이언트는 REST 호출 방식에 영향을 주므로 <code class="language-plaintext highlighter-rouge">Api</code>, <code class="language-plaintext highlighter-rouge">Domain</code> 모듈 모두에 영향을 준다고 생각하였다. 그래서 <code class="language-plaintext highlighter-rouge">Infra</code> 모듈에 의존성을 추가해 양 측 모두에서 사용할 수 있게끔 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springframework.cloud:spring-cloud-starter-openfeign' : 클라이언트 사이드 HTTP 요청을 쉽게 작성할 수 있도록 도와줌
    api 'org.springframework.cloud:spring-cloud-starter-openfeign'

    // 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8' : Optional, LocalDate 등의 JDK 8 추가 데이터 유형들을 지원
    api 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8'

    // 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310' : Java 8에 추가된 날짜 및 시간 API를 JSON 형식으로 직렬화 및 역직렬화하는 JSR-310 지원
    api 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'

    // 'io.github.openfeign:feign-jackson' : OpenFeign을 사용할 때 JSON 데이터를 직렬화하고 역직렬화에 활용되는 Jackson 지원
    api 'io.github.openfeign:feign-jackson:12.2'

    implementation project(':vw-core')
}
</code></pre></div></div>

<ul>
  <li>그리고 Feign 클라이언트가 응답을 디코딩할 때 사용할 디코더를 정의하기 위해 Feign 클라이언트에 대한 설정 클래스 <code class="language-plaintext highlighter-rouge">FeignConfig</code>를 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.infra.config.feign;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import feign.Logger;
import feign.Retryer;
import feign.codec.Decoder;
import feign.jackson.JacksonDecoder;
import java.util.concurrent.TimeUnit;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import vw.infra.outer.api.BaseFeignClientPackage;

@Configuration
@EnableFeignClients(
        basePackageClasses = BaseFeignClientPackage.class) // 해당 클래스가 위치한 패키지 밑에서 Feign 클라이언트를 탐색
public class FeignConfig { //  Feign 클라이언트가 응답을 디코딩할 때 사용할 디코더 정의
    @Bean
    public Decoder feignDecoder() {
        return new JacksonDecoder(
                customObjectMapper()); // JSON 응답을 객체로 디코딩하기 위한 JacksonDecoder를 사용하도록 설정
    }

    public ObjectMapper customObjectMapper() { // ObjectMapper 객체를 커스터마이징 (객체 직렬화/역직렬화 설정을 변경)
        ObjectMapper objectMapper = new ObjectMapper();

        objectMapper.registerModule(
                new JavaTimeModule()); // 시간 관련 클래스들을 JSON으로 변환하고, JSON 데이터를 해당 클래스들로 역직렬화 가능하게 함

        // JSON 직렬화 시에, Java Date나 Calendar 객체를 타임스탬프 형태로 출력하지 않음 -&gt; 일반적인 문자열 형태로 날짜를 표시
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

        // JSON 역직렬화 시에, 알 수 없는 필드가 포함되어 있을 경우에도 역직렬화 작업을 진행시킴 -&gt; 해당 필드를 무시하고 나머지 필드들을 역직렬화
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        // JSON 역직렬화 시에, 날짜와 시간을 JSON 데이터에 포함된 그대로의 타임존으로 유지
        objectMapper.configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false);

        // JSON 역직렬화 시에, 알 수 없는 enum 값을 null로 처리함
        objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, true);

        return objectMapper; // 커스텀마이징한 ObjectMapper 객체를 반환
    }

    @Bean
    Retryer.Default retryer() { // 재시도 (Retry) 설정
        return new Retryer.Default(
                100L,
                TimeUnit.SECONDS.toMillis(3L),
                5); // 0.1초의 간격으로 시작해 최대 3초의 간격으로 점점 증가하며, 최대5번 재시도
    }

    @Bean
    Logger.Level feignLoggerLevel() { // Feign의 로그 레벨을 설정
        return Logger.Level.FULL; // FULL 레벨로 설정해 모든 요청과 응답에 대한 자세한 로그를 출력
    }
}
</code></pre></div></div>

<ul>
  <li>이때 <code class="language-plaintext highlighter-rouge">FeignConfig</code> 클래스의 <code class="language-plaintext highlighter-rouge">feignLoggerLevel()</code>에서 eign의 로그 레벨을 설정하고 있는데, Feign은 DEBUG 레벨로만 로그를 남길 수 있다. 그러므로 반드시 로그 레벨이 아래처럼 DEBUG로 설정이 되어 있어야 한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logging:
  level:
    com.mangkyu.openfeign.app.openfeign: DEBUG # feign에 대한 로깅 수준을 DEBUG로 설정 (가장 상세한 로그를 출력)
</code></pre></div></div>

<h2 id="21-featinfra-redis-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/5fa4efde8f32f1327dd89bdb9cd85b6be71d26d9">#21</a>. feat(infra): redis 적용</h2>

<p>레디스 (<code class="language-plaintext highlighter-rouge">redis</code>)는  “키-값” 구조의 비정형 데이터를 저장하고 관리하는 비관계형 데이터베이스 관리 시스템이다. 레디스는 인메모리 데이터베이스이면서 다양한 자료구조를 갖고 있어 다른 DBMS에 비해 더 빠르고 간단한 방법으로 데이터를 정렬할 수 있다. 이는 우리가 구현하고자 하는 회원가입의 인증 이메일 전송에서 필요한 정보들 (이메일, 인증 키)를 저장하기에 적합하다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">redis</code>는 아마 서비스를 담당하는 <code class="language-plaintext highlighter-rouge">Domain</code> 모듈에서만 활용될 것으로 추측되지만, 우리 어플리케이션 외부에 존재하는 DBMS이다. 그러므로 외부 서비스를 담당할 <code class="language-plaintext highlighter-rouge">Infra</code> 모듈에 의존성을 추가하고 <code class="language-plaintext highlighter-rouge">Redis</code> 설정 클래스 또한 여기에 위치시키되, 이를 통해 구현될 레포지토리는 <code class="language-plaintext highlighter-rouge">Domain</code> 모듈에 위치시킬 생각이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    dependencies {
        // 'org.springframework.boot:spring-boot-starter-data-redis' : Redis에 필요한 모든 의존성들을 관리
        api 'org.springframework.boot:spring-boot-starter-data-redis'
    }
</code></pre></div></div>

<ul>
  <li>레디스에 대한 설정 클래스인 <code class="language-plaintext highlighter-rouge">RedisConfig</code>를 작성하였다. 여기에서는 Redis 연결 설정을 위한 Bean인 <code class="language-plaintext highlighter-rouge">redisConnectionFactory</code>와 Redis 데이터를 처리하는 데 사용될 RedisTemplate에 대한 Bean인 <code class="language-plaintext highlighter-rouge">redisTemplate</code>을 추가하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.infra.config.redis;

import java.time.Duration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.repository.configuration.EnableRedisRepositories;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@EnableRedisRepositories( // redis와 관련된 Spring Data Repositories 활성화
        basePackages = "vw")
public class RedisConfig {
    @Value("${spring.data.redis.host}")
    private String redisHost; // redis 호스트 주소

    @Value("${spring.data.redis.port}")
    private int redisPort; // redis 포트 번호

    @Value("${spring.data.redis.password}")
    private String redisPassword; // redis 비밀번호

    @Bean // Redis 연결 설정을 위한 Bean 생성
    public RedisConnectionFactory
            redisConnectionFactory() { // RedisConnectionFactory : redis와의 연결을 관리하는 인터페이스
        RedisStandaloneConfiguration redisStandaloneConfiguration =
                new RedisStandaloneConfiguration(redisHost, redisPort);

        if (redisPassword != null &amp;&amp; !redisPassword.isBlank()) // redis에 비밀번호가 설정되어 있지 않으면 비밀번호를 설정
        redisStandaloneConfiguration.setPassword(redisPassword);

        // LettuceClientConfiguration을 생성하여 Redis 연결 설정 구성
        LettuceClientConfiguration lettuceClientConfiguration =
                LettuceClientConfiguration.builder() // LettuceClientConfiguration의 builder 패턴 생성
                        .commandTimeout(Duration.ofSeconds(1)) // redis 명령의 최대 실행 시간을 1초로 설정
                        .shutdownTimeout(Duration.ZERO) // Redis 클라이언트의 종료 시간을 0초로 설정 (무한 대기)
                        .build();

        // LettuceConnectionFactory를 생성하여 Redis 연결 수립
        return new LettuceConnectionFactory(
                redisStandaloneConfiguration, lettuceClientConfiguration); // 내장 혹은 외부의 redis 연결
    }

    @Bean // RedisTemplate을 Bean으로 생성
    public RedisTemplate&lt;?, ?&gt; redisTemplate() { // RedisTemplate : Redis 데이터를 처리하는 데 사용
        RedisTemplate&lt;byte[], byte[]&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory());

        // 일반적인 key:value일 경우에 직렬화
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());

        // Hash를 사용할 경우에 직렬화
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new StringRedisSerializer());

        return redisTemplate; // RedisConnection에서 넘겨준 byte 값 객체 직렬화
    }
}
</code></pre></div></div>

<ul>
  <li>앞서 내가 필요로 하는 기능인 회원가입 인증 이메일 전송에 필요한 데이터들은 휘발성이 강하면서도 빠른 접근을 요한다. 그러므로 레디스를 캐시로 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">redisCacheManager</code> 클래스를 통해 캐시 기능을 활성화하고 이에 대한 설정을 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.infra.config.redis;

import java.time.Duration;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@EnableCaching // 캐시 기능 활성화
@Configuration
public class RedisCacheConfig {
    @Bean
    @Primary
    public CacheManager redisCacheManager(RedisConnectionFactory cf) { // 기본 CacheManager를 설정
        // redis 캐시의 기본 설정을 구성
        RedisCacheConfiguration redisCacheConfiguration =
                RedisCacheConfiguration.defaultCacheConfig()
                        .serializeKeysWith( // redis에서 키를 String으로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new StringRedisSerializer()))
                        .serializeValuesWith( // redis에서 값을 JSON 형태로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new GenericJackson2JsonRedisSerializer()))
                        .entryTtl( // Cache의 기본 TTL (Time-To-Live)을 1시간으로 설정
                                Duration.ofHours(1L));

        // RedisConnectionFactory를 사용하여 RedisCacheManager를 생성
        return RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(cf)
                .cacheDefaults(
                        redisCacheConfiguration) // redis 캐시의 기본 설정을 지정한 RedisCacheConfiguration으로
                // 설정
                .build();
    }

    // OIDC (OpenID Connect) : 인증 및 권한 부여를 위한 프로토콜
    @Bean
    public CacheManager oidcCacheManager(RedisConnectionFactory cf) { // OIDC CacheManager를 설정
        // OIDC Cache의 redis 캐시 설정을 구성
        RedisCacheConfiguration redisCacheConfiguration =
                RedisCacheConfiguration.defaultCacheConfig()
                        .serializeKeysWith( // redis에서 키를 String으로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new StringRedisSerializer()))
                        .serializeValuesWith( // redis에서 값을 JSON 형태로 직렬화하도록 설정
                                RedisSerializationContext.SerializationPair.fromSerializer(
                                        new GenericJackson2JsonRedisSerializer()))
                        .entryTtl( // OIDC Cache의 기본 TTL을 7일로 설정
                                Duration.ofDays(7L));

        // RedisConnectionFactory를 사용하여 RedisCacheManager를 생성
        return RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(cf)
                .cacheDefaults(
                        redisCacheConfiguration) // OIDC Cache 설정을 지정한 RedisCacheConfiguration으로 설정
                .build();
    }
}
</code></pre></div></div>

<ul>
  <li>그리고 레디스가 캐시 타입으로 지정될 수 있도록, 그리고 레디스에 대한 설정을 Github Secret을 통해 넣을 수 있게끔 yml 파일을 수정하자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring:
  cache:
    type:
      redis # 캐시 타입을 redis로 지정
    redis:
      cache-null-values: true # 캐시에 null 값도 저장
  data:
    redis:
      host: ${REDIS_HOST:localhost} # Redis 호스트 주소 설정 (환경 변수가 설정되지 않은 경우 기본값 localhost)
      port: ${REDIS_PORT:6379} # Redis 포트 번호 설정 (환경 변수가 설정되지 않은 경우 기본값 6379)
      password: ${REDIS_PASSWORD:} # Redis에 접속할 때 사용할 비밀번호 설정 (환경 변수가 설정되지 않은 경우 기본값 빈 문자열)
</code></pre></div></div>

<p>당연히 레디스를 설정하는 것만으로 끝나면 안된다! Redis 자체는 우리 어플리케이션 외부에 존재하므로, 실제로 개발을 진행중인 로컬 환경과 원격에 올라가 있는 AWS 환경에 Redis를 설치하고 이를 실행시켜 Redis를 우리 서비스에서 사용할 수 있게 하자.</p>

<h2 id="22-fix-illegalargumentexception-at-propertyplaceholderhelper-해결"><a href="https://github.com/pocj8ur4in/vw-backend/commit/5abda3e95557a613fe29f69688b864bc8df14964">#22</a>. fix: IllegalArgumentException at PropertyPlaceholderHelper 해결</h2>

<p><code class="language-plaintext highlighter-rouge">IllegalArgumentException at PropertyPlaceholderHelper</code>는 사실 로컬에서 발생하는 오류는 아니다. Github Actions를 통해 돌리다 보면 어느 시점에서 어플리케이션이 죽었는데, 이때 발생한 오류다. gradle의 빌드 시에 application의 properties를 참조하지 못하는 부분이 있는 것 같았는데 알고 보니 하위 서비스를 scanBasePackages에 넣으면 안되는 것이었다… (같은 이름의 파일을 중복해서 읽어서 문제가 생기는 것? 으로 보인다.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@SpringBootApplication( // '@SpringBootApplication' : 스프링 부트 애플리케이션의 주요 구성 요소들을 자동으로 설정
        scanBasePackages = { // 'scanBasePackages={}' : Spring이 Component Scan을 수행할 패키지들을 지정
            "vw.api"
            // , "vw.domain", "vw.infra" // 제외한 부분
        })
</code></pre></div></div>

<p>그리고 멀티모듈 프로젝트에서 자주 발생하는 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성 문제를 이때 같이 해결하였다. 매번 멀티모듈 프로젝트를 진행할 때마다 발생하는 부분인데, <code class="language-plaintext highlighter-rouge">Core</code>나 <code class="language-plaintext highlighter-rouge">Infra</code> 모듈처럼 어플리케이션이 없는 모듈은 순수 Jar 파일을 생성해야 하는 것 같다…?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 멀티모듈 프로젝트에서 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성
    bootJar.enabled = false
    jar.enabled = tru
</code></pre></div></div>

<h2 id="23-fixdomain-user-도메인-제약조건-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/4f3cf5b6505cdb037c0a5e4edb69c77bf55affa0">#23</a>. fix(domain): User 도메인 제약조건 추가</h2>

<p>원래 제약 조건은 DB 단에서 직접 설정해주곤 했었는데, JPA에서 엔티티를 자동으로 생성해주는 것을 보고 직접 코드로 넣어두는 것이 더 효율적으로 보여 이를 추가하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- nullable // 빈 값 금지
- unique // 중복된 값 금지
- length // 길이 제한
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #19. feat(domain): BaseDateTime 엔티티 추가 ~ #23. fix(domain): User 도메인 제약조건 추가에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 6. 07/19, 07/20 진행 내용</title><link href="http://localhost:4000/vcw6/" rel="alternate" type="text/html" title="[vocawik] 6. 07/19, 07/20 진행 내용" /><published>2023-07-19T00:00:00+09:00</published><updated>2023-07-20T00:00:00+09:00</updated><id>http://localhost:4000/vcw6</id><content type="html" xml:base="http://localhost:4000/vcw6/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #16. init: Exception 및 ErrorCode 추가 ~ #18. feat(domain): User 도메인 설정에 대한 내용입니다.</p>
</blockquote>

<h2 id="16-init-exception-및-errorcode-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/d877198b2b27cc6e48c30c2ac77a524d0d8a56ed">#16</a>. init: Exception 및 ErrorCode 추가</h2>
<p>만약 사용자가 잘못된 방식이나 접근을 하였을 때, 서버에서는 이에 대한 예외 처리를 할 것이다. 하지만 표준으로 명시된 예외 처리 메시지를 띄우는 것은 사용자 친화적인 방식이 아닐 뿐더러, 우리 서비스의 취약점을 노출시킬 수 있다. 예를 들어 사용자가 회원가입을 할 때 서버 내에 중복된 아이디를 제출하였다고 가정하자. 그렇다면 JDBC API는 SQLException을 발생시킬 것인데, 이를 그대로 사용자에게 전달한다면 예외 발생만 알 수 있을 뿐, 왜 발생했는지 알 수 없는 상황이 발생한다. 그러므로 예외 (Exception) 및 이에 대한 에러 코드 (ErrorCode)를 커스텀마이징할 필요성이 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void register() throws SQLException {
    ...
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BaseCodeException</code>는 런타임 오류를 처리하는 RuntimeException를 상속해 어떤 클래스가 실행 중일 때 발생할 수 있는 Exception를 처리할 클래스이다. 만약 어떤 예외가 발생한다면 이에 대한 원인 (baseErrorCode의 ErrorReason)을 반환한다 (getErrorReason).</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.exception;

import vw.core.dto.BaseErrorReason;

public class BaseCodeException extends RuntimeException { // 실행 시 발생하는 예외를 나타냄 (RuntimeException 상속)
    private BaseErrorCode baseErrorCode; // 예외 발생 시에 해당 예외의 원인을 BaseErrorCode 객체에 저장

    public BaseErrorReason getErrorReason() { // 해당 예외의 원인을 반환
        return this.baseErrorCode.getErrorReason();
    }
}
</code></pre></div></div>

<ul>
  <li>이를 위해 오류의 원인을 나타내는 DTO 클래스 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code>를 작성하였다. 앞으로는 <code class="language-plaintext highlighter-rouge">public enum GlobalErrorCode implements BaseErrorReason { ... }</code>와 같이 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code>를 주입받아 오류의 원인을 커스텀마이징할 것이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.dto;

import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class BaseErrorReason { // 오류의 원인을 나타내는 DTO
    private final Integer status; // HTTP 상태 코드
    private final String code; // HTTP 상태 코드 (문자열)
    private final String reason; // 오류의 원인
}
</code></pre></div></div>

<ul>
  <li>에러의 원인을 반환할 인터페이스인 <code class="language-plaintext highlighter-rouge">BaseErrorCode</code>를 작성하였다. 추가로 예외에 대한 설명을 문자열 형태로도 반환할 수 있게끔 <code class="language-plaintext highlighter-rouge">getExplainError()</code>를 작성하였는데, 이는 다음에 설명할 부분인 <code class="language-plaintext highlighter-rouge">ExplainError</code>라는 커스텀 어노테이션을 생성하는 것과 이어져 그때 한번에 설명하겠다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.exception;

import vw.core.dto.BaseErrorReason;

public interface BaseErrorCode {
    public BaseErrorReason getErrorReason(); // 에러의 원인을 반환

    String getExplainError() throws NoSuchFieldException; // 예외에 대한 설명을 문자열로 반환
    // NoSuchFieldException : Reflection을 사용하여 Field를 접근하려고 할 때, 해당 필드가 존재하지 않는 경우에 발생
}
</code></pre></div></div>

<ul>
  <li>오류에 대한 응답을 나타내는 DTO 클래스 <code class="language-plaintext highlighter-rouge">BaseErrorResponse</code>를 작성하였다. 근데 사실 이를 활용해서 프론트에 응답을 하는 게 맞는데, 이에 대한 생각이 못해버려 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code>으로만 처리하는 방식으로 다 구현해놓았다. 지금 다시 생각해보면 <code class="language-plaintext highlighter-rouge">BaseErrorReason</code> 객체와 오류가 발생한 시간 및 경로를 포함하는 <code class="language-plaintext highlighter-rouge">BaseErrorResponse</code>를 활용하는 게 맞고, 이를 처리할 핸들러 클래스르 나중에 변경해두어야 겠다…</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.core.dto;

import java.time.LocalDateTime;
import lombok.Getter;

@Getter
public class BaseErrorResponse { // 오류에 대한 응답을 나타내는 DTO
    private final boolean success = false;

    private final Integer status; // HTTP 상태 코드
    private final String code; // HTTP 상태 코드 (문자열)
    private final String reason; // 오류의 원인
    private final LocalDateTime timeStamp; // 오류가 발생한 시간
    private final String path; // 오류가 발생한 경로

    public BaseErrorResponse(BaseErrorReason baseErrorReason, String path) {
        this.status = baseErrorReason.getStatus();
        this.code = baseErrorReason.getCode();
        this.reason = baseErrorReason.getReason();
        this.timeStamp = LocalDateTime.now();
        this.path = path;
    }

    public BaseErrorResponse(int status, String code, String reason, String path) {
        this.status = status;
        this.code = code;
        this.reason = reason;
        this.timeStamp = LocalDateTime.now();
        this.path = path;
    }
}
</code></pre></div></div>

<h2 id="17-init-jpa-auditing-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/b21e88c86f0b54352a94d629125f544464b54537">#17</a>. init: JPA Auditing 추가</h2>

<p>JPA를 사용하여 도메인을 관계형 데이터베이스 테이블에 매핑하다 보면, 도메인들이 공통으로 가지는 필드 및 칼럼들 (ex. 생성자, 수정자, 생성일자, 수정일자, 식별자 등)이 존재한다. 특히 생성자, 수정자, 생성일자, 수정일자는 우리가 DB에 create나 update할 때마다 시간 데이터를 넣어주어야 하는데 이에 대한 코드를 따로 작성할 필요 없이 자동으로 사람이나 시간을 매핑하여 데이터베이스의 테이블에 넣어주는 기능이 바로 JPA Auditing이다.</p>

<ul>
  <li>사실 <code class="language-plaintext highlighter-rouge">spring-boot-starter-data-jpa</code>만 추가해도 Auditing에는 문제는 없다. 정확히 말하면 <code class="language-plaintext highlighter-rouge">@CreatedDateTime</code>, <code class="language-plaintext highlighter-rouge">@LastModifiedDateTime</code> 어노테이션만 추가하면 된다. 그렇지만 <code class="language-plaintext highlighter-rouge">@CreatedBy</code>, <code class="language-plaintext highlighter-rouge">LastModifiedBy</code>와 같이 생성자, 수정자를 저장하려면 <code class="language-plaintext highlighter-rouge">AuditorAware</code>를 스프링 빈으로 등록해야 된다. 이를 위해 JPA를 설정하는 데 활용할 클래스인 <code class="language-plaintext highlighter-rouge">JpaConfig</code>를 미리 만들어두자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.config;

import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import vw.domain.DomainPackageLocation;

@Configuration
@EnableJpaAuditing
@EntityScan(basePackageClasses = DomainPackageLocation.class) // // Entity 스캔을 위한 기본 패키지 위치를 설정
@EnableJpaRepositories(
        basePackageClasses = DomainPackageLocation.class) // JPA 저장소를 활성화하기 위한 기본 패키지 위치를 설정
public class JpaConfig { // JPA 설정
    // JPA Auditing 활성화
}
</code></pre></div></div>

<ul>
  <li>추가로 JPA 저장소를 활성화하기 위해 <code class="language-plaintext highlighter-rouge">DomainPackageLocation</code> 클래스를 엔티티를 스캔할 위치에 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain;

public class DomainPackageLocation {}
</code></pre></div></div>

<h2 id="18-featdomain-user-도메인-설정"><a href="https://github.com/pocj8ur4in/vw-backend/commit/bb68e72e418610d6edb4b13449c3cf90973a2cb1">#18</a>. feat(domain): User 도메인 설정</h2>

<p>회원에 관련된 정보를 저장하고 이를 활용한 서비스를 구현하기 위한 회원 (User) 도메인을 구현하였다. 회원 도메인에서는 회원가입, 회원정보 조회/수정, 회원탈퇴, 로그인 등의 기능을 구현할 것이고, 이를 위해 먼저 회원 엔티티와 회원 레포지토리를 설계하였다.</p>

<ul>
  <li>엔티티 클래스는 각 엔티티에 대한 식별자 및 여러 개의 칼럼들을 기본으로 갖되, 하나의 객체로 묶을 수 있으면 임베디드 타입 (<code class="language-plaintext highlighter-rouge">@Embedded</code>, <code class="language-plaintext highlighter-rouge">@Embeddable</code>) 혹은 Enum 타입을 활용할 것이고, 회원 엔티티 클래스 <code class="language-plaintext highlighter-rouge">User</code>는 이에 기반해 작성되었다. 그리고 Builder 패턴을 통해 각 객체를 생성 가능하게 하여 필요한 데이터를 동적으로 설정할 수 있게 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.user.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Getter
@Entity
@Table(name = "tbl_user")
@Slf4j
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User { // 회원 엔티티
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_index")
    private int index; // 회원 식별자

    @Enumerated(EnumType.STRING)
    @Column(name = "user_userType")
    private UserType userType = UserType.TYPE_NORMAL; // 회원 유형 정보

    @Enumerated(EnumType.STRING)
    @Column(name = "user_userState")
    private UserState userState = UserState.STATE_NORMAL; // 회원 상태 정보

    @Embedded private UserAuth userAuth; // 회원 인증 정보

    @Embedded private UserProfile userProfile; // 회원 프로필 정보

    @Embedded private UserToogle userToogle; // 회원 토글 정보

    @Builder
    public User(
            UserAuth userAuth,
            UserProfile userProfile,
            UserToogle userToogle) { // Builder 패턴으로 User 객체를 생성 가능하게 함
        this.userAuth = userAuth;
        this.userProfile = userProfile;
        this.userToogle = userToogle;
    }
}

</code></pre></div></div>

<ul>
  <li>그리고 <code class="language-plaintext highlighter-rouge">User</code> 엔티티 객체들을 관리할 레포지토리 클래스로 <code class="language-plaintext highlighter-rouge">UserRepository</code>을 작성하였다. 인터페이스를 생성한 후 <code class="language-plaintext highlighter-rouge">JpaRepository&lt;Entity 클래스, PK 타입&gt;</code>을 상속시키면 된다. 또한 <code class="language-plaintext highlighter-rouge">@EnableJpaRepositories</code>으로 JPA Repository 빈을 활성화해 JPA CRUD를 활용할 수 있게끔 하고 JPA를 사용하기 위한 설정을 자동으로 처리할 수 있게 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.user.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import vw.domain.user.entity.User;

@EnableJpaRepositories
public interface UserRepository extends JpaRepository&lt;User, Long&gt; { // 회원 레포지토리
	Optional&lt;User&gt; findUserByUserAuth_Id(String id); // 아이디로 회원을 조회

	Boolean existsUserByUserAuth_Id(String id); // 아이디로 회원 존재 여부를 조회

	Boolean existsUserByUserProfile_Nickname(String nickname); // 닉네임으로 회원 존재 여부를 조회

	Boolean existsUserByUserProfile_Email(String email); // 이메일로 회원 존재 여부를 조회
}

</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #16. init: Exception 및 ErrorCode 추가 ~ #18. feat(domain): User 도메인 설정에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 5. 07/18 진행 내용</title><link href="http://localhost:4000/vcw5/" rel="alternate" type="text/html" title="[vocawik] 5. 07/18 진행 내용" /><published>2023-07-18T00:00:00+09:00</published><updated>2023-07-18T00:00:00+09:00</updated><id>http://localhost:4000/vcw5</id><content type="html" xml:base="http://localhost:4000/vcw5/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #14. init: 멀티모듈 infra 모듈 추가 ~ #15. init: domain 이벤트 publisher 및 aop 추가에 대한 내용입니다.</p>
</blockquote>

<h2 id="14-init-멀티모듈-infra-모듈-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/65a75da78ca574165f3ff1341b08bbe14f1b1e41">#14</a>. init: 멀티모듈 infra 모듈 추가</h2>

<p>현재 <code class="language-plaintext highlighter-rouge">api</code>, <code class="language-plaintext highlighter-rouge">core</code>, <code class="language-plaintext highlighter-rouge">domain</code>의 멀티모듈 구조에 <code class="language-plaintext highlighter-rouge">infra</code> 영역에 해당하는 모듈을 추가하기로 하였다. <code class="language-plaintext highlighter-rouge">core</code> 모듈에서 실제 구현 기술에 해당하는 부분을 분리시켜 <code class="language-plaintext highlighter-rouge">core</code> 모듈에 최대한 논리적인 개념만 남겨 <code class="language-plaintext highlighter-rouge">core</code> 모듈로의 과도한 의존성을 줄이고, <code class="language-plaintext highlighter-rouge">domain</code>, <code class="language-plaintext highlighter-rouge">api</code> 모듈에 중복될 수 있는 구현 기술들을 <code class="language-plaintext highlighter-rouge">infra</code> 모듈에서 제공하는 기술로 도메인 혹은 프레젠테이션 영역에 필요한 기능을 개발하도록 하였다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setting.gradle</code>로 <code class="language-plaintext highlighter-rouge">infra</code> 모듈을 빌드하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rootProject.name = 'vw-backend'

// - include : 하위 프로젝트의 디렉토리 이름을 지정해 해당 디렉토리 안에 있는 빌드 스크립트를 실행
include 'vw-api'
include 'vw-core'
include 'vw-domain'
include 'vw-infra' // 추가된 부분
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">build.gradle</code>에 <code class="language-plaintext highlighter-rouge">infra</code>의 의존성을 추가하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    ...
    implementation project(':vw-domain')
    implementation project(':vw-core')
    implementation project(':vw-infra') // 추가된 부분
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">domain</code>, <code class="language-plaintext highlighter-rouge">api</code> 모듈에서 해당 기술을 사용할 수 있도록 각 모듈에 의존성을 추가하고, <code class="language-plaintext highlighter-rouge">core</code> 모듈에 존재하는 논리적인 개념을 사용할 수 있도록 해당 모듈에 <code class="language-plaintext highlighter-rouge">core</code> 모듈의 의존성을 추가하였다.</li>
</ul>

<h2 id="15-init-domain-이벤트-publisher-및-aop-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/ca773e108bdecacdbab20b7377c6fba8abbd3253">#15</a>. init: domain 이벤트 publisher 및 aop 추가</h2>

<ul>
  <li>도메인 이벤트는 바운디드 컨텐스트 간에 정보를 주고받는 수단으로 활용되면서, Aggregate 간의 일괄성을 유지하는 데에 사용되는 방법이다. 이를 적용할 수 있도록 먼저 스프링 비동기 처리를 활성화하자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;

@EnableAsync // 스프링 비동기 처리 활성화
@Configuration // 해당 클래스를 스프링의 설정 클래스로 지정
public class EnableAsyncConfig implements AsyncConfigurer {
    // 'AsyncConfigurer' : 비동기 처리에 필요한 구성 요소를 제공
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code>를 활용해 도메인 이벤트를 발행 및 처리할 수 있는 <code class="language-plaintext highlighter-rouge">BaseEventPublisher</code> 클래스를 생성하였다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">raise</code> : 도메인 이벤트를 발행</li>
      <li><code class="language-plaintext highlighter-rouge">set</code> : 도메인 이벤트를 설정</li>
      <li><code class="language-plaintext highlighter-rouge">reset</code> : 도메인 이벤트를 제거</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.event;

import org.springframework.context.ApplicationEventPublisher;

public class BaseEventPublisher { // ApplicationEventPublisher를 활용하여 도메인 이벤트를 발행 및 처리
    private static ThreadLocal&lt;ApplicationEventPublisher&gt; publisherLocal = new ThreadLocal&lt;&gt;();

    public static void raise(DomainEvent event) { // 도메인 이벤트를 발행
        // 이벤트가 null인 경우에는 종료
        if (event == null) return;

        // 현재 스레드의 ApplicationEventPublisher를 사용하여 이벤트를 발행
        if (publisherLocal.get() != null) {
            publisherLocal.get().publishEvent(event);
        }
    }

    public static void set(
            ApplicationEventPublisher publisher) { // 현재 스레드의 ApplicationEventPublisher를 설정
        publisherLocal.set(publisher);
    }

    public static void reset() { // 현재 스레드의 ApplicationEventPublisher를 제거
        publisherLocal.remove();
    }
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ApplicationEventPublisherAware</code>으로 트랜잭션과 관련된 메서드 실행 시 도메인 이벤트 처리하는 <code class="language-plaintext highlighter-rouge">BaseEventPublisherAspect</code> 클래스를 생성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.event;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.stereotype.Component;

@Aspect //  해당 클래스가 AOP의 Aspect 역할을 수행함을 표시
@Component // 해당 클래스를 스프링의 컴포넌트로 등록
@ConditionalOnExpression(
        "${ableDomainEvent:true}") // 지정된 표현식 ${ableDomainEvent:true}이 true인 경우에만 해당 Aspect가 활성화
public class BaseEventPublisherAspect
        implements ApplicationEventPublisherAware { // AOP를 사용해 트랜잭션과 관련된 메서드 실행 시 도메인 이벤트 처리

    private ApplicationEventPublisher publisher;
    private ThreadLocal&lt;Boolean&gt; threadLocal = new ThreadLocal&lt;&gt;();

    @Around(
            "@annotation(org.springframework.transaction.annotation.Transactional)")
                    // @Transactional이 적용된 메서드를 감싸는 Aspect를 정의
    public Object handleEvent(ProceedingJoinPoint joinPoint)
            throws Throwable { // @Transactional이 적용된 메서드를 감싸는 방식으로 도메인 이벤트를 처리하는 Aspect 클래스

        Boolean appliedValue = threadLocal.get();
        boolean nested;

        if (appliedValue != null &amp;&amp; appliedValue) { // 중첩된 트랙잭션이 있는지 확인
            nested = true;
        } else {
            nested = false;
            threadLocal.set(Boolean.TRUE);
        }

        // 중첩된 트랜잭션에 속하지 않으면, 이벤트 발행을 위한 ApplicationEventPublisher를 설정
        if (!nested) BaseEventPublisher.set(publisher);

        try {
            // 원본 메서드 실행
            return joinPoint.proceed();
        } finally {
            // 중첩된 트랜잭션에 속하지 않은 경우, 설정을 초기화
            if (!nested) {
                BaseEventPublisher.reset();
                threadLocal.remove();
            }
        }
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        // Spring으로부터 ApplicationEventPublisher를 주입받아 멤버 변수에 할당
        this.publisher = eventPublisher;
    }
}
</code></pre></div></div>
<ul>
  <li>추상 클래스인 <code class="language-plaintext highlighter-rouge">DomainEvent</code>를 통해 이벤트가 발행되었을 때 이벤트가 발생한 시간을 기록할 수 있도록 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.domain.common.event;

import java.time.LocalDateTime;
import lombok.Getter;

@Getter
public abstract class DomainEvent {
    private final LocalDateTime timestamp; // 이벤트 발생 시간

    public DomainEvent() {
        this.timestamp = LocalDateTime.now();
    }
}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #14. init: 멀티모듈 infra 모듈 추가 ~ #15. init: domain 이벤트 publisher 및 aop 추가에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 4. 07/13, 07/17 진행 내용</title><link href="http://localhost:4000/vcw4/" rel="alternate" type="text/html" title="[vocawik] 4. 07/13, 07/17 진행 내용" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-17T00:00:00+09:00</updated><id>http://localhost:4000/vcw4</id><content type="html" xml:base="http://localhost:4000/vcw4/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #11. init: Thymeleaf 적용 ~ #13. init: lombok.config 파일 추가에 대한 내용입니다.</p>
</blockquote>

<h2 id="11-init-thymeleaf-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/c283ce8e7734c2810b459ba053f6a144f3e4143b">#11</a>. init: Thymeleaf 적용</h2>

<p>서버에서 클라이언트에게 응답할 브라우저 화면을 만들어줄 차례이다. MVC 구조에서 뷰 (View) 에 해당되는 역할인데, 대다수의 웹 사이트들이 JSP나 Thymeleaf를 사용하는 것으로 알고 있어 이에 대해 정리하고자 한다.</p>

<p>JSP (JavaServer Pages)는 HTML 코드에 Java 코드를 넣어 동적인 웹 페이지를 생성하는 Java 기반 서버 사이드 템플릿 엔진 (Server Side Template Engine)이다. 확장자는 .jsp를 사용한다. 파일을 보면 HTML 문서 내에 <code class="language-plaintext highlighter-rouge">&lt;% ... %&gt;</code>에 둘러싸인 부분이 있는데 이를 서블릿 클래스로 변환하고 컴파일해 실행한다. 이때 JSP 파일을 서블릿 클래스로 변환하고 실행시켜 주는 역할을 하는 것이 바로 Tomcat과 같은 서블릿 컨테이너 (Servlet Container)이다. 말로 적으면 난해하니 아래 순서대로 하나씩 보자.</p>

<ol>
  <li>웹 클라이언트 : 웹 서버에 웹 페이지 요청</li>
  <li>웹 서버 : 요청받은 웹 페이지에 해당되는 JSP 실행</li>
  <li>JSP : JSP를 서블릿 코드 (.java)로 변환</li>
  <li>웹 서버 : 서블릿 코드를 컴파일해 실행 가능한 bytecode (.class)로 변환</li>
  <li>웹 서버 : 실행 결과로 생성된 HTML 문서를 웹 클라이언트에 응답</li>
  <li>웹 클라이언트 : 브라우저에서 HTML 문서를 웹 페이지 형태로 출력</li>
</ol>

<p><a href="https://www.thymeleaf.org">Thymeleaf</a>은 html, xml, js, css 등을 처리할 수 있는 Java 템플릿 엔진이다. Thymeleaf의 주요 목적은 유지관리가 수월한 템플릿을 작성하는 것인데, html 태그에 속성 (th:~)을 직접 추가하면 Thymeleaf가 html 파일을 파싱하여 웹 페이지에 동적으로 값을 추가하거나 처리할 수 있다. 이런 템플릿은 Natural Template을 통해 제공되는데, 이는 서버 사이드 렌더링에 필요한 데이터가 없어도 프로토타입을 볼 수 있도록 해주는 것을 의미한다. 그래서 JSP와 달리 서버의 도움 없이도 뷰를 볼 수도 있다. 또한 thymeleaf는 .war로만 export가 가능한 JSP와 달리 .jar로 export가 가능해 이 역시 서버의 도움 없이 브라우저에 화면을 띄워볼 수 있다.</p>

<ul>
  <li>Thymeleaf은 Gradle를 통해 의존성을 추가하면 따로 설정할 부분 없이 바로 적용해볼 수 있다. (아무래도 Thymeleaf는 처음 사용해본 거라 Thymeleaf의 기본 문법이나 내부 동작 과정까지는 쓰지 못했는데 추후에 이 부분은 별개의 포스트로 추가해야겠다…)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springframework.boot:spring-boot-starter-thymeleaf' : Java 기반 서버 사이드 렌더링 템플릿 엔진
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf:3.1.1'
    ...
}
</code></pre></div></div>

<h2 id="12-init-spring-security-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/d8addffa614a6344f102af84ff3f036169d15060">#12</a>. init: Spring Security 적용</h2>

<p>Spring Security는 인증과 권한에 대한 기능을 제공하는 Java Spring의 하위 프레임워크이다. 개발을 하면서 보안 분야는 시간이 많이 소요되는 활동 중 하나인데, Spring Security를 통해 미리 구현된 내부 로직으로 인증 및 권한에 필요한 기능과 옵션들을 제공받아 사용할 수 있다.</p>

<blockquote>
  <ul>
    <li>인증 (Authentication) : 해당 사용자가 본인이 맞는지를 확인하는 절차</li>
    <li>인가 (Authorization) : 인증된 사용자가 요청된 자원에 접근 가능한지 결정하는 절차</li>
  </ul>
</blockquote>

<ul>
  <li>여기서는 프로젝트에 적용 및 간단한 설정만 하고 추후 필요한 기능이 생갈 때 필요한 로직을 가져오겠다. 사용할 모듈에 의존성을 추가해주자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springframework.boot:spring-boot-starter-security'
    // : 사용자 인증 및 권한 부여를 처리하여 보안 설정의 커스텀마이징을 가능하게 함
    implementation 'org.springframework.boot:spring-boot-starter-security'
}
</code></pre></div></div>

<ul>
  <li>그리고 <code class="language-plaintext highlighter-rouge">SecurityConfig</code> 클래스를 생성해 기본적인 설정을 해주자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.api.config;

import lombok.AllArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@AllArgsConstructor
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                // HTTP 기본 인증을 비활성화
                .httpBasic()
                .disable()
                // CORS (Cross-Origin Resource Sharing) 설정을 비활성화
                .cors()
                .disable()
                // CSRF (Cross-Site Request Forgery) 공격 방어를 비활성화
                .csrf()
                .disable()
                // 세션 관리를 상태 없음 (STATELESS)로 설정
                .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        // 구성된 HttpSecurity 객체 반환
        return httpSecurity.build();
    }
}

</code></pre></div></div>

<h2 id="13-init-lombokconfig-파일-추가"><a href="https://github.com/pocj8ur4in/vw-backend/commit/9cb184acf937a1b779806475a4d7a65549411cd3">#13</a>. init: lombok.config 파일 추가</h2>

<p>jacoco에서 Lombok의 <code class="language-plaintext highlighter-rouge">@Data</code> 주석이 달린 도메인 클래스의 코드 커버리지가 0%로 나온다. 이는 lombok에서 생성한 코드에 <code class="language-plaintext highlighter-rouge">@lombok.Generated</code>를 붙이면 되는데 이를 <code class="language-plaintext highlighter-rouge">lombok.config</code> 파일로 할 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Lombok이 자동으로 생성한 코드에 @Generated 어노테이션을 자동으로 추기
lombok.addLombokGeneratedAnnotation = true
</code></pre></div></div>

<hr />

<p>추가로 이렇게 직접 하나씩 작업해보다가 몇 가지 의문이 든 부분이 있는데, 이를 여기에 적어둘까 한다.</p>

<p>먼저 현재까지 내가 작업한 배포 과정이 정말 사이트를 운영하는 데에 정말 적합한지? 에 대한 고찰이다. 일단 내 처음 계획은, master 브랜치에 작업한 내용을 병합하기 위한 PR이 종료될 때 -&gt; github action에서 도커 허브로 이미지를 올리고 -&gt; AWS 인스턴스 내의 도커에서 올라간 이미지에 대한 컨테이너를 실행하는 것이다. 원래는 난 내 로직이 괜찮다고 생각했는데, 내가 간과한 부분이 하나 있었다.</p>

<p>AWS 인스턴스 내에서 도커를 설치하고 이미지에 대한 컨테이너를 실행하는 것은 괜찮은데, 새로운 이미지에 대한 컨테이너를 실행해야 할 때가 문제이다. 이전 이미지에 대한 컨테이너를 종료하고 이를 삭제한 다음에 새로운 이미지에 대한 컨테이너를 실행하는 과정에서 약간의 소요 시간이 생기지 않을까?</p>

<p>약간의 딜레이가 뭐가 문제인건데?, 라고 생각할 수도 있겠지만, 구글이나 아마존 같이 세계를 대상으로 실시간으로 동작하는 사이트들이 이러면 어마어마한 손실이 날 것이다. 그래서 이들은 무중단 배포 (Zero-downtime Deployment) 전략을 통해 서비스를 중단되지 않는 상태로 유지하려 한다. (개념에 대한 자세한 내용과 세부 전략은 <a href="https://hudi.blog/zero-downtime-deployment/">이 포스트</a>를 참고해주길 바란다.) 여기서 등장하는 게 로드밸런서 (LoadBalancer)인데,  nginx나 HAProxy와 같은 제품들이 존재하고, AWS 역시 이를 지원하니 실제 운영 서버를 만들 때 이를 적용해볼 생각이다.</p>

<p>그리고 또 든 생각은, 내가 앞으로 만들 프로젝트가 모놀리식이 아닌 마이크로 서비스에 가깝게 구현되려면 어떻게 해야 하는가? 에 대한 고찰이다. 뜬금없지만 문득 그런 생각이 든 이유는, “마이크로서비스는 작은 서비스들을 많이 만들자는 거 아냐? 그러면 서비스 단위로 모듈을 나눠야 하는 게 맞는 거 아닌가?” 라는 의문이 들었기 때문이다.</p>

<p>응용 계층은 어쩔 수 없다고 하더라도, 그 아래는 서비스 단위로 <code class="language-plaintext highlighter-rouge">UserService</code>, <code class="language-plaintext highlighter-rouge">WikiService</code> 이런 식으로 존재해도 되는 거 아닌가? 라고 생각을 했는데, 이러면 공통으로 사용 가능한, Common 코드가 불필요하게 반복될 수 있을 것 같았다. 예를 들어 사용자가 원하는 이미지를 클라우드에 업로드하는 기능이 있다고 가정하면, 사용자 프로필로도 사용될 수 있을 것이고, 게시물에도 사용될 수 있을 것이고… 암튼 많이 사용될 건데 이를 일일이 넣는 것은 전혀 객체지향적이지 않다. 그러므로 이미지를 클라우드에 업로드하는 기능과 같이 중복될 수 있는 코드들은 초기 설계 및 구현할 때나 리팩토링할 때 무조건 분리해서 재사용하는 식으로 해야 할 필요성을 느끼게 되었다.</p>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #11. init: Thymeleaf 적용 ~ #13. init: lombok.config 파일 추가에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 3. 07/12 진행 내용</title><link href="http://localhost:4000/vcw3/" rel="alternate" type="text/html" title="[vocawik] 3. 07/12 진행 내용" /><published>2023-07-12T00:00:00+09:00</published><updated>2023-07-12T00:00:00+09:00</updated><id>http://localhost:4000/vcw3</id><content type="html" xml:base="http://localhost:4000/vcw3/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #9. init: Swagger3 적용 ~ #10. init: Github Actions를 통한 CI/CD 파이프라인 자동화에 대한 내용입니다.</p>
</blockquote>

<h2 id="9-init-swagger3-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/8103ea20b9e718e06a12d6cefd4c77a4a24826c5">#9</a>. init: Swagger3 적용</h2>

<p>REST 웹 서버로 요청되는 URL 리스트를 문서화 및 테스트 할 수 있는 Swagger3를 Api 모듈 내에 도입하였다.</p>

<blockquote>
  <ul>
    <li>처음엔 Springfox3 라이브러리의 Swagger를 사용하였는데 Springfox3가 실행되지 않는 오류가 발생했다. 개발자 포럼에서도 자주 언급되는 유명한 이슈인데, Spring Boot 2.6 이상의 환경에서 발생하는 이 오류는 아직까지도 해결되지 않았다고 한다. Spring Boot 버전을 2.6 이하로 낮추는 것이 제일 안전한 방법이겠지만, 다른 해결책이 없나 구글링해보았더니 <a href="https://shanepark.tistory.com/366">이 포스트</a>에서 @EnableSwagger2 어노테이션 대신 @EnableWebMvc 어노테이션을 이용해 문제를 해결하길래 나도 적용해서 해결했다.</li>
    <li>그런데 @EnableWebMvc 어노테이션을 추가하는 건 어떤 의미를 가질까? 라는 질문에 <a href="https://goodgid.github.io/Spring-Enable-MVC-Annotation/">해당 포스트</a>의 내용을 참고해 답변해본다면, @EnableWebMvc는 Spring 프레임워크에서 여러 Config 값을 알아서 설정해주는데 아래의 오류를 일으키는 this.condition 부분도 알아서 설정해주는 것 같다.</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Caused by: java.lang.NullPointerException:
Cannot invoke "org.springframework.web.servlet.mvc.
condition.PatternsRequestCondition.getPatterns()"
because "this.condition" is null
</code></pre></div>  </div>

  <ul>
    <li>그러나 <a href="https://mvnrepository.com/artifact/io.springfox/springfox-swagger2">Springfox3 라이브러리의 Swagger는 2020년 이후로 업데이트가 중지되었다는 것</a>을 알게 되었고, <a href="https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-ui">이를 대체하면서 최근까지도 업데이트가 이루어진 Spingdoc 라이브러리의 Swagger</a>를 적용하게 되었다.</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    // 'org.springdoc:springdoc-openapi-starter-webmvc-ui'
    // : SpringDoc OpenAPI를 통해 자동으로 API 문서를 생성하여 Swagger UI를 통해 보여줌
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0'

}
</code></pre></div></div>

<ul>
  <li>다음과 같이 <code class="language-plaintext highlighter-rouge">SwaggerConfig</code> 클래스를 통해 Swagger UI를 통해 보여질 OpenAPI 문서를 정의하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.api.config;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Info;
import lombok.RequiredArgsConstructor;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 제목, 버전과 같은 OpenAPI 문서의 정보 정의
@OpenAPIDefinition(info = @Info(title = "vocawik api", version = "v1"))
@RequiredArgsConstructor
@Configuration
public class SwaggerConfig {
    @Bean
    public GroupedOpenApi groupedOpenApi() {
        String[] paths = {"/v1/**"};

        // GroupedOpenApi : 그룹화된 OpenAPI 스펙을 담은 객체
        return GroupedOpenApi.builder().group("vocawik").pathsToMatch(paths).build();
    }
}

</code></pre></div></div>

<p><img src="https://github.com/pocj8ur4in/vw-backend/assets/105341168/3204e09d-eb05-4af4-afd6-e2f4bf34276c" style="padding-left: 10%; padding-right: 10%" /></p>

<ul>
  <li><a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a>로 접속해보면 Swagger 페이지가 정상적으로 출력된다.</li>
</ul>

<blockquote>
  <p>Swagger와 별개로 스프링부트 어플리케이션을 실행할 때 나오는 SPRING.JPA.OPEN-IN-VIEW 경고 메세지가 신경쓰였다. OSIV (Open Session In View) 설정이 true일 경우엔 지나치게 오랜 기간 데이터베이스 커넥션을 유지해 시스템 장애를 일으킬 수 있다고 한다. 그러나 OSIV가 꺼져 있으면 모든 지연 로디을 트랜잭션 안에서 처리하는 문제가 발생해 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해야 된다. 일단 이 점들을 인지하고 있다가, 추후에 문제가 터지면 이 부분을 고쳐야할 checklist로 적어두었다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> jpa:
   # SPRING.JPA.OPEN-IN-VIEW 로그 오류 해결
   open-in-view: false
</code></pre></div>  </div>
</blockquote>

<h2 id="10-init-github-actions를-통한-cicd-파이프라인-자동화"><a href="https://github.com/pocj8ur4in/vw-backend/commit/66b91ccbcce79d613f8beec47426d3dbc7eae408">#10</a>. init: Github Actions를 통한 CI/CD 파이프라인 자동화</h2>

<p>지속적 통합 및 배포를 위한 CI/CD 파이브라인에 대해 고민해볼 시간이다. Travis, Jenkins, github actions와 같은 CI/CD 관리 도구들이 있는데, <a href="https://choseongho93.tistory.com/295">이 게시글</a>을 참고했을 때 비교적 소규모 프로젝트인 나의 경우에는 Jenkins에 비해 github action를 사용하는 것이 바람직해 보였다. 일단 Github Action과 Github Flow와 관련해서 <a href="https://zzsza.github.io/development/2020/06/06/github-action/">해당 게시글</a>과 <a href="https://gmlwjd9405.github.io/2018/05/12/how-to-collaborate-on-GitHub-3.html">해당 게시글</a>을 참고하였다.</p>

<p>2명 이상의 작업을 진행할 때는 원격에서 <code class="language-plaintext highlighter-rouge">feature</code> 브랜치를 두어 이를 공유하고 <code class="language-plaintext highlighter-rouge">dev</code> 브랜치에서 병합될 때에도 <code class="language-plaintext highlighter-rouge">github flow</code>를 동작시키는 게 맞겠지만, 나 혼자 작업하는 것이니 편의상 생략하였다. 또한 협업에서는 보통 개발 서버와 운영 서버, 즉 2개 이상의 서버를 두어 개발하는데, 이 역시도 비용상의 문제로 로컬 서버를 개발 서버로 하고 이를 운영 서버로 배포하는 흐름으로 할 것이니 미리 양해를 구한다.</p>

<ul>
  <li>master 브랜치는 함부로 수정할 수 없도록 <a href="https://kotlinworld.com/292">해당 게시글</a>을 참고하여 Branch protection rules를 생성하였다.</li>
  <li>CI 및 CD 파이프라인의 자동화를 위한 <code class="language-plaintext highlighter-rouge">CI&amp;CD Pipeline.yml</code>을 작성하였다. 이제 작업물을 <code class="language-plaintext highlighter-rouge">push</code>가 이루어질 때, 빌드와 테스트 작업 혹은 빌드와 테스트 및 배포 작업이 자동화되어 실행된다.
    <ul>
      <li><a href="https://devjem.tistory.com/76">해당 게시글</a>을 참고하여 Github Actions에서 Gradle을 캐싱할 수 있도록 하였다.</li>
      <li><a href="https://velog.io/@bagt/Github-Actions를-통한-배포">해당 게시글</a>을 참고하여 AWS를 통한 배포 자동화 (CI)를 위해 빌드된 프로젝트를 미리 압축하도록 하였다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Github Actions의 workflow 이름 정의
name: CI&amp;CD Pipeline

# 이벤트 트리거 설정
on:
  push:
    branches:
      - master

# 실행 환경 설정
jobs:
  push:
    runs-on: ubuntu-latest
    strategy: # matrix : 동일한 workflow를 여러 가지 다른 환경에서 실행시킴
      matrix:
        java-version: [ 17 ]

    steps:
      # 레포지토리를 체크아웃하여 워크스페이스에 가져옴
      - name: Check Out The Repository
        uses: actions/checkout@v3

      # Java 환경 설정
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          java-version: $
          distribution: 'corretto'

      # 버전 정보 추출
      - name: Get the version
        id: get_version
        run: |
          RELEASE_VERSION_WITHOUT_V="$(cut -d'v' -f2 &lt;&lt;&lt; ${GITHUB_REF#refs/*/})"
          echo ::set-output name=VERSION::$RELEASE_VERSION_WITHOUT_V

      # gradlew 스크립트에 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew
        shell: bash

      # Spotless 코드 포매터를 실행해 코드 스타일 확인
      - name: Check spotless
        run: ./gradlew spotlessCheck

      # Gradle로 vw-api 모듈 빌드
      - name: Execute Gradle build
        run: ./gradlew :vw-api:build --no-daemon

      # Docker 빌드 툴인 Docker Buildx 설정
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Docker Hub에 로그인
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: $
          password: $

      # Docker 이미지 빌드 및 Docker Hub에 푸시
      - name: Build and push
        uses: docker/build-push-action@v3
        with:
          context: ./vw-api
          push: true
          tags: $/$

      # 빌드된 Docker 이미지의 디제스트 값 출력
      - name: Image digest
        run: echo $

      # EC2 인스턴스 내에서 Docker 컨테이너를 실행하여 애플리케이션을 실행
      - name: Application Run
        uses: appleboy/ssh-action@v0.1.6
        with:
          host: $
          username: $
          key: $
          script: |
            # 이전에 실행 중인 도커 컨테이너 중지
            sudo docker stop $

            # 이전에 실행 중인 도커 컨테이너 강제로 삭제
            sudo docker rm -f $

            # 최신 도커 이미지를 Docker Hub에서 EC2 인스턴스로 가져옴
            sudo docker pull $/$:latest

            # 새로운 도커 컨테이너 실행
            sudo docker run -p $:8080 \
              --name $ \
              -d $/$

            # 모든 미사용 도커 이미지를 삭제
            sudo docker image prune -a -f
      

      # gradlew 스크립트의 권한 변경
      - name: gradlew permission change
        run: sudo chmod 755 gradlew

      # Sonaqube 분석
      - name: Sonaqube Analysis
        run: ./gradlew test sonarqube
          -Dsonar.host.url=$
          -Dsonar.projectKey=$
          -Dsonar.projectName=$-$
          -Dsonar.login=$
</code></pre></div></div>

<ul>
  <li>지난번에 프로젝트를 진행했을 때 도커 허브에 올라온 빌드 파일을 실행했을 때 기본 Manifest 속성이 없다는 오류가 나오면서 정상적으로 작동이 되지 않는 것을 확인하였다. 이를 찾아보니 내가 이전에 참고했던 <a href="https://gist.github.com/ihoneymon/a2ed116069af470fec0d08110604c5db">해당 게시글</a>처럼 오류를 해결한 경우도 있지만, 이 둘을 반대로 진행한 <a href="https://earth-95.tistory.com/132">이 포스트</a>와 같은 경우도 있음을 확인하였다. 왜 그럴까?
    <ul>
      <li>BootJar task와 Jar task는 빌드를 통해 jar 파일을 만드는 작업이다. 그런데 이 둘이 동시에 존재하는 이유는 Jar은 의존성이 포함되지 않고 소스 코드의 클래스 파일과 리소스 파일만 포함한 Plain Jar을, BootJar은 의존성까지 포함해 어플리케이션 실행이 가능한 executable Jar을 만들기 때문이다.</li>
      <li>그러므로, 도커 이미지에 올라간 것은 Plain Jar라 실행이 되지 않는 것이라고 추측해볼 수 있다. 그래서 이를 고려해 build.gradle 파일을 수정하였다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bootJar.enabled = true
jar.enabled = false
</code></pre></div></div>

<ul>
  <li>그런데 이번엔 <code class="language-plaintext highlighter-rouge">Execution failed for task ':bootJar'.</code>이란 오류가 발생했다. 프로젝트의 build.gradle 파일을 보니 application이 없는 모듈들에도 bootJar task를 실행시키는 것으로 되어 있어 수정하였다. 그리고 <code class="language-plaintext highlighter-rouge">Core</code> 모듈에서 test하는 부분 때문에 빌드가 안되는 현상이 일어나 일단 그 부분에 해당하는 클래스를 제외하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bootJar.enabled = false
</code></pre></div></div>

<p>여기까지가 해당 커밋에서 반영된 내용이다. 그리고 아래부터는 그 외부에서 이루어진 작업들로, 솔직히 이 부분은 여러 차례 시행착오가 있었는데 이를 남기지 않으면 분명 나중에 다시 고생할 것 같아 글로 남긴다. <a href="https://zzang9ha.tistory.com/404">이 포스트</a>가 내가 작업한 내용에 제일 근접하면서도 깔끔히 정리된 듯 하니 참고하면 좋을 듯 하다.</p>

<ul>
  <li>도커 허브에 저장소를 생성하고, 계정에 대한 토큰을 발급받아 GitHub 저장소에 secret key로 등록시켰다.
    <ul>
      <li><a href="https://medium.com/day34/container-repository-comparsion-dd4826f6a683">해당 포스트</a>에서는 도커 허브와 AWS ECR을 비교하고 있는데, 우리의 경우에는 필자가 조금 더 익숙한 도커 허브를 사용할 계획이다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/105341168/233852739-0dd8cb96-9cea-4d71-9721-45cec2a49cd8.png" /></p>

<ul>
  <li><a href="https://goodgid.github.io/Github-Action-CI-CD-AWS-EC2/">해당 포스트</a>와 <a href="https://bcp0109.tistory.com/356">해당 포스트</a>를 참고하여, AWS EC2를 구축하였다. EC2의 인스턴스 유형은 프리티어인 t2.micro로, 용량은 15GB로 운영 체제는 우분투로 설정하였다. (linux 기반 EC2는 자잘한 오류가 많다고 한다.)  다음은 EC2 인스턴스 생성과 관련하여 설정한 부분이다.
    <ul>
      <li>IntelliJ나 터미널 등의 SSH 클라이언트 접속을 위한 프라이빗 키 파일을 생성하였다.</li>
      <li>인스턴스에 대한 보안 그룹을 생성해, 인바운드 규칙과 아웃바운드 규칙을 지정하였다.</li>
      <li>탄력적 IP 주소를 할당받아, 이를 인스턴스에 연결하였다.</li>
      <li>IAM 역할을 변경하여 추후 연결할 데이터베이스 서버와 이미지 서버에 접근할 수 있게끔 하였다.</li>
      <li>해당 AWS RDS의 파라미터 그룹을 변경하여 저장하였다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/105341168/230702707-954aa971-fd6f-45c2-aa96-5c1fbbb7be9a.png" /></p>

<ul>
  <li>SSH에 접속하는 과정에서 <code class="language-plaintext highlighter-rouge">WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</code>라는 오류 메시지를 띄우면서, RSA 공유키 충돌 문제가 발생하였다. 그래서 <a href="https://kingsong.tistory.com/127">이 게시글</a>을 참고하여 known_hosts 파일을 지웠다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm /root/.ssh/known_hosts 
</code></pre></div></div>

<ul>
  <li><a href="https://www.leafcats.com/168">SSH 클라이언트에 접속하여 사용자가 root 권한을 빌린다.</a></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo su
</code></pre></div></div>

<ul>
  <li><a href="https://someone-life.tistory.com/17">패키지를 최신으로 업데이트하기 위해 이에 대한 확인 및 실행을 주기적으로 한다.</a>
    <ul>
      <li>패키지를 업데이트할 때나 패키지를 설치할 때마다 계속 핑크색 화면이랑 이런저런 log가 계속 나오는 게 신경쓰여 <a href="https://chhanz.github.io/linux/2022/08/01/ubuntu-22-04-needrestart/">해당 게시글</a>을 needrestart를 제거하고, Kernel Hint와 daemon 재시작 권고 설정 역시 비활성화하였다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt update &amp;&amp; sudo apt upgrade
</code></pre></div></div>

<ul>
  <li>그런데 일괄적으로 업데이트가 안되는 패키지가 있길래, 업그레이드 가능한 패키지를 확인하고 이를 개별로 설치하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt list --upgradable
apt install &lt;패키지명&gt;
</code></pre></div></div>

<ul>
  <li>디스크별 용량을 주기적으로 확인해두자. 지난번 프로젝트를 진행할 때 이 부분을 신경 쓰지 못해서 EC2를 한번 지워야 하는 경우가 있었다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df -h
</code></pre></div></div>

<ul>
  <li>AWS 서비스를 관리할 수 있도록 AWS CLI를 설치하였다. 이전에 IAM 역할을 잘 변경했다면, s3나 rds 명령어도 잘 작동될 것이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt install awscli
</code></pre></div></div>

<ul>
  <li>SpringBoot 프로젝트를 빌드할 수 있도록 JDK를 설치하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt install openjdk-17-jdk
java -version
javac -version
</code></pre></div></div>

<ul>
  <li>추가로 <code class="language-plaintext highlighter-rouge">vim ~/.bashrc</code>으로 JDK의 환경변수를 설정하고, <code class="language-plaintext highlighter-rouge">source ~/.bashrc</code>로 이를 적용하였다. (변경된 내용은 <code class="language-plaintext highlighter-rouge">echo $JAVA_HOME</code>로 확인해볼 수 있다.)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which java))))
export PATH=$PATH:$JAVA_HOME/bin
</code></pre></div></div>

<ul>
  <li>아래의 명령어를 이용하여 도커를 설치하였는데, <code class="language-plaintext highlighter-rouge">Job for docker.service failed because the control process exited with error code</code>라는 오류가 발생하면서 도커가 실행되지 않아 <a href="https://dct-wonjung.tistory.com/entry/Docker-failed-control-process-exited-오류-해결">해당 게시글</a>을 통해 해결하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt install docker.io 
systemctl start docker
systemctl enable docker
</code></pre></div></div>

<ul>
  <li>이전에 프리티어가 메모리가 1기가밖에 안되어 소나큐브를 실행만 하면 계속 튕기는 일이 발생하였다. 사실 이런 일은 처음이라 감도 못 잡았다가 <a href="https://velog.io/@seungju0000/ec2-stop">이 게시글</a>로 어떤 일이 벌어지는지 대충이나마 이해하게 되었다. 그래서 이번에는 <a href="https://kth990303.tistory.com/361">해당 게시글</a>로 Swap File을 이용해 EC2 메모리 부족 현상을 해결해보고자 하였다.
    <ul>
      <li>스왑된 메모리는 <code class="language-plaintext highlighter-rouge">free</code> 명령어로 확인해볼 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">top</code> 명령어로 메모리 할당량을 프로세스 별로 확인해볼 수 있다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dd if=/dev/zero of=/swapfile bs=128M count=16
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
</code></pre></div></div>

<ul>
  <li>스왑된 메모리가 자동으로 마운트가 가능할 수 있도록 <code class="language-plaintext highlighter-rouge">vi /etc/fstab</code>으로 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 파일의 맨 밑줄에 해당 명령어를 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/swapfile swap swap defaults 0 0
</code></pre></div></div>

<ul>
  <li>그리고 톰캣을 설치하였는데, <a href="https://velog.io/@bonjaski0989/AWS-EC2-Linux-환경에서-톰캣-설치하기">이 게시글</a>에 잘 정리되어 있어 이를 그대로 작업하였다. (아, JAVA 환경변수는 이미 설정하였으므로 해당 부분만 제외하였다.)
    <ul>
      <li>톰캣을 매번 재시작할 수 있도록 <a href="https://velog.io/@bonjaski0989/EC2-Tomcat-서비스-등록">이 게시글</a>을 참고하였는데, 스크립트를 실행하는 과정에서 <code class="language-plaintext highlighter-rouge">files have no installation config</code>라는 오류가 발생하였다. 구글링해본 결과 Install 섹션을 활성화해야 한다고 하여 아래의 내용을 스크립트 파일에 추가하였다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<ul>
  <li>여러 개의 도커 컨테이너의 실행을 한 번에 관리할 수 있도록 도커 컴포즈를 설치하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose

docker-compose --version
</code></pre></div></div>

<ul>
  <li>도커로 SonarQube를 설치하였다. (사실 도커로 설치하지 않고 sonarqube를 설치한다면 아래의 작업들을 모두 진행해야 한다. 왜 아냐고? 다 했으니까… 근데 내가 설치한 자바 버전이랑 차이가 있어서 계속 오류가 났다.)
    <ul>
      <li>Java 설치, 환경설정</li>
      <li>DB 설치</li>
      <li>SonarQube에서 요구하는 DB table 생성</li>
      <li>DB 계정 생성 및 권한설정</li>
      <li>SonarQube 설치</li>
      <li>SonarQube에 DB 정보 설정</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube
</code></pre></div></div>

<ul>
  <li>그리고 이에 맞춰 Github workflow를 수정하였는데, <code class="language-plaintext highlighter-rouge">Permission denied(public key)</code>라는 문구를 띄우면서 Github Actions이 제대로 동작하지 않아 여러 커밋을 보냈다. 근데 원인은 Actions secrets and variables를 잘못 작성한 것이였다; 꼭, -BEGIN-와 -END- 부분도 지우지 말고 넣자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN OPENSSH PRIVATE KEY-----
...
-----END OPENSSH PRIVATE KEY-----
</code></pre></div></div>

<ul>
  <li><a href="https://bcp0109.tistory.com/357">해당 포스트</a>를 참고하여, 아래 이미지와 같이 EC2에 연결할 데이터베이스를 위해 AWS RDS를 구축하였다.
    <ul>
      <li>해당 RDS의 RDBMS는 MysSQL로 설정하였다.</li>
    </ul>
  </li>
  <li>EC2와 RDS의 연동을 위해 <a href="https://hiseon.me/linux/ubuntu/ubuntu-mysql-install/">해당 게시글</a>을 참고하여, EC2에 mysql-client를 설치하였다. 아래 이미지는 <code class="language-plaintext highlighter-rouge">sudo mysql_secure_installation</code>로 mysql를 초기화하였을 때 나오는 초기 설정으로, 래퍼런스가 정리되어 있지 않길래 나중에 필요할 때 확인할 수 있도록 첨부하였다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/105341168/230704131-ee09fe07-d135-49fa-b2df-b24341ec6f5d.png" /></p>

<ul>
  <li>mysql-client를 통해 EC2에서 RDS에 원격으로 접속되는 것까지 확인하였다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/105341168/230704595-aa3b5417-85f2-4ba9-aa8a-20a83d9746e1.png" /></p>

<ul>
  <li>그리고 ECR에 연결되는 거는 잘 되는데, 외부 접속이 계속 안되서 정말 머리깨지는 줄 알았다. 내가 해주고 싶은 말은, <a href="https://gksdudrb922.tistory.com/240">꼭 라우팅 테이블을 확인하자.</a></li>
</ul>

<p><img src="https://user-images.githubusercontent.com/105341168/233852570-41bb4a68-9448-4dcd-8e14-116a80c37eed.png" /></p>

<ul>
  <li>추가로 GitHub Actions 또한 이를 반영해 동작하게 하기 위해, <a href="https://chb2005.tistory.com/191">해당 포스트</a>를 참고하여 yml 파일을 수정하였다.</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #9. init: Swagger3 적용 ~ #10. init: Github Actions를 통한 CI/CD 파이프라인 자동화에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 2. 07/11 진행 내용</title><link href="http://localhost:4000/vcw2/" rel="alternate" type="text/html" title="[vocawik] 2. 07/11 진행 내용" /><published>2023-07-11T00:00:00+09:00</published><updated>2023-07-11T00:00:00+09:00</updated><id>http://localhost:4000/vcw2</id><content type="html" xml:base="http://localhost:4000/vcw2/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #4. init: spotless 적용 ~ #8. init: sonarqube 적용에 대한 내용입니다.</p>
</blockquote>

<h2 id="4-init-spotless-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/68f5025c7d1886575a90b36bb4bad62072b2f59d">#4</a>. init: spotless 적용</h2>

<p>Junit의 코드 포맷팅 및 유지보수를 위해 <a href="https://nesoy.github.io/articles/2020-04/Spotless">해당 게시글</a>을 참고해 <code class="language-plaintext highlighter-rouge">spotless</code> 플러그인을 추가하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins {
    ...

    // 'com.diffplug.spotless' : 코드 파일의 포맷팅 규칙을 정의하고, 코드에 적용될 자동 포맷팅 작업을 설정
    id 'com.diffplug.spotless' version '6.16.0'
}
</code></pre></div></div>

<ul>
  <li>sub 모듈에도 해당 플러그인이 적용되도록 <a href="https://keelim.tistory.com/entry/안드로이드-멀티-모듈-공통-gradle-그리고-ktlint-적용을-해보자">해당 게시글</a>을 참고해 외부 스크립트 <code class="language-plaintext highlighter-rouge">spotless.gradle</code> 파일을 생성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spotless {
    // Spotless 플러그인의 버전을 6.16.0으로 설정
    version = "6.16.0"

    // Java 소스 파일(**/*.java)에 대한 포맷팅과 스타일을 지정
    java {
        target("**/*.java")

        // importOrder() : import문의 순서 정렬
        importOrder()

        // removeUnusedImports() : 사용되지 않는 import문 제거
        removeUnusedImports()

        // googleJavaFormat().aosp() : Google Java 스타일 가이드에 따른 코드 포맷팅
        googleJavaFormat().aosp()

        // trimTrailingWhitespace() : 라인 끝의 공백 제거
        trimTrailingWhitespace()

        // endWithNewline() : 파일의 맨 마지막에 빈 줄 추가
        endWithNewline()
    }
}
</code></pre></div></div>

<ul>
  <li>그리고 sub 모듈에서도 spotless 플러그인이 적용될 수 있도록 root 모듈에 <code class="language-plaintext highlighter-rouge">spotless.gradle</code> 파일을 적용시켰다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// apply from : Gradle 빌드 스크립트에서 외부 스크립트 파일을 프로젝트에 적용
apply from: "$rootDir/spotless.gradle"
</code></pre></div></div>

<h2 id="5-init-git-hook과-gradle을-통한-spotless-자동화"><a href="https://github.com/pocj8ur4in/vw-backend/commit/4fed89c42bc0241e31123d7565b6781a11f83ccd">#5</a>. init: git hook과 gradle을 통한 spotless 자동화</h2>

<p>앞서 spotless를 적용하긴 했는데, spotless를 실행하는 것은 코드를 작성하고 이를 커밋하는 과정에서 까먹기 쉬운 작업이다. 그래서 <a href="https://techblog.woowahan.com/2530/">이 게시글</a>처럼 git hook으로 커밋을 하기 전에 spotless를 적용하는 것을 자동화하였다.<br /></p>

<p>그런데 .git는 처음에 .gitignore을 통해 제외하기로 한 디렉토리이다. 나 혼자 작업을 진행한다면 위의 내용으로 충분하겠지만, 협업에서는 모두가 같은 내용을 적용하는 것이 중요하다. 그래서 root에 <code class="language-plaintext highlighter-rouge">pre-commit</code> 파일을 두고, gradle task를 이용해 빌드가 이루어질 때 pre-commit 파일을 .git에 이동하는 것을 추가하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 'pre-commit'을 '.git/hooks' 디렉토리에 설치
    task installGitHooks(type: Copy) {
        from new File(rootProject.rootDir, 'pre-commit')
        into { new File(rootProject.rootDir, '.git/hooks') }
    }

    // 'installGitHooks'을 'build' 작업의 의존성으로 설정
    build.dependsOn installGitHooks
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pre-commit</code> 파일은 깃 스테이지에 올라간 파일들에 대해 spotlessApply를 실행하고 변경된 파일들을 다시 추가한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 스테이지에 올라간 파일 목록 가져오기
stagedFiles=$(git diff --staged --name-only)

# spotlessApply 실행
./gradlew spotlessApply

# 각 파일에 대해 주석 처리
for file in $stagedFiles; do
  # 파일인 경우에만 주석 처리
  if test -f "$file"; then
    # 파일을 스테이지에 추가
    git add "$file"
  fi
done
</code></pre></div></div>

<h2 id="6-init-모듈-내-applicationyml-설정"><a href="https://github.com/pocj8ur4in/vw-backend/commit/75770bf08a2f3d05548747d5b607700de63fa717">#6</a>. init: 모듈 내 application.yml 설정</h2>

<p><a href="https://tecoble.techcourse.co.kr/post/2022-10-04-active_profiles/">해당 게시글</a>을 참고하여 이전에 설장한 멀티모듈 내에 프로퍼티 설정을 관리하고 환경변수를 주입할 수 있는 application.yml 파일을 생성하였다. 일단 다음과 같은 템플릿을 만들어 적용시켰는데, 추후에 필요한 경우 이를 수정할 생각이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
---
# 개발 (dev) 프로파일
spring:
  config:
    activate:
      on-profile: dev

---
# 스테이징 (staging) 프로파일
spring:
  config:
    activate:
      on-profile: staging

---
# 운영 (production) 프로파일
spring:
  config:
    activate:
      on-profile: production

</code></pre></div></div>

<ul>
  <li>지난번에 작업하였을 때에 멀티모듈을 동작시키는 과정에서 외부 모듈의 yml 파일들을 가져오지 못하는 경우가 있었다. 그래서 XXXApplication.java의 XXXApplication 클래스에 System.setProperty를 통해 시스템 프로퍼티를 가져와 이를 설정으로 가져오게끔 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package vw.api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ApiApplication {
    public static void main(String[] args) { // 추가된 부분
        System.setProperty(
                "spring.config.name", "application, application-domain, application-core");

        SpringApplication.run(ApiApplication.class, args);
    }
}
</code></pre></div></div>

<h2 id="7-init-jacoco-설정"><a href="https://github.com/Hongik-Challenge/hc-backend/commit/a10ebd2a12774c3a40484d6bf76c26f265180a41">#7</a>. init: jacoco 설정</h2>

<p><a href="https://seller-lee.github.io/java-code-coverage-tool-part2">해당 게시글</a>을 참고해 sub 모듈에 코드 커버리지 도구인 Jacoco를 도입하였다. Jacoco도 spotless처럼 외부 스크립트를 통해 관리하고자 하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subprojects {
    // 'jacoco' : Java 코드의 코드 커버리지를 측정
    apply plugin: 'jacoco'

    apply from: "$rootDir/jacoco.gradle"
}
</code></pre></div></div>

<ul>
  <li>추후 SonarQube의 연동을 위해 jacocoTestReports task를 설정하였다. html, csv, xml 형태로 저장할 수 있게 해주고, xml 파일은 저장하는 경로를 다르게 설정하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jacoco {
    toolVersion = '0.8.9' // Jacoco 도구 버전 설정
}

test {
    finalizedBy jacocoTestReport // 테스트가 완료된 후에 jacocoTestReport 태스크 실행
}

jacocoTestReport {
    dependsOn test // jacocoTestReport 태스크가 실행되기 전에 test 태스크 실행
    reports {
        html.enabled true // HTML 형식의 보고서 생성
        csv.enabled true // CSV 형식의 보고서 생성
        xml.enabled true // XML 형식의 보고서 생성
    }

    def Qdomains = []

    for (qPattern in '*.QA'..'*.QZ') { // Q 패턴을 가진 도메인을 Qdomains에 추가
        Qdomains.add(qPattern + '*')
    }

    afterEvaluate {
        classDirectories.setFrom(
                files(classDirectories.files.collect {
                    fileTree(dir: it, excludes: [] + Qdomains)
                        // Q 패턴을 가진 도메인을 제외한 classDirectories 설정
                })
        )
    }

    finalizedBy 'jacocoTestCoverageVerification'
        // jacocoTestCoverageVerification 태스크가 실행된 후에 jacocoTestReport 태스크 실행
}

    violationRules {
        rule {
            enabled = true
            excludes = [] + Qdomains // Q 패턴을 가진 도메인을 제외하고 규칙을 적용
        }
    }
}

</code></pre></div></div>

<ul>
  <li>원하는 코드 커버리지를 설정하고, 커버리지를 만족하는지 여부를 확인하는 데에 쓰일 수 있는 jacocoTestCoverageVerification task를 설정하려 했으나, 커버리지를 만족시키기 위해 설정해야 하는 기준을 판단하기 어려워 다음의 내용은 일단 제외하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                counter = 'BRANCH'
                value = 'COVEREDRATIO'
                minimum = 0.90
            }

            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.80
            }

            limit {
                counter = 'LINE'
                value = 'TOTALCOUNT'
                maximum = 200
            }
        }
    }
}
</code></pre></div></div>

<ul>
  <li>대신 QueryDSL가 자동으로 생성하는 QDomain 클래스를 코드 커버리지에서 제외하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jacocoTestCoverageVerification {
    def Qdomains = []

    for (qPattern in '*.QA'..'*.QZ') { // Q 패턴을 가진 도메인을 Qdomains에 추가
        Qdomains.add(qPattern + '*')
    }
    ...
</code></pre></div></div>

<ul>
  <li>그런데 <code class="language-plaintext highlighter-rouge">./gradlew test --console verbose</code>으로 실행해도 빌드가 성공하지 않았는데, jacoco의 버전을 올려보라는 <a href="https://stackoverflow.com/questions/53911122/how-to-fix-error-while-creating-report-jacoco">답변</a>을 적용해 해결하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jacoco {
    toolVersion = '0.8.7' -&gt; '0.8.9'
}
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/105341168/230381060-a2972bf0-8abb-4c92-b493-d19c3912106d.png" /></p>

<h2 id="8-init-sonarqube-적용"><a href="https://github.com/pocj8ur4in/vw-backend/commit/5dc906b6d60e13cbcf0c093afad66cb0c5c9cfb3">#8</a>. init: sonarqube 적용</h2>
<p><a href="https://kdevkr.github.io/static-analysis-performed-by-sonarqube-and-github-action/#소나큐브-시스템-구성">해당 게시글</a>을 참고해, Jacoco와 비슷한 코드 커버리지 도구인 sonarqube를 프로젝트 내에 도입하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins { 
    // 'org.sonarqube' : 정적 코드 분석을 통해 버그, 취약점, 코드 스멜 등을 감지하고,
    // 이를 바탕으로 한 보고서를 생성하여 소프트웨어의 품질을 관리
    id 'org.sonarqube' version '4.0.0.2929'
    ...
}

apply from: "$rootDir/sonarqube.gradle"
...
</code></pre></div></div>

<ul>
  <li>pull request가 종료되면서 개발 서버에 빌드 파일이 배포되기 전에 소나큐브가 실행되는 것을 목표로 하므로, 차후 작성된 github action에 이를 반영할 것이다.</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #4. init: spotless 적용 ~ #8. init: sonarqube 적용에 대한 내용입니다.]]></summary></entry><entry><title type="html">[vocawik] 1. 07/10 진행 내용</title><link href="http://localhost:4000/vcw1/" rel="alternate" type="text/html" title="[vocawik] 1. 07/10 진행 내용" /><published>2023-07-10T00:00:00+09:00</published><updated>2023-07-10T00:00:00+09:00</updated><id>http://localhost:4000/vcw1</id><content type="html" xml:base="http://localhost:4000/vcw1/"><![CDATA[<blockquote>
  <p><a href="https://github.com/pocj8ur4in/vw-backend">vocawik</a> 프로젝트의 #1. init: git 저장소 생성 ~ #3. init: 멀티모듈 프로젝트 세팅에 대한 내용입니다.</p>
</blockquote>

<h2 id="1-init-git-저장소-생성"><a href="https://github.com/pocj8ur4in/vw-backend/commit/4dd2e5b458282cc895a7b38d3f2d3aa37ceabb65">#1</a>. init: git 저장소 생성</h2>

<p>가장 먼저 진행할 작업은 작업물의 변경점과 버전을 관리하는 버전 관리 시스템 (VCS; Version Control System)을 도입할 것이다. 변경점 관리를 통해 협업하는 과정에서 누가 어떤 내용을 언제 수정했는지 확인할 수 있고, 버전 관리를 통해 작업하는 과정에서 작업물의 백업과 복구를 간편하게 수행할 수 있다. 여기서는 배포할 코드와 작업할 코드를 나눠 프로젝트를 진행할 수 있는 브랜치 (branch) 개념이 있고 대부분의 개발자에게 이미 익숙할 <a href="https://git-scm.com">git</a>을 사용하겠다.</p>

<ul>
  <li>.git 디렉터리를 생성하였다.</li>
  <li>git이 관리하지 않을 파일을 지정하기 위해 .gitignore 파일을 생성하고, 그 내용은 <a href="https://www.toptal.com/developers/gitignore">gitignore.io</a>을 참고해 작성하였다.</li>
</ul>

<p>추가로 앞으로 있을 수 있는 협업에서의 원활한 의사소통을 위한 커밋 메세지 컨벤션 (commit message convention) 을 정하여, git에 커밋하는 메시지 제목과 내용에 반영하고자 한다. 여기서는 <a href="https://udacity.github.io/git-styleguide/">유다시티 커밋 메시지 스타일 가이드</a>를 참고해 다음과 같은 원칙을 정하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- message structure
  - type: subject
  - body

- type
  - init : 초기 업무
  - chore : 빌드 업무 및 패키지 매니저 수정
  - feat : 새로운 기능 도입
  - fix : 버그 수정
  - docs : 문서 수정
  - style : 코드 포맷팅 (크드 변경이 없는 경우)
  - refactor : 코드 리펙토링
  - test : 테스트 코드 추가

- subject
  - 제목에 해당하는 subject는 현재시제로 50자 내외에서 작성한다.

- body
  - 본문에 해당하는 body는 부연설명이 필요한 경우에만 작성한다.
</code></pre></div></div>

<p>그리고 Git 원격 저장소를 웹에 호스팅하는 서비스인 Git 웹 호스팅 서비스를 도입할 것이다. 이를 통해 협업하는 과정에서 작업 내용을 빠르게 공유하고, webhook 기능을 통해 pull이나 pull request 같은 이벤트에 반응하여 작업이 실행되게 할 수 있다. 여기서는 데비옵스 (DevOps) 파이프라인 자동화 툴인 Github Actions나 업무의 생성, 진행상황, 해결을 추적하는 이슈 트래커 툴인 Github Issue 등의 서비스를 지원하고 대부분의 개발자에게 이미 익숙할 <a href="https://github.com">Github</a>를 사용하겠다.</p>

<ul>
  <li>github 계정에 프로젝트를 저장할 원격 저장소를 만들고, 현재 로컬 저장소의 내용을 원격 저장소에 푸시하였다.</li>
</ul>

<h2 id="2-init-프로젝트-생성"><a href="https://github.com/pocj8ur4in/vw-backend/commit/fc26e92fe1235029c2b14c6aa45cc6419aaaa5cd">#2</a>. init: 프로젝트 생성</h2>

<p>이제 웹 어플리케이션을 구현하기 위한 기술을 정할 차례이다. 사실 이 부분은 개발자 조직과 비즈니스 기획을 고려해 의사결정을 해야 하는 게 맞겠지만, 나에게 러닝커브가 적고 라이브러리 및 래퍼런스가 많이 존재하는 Java를 프로그래밍 언어로, Spring Boot를 웹 프레임워크로, Gradle을 의존성 관리 도구로 사용할 계획이다.</p>

<ul>
  <li>Gradle을 빌드하기 위한 <code class="language-plaintext highlighter-rouge">build.gradle</code> 파일의 <code class="language-plaintext highlighter-rouge">plugins</code>와 <code class="language-plaintext highlighter-rouge">repositories</code>를 작성하였다.
    <ul>
      <li>.<code class="language-plaintext highlighter-rouge">gradle</code> 파일을 작성하는 방법은 <a href="https://velog.io/@appti/series/gradle">해당 포스트</a>와 <a href="https://araikuma.tistory.com/category/IT%20개발/Gradle">해당 포스트</a>를 참고하였다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Gradle 플러그인
plugins {
    id 'java'

    // Spring Framework 기반의 자바 애플리케이션의 개발 및 실행을 지원하는 프레임워크
    id 'org.springframework.boot' version '3.1.1'

    // Spring Boot 기반의 Gradle 프로젝트에서 의존성 버전을 관리하고 정의하는 플러그인
    id 'io.spring.dependency-management' version '1.1.0'
}

// Gradle 빌드 스크립트에서 Maven Central Repository를 프로젝트의 의존성 해결을 위한 저장소로 사용
repositories {
    mavenCentral()
}
</code></pre></div></div>

<h2 id="3-init-멀티모듈-프로젝트-세팅"><a href="https://github.com/pocj8ur4in/vw-backend/commit/fc0f6521f6a53169fc45dec379a307e119da4dc6">#3</a>. init: 멀티모듈 프로젝트 세팅</h2>

<p>프로젝트의 내부를 기존의 rootProject인 <code class="language-plaintext highlighter-rouge">vw-backend</code>에 sub 모듈인 <code class="language-plaintext highlighter-rouge">api</code>, <code class="language-plaintext highlighter-rouge">core</code>, <code class="language-plaintext highlighter-rouge">domain</code> 모듈을 포함시킨 멀티모듈 구조로 변경하였다.</p>

<ul>
  <li>sub 모듈들을 하나의 디렉토리에서 관리할 수 있도록 <code class="language-plaintext highlighter-rouge">settings.gradle</code> 파일을 작성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// rootProject : Gradle 프로젝트 구조에서 최상위 프로젝트를 나타내는 객체
// - .name : 루트 프로젝트의 이름을 지정
rootProject.name = 'vw-backend'

// - include : 하위 프로젝트의 디렉토리 이름을 지정해 해당 디렉토리 안에 있는 빌드 스크립트를 실행
include 'vw-api'
include 'vw-core'
include 'vw-domain'
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">build.gradle</code>에 subprojects와 allprojects 블록을 추가해 하위 모듈과 전체 모듈을 제어할 수 있도록 하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// plugins {} : Gradle 플러그인
// - Gradle 7.0 이상에선 apply plugin: '(plugin-id)' 대신 plugins { id '(plugin-id)' } 사용을 권장
plugins {
    // 'java' : Gradle에 내장된 Java 플러그인을 프로젝트에 적용
    id 'java'

    // 'org.springframework.boot' : Spring Framework 기반의 자바 애플리케이션의 개발 및 실행을 지원하는 프레임워크
    id 'org.springframework.boot' version '3.1.1'

    // 'io.spring.dependency-management' : Spring Boot 기반의 Gradle 프로젝트에서 의존성 버전을 관리하는 플러그인
    id 'io.spring.dependency-management' version '1.1.0'
}

// allprojects {} : Gradle 빌드 스크립트에서 모든 프로젝트에 공통으로 적용되는 설정을 지정
allprojects {
    // group : 모든 프로젝트의 고유한 식별자인 group을 지정
    group = 'vocawik'

    // version : 모든 프로젝트의 릴리스 또는 빌드 버전을 나타내는 version을 지정
    version = '0.0.1-SNAPSHOT'

    // sourceCompatibility : 모든 프로젝트의 소스 호환성을 Java 17로 설정
    sourceCompatibility = '17'

    // 모든 프로젝트의 Gradle 빌드 스크립트에서 Maven Central Repository를 프로젝트의 의존성 해결을 위한 저장소로 사용
    repositories {
        mavenCentral()
    }
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// subprojects {} : Gradle 빌드 스크립트에서 하위 프로젝트에 공통으로 적용되는 설정을 지정
subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    // java-library : Java 소스 코드를 컴파일하고 라이브러리 파일 (JAR) 형태로 빌드하는 플러그인
    apply plugin: 'java-library'

    // 멀티모듈 프로젝트에서 bootJar 파일 생성 비활성화 &amp; Jar 파일 생성화
    bootJar.enabled = false
    jar.enabled = true

    dependencies {
      ...
    }

    // configurations {} : Gradle 빌드 스크립트에서 의존성 구성을 정의
    configurations {
        compileOnly {
            // - extendsFrom : 특정 구성이 다른 구성을 확장하도록 지정
            extendsFrom annotationProcessor
        }
    }
}
</code></pre></div></div>

<ul>
  <li>반복 코드를 어노테이션으로 자동완성하는 lombok 라이브러리를 사용하기 위해 subprojects에 의존성을 추가하였다.</li>
  <li>스프링 어플리케이션에서 Junit 기반 테스트가 가능하도록 subprojects에 의존성을 추가하였다.</li>
  <li><a href="https://jundragon.tistory.com/9">해당 포스트</a>를 참고해 lombok을 테스팅 환경에서 사용할 수 있도록 subprojects에 의존성을 추가하였다.</li>
  <li>JUnit5 API를 테스팅 환경에서 사용할 수 있도록 subprojects에 의존성을 추가하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // dependencies {} : Gradle 빌드 스크립트에서 프로젝트 의존성을 정의
    // - implementation : 컴파일 및 런타임 의존성 선언
    // - testImplementation : 테스트 코드를 작성하고 실행하기 위해 필요한 의존성 정의
    // - api : 컴파일 및 런타임 시에, 그리고 프로젝트를 사용하는 다른 모듈에서 해당 의존성을 사용할 수 있도록 선언
    // - compileOnly : 컴파일 시에만 필요한 의존성 정의
    // - runtimeOnly : 런타임 시에만 필요한 의존성 정의
    // - testCompileOnly : 테스트 코드 컴파일 시에만 필요한 의존성 정의
    // - testRuntimeOnly : 테스트 실행 시에만 필요한 의존성 정의
    // - annotationProcessor : 컴파일 시에 어노테이션 프로세서 활성화
    // - testAnnotationProcessor : 테스트 코드 컴파일 시에 어노테이션 프로세서 활성화
    dependencies {
        // 'org.projectlombok:lombok' : Lombok 에노테이션을 사용해 소스 코드를 자동으로 생성
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'

        // 'org.springframework.boot:spring-boot-starter-test' : Spring Boot 어플리케이션의 단위 테스트, 통합 테스트, 모의 객체 등을 지원
        testImplementation 'org.springframework.boot:spring-boot-starter-test'

        // 'org.junit.jupiter:junit-jupiter-api:5.8.1' : Java 프로그래밍 언어를 위한 단위 테스트 프레임워크
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
    }
</code></pre></div></div>

<ul>
  <li><a href="https://math-coding.tistory.com/158">해당 포스트</a>를 참고해 Java 단위 테스트를 위한 JUnit5 프레임워크를 위해 <code class="language-plaintext highlighter-rouge">build.gradle</code>을 변경하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // tasks.named : 특정 이름을 가진 task를 선택하고 해당 task에 대한 구성을 수행
    tasks.named('test') {
        // useJUnitPlatform : test task에 JUnit Platform을 사용하도록 지정
        useJUnitPlatform()
    }
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Task 'wrapper' not found in project ':project'</code> 오류를 해결하고자, <a href="https://hororolol.tistory.com/546">해당 포스트</a>를 참고하여 <code class="language-plaintext highlighter-rouge">build.gradle</code>의 subprojects에서 gradle wrapper를 사용해서 빌드 환경을 맞추었다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>task wrapper(type: Wrapper) {
    gradleVersion = '7.4'    
    distributionUrl = distributionUrl.replace("bin", "all")
}
</code></pre></div></div>

<ul>
  <li>위 오류를 해결하는 과정에서 <code class="language-plaintext highlighter-rouge">Cannot add task 'wrapper' as a task with that name already exists</code> 오류가 발생해, <a href="https://taegyunum.tistory.com/entry/Cannot-add-task-wrapper-as-a-task-with-that-name-already-exists">해당 포스트</a>를 참고하여 <code class="language-plaintext highlighter-rouge">build.gradle</code>의 subprojects에서 gradle wrapper 형식을 변경하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // wrapper {} : Gradle 빌드 도구를 프로젝트에 내장시켜 빌드 환경의 일관성을 유지하는 Gradle Wrapper의 설정을 정의
    wrapper {
        // gradleVersion : 사용할 Gradle 버전을 지정
        gradleVersion = '7.4'

        // distributionUrl : Gradle 빌드 도구의 다운로드 위치를 지정
        // (기존 다운로드 URL에서 "bin"을 "all"로 변경하여 Gradle의 모든 버전을 다운로드)
        distributionUrl = distributionUrl.replace("bin", "all")
    }
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">:prepareKotlinBuildScriptModel Task fails in a Java project</code> 오류를 해결하고자, <a href="https://charactermail.tistory.com/351">해당 포스트</a>를 참고하여 <code class="language-plaintext highlighter-rouge">build.gradle</code>의 subprojects에서 <code class="language-plaintext highlighter-rouge">prepareKotlinBuildScriptModel</code>을 새로운 empty task로 추가하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 'prepareKotlinBuildScriptModel'라는 이름의 empty task 등록
    tasks.register('prepareKotlinBuildScriptModel'){}
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[vocawik 프로젝트의 #1. init: git 저장소 생성 ~ #3. init: 멀티모듈 프로젝트 세팅에 대한 내용입니다.]]></summary></entry><entry><title type="html">[Github Pages] 6. Github Pages 블로그 기능 추가</title><link href="http://localhost:4000/blog6/" rel="alternate" type="text/html" title="[Github Pages] 6. Github Pages 블로그 기능 추가" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-10-06T00:00:00+09:00</updated><id>http://localhost:4000/blog6</id><content type="html" xml:base="http://localhost:4000/blog6/"><![CDATA[<blockquote>
  <p>이 게시물은 Github Pages 블로그, 혹은 Minimal Mistakes 테마에 없는 기능들을 추가해나간 기록들이다. html이나 css를 다룰 줄 알면 금방 할 수 있는, 혹은 다 구글링하면 나오는 내용들이긴 하지만 내가 어떻게 문제를 인식하여 어떤 과정을 거쳐 이를 해결하였는지, 에 대해 자세히 쓰고 싶었다. 그래서 이 게시물은 다른 게시물들과 달리, 내가 블로그에서 부족하다고 느낀 점들을 계속 조금씩이라도 보충해나갈 계획이다.</p>
</blockquote>

<h2 id="1-블로그-댓글-feat-disqus-giscus">1. 블로그 댓글 (feat. disqus, giscus)</h2>
<p>앞서 서술한 게시물을 보면 Github Pages는 정적 웹 사이트 호스팅 서비스라는 말이 있다. 모든 웹 페이지를 미리 생성하고, 방문자로부터 요청이 들어오면 미리 만든 웹 페이지를 그대로 응답한다는 건데, 사용자와 동적으로 정보를 주고받아야 하는 댓글 등의 기능은 불가능하다는 것이다.<br /></p>

<p>그래서 처음에는 댓글 플랫폼인 <a href="https://disqus.com">disqus</a>를 통해 이를 해결하고자 하였다. 방법은 간단한데, 사이트에 가입하고 무료 플랜을 구독한 다음에 <code class="language-plaintext highlighter-rouge">_config.yml</code>를 다음과 같이 수정해주기만 하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>comments:
  provider               : "disqus" # 댓글 제공자 지정
  disqus:
    shortname            :          # disqus ID 지정
</code></pre></div></div>

<p>그런데 disqus에서 제공하는 기능인 ‘SNS로 댓글 달기’은 개발자 친화적인 기능은 아니였고, 또 나중에는 광고가 노출되기 시작했다. 그래서 대안으로 찾은 게 <a href="https://giscus.app/ko">giscus</a>인데, GitHub Discussions로 작동하고, 마크다운도 지원하면서 대댓글이나 반응과 같은 자잘한 기능들이 마음에 들었다.</p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d0db9e9a-29a3-4529-918e-f9ae0ddc9b65" width="100%" /></p>

<p>적용하는 방법도 Github 앱을 저장소에 설치한 뒤에 html 파일에 아래의 스크립트를 넣어주기만 하면 되는데, 나 같은 경우에는 Minimal Mistakes 테마에서 <code class="language-plaintext highlighter-rouge">_includes/social_share.html</code> 파일에 해당 구문을 넣어 적용시켰다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;section class="page__share"&gt;
  &lt;script src="https://giscus.app/client.js"
    data-repo="pocj8ur4in/pocj8ur4in.github.io"
    data-repo-id="R_kgDOICGarA"
    data-category="Q&amp;A"
    data-category-id="DIC_kwDOICGarM4CZ65L"
    data-mapping="pathname"
    data-strict="1"
    data-reactions-enabled="0"
    data-emit-metadata="1"
    data-input-position="top"
    data-theme="dark_dimmed"
    data-lang="ko"
    data-loading="lazy"
    crossorigin="anonymous"
    async&gt;
  &lt;/script&gt;
&lt;/section&gt;
</code></pre></div></div>

<h2 id="2-블로그-google-검색-노출-및-검색-설정">2. 블로그 Google 검색 노출 및 검색 설정</h2>
<p>아무래도 블로그를 운영하다 보면 다른 사람들의 반응이 궁금할 때가 많은데, 아무것도 설정하지 않은 블로그는 검색되지 않는다는 사실을 깨닫고 해결책을 찾아보았다. <a href="https://search.google.com/search-console/about">Google Search Console</a>에서 내 도메인을 입력한 다음에 소유권 확인을 위해 다운받은 <code class="language-plaintext highlighter-rouge">.HTML</code>파일을 <code class="language-plaintext highlighter-rouge">root</code>에 위치시키만 하면 며칠 안으로 아래와 같이 적용된다.</p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5876c2af-191d-47d7-ab9e-f3c2c55bde32" width="70%" /></p>

<p>추가로 블로그 포스트들이 검색 엔진에 검색되는 것을 가능하도록 진행할 작업들이 있는데, 먼저 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일에서 아래 설정들을 <code class="language-plaintext highlighter-rouge">true</code>로 설정한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>search                   : # 블로그 검색 여부 지정
search_full_content      : # 블로그의 내용 검색 여부 지정
</code></pre></div></div>

<p>그리고 웹 크롤링을 위해 <a href="https://github.com/pocj8ur4in/pocj8ur4in.github.io/blob/main/sitemap.yml"><code class="language-plaintext highlighter-rouge">sitemap.yml</code></a>과 <code class="language-plaintext highlighter-rouge">robots.txt</code> 파일을 생성해 <code class="language-plaintext highlighter-rouge">root</code>에 위치시키면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: *
Allow: /

# 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 차단
User-agent: *
Disallow: /

# 구글 검색 로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: Googlebot
Disallow: /

# 네이버 검색로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: Yeti
Disallow: /

Sitemap: https://pocj8ur4in.github.io/sitemap.xml
</code></pre></div></div>

<p>만약에 블로그의 방문자 수 통계를 보고 싶다면, <a href="https://analytics.google.com/analytics/web/provision/#/provision">Google Analytics</a>를 가입한 후 애널리틱스 데이터 스트림을 설정하면 된다. 이때, 측정 ID를 복사한 후 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일을 다음과 같이 수정하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Analytics
analytics:
  provider               : "google-gtag"
  google:
    tracking_id          : "(측정 ID)"
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Github Pages" /><summary type="html"><![CDATA[이 게시물은 Github Pages 블로그, 혹은 Minimal Mistakes 테마에 없는 기능들을 추가해나간 기록들이다. html이나 css를 다룰 줄 알면 금방 할 수 있는, 혹은 다 구글링하면 나오는 내용들이긴 하지만 내가 어떻게 문제를 인식하여 어떤 과정을 거쳐 이를 해결하였는지, 에 대해 자세히 쓰고 싶었다. 그래서 이 게시물은 다른 게시물들과 달리, 내가 블로그에서 부족하다고 느낀 점들을 계속 조금씩이라도 보충해나갈 계획이다.]]></summary></entry><entry><title type="html">[Github Pages] 5. Github Pages 블로그 설정 &amp;amp; 포스트</title><link href="http://localhost:4000/blog5/" rel="alternate" type="text/html" title="[Github Pages] 5. Github Pages 블로그 설정 &amp;amp; 포스트" /><published>2023-04-05T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/blog5</id><content type="html" xml:base="http://localhost:4000/blog5/"><![CDATA[<blockquote>
  <p>솔직히 블로그 설정을 건드는 부분은 내가 아는 정보들을 그대로 나열할 수 밖에 없다고 생각한다… 그래도 내가 시행착오를 겪었던 경험을 떠올리면서 하나하나 풀어서 작성하려 하였으니, 미숙한 글이지만 남들에게 도움이 되었으면 정말 좋겠다… 그리고 Github Pages이나 Minimal Mistakes으로 처음 블로그를 운영하시는 분들의 시선에 맞춰 html, css에 대한 자세한 내용은 다른 포스트로 옮겼으니 참고해주셨으면 한다.</p>
</blockquote>

<h2 id="1-블로그-기본-설정">1. 블로그 기본 설정</h2>
<p><img width="228" alt="blog1-1" src="https://user-images.githubusercontent.com/105341168/229804167-bbb75af4-6ec4-4683-9753-0f2cbf7d97bb.png" /></p>

<p>위의 디렉터리에서 <code class="language-plaintext highlighter-rouge">_config.yml</code>이라는 파일을 열어보면 다음과 같이 구성되어 있는데, 오른쪽의 주석을 참조해서 나만의 블로그를 커스텀마이징해보자. 이걸 어떻게 적용하는지 잘 모르겠다, 싶은 사람은 <a href="https://github.com/pocj8ur4in/pocj8ur4in.github.io/blob/main/_config.yml">내 블로그에 적용된 것</a>을 예시로 보면서 작업해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minimal_mistakes_skin    :         # 블로그의 전체적인 스킨 지정 
                                   # (Minimal Mistakes에서 기본적으로 제공)
                                   # "default" "air", "aqua", "contrast", "dark"
                                   # "dirt", "neon", "mint", "plum", "sunrise"

# Site Settings
locale                   : "ko-KR" # 블로그에 쓰일 로컬 언어 지정
title                    :         # 메타 태그에 들어갈 블로그의 제목 지정
subtitle                 :         # 블로그의 제목 하단에 위치할 부제목 지정
name                     :         # 블로그 저자 이름 지정
description              :         # SEO 향상을 위한 meta description 태그 지정
url                      :         # 블로그 url 
                                   # "https://(github ID).github.io"
repository               :         # github repository url
                                   # "https://github.com/(github ID)/(github ID).github.io"
teaser                   :         # 관련 포스트나 검색 등에 들어갈 미리보기 이미지 지정
                                   # ("assets/images/"로 연결)
logo                     :         # 블로그의 제목 옆에 들어갈 로고 이미지 지정
                                   # ("assets/images"로 연결)
masthead_title           :         # 블로그 프로필 상단에 위치할 사이트 제목 지정
breadcrumbs              : true    # 브래드크럼 사용 여부 지정
words_per_minute         : 200     # 포스트를 읽는 데 걸리는 시간을 계산히기 위한 분당 읽는 글자의 지정
</code></pre></div></div>

<h2 id="2-블로그-레이아웃-설정">2. 블로그 레이아웃 설정</h2>
<p>이제 조금은 삭막한(?) 블로그의 레이아웃을 뜯어고칠 차례이다. 우선은 이전처럼 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일을 아래와 같이 자신이 원하는 대로 수정하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 블로그 좌측 사이드바에 위치할 프로필 설정
author:
  name             :       # 저자 이름 지정
  avatar           :       # 저자 이미지 지정
  bio              :       # 저자 바이오그래피 지정
  location         :       # 저자 위치 지정
  email            :       # 저자 이메일 지정
  links:                   # 저자 관련 사이트 링크 지정
    - label:               # 사이트 분류 지정
      icon:                # 사이트 아이콘 지정
      url:                 # 사이트 url 지정

## 블로그 하단에 위치할 꼬리말 설정
footer:
  links:                   # 블로그 관련 사이트 링크 지정
    - label:               # 사이트 분류 지정
      icon:                # 사이트 아이콘 지정
      url:                 # 사이트 url 지정
</code></pre></div></div>

<h3 id="1-네비게이션-바">(1) 네비게이션 바</h3>

<p>다음은 기본 테마를 보면서 혹은 자기가 기능을 적용하면서 불편한 점들을 확인하고, 직접 테마의 요소들을 뜯어고치는 건데… 이건 사람마다 달라서 뭐라고 말을 못하겠다. 그래서 나 같은 경우에 어떤 부분이 불편했고, 그래서 수정했는지 얘기해보고자 한다. 우선은 블로그 상단의 네비게이션 바에 내가 보기에 불필요한 카테고리들이 있었다. 그래서 카테고리, 태그만 남기기 위해  <code class="language-plaintext highlighter-rouge">_data/navigation.yml</code> 파일을 수정하였다.  <code class="language-plaintext highlighter-rouge">_pages</code> 디렉토리를 보면 여기에 적용할 수 있는 여러 요소들이 있는데, 직접 입맛에 맛게 적용해보면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
  - title: (카테고리)        # 화면에 보여질 세부 항목의 이름 지정
    url: /(카테고리)/        # _pages 내에 정해진 양식 파일이나 특정 링크로 연결
</code></pre></div></div>

<h3 id="2-블로그-너비-및-폰트-크기">(2) 블로그 너비 및 폰트 크기</h3>

<p>그리고 블로그에 포스트를 쓸 때에 한쪽에는 VS Code를, 다른 쪽에는 로컬에서 호스팅한 블로그를 보기 위한 사파리 브라우저를 띄워 놓곤 했는데, 그때마다 기본으로 설정된 블로그 너비랑 폰트 크기가 글을 읽기에 굉장히 불편했다. 그래서 <code class="language-plaintext highlighter-rouge">_sass/minimal_mistakes/_variables.scss</code> 파일과 <code class="language-plaintext highlighter-rouge">_sass/minimal_mistakes/_reset.scss</code> 파일을 다음과 같이 수정해보았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 블로그 너비 설정
/*
   Grid
   ========================================================================== */

$right-sidebar-width-narrow: 200px !default;    // default 200px
$right-sidebar-width: 300px !default;           // default 300px
$right-sidebar-width-wide: 400px !default;      // default 400px
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 블로그 폰트 크기 설정
html {
  /* apply a natural box layout model to all elements */
  box-sizing: border-box;
  background-color: $background-color;
  font-size: 16px;                    // Default 16px;

  @include breakpoint($medium) {
    font-size: 16px;                  // Default 18px;
  }

  @include breakpoint($large) {
    font-size: 16px;                  // Default 20px;
  }

  @include breakpoint($x-large) {
    font-size: 16px;                  // Default 22px;
  }

  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
</code></pre></div></div>

<h3 id="3-블로그-아이콘">(3) 블로그 아이콘</h3>

<p>또 블로그 주소 창에 같이 뜰 아이콘이 아무것도 안 뜨니 뭔가 내 블로그 같다는 느낌이 안들었다. 그래서 이것 또한 <code class="language-plaintext highlighter-rouge">_includes/_head/custom.html</code> 파일에 내가 원하는 아이콘을 넣었다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- start custom head snippets --&gt;

&lt;!-- insert favicons. use https://realfavicongenerator.net/ --&gt;
&lt;link rel="apple-touch-icon" sizes="180x180" href="/assets/logo.ico/apple-touch-icon.png"&gt;
&lt;link rel="icon" type="image/png" sizes="32x32" href="/assets/logo.ico/favicon-32x32.png"&gt;
&lt;link rel="icon" type="image/png" sizes="16x16" href="/assets/logo.ico/favicon-16x16.png"&gt;
&lt;link rel="mask-icon" href="/assets/logo.ico/safari-pinned-tab.svg" color="#ffffff"&gt;
&lt;meta name="msapplication-TileColor" content="#ffffff"&gt;
&lt;meta name="theme-color" content="#ffffff"&gt;
</code></pre></div></div>

<p>내가 수정한 것은 이정도? 인데 자잘하게 더 파고들면 커스텀마이징할 레이아웃 요소가 정말 많다. html, css, yml 파일을 건드는 것이라 그리 어렵지도 않고, 한번 배워두면 생각보다 쓸 때도 많다. 아래는 Minimal Mistakes Themes의 디렉토리 구조에 주석을 단 것인데, 커스텀마이징이 필요할 때 이를 참고하기 좋은 것 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minimal-mistakes
├── _data                                 # 테마를 커스터마이징하기 위한 파일을 저장하는 디렉터리 
| |                                       # (yml, yaml, json, csv, tsv 파일을 자동으로 읽어들어 site.data로 사용)
| ├── navigation.yml                      # 상단 메뉴바를 커스터마이징하기 위한 파일
| └── ui-text.yml                         # 언어별로 어떤 텍스트로 표시되는지 나열하는 파일
|
├── _site                                 # 재사용되는 html 파일을 저장하는 디렉터리 (공통된 컴포넌트들 보관)
| ├── search                              # 검색 엔진을 커스터마이징한 내용을 저장하는 디렉터리
| ├── analytics-providers
| └── custom.html                         # 분석 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일
| ├── comments-providers
| └── custom.html                         # 댓글 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일
| ├── head
| └── custom.html                         # head를 커스터마이징한 내용을 저장하는 파일
| ├── footer
| └── custom.html                         # footer를 커스마이징한 내용을 저장하는 파일
| ├── nav_list                            # 메뉴 상단바의 리스트에 대한 helper 파일
| ├── archive-single.html                 # 아카이브 문서에서 단일 문서를 표현하는 방법을 저장하는 파일
| ├── author-profiles.html                # author profile link애 대한 내용을 저장하는 파일
| ├── author-profile-custom-links.html    # author profile link를 커스마이징한 내용을 저장하는 파일
| ├── breadcrumbs.html                    # breadcrumbs에 대한 내용을 저장하는 파일
| ├── single-page
| ├── page__taxonomy.html                 # 단일 문서에서 태그와 카테고리를 표현하는 방법을 저장하는 파일
| ├── tag-list.html                       # 단일 문서에서 태그 리스트를 표현하는 방법을 저장하는 파일
| └── category-list.html                  # 단일 문서에서 카테고리 리스트를 표현하는 방법을 저장하는 파일
├── _posts                                # 블로그에 포스트한 md 파일을 저장하는 디렉터리
├── _includes
├── _layouts                              # 각 문서의 디자인과 직접적으로 연결된 전체적인 레이아웃 디렉토리
├── _sass                                 # minimal-mistakes.scss에 임포트할 수 있는 scss 파일을 저장하는 스타일시트 디렉터리
├── assets                                # css, js, 이미지 파일을 저장하는 디렉터리
| ├── _css
| ├── _images
| └── _js 
├── _config.yml                           # 블로그를 구성하기 위한 기본적인 설정값을 설정하는 yml 파일
├── Gemfile                               # 사용할 gem 플러그인 목록
├── index.html                            # 블로그 처음 홈 페이지
└── package.json
</code></pre></div></div>

<h2 id="3-블로그-포스트-작성-및-머릿말-작성">3. 블로그 포스트 작성 및 머릿말 작성</h2>
<p><code class="language-plaintext highlighter-rouge">_posts</code> 폴더에 <code class="language-plaintext highlighter-rouge">XXXX(YEAR)-XX(MONTH)-XX(DAY)-(NAME).md</code>을 생성해보자. 이때 YEAR, MONTH, DAY는 포스트가 작성된 연도, 월, 일이 되고 NAME은 포스트의 경로가 된다. 그리고 파일 상단에 위치할 머릿말을 작성하기 위해 아래와 같이 <code class="language-plaintext highlighter-rouge">---</code>에 둘러싸인 내용을 작성해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
title: "[Blog] macOS에서 Minimal Mistakes로 깃허브 블로그 만들기"

categories:
    - Github.io

tag:
    [HTML, JavaScript, SCSS, Ruby]

toc: true
toc_sticky: true

date: 2022-09-26
lastmod: 2022-09-26
---
</code></pre></div></div>

<table>
    <thead>
        <tr>
            <th>양식 이름</th>
            <td>양식 설명</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>title</th>
            <td>포스트 제목</td>
        </tr>
        <tr>
            <th>categories</th>
            <td>포스트 카테고리</td>
        </tr>
        <tr>
            <th>tags</th>
            <td>포스트 태그</td>
        </tr>
        <tr>
            <th>toc</th>
            <td>우측 상단의 목차</td>
        </tr>
        <tr>
            <th>toc_label</th>
            <td>목차 이름</td>
        </tr>
        <tr>
            <th>toc_icon</th>
            <td>목차 아이콘</td>
        </tr>
        <tr>
            <th>toc_sticky</th>
            <td>목차 고정 여부</td>
        </tr>
        <tr>
            <th>date</th>
            <td>포스트 작성일</td>
        </tr>
        <tr>
            <th>lastmod</th>
            <td>포스트 수정일</td>
        </tr>
        <tr>
            <th>author_profile</th>
            <td>프로필 창 표시 여부</td>
        </tr>
    </tbody>
</table>

<p>우리가 글을 작성하는 데에 사용할 <a href="https://www.markdownguide.org/getting-started/">Markdown</a>은 텍스트 기반의 마크업 (MarkUp) 언어로, 특수기호와 문자를 활용한 매우 간단한 구조의 문법을 사용해 보다 빠르게 컨텐츠를 작성할 수 있다! Github의 <code class="language-plaintext highlighter-rouge">README.md</code>가 대표적인 예시인데, Github Pages 역시 이를 활용해 문서를 작성하는 데에 사용한다. 마크다운 문법은 <a href="https://www.markdownguide.org">여기서</a> 상세히 설명하고 있으니 참고하자.</p>

<h2 id="4-블로그-포스트-내에-문자-박스-양식-넣어보기">4. 블로그 포스트 내에 문자 박스 양식 넣어보기</h2>
<p>추가로 <code class="language-plaintext highlighter-rouge">minimal-mistakes theme</code>의 css로 설정된 스타일 요소를 class로 불러와 적용할 수 있는데, 그중 하나인 상자 양식을 활용해보자. Markdown (<code class="language-plaintext highlighter-rouge">.md</code>) 파일이니까 html 태그들을 쓰면 그대로 화면에 표현할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p class="notice--primary"&gt;
  &lt;strong&gt;
    이 항목은 현재 작성중입니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--info"&gt;
  &lt;strong&gt;
    이 항목은 macOS 기반으로 작성되었습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--danger"&gt;
  &lt;strong&gt;
    이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--warning"&gt;
  &lt;strong&gt;
    이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.
&lt;/p&gt;
</code></pre></div></div>

<div style="background-color: black; padding: 2% 2% 2% 2%">
  <p class="notice--primary">
    <strong>
      이 항목은 현재 작성중입니다.
    </strong><br />
      &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.
  </p>

  <p class="notice--info">
    <strong>
      이 항목은 macOS 기반으로 작성되었습니다.
    </strong><br />
      &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.
  </p>

  <p class="notice--danger">
    <strong>
      이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.
    </strong><br />
      &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.
  </p>

  <p class="notice--warning">
    <strong>
      이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.
    </strong><br />
      &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.
  </p>
</div>

<blockquote>
  <p>Reference</p>
  <ul>
    <li><a href="http://jekyllrb-ko.github.io/docs/structure/">Jekyll 디렉토리 구조 (번역)</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Github Pages" /><summary type="html"><![CDATA[솔직히 블로그 설정을 건드는 부분은 내가 아는 정보들을 그대로 나열할 수 밖에 없다고 생각한다… 그래도 내가 시행착오를 겪었던 경험을 떠올리면서 하나하나 풀어서 작성하려 하였으니, 미숙한 글이지만 남들에게 도움이 되었으면 정말 좋겠다… 그리고 Github Pages이나 Minimal Mistakes으로 처음 블로그를 운영하시는 분들의 시선에 맞춰 html, css에 대한 자세한 내용은 다른 포스트로 옮겼으니 참고해주셨으면 한다.]]></summary></entry></feed>