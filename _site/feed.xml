<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-05T20:36:21+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[Next.js] 1. Next.js</title><link href="http://localhost:4000/nex1/" rel="alternate" type="text/html" title="[Next.js] 1. Next.js" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/nex1</id><content type="html" xml:base="http://localhost:4000/nex1/"><![CDATA[<h2 id="nextjs--웹-애플리케이션-구축에-활용되는-오픈-소스-react-프레임워크"><a href="https://nextjs.org"><code>Next.js</code></a> : 웹 애플리케이션 구축에 활용되는 오픈 소스 <code class="language-plaintext highlighter-rouge">React</code> 프레임워크</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">React</code> 기반 : 리액트 위에서 구축되어 구성 기반 아키텍처를 활용하여 사용자 인터페이스 구축</li>
  <li>서버 측 렌더링 (<code class="language-plaintext highlighter-rouge">SSR</code>), 정적 사이트 생성 (<code class="language-plaintext highlighter-rouge">SSG</code>) 모두 지원</li>
  <li>파일 시스템 기반 라우팅 (<code class="language-plaintext highlighter-rouge">File System Routing</code>) 지원 : <code class="language-plaintext highlighter-rouge">URL</code> 경로와 프로젝트 디렉터 구조가 직접 연결</li>
  <li><code class="language-plaintext highlighter-rouge">API</code> 라우트 생성 지원 : 서버 사이드 로직을 처리할 수 있는 엔드포인트를 만들어 이를 클라이언트가 호출<br />→ 서버리스 함수의 간단한 구현 및 활용 가능</li>
  <li>자동 코드 분할 : 자바스크리트 코드를 자동으로 작은 정크로 분할해, 각 페이지에 필요한 코드만 로드</li>
  <li><code class="language-plaintext highlighter-rouge">CSS-in-JS</code> 지원 : 스타일링 솔루션에 대한 내장 지원</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Next.js" /><summary type="html"><![CDATA[Next.js : 웹 애플리케이션 구축에 활용되는 오픈 소스 React 프레임워크]]></summary></entry><entry><title type="html">[React] 3. 함수 컴포넌트 (Functional Component)</title><link href="http://localhost:4000/react3/" rel="alternate" type="text/html" title="[React] 3. 함수 컴포넌트 (Functional Component)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react3</id><content type="html" xml:base="http://localhost:4000/react3/"><![CDATA[<h2 id="함수-컴포넌트-functional-component--리액트-훅을-통한-상태와-생명주기-관리">함수 컴포넌트 (<code class="language-plaintext highlighter-rouge">Functional Component</code>) : 리액트 훅을 통한 상태와 생명주기 관리</h2>

<blockquote>
  <p>클래스 컴포넌트의 한계?</p>

  <ul>
    <li>데이터의 흐름을 추적하기 어려움 : 서로 다른 여러 메소드에서, 작성 순서에 상관없이 상태의 업데이트 발생 가능</li>
    <li>어플리케이션 내부 로직의 재사용이 어려움 : 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트나 <code class="language-plaintext highlighter-rouge">props</code>이 많아짐</li>
    <li>기능이 많아질수록 컴포넌트의 크기가 커짐 : 내부에서 처리하는 데이터 흐름이 복잡해짐</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState, useEffect } from 'react';

const MyFunctionalComponent = () =&gt; {
  // useState 훅을 사용하여 상태 정의
  const [count, setCount] = useState(0);

  // useEffect 훅을 사용하여 부수 효과(라이프사이클 작업 등) 처리
  useEffect(() =&gt; {
    console.log('Component mounted or count updated:', count);
    // componentWillUnmount 역할을 하는 함수 (클린업 함수)
    return () =&gt; {
      console.log('Component will unmount');
    };
  }, [count]); // count가 업데이트될 때만 실행

  const handleIncrement = () =&gt; {
    // setCount를 사용하여 상태 업데이트
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default MyFunctionalComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useContext</code>와 같은 리액트 훅을 사용하여 상태를 관리</li>
  <li><code class="language-plaintext highlighter-rouge">useEffect</code> 훅을 통해 라이프사이클 메소드와 유사한 동작을 수행 가능</li>
  <li><code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용하지 않고, 클래스 컴포넌트보다 간결하고 명료하게 작성 가능</li>
</ul>

<h3 id="리액트-훅-react-hook--함수형-컴포넌트에서-상태와-생명주기-메서드를-사용할-때-사용">리액트 훅 (<code class="language-plaintext highlighter-rouge">React Hook</code>) : 함수형 컴포넌트에서 상태와 생명주기 메서드를 사용할 때 사용</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c4f6fd02-e4fd-4f86-bd52-e4eed847cc3c" width="50%" /></p>

<ul>
  <li>상태 관리 훅 : <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">userContext</code>, <code class="language-plaintext highlighter-rouge">useReducer</code></li>
  <li>시점 훅 : <code class="language-plaintext highlighter-rouge">useLayoutEffect</code>, <code class="language-plaintext highlighter-rouge">useEffect</code></li>
  <li>메모이제이션 (<code class="language-plaintext highlighter-rouge">Memo</code>) 훅 : <code class="language-plaintext highlighter-rouge">useMemo</code>, <code class="language-plaintext highlighter-rouge">useCallback</code>, <code class="language-plaintext highlighter-rouge">memo</code></li>
</ul>

<blockquote>
  <p>훅의 규칙 (<code class="language-plaintext highlighter-rouge">Rules-of-Hooks</code>) : 관련 <code class="language-plaintext highlighter-rouge">ESLint</code> 규칙으로 <code class="language-plaintext highlighter-rouge">react-hooks/rules-of-hooks</code> 또한 존재</p>

  <p><code class="language-plaintext highlighter-rouge">(1)</code> 최상위에서만 훅을 호출해야 한다. (반복문, 조건문, 중첩 함수 내에서 훅을 실행할 수 없다.)<br />→ 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.<br />
<code class="language-plaintext highlighter-rouge">(2)</code> 훅을 호출할 수 있는 것은 함수 컴포넌트, 혹은 커스텀 훅만 가능하다.</p>
</blockquote>

<h4 id="usestate--함수형-컴포넌트-내부에서-상태를-정의하고-관리할-때-사용"><code class="language-plaintext highlighter-rouge">useState</code> : 함수형 컴포넌트 내부에서 상태를 정의하고 관리할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react'
const [state, setState] = useState(initState)
</code></pre></div></div>

<ul>
  <li>인수로 사용할 상태의 초기값을 받음</li>
  <li>첫번째 값에 현재 상태의 값, 두번째 값에 상태를 업데이트하는 함수가 담긴 배열을 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const [state, setState] = useState(() =&gt; Number.praseInt(window.localStorage.getItem(cacheKey)));
</code></pre></div></div>

<ul>
  <li>게으른 초기화 (<code class="language-plaintext highlighter-rouge">Lazy Initialization</code>) : <code class="language-plaintext highlighter-rouge">useState</code> 등 리액트 훅의 인자에 변수 대신 함수 자체를 넘기는 것
    <ul>
      <li><code class="language-plaintext highlighter-rouge">useState</code>의 초기값이 복잡하거나 무거운 연산을 포함하는 경우에 사용</li>
      <li>오직 상태가 처음 만들어질 때만 사용 → 리렌더링이 발생하면 이 함수의 실행은 무시</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react';

const Component = () =&gt; {
  // useState를 사용하여 counter라는 상태를 정의하고 초기값을 0으로 설정
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1)
  }

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<h4 id="useeffect--어플리케이션-내-컴포넌트의-여러-값들을-통해-부수-효과를-만들-때-사용"><code class="language-plaintext highlighter-rouge">useEffect</code> : 어플리케이션 내 컴포넌트의 여러 값들을 통해 부수 효과를 만들 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Component = () =&gt; {
  useEffect(
    () =&gt; {},
    [props, state]
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 콜백 함수, 두번째 인수로 의존성 배열을 받음 : 의존성 배열의 값이 변경되면 콜백 실행
    <ul>
      <li><code class="language-plaintext highlighter-rouge">componentDidMount</code> 시점에 비동기로 실행 → <code class="language-plaintext highlighter-rouge">rendering</code> 이후, <code class="language-plaintext highlighter-rouge">mount</code> 이후</li>
    </ul>
  </li>
  <li>클래스 컴포넌트의 생명주기와 비슷한 동작을 구현 가능 : 의존성 배열에 빈 배열을 넣으면 컴포넌트가 마운트될 때만 실행</li>
  <li>렌더링이 실행될 때마다 의존성에 있는 값을 보면서 값 (<code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">props</code>)이 변경되면 부수 효과를 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Component = () =&gt; {
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1)
  }

  const counter = 1

  useEffect(
    () =&gt; {
      console.log(count) // 1, 2, 3, 4...
    }
  )

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onClick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>클린업 함수를 반환 가능 : 컴포넌트가 언마운트될 때 실행 (<code class="language-plaintext highlighter-rouge">componentWillUnMount</code>)
    <ul>
      <li>함수 컴포넌트가 리렌더링되었을 때 의존성 변화가 있었을 당시의 값 기준으로 실행되어 이전 상태를 청소</li>
      <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useEffect</code>는 콜백이 실행될 때마다 이전 클린업 함수가 존재하면 그 클린업 함수를 실행한 뒤 콜백 실행
        <ul>
          <li>특정 이벤트 핸돌러가 무한히 생성되는 것을 방지</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState, useEffect } from 'react'

export default function App() {
  const [counter, setCounter] = useState(0)

  const handleClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  }

  useEffect(() =&gt; {
    const addMouseEffect = () =&gt; {
      console.log(counter)
    }

    window.addEventListener('click', addMouseEffect);

    return () =&gt; {
      console.log('클린업 함수', counter);
      window.removeEventListener('click', addMouseEffect);
    }
  }, [counter]);

  return (
    &lt;&gt;
      &lt;h1&gt;{counter}&lt;/h1&gt;
      &lt;button onclick={handleClick}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}

// 클린업 함수 0
// 1
// 클린업 함수 1
// 2
// ...
</code></pre></div></div>

<ul>
  <li>의존성 배열 (<code class="language-plaintext highlighter-rouge">dependency arra</code>) : 내부의 특정 값이 변경될 때에만 <code class="language-plaintext highlighter-rouge">useEffect</code> 콜백이 실행되도록 제어
    <ul>
      <li>의존성 배열에 사용자가 원하는 값을 넣는 경우 : 해당 값이 변경될 따마다 실행</li>
      <li>의존성 배열에 빈 배열을 두는 경우 : 최초 렌더링 직후에 한번 실행하고 더 이상 실행하지 않음</li>
      <li>의존성 배열에 아무런 값을 두지 않는 경우 : 렌더링이 발생할 때마다 매번 실행
        <ul>
          <li><code class="language-plaintext highlighter-rouge">vs</code> 직접 실행? : 클라이언트 사이드에서 실행 보장, 컴포넌트 렌더링 완료 이후에 실행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useEffect(() =&gt; {
  // 실행될 코드
}, [dependency1, dependency2, ...]); // 의존성 배열
</code></pre></div></div>

<h4 id="usememo--큰-연산에-대한-결과를-메모이제이션-memoization할-때-사용"><code class="language-plaintext highlighter-rouge">useMemo</code> : 큰 연산에 대한 결과를 메모이제이션 (<code class="language-plaintext highlighter-rouge">Memoization</code>)할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useMemo, useState } from 'react'

const ExpensiveComponent = ({ value }) =&gt; {
  useEffect(() =&gt; {
    console.log('rendering')
  })

  return &lt;span{value + 10000}&gt;&lt;/span&gt;
}

const App = () =&gt; {
  const [value, setValue] = useState(10);
  const [, triggerRendering] = useState(false);

  const MemoizedComponent = useMemo(
    () =&gt; &lt;ExpensiveComponent value={value}&gt;, [value]
  )

  const handleChange = (e) =&gt; {
    setValue(Number(e.target.value))
  }

  const handleClick = () =&gt; {
    setValue(Number(e.target.value))
  }

  return (
    &lt;&gt;
      &lt;input value={value} onChange={handleChange}&gt;&lt;/input&gt;
      &lt;button = onClick={handleClick}&gt;렌더링 발생&lt;/button&gt;
      {MemoizedComponent}
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 생성 함수, 두번째 인수로 해당 함수가 의존하는 값의 배열을 전달
    <ul>
      <li>렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면, 함수를 재실행하지 않고 이전의 값을 반환</li>
      <li>렌더링 발생 시 의존성 배열의 값이 변경되었으면, 첫번째 인수의 함수를 실행한 후에 그 값을 반환 및 메모이제이션</li>
    </ul>
  </li>
</ul>

<h4 id="reactmemo--외부-상태나-컨텍스트에-의존하지-않고-순수-함수형-컴포넌트를-메모이제이션할-때-사용"><code class="language-plaintext highlighter-rouge">React.Memo</code> : 외부 상태나 컨텍스트에 의존하지 않고 순수 함수형 컴포넌트를 메모이제이션할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const CreateUser = React.memo(({ username, email, onChange, onCreate }) =&gt; {
  return (
    &lt;div&gt;
      &lt;input
        name="username"
        placeholder="계정명"
        onChange={onChange}
        value={username}
      /&gt;
      &lt;input
        name="email"
        placeholder="이메일"
        onChange={onChange}
        value={email}
      /&gt;
      &lt;button onClick={onCreate}&gt;등록&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre></div></div>

<ul>
  <li>컴포넌트의 <code class="language-plaintext highlighter-rouge">props</code>이 바뀔 때에만 리렌더링을 수행</li>
</ul>

<h4 id="usecallback--인수로-넘겨받은-콜백-자체를-저장해-재성성-대신-재사용할-때-사용"><code class="language-plaintext highlighter-rouge">useCallback</code> : 인수로 넘겨받은 콜백 자체를 저장해, 재성성 대신 재사용할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const ChildComponent = memo(({name, value, onChange}) =&gt; {
  useEffect(
    () =&gt; {
      console.log('rendering', name)
    }
  )

  return(
    &lt;&gt;
      &lt;h1&gt;{name} (value ? '켜짐' : '꺼짐')&lt;/h1&gt;
      &lt;button onClick={onChange}&gt;toggle&lt;/button&gt;
    &lt;/&gt;
  )
})

const App = () =&gt; {
  const [status1, setStatus1] = useState(false)
  const [status2, setStatus2] = useState(false)

  const toggle1 = useCallback(
    function toggle1() {
      setStatus(!status1)
    }, [status1],
  )

  const toggle2 = useCallback(
    function toggle2() {
      setStatus(!status2)
    }, [status2],
  )

  return (
    &lt;&gt;
      &lt;ChildComponent name="1" value={status1} onChange={toggle1}&gt;&lt;/ChildComponent&gt;
      &lt;ChildComponent name="2" value={status2} onChange={toggle2}&gt;&lt;/ChildComponent&gt;
    &lt;/&gt;
  )
}
</code></pre></div></div>

<ul>
  <li>첫번째 인수로 함수, 두번째 인수로 해당 함수가 의존하는 값의 배열을 전달</li>
  <li>값의 메모이제이션을 위해 <code class="language-plaintext highlighter-rouge">useMemo</code>를 사용했다면, 함수의 메모이제이션을 위해 사용하는 것이 <code class="language-plaintext highlighter-rouge">useCallback</code>!
    <ul>
      <li>해당 의존성이 변경되었을 때만 함수가 재생성 : 불필요한 리소스 및 리렌더링 방지 가능</li>
      <li><code class="language-plaintext highlighter-rouge">useMemo</code>을 통해 <code class="language-plaintext highlighter-rouge">useCallback</code>를 구현할 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="useref--함수형-컴포넌트-내에서-참조를-생성하고-관리할-때-사용"><code class="language-plaintext highlighter-rouge">useRef</code> : 함수형 컴포넌트 내에서 참조를 생성하고 관리할 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, useEffect } from 'react';

function MyComponent() {
  const myInputRef = useRef(null);

  useEffect(() =&gt; {
    // 컴포넌트가 마운트된 후, input 요소에 포커스를 줌
    myInputRef.current.focus();
  }, []);

  return &lt;input ref={myInputRef} /&gt;;
}
</code></pre></div></div>

<ul>
  <li>반환값인 객체 내부에 있는 <code class="language-plaintext highlighter-rouge">.current</code>로 값에 접근 혹은 변경이 가능</li>
  <li>컴포넌트의 렌더링과 관계없이 변수를 저장 가능 → <code class="language-plaintext highlighter-rouge">useState</code>와 달리, 매번 리렌더링이 일어나지 않음</li>
  <li>주로 <code class="language-plaintext highlighter-rouge">DOM</code> 요소에 접근하거나 컴포넌트의 생명주기와 독립적으로 값을 유지하는 상황에서 활용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, useState, useEffect } from 'react';

function MyComponent() {
  const countRef = useRef(0);
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    // countRef는 렌더링과 무관하게 유지되는 변수
    countRef.current = count;
  }, [count]);

  const handleClick = () =&gt; {
    setCount(count + 1);
    console.log(countRef.current); // 항상 가장 최근 값 출력
  };

  return &lt;button onClick={handleClick}&gt;증가&lt;/button&gt;;
}
</code></pre></div></div>

<h4 id="usecontext--react-context를-통해-전역으로-상태를-공유하거나-전달할-때-사용"><code class="language-plaintext highlighter-rouge">useContext</code> : <code class="language-plaintext highlighter-rouge">React Context</code>를 통해 전역으로 상태를 공유하거나 전달할 때 사용</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prop</code> 내려주기 : <code class="language-plaintext highlighter-rouge">A</code> 컴포넌트가 제공하는 데이터를 <code class="language-plaintext highlighter-rouge">D</code> 컴포넌트에서 사용하려면, …
    <ul>
      <li>하위 컴포넌트로 필요한 위치까지 계속해서 넘겨주어야 함 → 제공하는 쪽, 제공받는 쪽 모두 번거로운 작업!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;A props={props}&gt;
  &lt;B props={props}&gt;
    &lt;C props={props}&gt;
      &lt;D props={props}&gt;
        ...
      &lt;/D&gt;
    &lt;/C&gt;
  &lt;/B&gt;
&lt;/A&gt;
</code></pre></div></div>

<ul>
  <li>리액트 컨텍스트 (<code class="language-plaintext highlighter-rouge">React Context</code>) : 컴포넌트 트리 안에서 전역적으로 데이터를 공유
    <ul>
      <li>중첩 컴포넌트 간에 데이터를 명시적으로 전달하지 않아도 되므로, <code class="language-plaintext highlighter-rouge">Props</code>를 여러 단계에 걸쳐 전달하지 않아도 됨</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1. Context 객체 생성
const MyContext = React.createContext(defaultValue);

// 2. Context를 제공하는 컴포넌트 작성
const MyContextProvider = ({ children }) =&gt; {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
};

// 3. useContext를 사용하여 값에 접근
import { useContext } from 'react';

const MyComponent = () =&gt; {
  const contextValue = useContext(MyContext); // 이때, 리액트가 아닌 자비스크립트가 반환된다.

  // contextValue를 사용하여 렌더링 또는 다른 로직 수행
};
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Context.Provider</code> : 컨텍스트 값을 하위 컴포넌트에 제공
    <ul>
      <li><code class="language-plaintext highlighter-rouge">value</code> 속성을 통해 전달할 값을 설정</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const MyContextProvider = ({ children }) =&gt; {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
};
</code></pre></div></div>

<h4 id="usereducer--복잡한-상태-로직을-다룰-때-사용"><code class="language-plaintext highlighter-rouge">useReducer</code> : 복잡한 상태 로직을 다룰 때 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// useReducer가 사용할 State 정의
type State = {
  count: number
}

// State의 변화를 발생시킬 Action의 타입과 넘겨줄 payload 정의
type Action = {
  type: 'up' | 'down' | 'reset';
  payload?: State;
}

// 무거운 연산이 포함된 게으른 초기화 함수 init 정의
const init = (count: State) =&gt; {
  return count
}

const initState: State = { count: 0 }

const reducer = ((state: State, action: Action): State) =&gt; {
  switch (action.type) {
    case 'up':
      return { count: state.count + 1 }
    case 'down':
      return { count: state.count - 1 &gt; 0 ? state.count - 1 : 0 }
    case 'down':
      return init(action.payload || { count: 0 })
    default:
      throw new Error(`Unexpected Action type: ${action.type}`)
  }
}

const export default App = () =&gt; {
  const [state, dispatcher] = useReducer(reducer, initialState, init)

  const handleUpButtonClick = () =&gt; {
    dispatcher({ type: 'up' })
  }

  const handleDownButtonClick = () =&gt; {
    dispatcher({ type: 'down' })
  }

  const handleResetButtonClick = () =&gt; {
    dispatcher({ type: 'reset', payload: { count: 1 } })
  }

  return {
    &lt;div className="App"&gt;
      &lt;button onclick={handleUpButtonClick}&gt;+&lt;/button&gt;
      &lt;button onclick={handleDownButtonClick}&gt;-&lt;/button&gt;
      &lt;button onclick={handleResetButtonClick}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  }
}
</code></pre></div></div>

<ul>
  <li>반환값은 <code class="language-plaintext highlighter-rouge">useState</code>와 동일하게 길이가 <code class="language-plaintext highlighter-rouge">2</code>인 배열
    <ul>
      <li><code class="language-plaintext highlighter-rouge">state</code> : 현재 <code class="language-plaintext highlighter-rouge">useReducer</code>가 갖고 있는 값</li>
      <li><code class="language-plaintext highlighter-rouge">dispatcher</code> : <code class="language-plaintext highlighter-rouge">state</code>를 업데이트하는 함수<br />(값만 넘겨주는 <code class="language-plaintext highlighter-rouge">setState</code>와 달리, <code class="language-plaintext highlighter-rouge">state</code>를 변경할 수 있는 <code class="language-plaintext highlighter-rouge">action</code> 반환)</li>
    </ul>
  </li>
  <li>인수는 <code class="language-plaintext highlighter-rouge">useState</code>와 달리 2~3개의 인수를 필요로 함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">reducer</code> : 첫번째 인수 → <code class="language-plaintext highlighter-rouge">useReducer</code>의 기본 <code class="language-plaintext highlighter-rouge">action</code>을 정의하는 함수</li>
      <li><code class="language-plaintext highlighter-rouge">initialState</code> : 두번째 인수 → <code class="language-plaintext highlighter-rouge">useReducer</code>의 초깃값</li>
      <li><code class="language-plaintext highlighter-rouge">init</code> : (선택) 세번째 인수 → 초깃값을 지연해서 생성 (게으른 초기화)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">useReducer</code>의 목적?</p>

  <p><code class="language-plaintext highlighter-rouge">(1)</code> 복잡한 형태의 <code class="language-plaintext highlighter-rouge">state</code>를 사전에 정의된 <code class="language-plaintext highlighter-rouge">dispatcher</code>로만 수정할 수 있게 하여,<br /><code class="language-plaintext highlighter-rouge">(2)</code> <code class="language-plaintext highlighter-rouge">state</code> 값에 대한 접근은 컴포넌트에서만 가능하게 하고,<br /><code class="language-plaintext highlighter-rouge">(3)</code> 이를 업데이트하하는 방법에 대한 상세 정의 컴포넌트 밖에 둔 다음,<br /><code class="language-plaintext highlighter-rouge">(4)</code> <code class="language-plaintext highlighter-rouge">state</code>의 업데이트를 <code class="language-plaintext highlighter-rouge">dispatcher</code>로 제한한다!</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">state</code> 하나가 가질 값이 복잡하고 이를 수정하는 경우의 수가 많아지면 <code class="language-plaintext highlighter-rouge">state</code>를 관리하는 것이 어려워짐</li>
    <li>여러 <code class="language-plaintext highlighter-rouge">state</code>를 관리하는 것보다 성격이 비슷한 것들을 묶어 <code class="language-plaintext highlighter-rouge">useReducer</code>로 관리하는 것이 효율적</li>
    <li>게으른 초기화 함수를 인자로 사용하여 <code class="language-plaintext highlighter-rouge">useState</code>에 함수를 넣은 것과 같은 이점을 누릴 수 있음</li>
    <li>추가로 <code class="language-plaintext highlighter-rouge">state</code>에 대한 초기화가 필요할 때 <code class="language-plaintext highlighter-rouge">reducer</code>에서 재사용할 수 있음</li>
  </ul>
</blockquote>

<h4 id="forwardref--부모-컴포넌트에서-자식-컴포넌트로-ref를-전달할-수-있게-함"><code class="language-plaintext highlighter-rouge">forwardRef</code> : 부모 컴포넌트에서 자식 컴포넌트로 <code class="language-plaintext highlighter-rouge">ref</code>를 전달할 수 있게 함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useRef, forwardRef } from 'react';

// 자식 컴포넌트
const ChildComponent = forwardRef((props, ref) =&gt; {
  const internalState = useRef(null);

  // 부모 컴포넌트에서 전달한 ref에 직접 접근
  // ref.current를 통해 부모 컴포넌트의 ref를 참조할 수 있음
  const handleButtonClick = () =&gt; {
    console.log('자식 컴포넌트에서 버튼 클릭');
    console.log('내부 상태:', internalState.current);
  };

  return (
    // 여기에 컴포넌트 JSX를 작성
    &lt;div&gt;
      &lt;button onClick={handleButtonClick}&gt;자식 컴포넌트에서 클릭&lt;/button&gt;
    &lt;/div&gt;
  );
});

// 부모 컴포넌트
const ParentComponent = () =&gt; {
  // ref를 생성하여 자식 컴포넌트에 전달
  const childRef = useRef();

  // 부모 컴포넌트에서 ref를 자식 컴포넌트에 전달
  return (
    &lt;div&gt;
      {/* forwardRef를 사용하여 자식 컴포넌트에 ref 전달 */}
      &lt;ChildComponent ref={childRef} /&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ref</code>를 받고자 하는 컴포넌트를 <code class="language-plaintext highlighter-rouge">forwards</code>로 감싸고, 두번째 인수로 <code class="language-plaintext highlighter-rouge">ref</code> 전달
    <ul>
      <li>부모 컴포넌트에서 <code class="language-plaintext highlighter-rouge">props.ref</code>를 통해 <code class="language-plaintext highlighter-rouge">ref</code>를 전달</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">useRef</code>에서 반환된 <code class="language-plaintext highlighter-rouge">ref</code> 객체를 상위에서 하위 컴포넌트로 전달할 때, 직접 <code class="language-plaintext highlighter-rouge">props</code>를 넣을 수 없을 때 사용
    <ul>
      <li>컴포넌트 외부의 <code class="language-plaintext highlighter-rouge">DOM</code>에 접근 : 부모에서 선언 → 자식에 전달 → 자식에 참조 걸기 → 부모에서 컨트롤</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">But</code>, 외부 <code class="language-plaintext highlighter-rouge">DOM</code>을 참조하는 <code class="language-plaintext highlighter-rouge">ref</code>를 갖는 것은 <code class="language-plaintext highlighter-rouge">Coupling</code>이 강해지므로 좋지 않다!</p>
</blockquote>

<h4 id="useimperativehandle-with-forwardref--부모-컴포넌트가-자식-컴포넌트를-컨트롤할-수-있게-함"><code class="language-plaintext highlighter-rouge">useImperativeHandle (with forwardRef)</code> : 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있게 함</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { forwardRef, useRef, useImperativeHandle } from 'react';

const ChildComponent = forwardRef((props, ref) =&gt; {
  // useImperativeHandle을 사용하여 부모 컴포넌트에 특정 함수나 값들을 노출
  useImperativeHandle(ref, () =&gt; ({
    // 부모 컴포넌트에서 입력 엘리먼트에 포커스를 맞추기 위해 함수를 노출
    focusInput: () =&gt; {
      inputRef.current.focus();
    }
  }));

  const inputRef = useRef(null);

  return &lt;input ref={inputRef} /&gt;;
});

const ParentComponent = () =&gt; {
  const childRef = useRef(null);

  const handleClick = () =&gt; {
    // 자식 컴포넌트에서 노출한 함수를 호출하여 입력 엘리먼트에 포커스를 맞춤
    childRef.current.focusInput();
  };

  return (
    &lt;div&gt;
      &lt;ChildComponent ref={childRef} /&gt;
      &lt;button onClick={handleClick}&gt;입력에 포커스 맞추기&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useImperativeHandle</code>을 통해 부모 컴포넌트에 함수 및 기능을 노출시킴
    <ul>
      <li>부모에게 참조값을 전달 → 자식은 객체를 반환</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">HTMLElement</code>만 주입 가능한 <code class="language-plaintext highlighter-rouge">ref</code>에, 자식 컴포넌트에 새로 설정한 객체의 키·값에 대해서도 접근 가능</li>
</ul>

<h4 id="uselayouteffect--시그니처가-useeffect와-동일하나-모든-dom-변경-후의-콜백-실행이-동기적으로-발생"><code class="language-plaintext highlighter-rouge">useLayoutEffect</code> : 시그니처가 <code class="language-plaintext highlighter-rouge">useEffect</code>와 동일하나, 모든 <code class="language-plaintext highlighter-rouge">DOM</code> 변경 후의 콜백 실행이 동기적으로 발생</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React, { useLayoutEffect, useState } from 'react';

const MyComponent = () =&gt; {
  const [width, setWidth] = useState(0);

  useLayoutEffect(() =&gt; {
    // DOM 요소의 너비 측정
    const element = document.getElementById('myElement');
    if (element) {
      const elementWidth = element.clientWidth;
      setWidth(elementWidth);
    }
  }, []); // 빈 의존성 배열은 이 효과가 초기 렌더 이후에 한 번만 실행되도록 함

  return (
    &lt;div&gt;
      &lt;p&gt;내 요소의 너비는: {width}px&lt;/p&gt;
      &lt;div id="myElement"&gt;이것은 내 요소입니다&lt;/div&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre></div></div>

<ul>
  <li>‘시그니처가 <code class="language-plaintext highlighter-rouge">useEffect</code>와 동일하나,’ : 두 훅의 형태나 사용 예제가 동일함</li>
  <li>‘모든 <code class="language-plaintext highlighter-rouge">DOM</code> 변경 후의 콜백 실행이 동기적으로 발생’ :<br /><code class="language-plaintext highlighter-rouge">(1)</code> 리액트가 <code class="language-plaintext highlighter-rouge">DOM</code>을 업데이트 → <code class="language-plaintext highlighter-rouge">(2)</code><code class="language-plaintext highlighter-rouge">useLayoutEffect</code> 실행 → <code class="language-plaintext highlighter-rouge">(3)</code><code class="language-plaintext highlighter-rouge">useEffect</code> 실행<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/db687861-6983-4eac-8615-a144ef0efb3c" width="90%" /></li>
  <li><code class="language-plaintext highlighter-rouge">DOM</code>은 계산되었지만, 이것이 화면에 반영되기 전에 하고 싶은 작업을 처리할 때 사용</li>
</ul>

<h3 id="사용자-정의-훅-custom-hook--서로-다른-컴포넌트-내부에서-같은-로직을-공유할-때-사용">사용자 정의 훅 (<code class="language-plaintext highlighter-rouge">Custom Hook</code>) : 서로 다른 컴포넌트 내부에서 같은 로직을 공유할 때 사용</h3>

<ul>
  <li>기존에 존재하는 훅을 기반으로 필요한 훅을 개발 (함수 이름이 반드시 <code class="language-plaintext highlighter-rouge">use</code>로 시작)
    <ul>
      <li>사용자 정의 훅의 동작, 매개변수, 반환값을 사전에  정의한 상태에서 구현하여 다른 컴포넌트에서 활용</li>
    </ul>
  </li>
</ul>

<h4 id="usefetch--http-요청을-fetch하여-데이터를-가져오는-작업을-추상화"><code class="language-plaintext highlighter-rouge">useFetch</code> : <code class="language-plaintext highlighter-rouge">HTTP</code> 요청을 <code class="language-plaintext highlighter-rouge">fetch</code>하여 데이터를 가져오는 작업을 추상화</h4>

<h4 id="usetimeout--일정-시간이-지난-후에-콜백-함수를-실행하는-작업을-추상화"><code class="language-plaintext highlighter-rouge">useTimeout</code> : 일정 시간이 지난 후에 콜백 함수를 실행하는 작업을 추상화</h4>

<h4 id="usetoggle--불리언-상태를-토글하는-작업을-추상화"><code class="language-plaintext highlighter-rouge">useToggle</code> : 불리언 상태를 토글하는 작업을 추상화</h4>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[함수 컴포넌트 (Functional Component) : 리액트 훅을 통한 상태와 생명주기 관리]]></summary></entry><entry><title type="html">[React] 4. 리액트 라우팅 (React Routing)</title><link href="http://localhost:4000/react4/" rel="alternate" type="text/html" title="[React] 4. 리액트 라우팅 (React Routing)" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/react4</id><content type="html" xml:base="http://localhost:4000/react4/"><![CDATA[<h2 id="react-router-dom--react로-생성된-spa-내에서-페이지-이동이-가능하도록-라우팅"><code class="language-plaintext highlighter-rouge">React-Router-Dom</code> : <code class="language-plaintext highlighter-rouge">React</code>로 생성된 <code class="language-plaintext highlighter-rouge">SPA</code> 내에서 페이지 이동이 가능하도록 라우팅</h2>

<ul>
  <li>라우팅 (<code class="language-plaintext highlighter-rouge">Routing</code>) : 네트워크에서 경로를 선택하는 프로세스
    <ul>
      <li>다양한 주소의 요청이 들어왔을 때 각각 맞는 컨텐츠로 이동</li>
      <li>페이지 전체가 새로 로딩되는 대신, 라우팅을 통해 부드럽게 화면을 전환</li>
      <li><code class="language-plaintext highlighter-rouge">SPA</code> 안에서 모든 페이지를 렌더링하지 않는 이유? : 고정된 <code class="language-plaintext highlighter-rouge">URL</code>로 즐겨찾기·뒤로가기·새로고침 불가, <code class="language-plaintext highlighter-rouge">SEO</code> 문제</li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[React-Router-Dom : React로 생성된 SPA 내에서 페이지 이동이 가능하도록 라우팅]]></summary></entry><entry><title type="html">[Engineer Information Processing] 5. 정보 시스템 구축 관리</title><link href="http://localhost:4000/engineer_information_processing5/" rel="alternate" type="text/html" title="[Engineer Information Processing] 5. 정보 시스템 구축 관리" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing5</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing5/"><![CDATA[<h2 id="소프트웨어-개발-생명-주기">소프트웨어 개발 생명 주기</h2>

<h3 id="프로젝트-관리-도구">프로젝트 관리 도구</h3>

<ul>
  <li><b><code>CPM</code> (임계 경로법) : 프로젝트 완성에 필요한 작업을 나열해 작업 소요 기간 예측</b>
    <ul>
      <li>작업을 표시하는 노드와 전후 의존 관계를 표시하는 간선으로 구성</li>
      <li>프로젝트 중간 점검을 뜻하는 박스 노드에 예상 완료 시간 표시</li>
      <li>박스 노드 도달 이전 작업이 완료되야 다음 작업 진행</li>
    </ul>
  </li>
  <li><b>간트 차트 : 각 작업들의 일정을 막대로 표시하는 시간선 차트</b></li>
  <li><b><code>WBS</code> (작업 분해) : 프로젝트 작업을 계층적으로 분해 및 구조화</b></li>
</ul>

<h3 id="소프트웨어-개발-방법론">소프트웨어 개발 방법론</h3>

<ul>
  <li>소프트웨어 개발 방법론 : 소프트웨어 개발 생명주기에 소프트웨어 공학 원리를 적용
    <ul>
      <li><b>구조적 방법론 : 정형화된 분석 절차에 따라 구조적으로 사용자 요구 파악</b></li>
      <li><b>정보 공학 방법론 : 정보 시스템 개발의 관리 절차 체계화 (구조적 방법론의 거시적 관점 부재에 등장)</b></li>
      <li><b>컴포넌트 기반 개발 방법론 (<code>CBD</code>) : 재사용 가능한 컴포넌트를 조합해 어플리케이션을 개발</b>
        <ul>
          <li><b><code>CBD</code> 특징 : 점진적 개발, 컴포넌트 설계서 사용, 재사용 가능, 높은 확장성</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b>소프트웨어 재사용 : 소프트웨어의 전체 혹은 일부분을 다른 소프트웨어 개발 및 유지에 사용</b>
    <ul>
      <li>소프트웨어 재사용 접근 : <b>합성 중심 (블록 구성)</b>, 생성 중심 (템플릿·프레임워크 등 패턴 사용)</li>
    </ul>
  </li>
</ul>

<h3 id="비용-산정-모델">비용 산정 모델</h3>

<ul>
  <li><b>비용 산정 모델 : 프로젝트 특성 및 요구사항을 고려해 소프트웨어 개발 비용 산정</b>
    <ul>
      <li><b>델파이 기법 : 산정 요원 및 조정에 의해 단계별로 전문가들의 견해를 조정자가 조정해 최종 결정</b></li>
      <li><b><code>LOC</code> 기법 : 소프트웨어 각 기능 구현 시 작성될 원시 코드 라인 수로 예측치 추정</b></li>
      <li><b><code>COCOMO</code> 기법 : 소스 코드 규모에 따른 비용을 예측해 <code>Man-Month</code>로 나타냄</b>
        <ul>
          <li><b><code>COCOMO</code> 모형 종류 : <code>Basic COCOMO</code> (프로젝트 크기를 코드 라인 수로 측정), <code>Intermediate COCOMO</code> (개발자 경험 수준, 신뢰성 요구사항을 고려해 보정 계수 적용), <code>Detailed COCOMO</code> </b></li>
          <li><b><code>COCOMO</code> 개발 유형 : 단순형 (5만 라인 이하), 중간형 (30만 라인 이하), 임배디드형 (30만 라인 이상)</b></li>
        </ul>
      </li>
      <li><b><code>Putnam</code> 모델 : 소프트웨어 개발 생명 주기 내 노력 분포 예측 (크기, 생산성, 기술 요소)</b></li>
      <li><b>기능 점수 : 시스템 구현 기술에 의존적이고 개발자에 식별된 기능 기반해 시스템 크기 측정</b>
        <ul>
          <li><b>기능 점수 비용 산정 요소 : 코드 라인 수, 데이터 파일 수, 문서 수, 입력 유형 수, 보고서 수</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어-개발-표준">소프트웨어 개발 표준</h3>

<ul>
  <li><b><code>ISO/IEC 25000</code> : 소프트웨어 품질 평가 및 절차 모델</b>
    <ul>
      <li><code>ISO/IEC 9126</code>과 <code>ISO/IEC 14598</code> 통합</li>
      <li><code>2501n</code> : 품질 모형, <code>2503n</code> : 품질 측정</li>
    </ul>
  </li>
  <li><b><code>SPICE</code>, <code>ISO/IEC 15504</code> : 소프트웨어 프로세스 평가 및 개선</b>
    <ul>
      <li><code>ISO/IEC 12207</code> 개선</li>
      <li><code>SPICE</code> 모델 범주 : 고객-공급자 프로세스, 공학 프로세스, 지원 프로세스, 관리 프로세스, 조직 프로세스</li>
      <li><b><code>SPICE</code> 모델 레벨 : 레벨5, 최적 / 레벨4, 예측 / 레벨3, 확립 / 레벨2, 관리 / 레벨1, 수행 / 레벨0, 불완전</b></li>
    </ul>
  </li>
  <li><b><code>CMM</code> : 조직 업무 능력 평가 기준을 세우기 위한 능력 성숙도 모델</b>
    <ul>
      <li><b><code>CMM</code> 모델 레벨 : 레벨5, 최적 / 레벨4, 관리 / 레벨3, 정의 / 레벨2, 반복 / 레벨1, 초보</b></li>
    </ul>
  </li>
</ul>

<h3 id="테일러링과-프레임워크">테일러링과 프레임워크</h3>

<ul>
  <li><b>테일러링 : 기존 개발 방법론을 프로젝트 상황 (요구사항 및 조건)에 맞게 수정해 개발 프로세스 최적화</b>
    <ul>
      <li>테일러링 절차 : 프로젝트 특정 정의 → 표준 프로세스 선정·검증 → 상위 레벨 커스터마이징 → 세부 커스터마이징 → 문서화</li>
    </ul>
  </li>
  <li><b>소프트웨어 프레임워크 : 비슷한 유형의 응용 프로그램을 위해 아키턱처, 산출물의 통합된 집합</b></li>
  <li>라이브러리 : 단순 활용될 수 있는 도구들의 집합 (<b>차이점? : 프레임워크는 전체적인 흐름을 자체적으로 가짐</b>)</li>
  <li><b>소프트웨어 개발 프레임워크 : 소프트웨어 개발을 돕는 재사용 가능한 클래스·패턴의 집합</b>
    <ul>
      <li><b>소프트웨어 개발 프레임워크 장점 : 개발 용이, 시스템 복잡도의 감소, 이식성, 품질 보증, 운영 용이, 개발 코드 간소화, 변경 용이성, 설계 및 코드의 재사용성 증가</b></li>
    </ul>
  </li>
</ul>

<h2 id="신기술-용어">신기술 용어</h2>

<h3 id="네트워크-소프트웨어-하드웨어-관련-신기술">네트워크, 소프트웨어, 하드웨어 관련 신기술</h3>

<blockquote>
  <p>중복 출제된 내용만 정리</p>
</blockquote>

<ul>
  <li>프로토콜 관련
    <ul>
      <li><b><code>RIP</code> : 최단 경로 탐색, <code>Bellman-Ford</code>, 벡터 라우팅 프로토콜</b></li>
      <li><b><code>MQTT</code> : <code>IBM</code>, 대역폭 제한, <code>TCP/IP</code>, <code>IoT</code></b></li>
    </ul>
  </li>
  <li>모바일 관련
    <ul>
      <li><b><code>Mesh</code> : 무선 랜 한계, 대규모 디바이스 네트워크 생성 최적화, 차세대 이동 통신</b></li>
    </ul>
  </li>
  <li>하드웨어 관련
    <ul>
      <li><b>고가용성 솔루션 (<code>HACMP</code>) : 공유 디스크, 클러스터링</b></li>
      <li><b>직접 연결 저장 장치 (<code>DAS</code>) : 호스트 버스 어댑터, 네트워크 디바이스 없이 직접 연결 </b></li>
    </ul>
  </li>
</ul>

<h2 id="소프트웨어-개발-보안">소프트웨어 개발 보안</h2>

<h3 id="소프트웨어-개발-보안-개요">소프트웨어 개발 보안 개요</h3>

<ul>
  <li><b>시큐어 <code>OS</code> : 컴퓨터 운영체제에 보안 기능을 추가</b>
    <ul>
      <li><b>시큐어 <code>OS</code> 접근 통제 종류 : 강제적, 임의적, 역할 기반</b></li>
    </ul>
  </li>
  <li><b>스택 가드 : 메모리 상에 프로그램 복귀 주소와 변수 사이에 특정 값 (카나리)를 저장했다가, 그 값이 변경되면 오버플로우 상태로 가정해 프로그램 실행 중단</b></li>
</ul>

<h3 id="소프트웨어-개발-보안-구축-및-방법론">소프트웨어 개발 보안 구축 및 방법론</h3>

<ul>
  <li><b>정보 보안 3대 요소 : 기밀성 (인가 사용자만 접근), 무결성 (인가 방법으로만 수정), 기용성 (인가 사용자 업무 수행 유지)</b></li>
</ul>

<h3 id="시큐어-코딩-가이드">시큐어 코딩 가이드</h3>

<ul>
  <li><b>입력 데이터 검증 및 표현의 보안 약점 종류 : <code>SQL Injection</code>, 자원 삽입, 크로스 사이트 스크립트 (<code>XSS</code>)</b></li>
  <li><b>보안 기능의 보안 약점 종류 : 하드 코드된 비밀번호</b></li>
</ul>

<h3 id="암호화-알고리즘">암호화 알고리즘</h3>

<ul>
  <li><b>암호 알고리즘 : 평문을 암호문으로 (암호화), 암호문을 평문으로 (복호화) 바꿀 때 암호 키를 통해 사용되는 알고리즘</b></li>
  <li><b>공개 키 : 암호 키와 해독 키가 다름 (비대칭 키 암호화), 쉬운 키 분배, 느린 속도, 복잡한 알고리즘, <code>RSA</code></b></li>
  <li><b>비밀 키 : 암호 키와 해독 키가 같음 (대칭 키 암호화), 어려운 키 분배, 빠른 속도, 쉬운 알고리즘, <code>DES/AES</code></b></li>
  <li><b>해시 암호화 : 임의 길이의 메시지를 입력하면 고정 길이의 출력값으로 변환 (디지털 서명에 활용 → 데이터 무결성 제공)</b>
    <ul>
      <li>해시 3저항성 : 역상 저항성, 제2 역상 저항성, 충돌 저항성</li>
    </ul>
  </li>
</ul>

<h2 id="서버-인증과-접근-통제">서버 인증과 접근 통제</h2>

<h3 id="서버-인증-및-서버-통제-개요">서버 인증 및 서버 통제 개요</h3>

<ul>
  <li><b>사용자 인증 : 지식 기반 인증 (<code>ID/PW</code>), 소유 기반 인증 (토큰), 생체 기반 인증, 다중 인증</b></li>
  <li><b>접근 통제 : 시스템 자원 이용에 대한 불법적인 접근 방지</b>
    <ul>
      <li>접근 통제 요소 → <b><code>AAA</code> (인증 권한 검증 계정 관리)</b></li>
      <li><b>강제적 접근 통제 : 중앙에서 정보 수집 및 분류하여 보안 레벨 결정</b></li>
      <li><b>임의적 접근 통제 : 정보 소유자가 보안 레벨 및 접근 제어 설정</b></li>
      <li><b>역할 기반 접근 통제 : 사람이 아닌 직책에 대해 권한을 부여</b></li>
    </ul>
  </li>
  <li><b>벨 라파둘라 모델 (<code>BLP</code>) : 정보의 기밀성에 따라 상하 관계가 구분된 정보의 보호를 위해 자신의 권한보다 낮은 수분의 문서만을 읽을 수 있게 함 (다중 마스터 복제 방식 기반, 데이터 복제·분산 처리에 효과적)</b></li>
</ul>

<h3 id="보안-솔루션과-보안-아키텍처">보안 솔루션과 보안 아키텍처</h3>

<ul>
  <li><b><code>IDS</code> (침입 탐지 시스템) : 외부 침입 공격에 대해 탐지하는 네트워크 보안 시스템</b>
    <ul>
      <li><b>침입 탐지 기법 : 오용 탐지, 이상 탐지, </b></li>
    </ul>
  </li>
  <li><b><code>IPSec</code> (<code>IP Security</code>) : 통신 세션의 각 <code>IP</code> 패킷을 암호화하고 인증하는 인터넷 프로토콜</b></li>
  <li><b>가상 사설망 : 이용자가 공중망에 사설망을 구축해 전용망을 사용하는 듯한 효과를 가짐</b></li>
</ul>

<h2 id="공격-유형">공격 유형</h2>

<h3 id="서비스-공격-유형">서비스 공격 유형</h3>

<ul>
  <li><b>스머프 공격 : 공격 대상 주소에 근원지로 대량의 <code>ICMP</code> 응답 패킷을 전송해 서비스 거부 유발</b></li>
  <li><b><code>Ping of Death</code> : 비정상적인 <code>ICMP</code> 패킷으로 시스템 성능 저하</b></li>
  <li><b><code>Ping</code> 플러딩 : <code>Ping</code> 테스트로 공격자가 공격 대상 컴퓨터 확인</b></li>
  <li><b><code>DDos</code> : 여러 대의 공격자를 분산 배치 및 동시에 서비스 거부 공격</b></li>
  <li><b><code>TCP</code> 세션 하이재킹 : 서버와 클라이언트가 <code>TCP</code>로 통신할 때, <code>RST</code> 패킷을 보내 세션을 끊고 세션을 탈취</b></li>
  <li><b>피싱 : 가짜 웹사이트로 개인 정보를 탈취</b></li>
  <li><b>랜섬웨어 : 시스템을 잠그거나 데이터를 암호화해 이를 인질로 금전 요구</b></li>
  <li><b>키 로거 : 키보드 움직임을 탐지해 개인정보 탈취</b></li>
  <li><b><code>APT</code> (지능적 지속 위협) : 다양한 보안 위협을 만드렁 정보 유츌</b></li>
  <li><b>백도어 : 프로그램이나 손상된 시스템에 허가되지 않은 접근을 가능하게 정상적인 보안 절차를 우회</b>
    <ul>
      <li><b><code>Tripwire</code> : 크래커가 백도어를 만들거나, 설정 파일을 변경했을 때 분석하는 도구</b></li>
    </ul>
  </li>
  <li><b><code>Switch Jamming</code>  스위치 허브의 기능을 방해해 스위치를 더미 허브처럼 작동시킴</b></li>
</ul>

<h3 id="공격-탐지-및-방지">공격 탐지 및 방지</h3>

<ul>
  <li><b><code>Honeypot</code> : 침입자를 속여 실제 공격당하는 것처럼 보여주어 크래커 추적 및 공격 기법 정보 수집</b></li>
  <li><b><code>DPI</code> : 전 계층 프로토콜과 패킷 내부 컨텐츠를 파악하는 패킷 분석 기술</b></li>
  <li><b><code>HSM</code> : 암호화 키를 생성 및 저장하는 전용 하드웨어 장치</b></li>
  <li><b><code>TCP Wrapper</code> : 외부 컴퓨터가 접속되면 접속 인가 여불를 점검해 접속 허용</b></li>
  <li><b><code>HSM</code> : 네트워크를 제어부, 데이터 전달부로 분리해 네트워크를 제어 및 관리</b></li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[소프트웨어 개발 생명 주기]]></summary></entry><entry><title type="html">[Engineer Information Processing] 3. 데이터베이스 구축</title><link href="http://localhost:4000/engineer_information_processing3/" rel="alternate" type="text/html" title="[Engineer Information Processing] 3. 데이터베이스 구축" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing3</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing3/"><![CDATA[<h2 id="데이터베이스의-개념">데이터베이스의 개념</h2>

<h3 id="데이터베이스--dbms">데이터베이스 : <code>DBMS</code></h3>

<ul>
  <li>지료 : 단순한 데이터, 정보 : 의미 있는 데이터, 지식 : 가공되어 의미 있는 데이터</li>
  <li>정보 시스템 : 조직체의 데이터를 바탕으로 정보를 추출 및 생성하는 시스템
    <ul>
      <li>정보 시스템 종류 : 일괄 처리 시스템, 온라인 실시간 처리 시스템, 분산 처리 시스템</li>
    </ul>
  </li>
  <li><code>DB</code>정의 : <b>통합 데이터</b>, 저장 데이터, 운영 데이터, 공용 데이터</li>
  <li><code>DB</code> 특성 : 실시간 접근성, 내용에 의한 참조, 동시 공유, 계속적 변화</li>
  <li><code>DB</code> 시스템 구성 : <code>DB</code>, <code>DBMS</code>, <code>DB</code> 관리자, <code>DB</code> 언어</li>
</ul>

<h3 id="데이터-관리--빅데이터-관리">데이터 관리 / 빅데이터 관리</h3>

<ul>
  <li><b>데이터 마이닝 : 데이터 웨어하우징에서 수집·분석된 자료를 사용자에 제공하기 위해 분류·가공하는 요소 기술</b>
    <ul>
      <li>분류 : 데이터를 여러 그룹으로 분류</li>
      <li>연관 규칙 분석 : 특정 규칙 탐색</li>
      <li>연속 : 순서 정보를 갖는 데이터에서 순서 관련 패턴 탐색</li>
      <li>군집화 : 데이터를 비슷한 특성의 그룹으로 나눔</li>
      <li>예측 : 과거 데이터를 분석해 미래 예측</li>
      <li>이상 탐지 : 데이터에섯 비정상적인 패턴 탐색</li>
      <li>회귀 분석 : 데이터 간의 관계를 분석</li>
      <li>차원 축소 : 데이터 차원을 줄여서 분석</li>
    </ul>
  </li>
  <li><b>하둡 : 빅데이터 세트를 병렬로 처리하기 위한 데이터 분산 처리를 돕는 자바 기반 소프트웨어 오픈소스 프레임워크</b>
    <ul>
      <li>맴리듀스 : 대용량 데이터를 분산 처리하기 위한 프로그래밍 모델 (<code>Map</code>, <code>Reduce</code> 함수로 구성)</li>
      <li><code>Sqoop</code> : <code>RDBMS</code>과 하둡 간의 데이터 전송을 지원하는 도구</li>
    </ul>
  </li>
</ul>

<h3 id="데이터베이스-스키마와-언어">데이터베이스 스키마와 언어</h3>

<ul>
  <li>스키마 : 데이터베이스 구조 (개체, 속성, 관계) 정의 (데이터베이스의 논리적 구조를 기술해 데이터 일관성·무결성 보장)
    <ul>
      <li>외부 스키마 : 데이터베이스 사용자, 응용 프로그램의 관점에서 데이터베이스 정의</li>
      <li><b>개념 스키마 : 데이터베이스 전체를 정의한 것으로, 데이터 개체·관계·제약 조건·접근 권한·무결성 규칙을 명세</b></li>
      <li><b>내부 스키마 : 내부 물리적 저장 구조를 정의해 데이터의 실제 저장 방법을 기술</b></li>
    </ul>
  </li>
  <li>스키마 간 독립성 : 논리적 독립성, 물리적 독립성</li>
  <li>데이터베이스 언어 : 데이터베이스 내에서 활용되는 언어
    <ul>
      <li><b><code>SQL</code> : 관계형 데이터베이스의 표준 질의어</b></li>
    </ul>
  </li>
</ul>

<h2 id="데이터베이스-설계와-관계형-모델">데이터베이스 설계와 관계형 모델</h2>

<h3 id="데이터베이스-설계">데이터베이스 설계</h3>

<ul>
  <li>데이터베이스 설계 단계 : 요구사항 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0afa4247-f3c7-4848-b2c0-09820caddc61" width="80%" />
    <ul>
      <li><b>개념적 설계 : 목표 <code>DBMS</code>에 독립적인 개념 스키마 설계 (기념 스키마 모델링, 트랜잭션 모델링)</b></li>
      <li><b>논리적 설계 : 목표 <code>DBMS</code>에 종속적인 논리 스키마 설계 (스키마 평가 및 정제, 트랜잭션 인터페이스 설계)</b></li>
      <li><b>물리적 설계 : 목표 <code>DBMS</code>에 종속적인 물리적 구조 설계 (저장 레코드 양식 설계, 레코드 클러스터링)</b>
        <ul>
          <li><b>물리적 설계 고려사항 : 인덱스 구조, 레코드 크기·개수, 트랜잭션 갱신·참조 성향, 개념 스키마 변경 여부</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="데이터-모델--관계형-데이터베이스-모델">데이터 모델 / 관계형 데이터베이스 모델</h3>

<ul>
  <li>데이터 모델 : 데이터베이스 설계 과정에서 데이터 구조를 표현하기 위해 사용되는 도구
    <ul>
      <li>데이텉 모델 구성 요소 : 데이터 구조, 연산, 제약 조건</li>
    </ul>
  </li>
  <li>개념 데이터 모델 : 속성들로 기술된 개체 타입과 개체 타입 간의 관계를 이용해 현실 세계를 표현
    <ul>
      <li><b>개체-관계 모델 (<code>E-R</code> 모델): 개체 타입과 이들 간 관계 타입을 이용해 개념적 표현<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d4eb5c97-8ac9-4e94-ac67-49d51725340f" width="80%" /></b></li>
      <li>논리 데이터 모델 : 엔티티와 속성들의 관계를 구조적으로 정의
        <ul>
          <li><b>논리 데이터 모델 종류 : 계층적 데이터 모델, 네트워크형 데이터 모델, 관계형 데이터 모델</b>
            <ul>
              <li>논리 데이터 모델 구성 요소 : 개체, 속성, 관계</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>관계형 데이터베이스 모델 : 관계형 데이터베이스를 구성하는 개체나 관계를 릴레이션으로 표현
    <ul>
      <li>릴레이션 스키마 : 개념 모델에 도출된 개체를 컴퓨터로 처리 가능한 단위로 매핑한 모델<b>(릴레이션 이름과 속성의 집합)</b></li>
      <li>릴레이션 인스턴스 : 릴레이션 스키마에 따라 저장된 튜플 (테이블의 각 행)</li>
      <li>릴레이션 속성 : 순서가 없는 데이터베이스의 가장 작은 논리적 단위로서의 릴레이션의 열</li>
      <li><b>디그리 : 릴레이션이 가지는 속성의 개수 (디그리 값이 클수록 복잡한 구조 → 정규화 필요)</b></li>
      <li><b>도메인 : 하나의 속성이 가질 수 있는 원자값들의 집합 (데이터 무결성·일관성 유지에 활용)</b></li>
      <li><b>튜플 : 순서가 없는 릴레이션의 행 (카디널리티 : 튜픙의 수)</b></li>
    </ul>
  </li>
  <li><b>릴레이션의 특징 : 튜플의 유일성, 튜플의 무순서성, 속성의 원자성, 속성의 무순서성</b></li>
  <li><b><code>CRUD</code> 매트릭스 : 데이터베이스에 영향 주는 <code>CRUD</code> 연산으로 프로세스·테이블 간 메트릭스를 만들어 트랜잭션 분석</b></li>
</ul>

<h3 id="키와-무결성">키와 무결성</h3>

<ul>
  <li><b>슈퍼 키 : 튜플을 고유하게 식별하는 하나 이상의 속성 집합 (유일성<code>O</code>, 최소성<code>X</code>)</b></li>
  <li><b>후보 키 : 튜플을 고유하게 식별하는 하나 이상의 속성 집합 (유일성<code>O</code>, 최소성<code>O</code>)</b></li>
  <li><b>기본 키 : 후보 키 중 대표인 키 (<code>Null</code><code>X</code>, 중복<code>X</code>, 유일성<code>O</code>, 최소성<code>O</code>)</b></li>
  <li><b>대체 키 : 후보 키 중 기본 키 외의 나머지 키</b></li>
  <li><b>외래 키 : 릴레이션 간 연결을 위해 다른 테이블의 기본 키로 사용되는 키</b></li>
  <li><b>무결성 : 데이터에 적용되는 연산에 제한을 두어 데이터의 정확성·일관성·유효성 유지</b>
    <ul>
      <li>개체 무결성 : 기본 키는 <code>Null</code><code>X</code>, 중복<code>X</code></li>
      <li>참조 무결성 : 외래 키를 변경하려면, 외래 키가 참조하는 대상의 기본 키도 변경해야 함</li>
      <li>도메인 무결성 : 각 속성은 해당 속성 도메인에 지정된 값이어야 함</li>
    </ul>
  </li>
</ul>

<h2 id="데이터베이스-정규화">데이터베이스 정규화</h2>

<h3 id="이상-현상과-함수적-종속">이상 현상과 함수적 종속</h3>

<ul>
  <li><b>이상 현상 : 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 현상</b>
    <ul>
      <li>삽입 이상 : 데이터를 삽입할 때 불필요한 데이터가 함께 삽입되는 현상</li>
      <li>삭제 이상 : 릴레이션의 한 튜플을 삭제할 때 연쇄적으로 삭제되는 현상</li>
      <li>갱신 이상 : 튜플 중에 일부 속성을 갱신해 정보의 모순성이 발생하는 현상</li>
    </ul>
  </li>
  <li>함수적 종속 : 개체 내에 존재하는 속성 간의 관계를 종속적인 관계로 정리하는 방법
    <ul>
      <li><b>부분적 함수 종속 : 혼한 속상 기본키 <code>{A, B}</code>에 대해 <code>A → C</code>가 성립</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/72649301-5d4f-4bf0-97bc-788761c7d3ef" width="70%" /></li>
      <li><b>이행 함수적 종속 : 속성 <code>X, Y, Z</code>가 주어졌을 때, <code>X → Y</code>, <code>Y → Z</code>하면 <code>X → Z</code></b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4105e4d9-df0e-46fc-af34-e8b77a2f2952" width="70%" /></li>
    </ul>
  </li>
</ul>

<h3 id="데이터베이스-정규화--반정규화">데이터베이스 정규화 / 반정규화</h3>

<ul>
  <li><b>정규화 : 논리적 설계 단계에서 발생할 수 있는 종속으로 인한 이상 현상의 문제를 해결하기 위해 여러 테이블로 분해</b>
    <ul>
      <li><b>정규화 목적 : 데이터 구조 안정성 확보, 중복 데이터·수정 및 삭제 시 이상·테이블 불일치 최소화</b></li>
      <li><b>정규화 과정 : 비정규 릴레이션 → <code>1NF</code> → <code>2NF</code> → <code>3NF</code> → <code>BCNF</code> → <code>4NF</code> → <code>5NF</code></b></li>
    </ul>
  </li>
  <li><b>1정규형 : 어떤 테이블에 속한 모든 도메인이 원자값만으로 되어 있는 테이블</b></li>
  <li><b>2정규형 : 1정규형을 만족하면서, 테이블의 부분 함수적 종속을 제거해 완전 함수적 종속이 되도록 분해된 테이블</b></li>
  <li><b>3정규형 : 1,2정규형을 만족하면서, 속성 간 이행 함수 종속을 만족하는 테이블</b></li>
  <li><b><code>BCNF</code>정규형 : 1,2,3정규형을 만족하면서, 결정자가 후보키가 아닌 함수 종속이 제거된 테이블</b></li>
  <li><b>4정규형 : 1,2,3정규형을 만족하면서, 다치 종속이 제거된 테이블</b></li>
  <li><b>5정규형 : 1,2,3,4정규형을 만족하면서, 조인 종속이 제거된 테이블</b></li>
  <li><b>반정규화 : 정규화된 결과를 시스템 성능 향상 및 개발·운영 단순화를 위해 중복·통합·분리를 수행</b>
    <ul>
      <li>반정규화 기법 : 테이블 반정규화 (테이블 병합, 테이블 분할, <b>테이블 추가</b>), 컬럼 반정규화, 관계 반정규화</li>
      <li><b>파티셔닝 : 데이터베이스의 테이블을 분할하는 것</b>
        <ul>
          <li><b>파티셔닝 키 기준 유형 : 범위 분할, 목록 분할, 해시 분할, 합성 분할, 라운드로빈 분할</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="sql"><code class="language-plaintext highlighter-rouge">SQL</code></h2>

<h3 id="관계-대수와-연산자">관계 대수와 연산자</h3>

<ul>
  <li><b>관계 대수 : 원하는 정보 및 정보를 어떻게 유도하는지 기술하는 절차적 방법 (일반 집합 연산, 순수 관계 연산)</b></li>
  <li><b>관계 해석 : 원하는 정보가 무엇이라는 것만 정의하는 비절차적인 방법 (도메인 관계 해석, 튜플 관계 해석)</b>
    <ul>
      <li>관계 해석 자유 변수 : 전칭 정량자 <code>∀</code> (<code>For All</code>), 존재 정량자 <code>∃</code>(<code>For Some</code>)</li>
    </ul>
  </li>
  <li><b>순수 관계 연산자 : <code>Select</code> (튜플 집합 검색), <code>Project</code> (속성 집합 추출), <code>Join</code> (두 릴레이션 공통 속성 결합), <code>Division</code> (두 릴레이션에서 특정 속성를 제외한 속성으로 나눔)</b></li>
  <li>집합 산자 : <b>합집합 (<code>Union</code>), 교집합 (<code>Intersection</code>), 차집합 (<code>Difference</code>), 교차곱 (<code>Cartesian Product</code>)</b></li>
</ul>

<h3 id="뷰-시스템-카탈로그">뷰, 시스템 카탈로그</h3>

<ul>
  <li>뷰 : 사용자에 접근 허용된 자료만을 제한적으로 보여주기 위해 기본 테이블에서 유도되는 가상 테이블
    <ul>
      <li><b>뷰 생성 시 <code>CREATE</code>, 검색 시 <code>SELECT</code> 사용</b></li>
      <li><b>뷰 정의 변경 시 <code>ALTER</code> 대신 <code>DROP</code> 사용</b></li>
      <li><b>뷰를 이용한 또다른 뷰의 생성이 가능 (하나의 뷰 제거 시 기반한 뷰들도 함꼐 삭제)</b></li>
      <li><b>뷰에 대한 조작에서 삽입·갱신·삭제는 제약</b></li>
      <li><b>뷰가 정의된 기본 테이블이 제거되면 뷰도 자동 제거</b></li>
    </ul>
  </li>
  <li><b>시스템 카탈로그 (데이터 사전) : 시스템 자신이 필요하는 여러 객체들에 대한 정보를 가진 시스템 데이터베이스</b>
    <ul>
      <li>메타 데이터 : 시스템 카탈로그에 저장되는 내용</li>
      <li>시스템 카탈로그 기능 : 테이블·뷰·인덱스·사용자 계정 정보 조회</li>
    </ul>
  </li>
  <li><b>인덱스 : 원하는 자료를 검색하기 위해, 인덱스 파일 및 인덱스 파일 (키, 주소)로 구성된, 독립적인 저장 공간</b></li>
</ul>

<h3 id="ddl"><code class="language-plaintext highlighter-rouge">DDL</code></h3>

<ul>
  <li><b>데이터 정의어 (<code>DDL</code>) : 스키마 정의·변경·삭제 (논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의)</b>
    <ul>
      <li><b><code>CREATE</code> : 스키마·도메인·테이블·뷰 정의</b>
        <ul>
          <li><b><code>CREATE TABLE</code> : 테이블 생성 </b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/11c90a08-572b-4ef0-ac4d-6752f5702308" width="80%" /></li>
        </ul>
      </li>
      <li><b><code>ALTER</code> : 테이블 정의 변경 (필드 추가·삭제·갱신)</b>
        <ul>
          <li><b><code>ALTER TABLE</code> : 테이블 구조 변경</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/4b8fde9c-c9da-4232-bc19-79c19a66af46" width="80%" /></li>
        </ul>
      </li>
      <li><b><code>DROP</code> : 스키마·도메인·테이블·뷰 삭제</b></li>
    </ul>
  </li>
</ul>

<h3 id="dcl"><code class="language-plaintext highlighter-rouge">DCL</code></h3>

<ul>
  <li><b>데이터 제어어 (<code>DCL</code>) : 데이터 무결성·제어</b>
    <ul>
      <li><b><code>COMMIT</code></b> : 명령어로 수행된 실제 물리적 디스크에 저장한 뒤에 결과 반환</li>
      <li><b><code>ROLLBACK</code> : 명령어로 수행에 실패했음을 알리고, 수행된 결과를 원상 복귀</b></li>
      <li><b><code>GRANT</code> : 관리자가 사용자에 데이터베이스에 대한 권한을 부여</b></li>
      <li><b><code>REVOKE</code> : 관리자가 사용자에 데이터베이스에 대한 권한을 취소</b></li>
    </ul>
  </li>
</ul>

<h3 id="dml"><code class="language-plaintext highlighter-rouge">DML</code></h3>

<ul>
  <li><b>데이터 조작어 (<code>DML</code>) : 데이터 검색·삽입·삭제·변경</b>
    <ul>
      <li><b><code>SELECT</code> : 튜플 검색</b>
        <ul>
          <li><b><code>BETWEEN ~ AND ~</code> : 튜플 검색 시 구간 값 조건식</b></li>
          <li><b>그룹 함수 (<code>GROUP BY~</code>) : <code>COUNT</code> (행의 수), <code>SUM</code> (하나 이상의 열 합게),<br /><code>AVG</code> (하나 이상의 열 평균), <code>MAX</code> (열의 최댓값), <code>MIN</code> (열의 최솟값)&lt;/br&gt;
</b>            <ul>
              <li><b><code>HAVING</code> : 튜플 검색 시 그룹 함수와 결합해 탐색 조건을 지정하는 조건식</b></li>
            </ul>
          </li>
          <li><b><code>ORDER BY~</code> : 특정 항목 기준으로 검색 테이블의 행들을 오름차순·내림차순으로 정렬</b></li>
          <li>하위 질의 = 서브 퀴리 : 하위 질의를 1차 수행한 다음, 반환값을 상위 릴레이션의 <code>WHERE</code>에서 사용</li>
        </ul>
      </li>
      <li><b><code>INSERT</code> : 튜플 삽입</b></li>
      <li><b><code>UPDATE</code> : 튜플 내용 변경</b></li>
      <li><b><code>DELETE</code> : 튜플 삭제</b></li>
    </ul>
  </li>
</ul>

<h3 id="nosql-절차형-sql"><code class="language-plaintext highlighter-rouge">NoSQL</code>, 절차형 <code class="language-plaintext highlighter-rouge">SQL</code></h3>

<ul>
  <li><b><code>NoSQL</code> : 스키마가 고정되지 않은 비관계형 데이터 모델로 데이터를 저장·검색하는 데이터베이스</b></li>
  <li>절차형 <code>SQL</code> : <code>SQL</code>의 연속 실행, 조건에 따른 반복, 분기 등의 제어 가능
    <ul>
      <li>저장 프로시저 : 사용자가 자주 사용하는 명령문을 작성해 데이터베이스에 저장한 <code>PL/SQL</code> 명령문
        <ul>
          <li><b>트리거 : 데이터베이스에 특정 사건이 발생할 때마다 자동으로 수행되는 저장 프로시저</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="데이터베이스-병행-제어와-보안">데이터베이스 병행 제어와 보안</h2>

<h3 id="트랜잭션">트랜잭션</h3>

<ul>
  <li><b>트랜잭션 : 하나의 논리적 기능을 수행하기 위한 작업 단위</b>
    <ul>
      <li><b>트랜잭션의 특징 : 원자성 (완전 수행 안되면 수행 <code>X</code>), 일관성 (트랜잭션 실행 전후 상태가 일관성 유지)<br />고립성 (트랜잭션 실행 시 다른 트랜잭션에 독립적), 영속성 (트랜잭션 결과가 데이터베이스에 저장)</b></li>
      <li><b>트랜잭션 상태 : 활동, 부분 완료 (실행 마치고 저장 직전), 완료, 실패, 철회</b></li>
      <li><b>리커버리 연산 : 트랜잭션 수행 중에 장애로 손상된 데이터베이스를 정상 상태로 복구 (<code>Redo</code>, <code>Undo</code>)</b></li>
      <li><b>즉각 갱신 : 데이터를 갱신하면 트랜잭션 완료 전에 실제 데이터베이스에 반영</b></li>
    </ul>
  </li>
</ul>

<h3 id="병행-제어-회복">병행 제어, 회복</h3>

<ul>
  <li><b>병행 제어 : 동시에 수행되는 트랜잭션을 일관성 있게 처리하기 위해 제어</b>
    <ul>
      <li><b>병행 제어 목적 : 데이터베이스 공유·일관성·시스템 활용도 최대화, 사용자 응답 시간 최소화</b></li>
      <li><b>병행 제어 종류 : 로킹, 타임스탬프, 최적 병행 수행, 다중 버전 기법</b></li>
    </ul>
  </li>
  <li><b>로킹 : 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스 불가하게 함</b>
    <ul>
      <li><b>2단계 로킹 : 트랜잭션의 로크·해제 요청을 2단계로 실시 (직렬성은 보장하지만, 교착상태 예방은 불가능)</b>
        <ul>
          <li>2단계 로킹 단계 : 확장 단계 (트랜잭션 시작 시 모든 잠금 확보), 축소 단계 (트랜잭션 완료 시 잠금 해제)</li>
          <li>2단계 로킹 잠금 상태 : 공유 잠금 (타 트랜잭션 읽기 가능), 배타적 잠금 (타 트랜잭션 읽기 불가능)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>타임스탬프 : 시간 허가 인증 도장을 부여받아 트랜잭션 간 순서를 미리 정함</li>
  <li>회복 : 데이터 손실 및 손상이 발생했을 때 이를 복구
    <ul>
      <li><b>회복 기법 종류 : 즉시 갱신, 지연 갱신, <code>Redo</code>, <code>Undo</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="데이터베이스-보안과-권한-설정">데이터베이스 보안과 권한 설정</h3>

<ul>
  <li><b>암호화 : 네트워를 통하거나 컴퓨터 내부에 자료를 저장할 때 권한을 가진 사람 외엔 데이터를 보지 못하도록 함</b>
    <ul>
      <li><b>암호화 기법 : 비밀 키 (대칭 키), 공개 키 (비대칭 키)</b></li>
    </ul>
  </li>
  <li><b>데이터베이스 보안 적용 주의사항 : 접근 제어, 데이터 암호화, 취약점 관리, 백업과 복원, 감시와 모니터링</b></li>
</ul>

<h3 id="분산-데이터베이스">분산 데이터베이스</h3>

<ul>
  <li>분산 데이터베이스 : 네트워크를 통해 연결된 여러 컴퓨터에 데이터가 분산된 데이터베이스 → 분산 데이터베이스 투명성
    <ul>
      <li><b>위치 투명성 : 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요가 없다.</b></li>
      <li><b>중복 투명성 : 사용자에 통지할 필요 없이 시스템 안에 자원들의 부가적인 복사를 자유롭게 할 수 있다.</b></li>
      <li><b>병행 투명성 : 다중 사용자들이 자원을 자동으로 공유할 수 있다.</b></li>
      <li><b>장애 투명성 : 사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없다.</b></li>
    </ul>
  </li>
  <li>분산 데이터베이스 구성 요소 : 분산 처리기, 분산 데이터베이스, 틍신 네트워크</li>
  <li>분산 데이터베이스 연결 모델 : 클라이언트·서버 모델, <code>Peer-to-Peer</code> 모델, 클러스터 모델</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[데이터베이스의 개념]]></summary></entry><entry><title type="html">[Engineer Information Processing] 2. 소프트웨어 개발</title><link href="http://localhost:4000/engineer_information_processing2/" rel="alternate" type="text/html" title="[Engineer Information Processing] 2. 소프트웨어 개발" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing2</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing2/"><![CDATA[<h2 id="통합-구현">통합 구현</h2>

<h3 id="통합-구현-1">통합 구현</h3>

<ul>
  <li>단위 모듈 : 소프트웨어 구현에 필요한 다양한 동작 중에 하나의 동작을 수행하는 기능을 모듈료 구현
    <ul>
      <li>단위 기능 명세서 : 큰 규모의 시스템을 분해아여 단위 기능별로 계층적 구조화·단순화하여 추상화한 문서</li>
    </ul>
  </li>
  <li><b>모듈화 : 소프트웨어 개발에 있어 기능을 나누고 추상화하여, 소프트웨어 성능을 향상 및 효과적인 유지보수 구현</b>
    <ul>
      <li>분할 정복법 : 복잡한 문제를 분해하여, 모듈 단위로 문제 해결</li>
      <li>정보 은닉 : 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐</li>
      <li>자료 추상화 : 함수 내에 자료 구조의 표현 명세를 은폐하고, 자료 및 오퍼레이션을 함께 정의</li>
      <li>모듈 독립성 : 낮은 결합도, 높은 응집도를 갖도록 함</li>
      <li>단위 모듈 테스트 : 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증
        <ul>
          <li>단위 모듈 테스트 기법 : 화이트박스 테스트, 블랙박스 테스트</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b>구현 단계의 작업 절차 : 코딩 계획 → 코딩 → 컴파일 → 코드 테스트</b></li>
  <li><b><code>IDE</code> : 소프트웨어 개발 단계에서 필요한 도구들을 하나의 인터페이스로 통합 제공</b>
    <ul>
      <li><code>IDE</code> 종류 : 이클립스, 비주얼 스튜디오, <code>Xcode</code>, 안드로이드 스튜디오, <code>IntelliJ</code>, <code>PyCharm</code></li>
      <li><b><code>IDE</code> 구성 요소 : 소스 코드 편집기, 컴파일러, 디버거</b></li>
      <li><b><code>IDB</code> 기능 : 개발 환경 지원, 컴파일, 디버깅, 외부 연계, <code>DB</code> 연동, 배포</b></li>
    </ul>
  </li>
  <li><b>빌드 자동화 도구 : 소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만듬 (<code>Gradle</code>)</b>
    <ul>
      <li>빌드 자동화 도구 기능 : 컴파일, 컴포넌트 패키징, 파일 조작, 버전 관리 도구 통합, 문서 생성, 테스트, 품질 분석, 배포</li>
      <li>빌드 자동화 도구 프로세스 : 컴파일 → 패키징 → 단위 테스트 → 정적 분석 → 리포팅 → 배포 → 최종 빌드</li>
      <li><b><code>Ant</code>, <code>Maven</code>, <code>Gradle</code>, <code>Jenkins</code>, <code>Makefile</code>, <code>Travis CI</code>, <code>TeamCity</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="형상-관리">형상 관리</h3>

<ul>
  <li><b>형상 관리 : 개발 단계에 생성되는 모든 문서·코드 등 소프트웨어 변경 사항을 체계젹으로 관리하기 위해 추적·통제</b>
    <ul>
      <li><b>형상 관리 항목 : 프로젝트 요구 분석서, 운영·설치 지침, 요구사항 명세서, 설계·인터페이스 명세서, 테스트 설계서, 소프트웨어 품질보증, 형상관리 계획서, 코드 모듈, 소스·테스트 코드</b></li>
      <li><b>형상 관리 도구 : 소프트웨어 개발 생명주기 전반에 걸쳐 산출물의 종합 및 변경 과정을 체계적으로 관리</b></li>
      <li><b>형상 관리 절차 : 형상 식별 → 형상 식별자 선정 → 형상 통제 → 형상 기록·보고 → 형상 검사</b></li>
    </ul>
  </li>
</ul>

<h3 id="버전-관리">버전 관리</h3>

<ul>
  <li>버전 관리 : 요구사항 변화에 따른 다양한 형상 항목에 버전을 부여해 이력을 관리
    <ul>
      <li>변경 관리 : 변경된 요구사항에 대해, 비용·기간을 고려해 타당성 평가 (변경 관리 ⊂ 버전 관리 ⊂ 형상 관리)</li>
      <li>버전 관리 도구 구분 : 공유 폴더 방식, 클라이언트·서버 방식, <b>분산 저장소 방식</b></li>
      <li><b>버전 관리 도구 종류 : <code>CVS</code>, <code>RCS</code>, <code>SVN</code>, <code>BitKeeper</code>, <code>Git</code>, <code>Clear Case</code></b></li>
    </ul>
  </li>
</ul>

<h2 id="시스템-인터페이스-구현">시스템 인터페이스 구현</h2>

<h3 id="모듈-연계">모듈 연계</h3>

<ul>
  <li>모듈 연계 : 시스템 인터페이스를 목적으로 내부-외부 혹은 내부-내부 모듈 간 인터페이스를 설정하는 것
    <ul>
      <li><b><code>EAI</code> : 기업 내부에서 운영되는 각종 플랫폼 및 어플리케이션 간의 정보 전달·연계·통합 솔루션</b>
        <ul>
          <li><b><code>Point-to-Point</code> : 어플리케이션을 미들웨어 없이 점 대 점을 연결하는 방식</b></li>
        </ul>
      </li>
      <li><b><code>Hun &amp; Spoke</code> : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식</b></li>
      <li><b><code>Message Bus</code> : 어플리케이션 간에 미들웨어를 배치해 처리하는 방식</b></li>
      <li><b><code>Hybrid</code> : <code>Hun &amp; Spoke</code>와 <code>Message Bus</code>를 혼합</b></li>
      <li><code>EAI</code> 구성 요소 : <code>EAI</code> 플랫폼, 어댑터, 브로커, 메시지 큐, 비즈니스 워크플로우</li>
    </ul>
  </li>
  <li><code>ESB</code> : 어플리케이션 간의 데이터 변환 및 연계 지원을 제공하는 인터페이스 제공 솔루션</li>
  <li><code>Web Service</code> : 네트워크 정보를 표준화된 서비스의 형태로 만들어 공유하는 기술 (<code>SOA</code> 실천)</li>
  <li><code>IPC</code> : <code>OS</code>에서 프로세스 간 데이터에 대한 통신 기술
    <ul>
      <li><code>IPC</code> 기술 : 파이프, 소켓, 메시지 큐, 공유 메모리</li>
    </ul>
  </li>
</ul>

<h3 id="인터페이스-구현">인터페이스 구현</h3>

<ul>
  <li>인터페이스 기능 정의 : 인터페이스를 실제 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술하는 과정
    <ul>
      <li>인터페이스 기능 정의 순서 : 컴포넌트 명세서 확인 → 인터페이스 명세서 확인 → 인터페이스 기능 구현 정의서 → 인터페이스 기능 구현 정형화</li>
    </ul>
  </li>
  <li>모듈 세부 설계서 : 컴포넌트 설계서, 인터페이스 명세서</li>
  <li><b>인터페이스 구현 : 송·수신 시스템 간의 데이터 교환 및 처리를 실현하는 작업</b>
    <ul>
      <li><b><code>AJAX</code> : <code>JS</code> 기반의 비동기 통신 기술 (클라이언트·서버 간 <code>XML</code>으로 통신)</b></li>
      <li><b><code>JSON</code> : <code>JS</code> 기반의 데이터 통신을 이용한 인터페이스 구현</b></li>
    </ul>
  </li>
  <li>인터페이스 구현 검증 : 구현된 인터페이스의 동작 상태 검증·감시 (<code>Watir</code>, <code>FitNesse</code>, <code>NTAF Naver</code>, <code>Selenum</code>, <code>Appium</code>)
    <ul>
      <li><b><code>xUnit</code> : <code>Assertion</code>, <code>Fixture</code>, <code>Test Runner</code>를 지원하는 단위 테스트 프레임워크</b></li>
      <li><b><code>STAF</code> : 서비스 호출, 컴포넌트 재사용을 데몬 기반 테스트 분산 환경에서 테스트 수행</b></li>
    </ul>
  </li>
  <li>인터페이스 구현 감시 도구 : <code>APM</code>을 통한 동작 상태 감시 (트랜잭션·변수값·호출 함수·로그·시스템 부하 조회·분석)</li>
</ul>

<h3 id="인터페이스-보안">인터페이스 보안</h3>

<ul>
  <li>인터페이스 보안 : 모듈 컴포넌트 간 데이터 교환 시 데이터 변조·탈취 및 인터페이스 모듈 자체의 보안 취약점
    <ul>
      <li><b>데이터 통신 시 데이터 탈취 위협 : 스니핑 (네트워크 패킷을 엿봐 계정·비밀번호 탈취), 스푸핑 (사용자가 크래커의 사이트로 통신해 비밀번호 탈취)</b></li>
    </ul>
  </li>
  <li>네트워크 보안 적용 : 송·수신 중간자의 데이터 탈취·위변조를 방지하기 위한 네트워크 트래픽 암호화
    <ul>
      <li>네트워크 구간 보안 기능 적용 시 고려사항 : 상대방 인증 적용, 데이터 기밀성의 보장, <code>End-to-End</code> 보안의 적용, 인증 키를 통한 통신, 연결 단위 외에 메시지 단위 인증 및 암호화</li>
      <li><code>SSL</code> : 웹 브라우저·서버 간 통신에서 데이터 암호화 및 인증</li>
      <li><code>S-HTTP</code> : 웹 서버·클라이언트 간 통신에서 전송 데이터 암호화</li>
    </ul>
  </li>
  <li>데이터베이스 보안 적용 : 데이터베이스의 기밀성 유지를 위해 중요하고 민감한 데이터는 암호화
    <ul>
      <li>데이터베이스 암호화 기법 : <code>API</code>, <code>Filter (Plug-in)</code>, <code>Hybrid</code></li>
      <li>데이터베이스 암호화 알고리즘 : 대칭키 알고리즘 (<code>ARIA 256</code>), 해시 알고리즘 (<code>SHA-512</code>), 비대칭키 알고리즘 (<code>RSA</code>)</li>
    </ul>
  </li>
  <li>인터페이스 연계 테스트 : 송·수신 시스템 간 구성 요소가 정상적으로 동작하는지 테스트
    <ul>
      <li>인터페이스 연계 태스트 순서 : 테스트 케이스 작성 → 테스트 환경 구축 → 테스트 수행 → 테스트 수행 결과 검증</li>
    </ul>
  </li>
</ul>

<h2 id="제품-소프트웨어-패키징">제품 소프트웨어 패키징</h2>

<h3 id="제품-소프트웨어-패키징-1">제품 소프트웨어 패키징</h3>

<ul>
  <li><b>제품 소프트웨어 패키징 : 개발 완료된 소프트웨어를 고객에 인도하기 위해 패키징하고, 배포 설치 파일을 만드는 작업</b>
    <ul>
      <li>제품 소프트웨어 패키징 프로세스 : 기능 식별 → 모듈화 → 빌드 → 사용자 환경 분석 → 적용 시험 → 변경 개선</li>
    </ul>
  </li>
  <li>제품 소프트웨어 패키징 도구 : 소프트웨어 배포 목적으로 패키징 시에 지식재산권 보호·관리 기능을 제공하는 도구
    <ul>
      <li><b>제품 소프트웨어 패키징 도구 고려 사항 : 내부의 컨텐츠 암호화·보안, 암호화 알고리즘 적합한지, 이기종 컨텐츠 및 단말기 간 <code>DRM</code> 연동 고려, 사용자 편의성을 위한 복잡성·비효율성 문제 고려</b></li>
      <li><code>REL</code> : <code>XML</code> 기반 디지털 컨텐츠의 권한 관리를 위한 언어</li>
      <li><code>ODRL</code> : <code>XML</code> 기반 디지털 컨텐츠의 저작권 관리 위한 권한 표현 언어</li>
      <li><code>SSO</code> : 사용자가 하나의 로그인으로 여러 시스템에 접근할 수 있는 인증 방식</li>
      <li>디지털 인증서 : 디지털 컨텐츠나 서비스의 보안을 강화하기 위한 전자 문서</li>
    </ul>
  </li>
  <li>어플리케이션 모니터링 도구 (<code>APM</code>) : 응용 소프트웨어 성능 및 서비스 이용성을 감시하고 관리하는 도구
    <ul>
      <li><code>APM</code> 제공 기능 : 어플리케이션 모니터링, 사용자 모니터링, 성능 최적화, 장애 대응</li>
    </ul>
  </li>
  <li>협업 도구 : 소프트웨어 개발 과정에서 이해관계자 간 이견 조율을 수행하기 위한 도구
    <ul>
      <li>협업 도구 종류 : 버전 관리 시스템, 이슈 트래커, 채팅 도구, 코드 리뷰 도구, <code>CI·CD</code> 도구</li>
    </ul>
  </li>
</ul>

<h3 id="제품-소프트웨어-저작권">제품 소프트웨어 저작권</h3>

<ul>
  <li><b><code>DRM</code> : 디지털 컨텐츠의 유통 과정에서 컨텐츠를 안전한 관리·보호를 위해 허가된 사용자만 접근 제한</b>
    <ul>
      <li><code>DRM</code> 기술적 요구사항 : 지속적 보호, 이용 편리성, 유연성, 통합 용이성</li>
      <li><b><code>DRM</code> 기술 요소</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ea806705-3295-4cf9-b929-44b93563fb58" width="80%" /></li>
      <li><b><code>DRM</code> 유통 과정</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c363604b-b7e3-4113-97c9-66c239d10d27" width="80%" /></li>
      <li><b><code>DRM</code> 유통 구성</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/81ec6d7b-97b2-4e67-9496-e9e7290456c6" width="80%" /></li>
      <li><code>DRM</code> 정책 : <code>Render Permission</code>, <code>Transport Permission</code>, <code>Derivative Permission</code></li>
      <li><code>DRM</code> 사용 조건 : <code>Period</code>, <code>Count</code>, <code>Domain</code></li>
    </ul>
  </li>
</ul>

<h3 id="제품-소프트웨어-메뉴얼-작성">제품 소프트웨어 메뉴얼 작성</h3>

<ul>
  <li>소프트웨어 메뉴얼 : 제품 소프트웨어 개발 단계부터 적용된 기준, 패키징 이후 설치 및 사용자 측면의 내용을 기록
    <ul>
      <li><b>소프트웨어 설치 메뉴얼 : 소프트웨어 실사용자가 제품을 최초 설치 시 참조하는 메뉴얼</b>
        <ul>
          <li><b>소프트웨어 설치 메뉴얼 기본 사항 : 개요, 관련 파일, 아이콘, 설치 환경 체크 항목</b></li>
        </ul>
      </li>
      <li>소프트웨어 사용자 메뉴얼 : 소프트웨어 설치와 사용에 필요한 제반 절차·환경을 포함하는 메뉴얼
        <ul>
          <li><b>사용자 메뉴얼 작성 순서 : 작성 지침 정의 → 사용 설명서 구성 요소 정의 → 구성 요소별 내용 작성 → 사용자 메뉴얼 검토 → 메뉴얼 배포</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>릴리즈 노트 : 어플리케이션 최종 사용자인 고객에 제공하는 배포 정보 문서
    <ul>
      <li><b>릴리즈 노트 항목 : 헤더, 개요, 목적, 이슈 요약, 재현 항목, 수정·개선 내용, 최종 사용자 영향도, 노트, 면책 조항, 연락 정보</b></li>
    </ul>
  </li>
</ul>

<h3 id="제품-소프트웨어-품질-관리">제품 소프트웨어 품질 관리</h3>

<ul>
  <li>소프트웨어 품질 관리 : 소프트웨어 개발 과정에서 발생할 수 있는 다양한 문제점들을 사전에 파악해 품질 향상
    <ul>
      <li>소프트웨어 품질 국제 표준 : <code><b>ISO/IEC 9126</b></code>, <code><b>ISO/IEC 12119</b></code>, <code><b>ISO/IEC 25000</b></code>, <code><b>ISO/IEC 15504 (SPICE)</b></code></li>
      <li><b>소프트웨어 품질 목표 : <code>Software Quality and Goals</code></b>
        <ul>
          <li><b>운영 측면 : 정확성, 신뢰성, 사용 용이성, 효율성, 무결성</b></li>
          <li><b>변경 수용 특성 : 이식성, 상호운용성, 재사용성, 유지보수성, 유연성, 시험 역량</b></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="어플리케이션-테스트">어플리케이션 테스트</h2>

<h3 id="테스트-관리">테스트 관리</h3>

<ul>
  <li><b>소프트웨어 테스트 : 소프트웨어 개발 단계에서 소프트웨어 결함을 찾아내는 활동</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/cab6acf2-9601-452f-9219-f03c397435ce" width="80%" />
    <ul>
      <li>소프트웨어 테스트 프로세스 : 계획·제어 → 분석·설계 → 구현·실행 → 평가·보고</li>
      <li>소프트웨어 테스트 원리 : 결함 존재 증명, <b>완벽한 테스트는 불가능</b>, 개발 초기에 수행되어야 함, <b>특정 모듈에 결함 대부분이 존재</b>, 테스트는 컨텍스트에 의존
        <ul>
          <li><b>파레토의 법칙 : 전체 결과의 <code>80%</code>가 전체 원인의 <code>20%</code></b></li>
          <li><b>살충제 패러독스 : 동일한 테스트 케이스로 테스트하면 어느 시점부터 결함 발견 불가능</b></li>
          <li>오류-부재의 궤변 : 요구사항을 만족하지 못하는 오류를 발견해 제거해도, 해당 어플리케이션 품질이 높다고 할 수 없음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="테스트-케이스와-테스트-오라클">테스트 케이스와 테스트 오라클</h3>

<ul>
  <li><b>테스트 케이스 : 구현된 소프트웨어가 사용자 요구사항을 준수하는지 확인하기 위한 테스트 항목에 대한 명세서</b>
    <ul>
      <li><b>표준 테스트 케이스 형식 : <code>ID</code>, 시나리오, 단계, 데이터, 예상 결과, 실제 결과, 통과 실패</b></li>
      <li><b>테스트 케이스 자동 생성 : 자료 흐름도 → 테스트 경로 관리·입력 도메인 분석 → 테스트 데이터 산출·랜덤 테스트 → 무작위 값 입력·신뢰성 검사</b></li>
      <li>테스트 케이스 구성 요소 (<code>ISO/IEC/IEEE 29119-3</code>)<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1d53b65b-aeef-4253-8748-60accb3d844a" width="80%" /></li>
    </ul>
  </li>
  <li><b>테스트 오라클 : 테스트 결과가 참인지 거짓인지 판단하기 위해 사전에 정의된 <code>True</code>를 입력해 비교</b>
    <ul>
      <li>테스트 오라클 종류 : 참 오라클, 일관성 검사 오라클, 샘플링 오라클, 휴리스틱 오라클</li>
    </ul>
  </li>
</ul>

<h3 id="v-모델과-테스트-레벨"><code class="language-plaintext highlighter-rouge">V</code>-모델과 테스트 레벨</h3>

<ul>
  <li><b>시각에 따른 테스트 : 검증 (<code>Verification</code>)<code>vs</code>확인 (<code>Validation</code>)</b></li>
  <li><code>Test Bases</code> 테스트 : 소프트웨 내부 구조에 따른 테스트 케이스 작성 및 확인
    <ul>
      <li><code>Test Bases</code> 종류 : 구문 기반, 결정 기반, 조건 기반, 데이트 흐름 기반, 명세 기반, 경험 기반</li>
    </ul>
  </li>
  <li>동적 테스트 : 어플리케이션을 직접 실행 (<code>vs</code>정적 테스트)<br />→ <b>블랙박스 테스팅 (명세 기반), 화이트박스 테스팅 (구조 기반)</b></li>
  <li>알파 테스트 (개발자 관점에서 사용자가 테스트)<code>vs</code>베타 테스트 (사용자 관점에서 사용자가 테스트)</li>
  <li>테스트 분류 : 회복 테스트, 안전 테스트, 성능 테스트, 구조 테스트, <b>회귀 테스트</b>, 병행 테스트</li>
  <li>성능 테스트 유형 : 부하 테스트, 강도 테스트, 스파이크 테스트, 내구성 테스트</li>
  <li><code class="language-plaintext highlighter-rouge">V</code>-모델 : 어플리케이션 개발 단계에 따라 어플리케이션르 총체적을 관리하기 위한 테스트 활동의 묶음<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0d419760-7be8-40fc-b4df-d40adc5a5fa8" width="80%" />
    <ul>
      <li><b>단위 테스트 : 개발자가 원시 코드를 대상으로 각 단위를 다른 부분과 연계되는 부분을 고려치 않고 테스트</b></li>
      <li>통합 테스트 : 단위 테스트를 통과한 개발 소프트웨어·하드웨어 컴포넌트 간 인터페이스 및 연동 기능을 테스트</li>
      <li>시스템 테스트 : 단위·통합 테스트 이후 실제 환경과 유사한 환경에서 시스템 성능과 관련된 요구사항을 테스트</li>
      <li><b>인수 테스트 : 소프트웨어 제품에 대한 요구사항을 제대로 이행되었는지 확인</b></li>
    </ul>
  </li>
</ul>

<h3 id="테스트-시나리오와-테스트-기법">테스트 시나리오와 테스트 기법</h3>

<ul>
  <li>테스트 시나리오 : 테스트를 위한 테스트 케이스의 집합 (테스트 케이스의 동작 순서 기술)</li>
  <li>테스트 환경 구축 : 실제 운영 시스템에 정상적으로 작동하는지 테스트하기 위한 실제 운영 환경과 동일한 시설 구축</li>
  <li><b>화이트박스 테스트 : 모듈의 원시 코드를 오픈한 상태에서 코드의 모든 논리적 경로 테스트</b>
    <ul>
      <li><b>화이트박스 테스트 종류 : 기초 경로 검사, 제어 구조 검사 (조건 검사, 루프 검사, 데이터 흐름 검사)</b></li>
    </ul>
  </li>
  <li><b>블랙박스 테스트 : 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 정상 작동되는지 입증 (기능 테스트)</b>
    <ul>
      <li><b>블랙박스 테스트 종류 : 동치 분할 검사, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사, 경계값 분석</b>
<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f06ef31a-a382-4d07-bee6-cf9db10df171" width="70%" /></li>
    </ul>
  </li>
</ul>

<h3 id="테스트-커버리지">테스트 커버리지</h3>

<ul>
  <li><b>테스트 커버리지 : 주어진 테스트 케이스에 의해 수해오디는 소프트웨어 테스트 범위를 측정하는 테스트 품질 측정 기준</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/042d81b0-8871-4949-af3c-c18e59e0fe13" width="50%" /></li>
</ul>

<h3 id="통합-테스트">통합 테스트</h3>

<ul>
  <li><b>단위 테스트 : 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트</b>
    <ul>
      <li><b>단위 테스트 지원 도구 (<code>xUnit</code>) : <code>JUnit</code>, <code>Mocha</code>, <code>Mockito</code>, <code>Karma</code>, <code>Selenium</code><b></b></b></li>
    </ul>
  </li>
  <li>통합 테스트 : 각 모듈을 결합해 시스템을 완성할 때, 모듈 간 인터페이스나 통합 컴포넌트 간 오류 탐색<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5463b8f8-85ba-4a02-9e24-ece7cdd50502" width="80%" />
    <ul>
      <li>비 점진적 통합 방식 (빅뱅 통합) : 모든 모듈이 결합된 프로그램 전체 대상으로 테스트</li>
      <li>점진적 통합 방식 (상향식·하향식) : 단계적으로 통합하면서 테스트</li>
    </ul>
  </li>
  <li><b>하향식 통합 테스트 : 상위 컴포넌트 → 하위 컴포넌트</b>
    <ul>
      <li>시스템 테스트 기능, 개발 일정 예측 가능, 통합 오류 발견 어려움, 테스트 스텁 사용 가능, 협력 필요</li>
    </ul>
  </li>
  <li><b>상향식 통합 테스트 : 하위 컴포넌트 → 상위 컴포넌트</b>
    <ul>
      <li>하위 모듈 결함 전파 방지, 드라이버 통한 테스트 가능, 개바 속도 빠름, 조기 결함 발견 가능</li>
    </ul>
  </li>
  <li>테스트 자동화 도구 : 어플리케이션 개발 중에 반복되는 테스트 과정을 자동화하는 도구
    <ul>
      <li><b>테스트 자동화 도구 유형 : 정적 분석 도구, 테스트 실행 도구, 성능 테스트 도구, 테스트 통제 도구</b>
        <ul>
          <li>테스트 하네스 도구 : 소프트웨어 컴포넌트 테스트, 프로그램 입력, 결과 비교, 컴포넌트 기능 대행 목적
            <ul>
              <li><b>테스트 드라이버 : 상향식 테스트에서 테스트 대상을 제어·동작하기 위한 도구</b></li>
              <li><b>테스트 스탑 : 하향식 테스트에서 시스템 컴포넌트가 개발되지 않은 상황의 가상 더미 컴포넌트</b></li>
              <li>테스트 슈트 : 일정 순서에 의해 수행될 계별 테스트 집합 및 패키지</li>
              <li>테스트 케이스 : 요구사항에 맞게 개발되었는지 확인할 테스트 입력 및 예상 결과</li>
              <li>테스트 스크립트 : 테스트 케이스르 수행해 결과를 보고할 목적으로 작성된 명령어·이벤트 중심 파일</li>
              <li>목 오브젝트 : 사용자 행위를 미리 조건부로 입력해 그 상황에 맞는 행위를 수행하는 객체</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="어플리케이션-성능-개선">어플리케이션 성능 개선</h2>

<h3 id="결함-관리">결함 관리</h3>

<ul>
  <li>결함 : 소프트웨어의 에러, 결함, 결점, 버그, 실패
    <ul>
      <li>결함 심각도별 분류 : 치명적, 주요, 보통, 경미한 단순</li>
      <li>결함 우선순위 : 결정적, 높음, 보통, 낮거나 즉시 해결, 주의 요망, 대기, 개선 권고</li>
      <li>결함 위치별 분류 : 시스템 결함, 기능 결함, <code class="language-plaintext highlighter-rouge">GUI</code> 결함, 문서 결함</li>
      <li>결함 관리 프로세스 : 결합 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 → 보고서 작성</li>
    </ul>
  </li>
  <li>에러 : 소프트웨어 개발 또는 유지보수 수행 중에 발생한 부정확한 결과</li>
  <li><b>오류 : 소프트웨어 구현이나 설계상의 오류로 인해 시스템의 고장을 일으킴</b></li>
  <li>고장 : 정상적인 프로그램과 비정상적인 프로그램의 실행 결과 차이</li>
  <li>결함 : 버그, 에러, 오류, 실패를 모두 포괄</li>
</ul>

<h3 id="어플리케이션-성능-개선-1">어플리케이션 성능 개선</h3>

<ul>
  <li>성능 처리 지표 : 처리량, 응답 시간, 경과 시간, 갸용성, 확장성, 안정성</li>
  <li>성능 분석 도구 : 성능·부하·스트레스 점검 도구, 머니터링 도구</li>
  <li><b>위험 감시 : 위험 요수 징후들에 대해 계속해서 인지하는 것</b>
    <ul>
      <li>위험 감시 절차 : 위험 식별 → 위험 평가 → 위험 대응 계획 수립 → 위험 모니터링</li>
    </ul>
  </li>
  <li>어플리케이션 성능 저하 원인 : <code>DB Lock</code>, 불필요한 <code>DB Fetch</code>, 연결 누수, 부적절한 <code>Connection Pool Size</code></li>
  <li>알고리즘 : 주어진 과제를 해결하는 방법 및 절차 (자연여, 의사코드, 순서도, 프로그래밍 언어로 표현)
    <ul>
      <li>분할 정복법 : 제시된 문제를 분할이 불가능할 때까지 나누고, 각 과제를 해결하면서 다시 결합 (<code>Top-Down</code>)
        <ul>
          <li>분할 정복법 예시 : 퀵 정렬, 병합 정렬</li>
        </ul>
      </li>
      <li>동적 계획법 : 주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용 (<code>Bottom-Up</code>)
        <ul>
          <li>동적 계획법 예시 : 플로이드 알고리즘, 피보니치 수열 알고리즘 → 최적 부분 구조, 중복 부분 문제에 적합</li>
        </ul>
      </li>
      <li>탐욕법 : 각 부분에 대한 최적해를 구해 이를 결합하여, 국소적인 관점에서 최적의 해결 방법을 구함
        <ul>
          <li>탐욕법 예시 : 크루스칼 알고리즘, 다익스트라 알고리즘</li>
        </ul>
      </li>
      <li>퇴각 검색법 : 어떤 문제의 최적해를 구하기 위해 모든 가능성을 탐색
        <ul>
          <li>퇴각 검색법 예시 : <code>N-Queen</code></li>
        </ul>
      </li>
      <li>분기 한정법 : 정해진 범위를 벗어나는 값들은 가지치기하면서 결과값을 추적
        <ul>
          <li>분기 한정법 예시 : 최적 우선 탐색 알고리즘, <code>A*</code> 알고리즘</li>
        </ul>
      </li>
      <li>근사 해법 : 복잡도가 매우 높은 문제에 대해 가장 근사치의 값을 구하는 결정성 구현
        <ul>
          <li>근사 해법 예시 : 근사 알고리즘</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>알고리즘 시간 복잡도 : 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것
    <ul>
      <li><b>빅오 표기법 : 알고리즘 실행 시간이 최악일 때를 표기하는 방법</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3b1bdb74-3483-4178-b2c8-c7f5cb09a42b" width="80%" /></li>
    </ul>
  </li>
  <li><b>순환 복잡도 : 프로그램의 이해 난이도는 제어 흐름 그래프의 복잡도에 따라 결정 → 복잡도를 싸이클로메틱 개수로 산정</b>
    <ul>
      <li>최대 10이 넘지 않도록 하며, 넘으면 이를 분해하도록 함</li>
      <li>복잡도 = 화살표 수 - 노드 수 + 2 = 영역 수 + 1 = 의사 결정 수 + 조건 수 + 1<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7c67d819-c188-4cee-9528-332bdfc2c6ed" width="90%" /></li>
    </ul>
  </li>
</ul>

<h3 id="소스-코드-최적화">소스 코드 최적화</h3>

<ul>
  <li>소스 코드 최적화 : 읽기 쉽고 변경·추가가 쉬운 클린 코드를 위해 기본적으로 지킬 윈칙 및 기준 정의
    <ul>
      <li>스파게티 코드 : 처리 로직의 제어가 체계화되어 있지 않고 서로 얽혀있는 코드</li>
      <li>외계인 코드 : 오래되거나 참고 문서·개발자가 없어 유지보수가 어려운 프로그램</li>
      <li><b>클린 코드 : 깔끔하게 잘 정리된 코드 (중복 코드 제거, 높은 가독성·프로그래밍 속도·버그 탐색 속도)</b>
        <ul>
          <li><b>클린 코드 작성 원칙 : 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화</b></li>
          <li><b>클린 코드 유형 : 좋은 배치, 작은 함수, 분석 가능한 제어 흐름, 간결한 주석, 의미 있는 이름</b></li>
        </ul>
      </li>
      <li><b>코드 간결성 유지 지침 : 공백으로 실행문·주석 구분, 복잡한 논리식·산술식 들여쓰기, 빈 줄로 선언부·구현부 구별, 한줄에 적은 문장</b></li>
      <li>소스 코드 최적화 유형 : 클래스 분할 배치, 좋은 이름 사용, 코딩 형식 준수, 느슨한 결합, 적절한 주석</li>
    </ul>
  </li>
  <li><b>소스 코드 품질 분석 도구 : 코딩 스타일, 코드 표준, 코드 복잡도, 메모리 누수, 스레드 결함을 발견하기 위해 사용</b>
    <ul>
      <li><b>정적 분석 도구 : 소스 코드 검증, 코드 리뷰, 정적 리버스 엔지니어링</b>
        <ul>
          <li><b>정적 분석 도구 종류 : <code>PMD</code>, <code>CPPCheck</code>, <code>SonarQube</code>, <code>CheckStyle</code>, <code>CCM</code>, <code>Coberfura</code></b></li>
        </ul>
      </li>
      <li>동적 분석 도구 : 디버깅, 스트레스 테스트, 모의 해킹, 동적 리버스 엔지니어링<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/17507c69-6c8a-4049-b5ee-f7d5a064f820" width="80%" /></li>
    </ul>
  </li>
</ul>

<h2 id="데이터-입출력-구현">데이터 입출력 구현</h2>

<h3 id="자료-구조">자료 구조</h3>

<ul>
  <li>자료 구조의 분류 : 선형 구조, 비선형 구조, 파일 구조로 대분류<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/27fa958b-8c44-4516-ac0d-cfe496f748fa" width="80%" />
    <ul>
      <li>자료구조의 활용 : 정렬, 검색, <b>인덱스</b>, 레코드</li>
    </ul>
  </li>
  <li>선형 자료 구조 : 데이터를 일렬로 늘어놓은 자료 구조, 데이터를 순서대로 저장하고 순차적으로 처리
    <ul>
      <li><b>스택 : 후입선출 (<code>LIFO</code>), 큐 : 선입선출 (<code>FIFO</code>), 데크 : 리스트 양끝에 포인터 2개 사용</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/1d7edc16-6e1e-4887-a157-e7d8b9fb4172" width="80%" /></li>
    </ul>
  </li>
  <li>비선형 구조 : 데이터를 한줄로 연결하지 않는 구조, 자료 간 선후관계가 <code>1:N</code>, <code>N:1</code>으로 표현
    <ul>
      <li><b>트리 : 노드와 브랜치로 사이클을 이루지 않는 그래프</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5c562017-31a9-41c5-b4d8-d120f5d5022d" width="70%" /></li>
      <li>이진 트리 : 차수가 2 이하인 노드들로 구성된 트리 (이진 트리 레벨 <code>K</code>의 최대 노드 수는 <code>2^K-1</code>)<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c4de5709-b5a5-49f0-815a-0cc54e547092" width="80%" />
        <ul>
          <li><b>이진 트리의 운행법 : 전위 운행 (<code>Root → Left → Right</code>), 중위 운행 (<code>Left → Root → Right</code>), 후위 운행 (<code>Left → Right → Root</code>)</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7d5170ec-dcac-45af-970f-40b809c469b1" width="80%" /></li>
          <li><b>이진 트리의 수식 표기법 : 전위 표기법 (연산자 → 피연산자 → 피연산자), 중위 표기법 (피연산자 → 연산자 → 피연산자), 후위 표기법 (피연산자 → 피연산자 → 연산자)</b><br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/eb9e452d-3156-4e9e-baeb-b310b52eaf71" width="80%" /></li>
        </ul>
      </li>
      <li><b>그래프 : 정점과 간선의 집합으로 이루어진 자료 구조 (인접 행렬로 표현)</b>
        <ul>
          <li>그래프 종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프</li>
          <li><code>N</code>개의 노드로 구성된 무방향 그래프의 최대 간선 수 : <code>N(N-1)/2</code></li>
          <li><b>제어 흐름 그래프의 순환 복잡도 : <code>V(G) = (화살표 수) - (노드 수) + 2</code></b></li>
        </ul>
      </li>
      <li><b>인접 행렬 : 방향 그래프에서 정점 <code>Vi</code>과 <code>Vj</code>의 관계를 나타내는 행렬의 원소를 <code>Aij</code>라 할 때,<br />정점 <code>Vi</code>에서 <code>Vj</code>로 향하는 방향 간선이 있으면 행렬의 <code>Aij = 1</code>,<br />방향 간선이 없으면 행렬의 <code>Aij = 0</code>,<br />정점 <code>Vi</code>와 <code>Vj</code>가 서로 인접하면 <code>Aij = 1</code><br />정점 <code>Vi</code>와 <code>Vj</code>가 서로 인접하지 않으면 <code>Aij = 0</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="정렬">정렬</h3>

<ul>
  <li>정렬 : 자료를 특정 기준에 따라 다시 나열 하는 것<br /><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/dd0af678-cbe9-467b-8075-70adbdf6ca1c" width="80%" />
    <ul>
      <li><b>삽입 정렬 : 정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입해 정렬</b></li>
      <li><b>버블 정렬 : 인접한 데이터와 비교하면서 그 크기에 따라 데이터 위치를 바꾸어 정렬</b></li>
      <li><b>선택 정렬 :<code>N</code>개의 레코드 중 최소값(최대값)을 찾아 배열의 <code>N</code>번째로 놓는 것을 반복해 정렬</b></li>
      <li><b>병합 정렬 : 배열을 최대로 나눈 뒤, 나뉜 각 키 한 쌍을 순서를 정하며 병합해 정렬</b></li>
      <li><b>퀵 정렬 : 피벗을 기분으로 작은 값은 왼쪽에, 큰 값은 오른쪽에 모이도록 서로 교환해 정렬</b></li>
    </ul>
  </li>
</ul>

<h3 id="검색-해싱">검색, 해싱</h3>

<ul>
  <li>검색 : 기억 공간 내에서 주어진 조건 을만족하는 자료 탐색
    <ul>
      <li>이분 검색 : 정렬된 배열의 가운데 인덱스 값을 선택 → 크면 작은 값 쪽으로, 작으면 큰 값 쪽으로 이동 반복</li>
      <li><b>선형 검색 : 주어진 자료에서 원소를 첫번째 레코드부터 순차 비교해 탐색</b></li>
      <li>이진 트리 검색 : 전체 레코드를 이진 트리로 구성해 검색</li>
      <li>블록 검색 : 전체 레코드를 블록으로 분리해 순서대로 비교해 검색</li>
    </ul>
  </li>
  <li>해싱 함수 : 레코드 키에 대한 해시 테이블 내의 홈 주소를 계산해 주어진 레코드에 접근할 때 활용되는 함수
    <ul>
      <li><b>해싱 함수 종류 : 제산 방법, 중간 제곱 방법, 중첩 방법, 기수 변환 방법</b></li>
      <li>해싱 오버플로우 해결 : 선형 개방 주소법, 폐쇄 주소 방법, 재해싱</li>
      <li>해싱 관련 용어 : 동의어, 슬롯, 충돌</li>
    </ul>
  </li>
</ul>

<h3 id="인덱스-구조와-파일-편성">인덱스 구조와 파일 편성</h3>

<ul>
  <li>인덱스 : <code>DB</code> 테이블 내의 원하는 레코드를 빠르게 탐색하는 데이터 구조
    <ul>
      <li>인덱스 구성 방법 : <code>B</code> 트리, <code>B+</code> 트리, 트라이 색인</li>
      <li>정적 인덱싱 (색인 순차 파일 방식)<code>vs</code>동적 인덱싱 (가상 기억 접근 방식)</li>
    </ul>
  </li>
  <li><b>파일 편성 기법 : 순차 파일, 색인 순차 파일, <code>VSAM</code> 파일, 직접 파일, 역파일</b></li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[통합 구현]]></summary></entry><entry><title type="html">[Engineer Information Processing] 4. 프로그래밍 언어 활용</title><link href="http://localhost:4000/engineer_information_processing4/" rel="alternate" type="text/html" title="[Engineer Information Processing] 4. 프로그래밍 언어 활용" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/engineer_information_processing4</id><content type="html" xml:base="http://localhost:4000/engineer_information_processing4/"><![CDATA[<h2 id="c"><code class="language-plaintext highlighter-rouge">C</code></h2>

<h3 id="c-개요"><code class="language-plaintext highlighter-rouge">C</code> 개요</h3>

<ul>
  <li><b><code>C</code> 기본 자료형 : <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code></b></li>
  <li><b><code>C</code> 변수명 작성 규칙 : 영문 대소문자, 숫자, <code>_</code> 혼용 (첫글자 숫자<code>X</code>, 예약어<code>X</code>)</b></li>
</ul>

<h3 id="c-라이브러리"><code class="language-plaintext highlighter-rouge">C</code> 라이브러리</h3>

<ul>
  <li><b>라이브러리 : 필요할 때 찾아 쓸 수 있도록 모듈화되어 모듈, 패키지의 형태로 제공되는 프로그램</b></li>
  <li><b>헤더 파일 (<code>.h</code>)가 필요한 이유? : 라이브러리를 사용하기 위해</b></li>
  <li><b>표준 라이브러리 : <code>string.h</code>, <code>stdio.h</code>, <code>stdlib.h</code>, <code>ctype.h</code></b>
    <ul>
      <li><b><code>stdlib.h</code> 함수 : <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, <code>free</code>, <code>rand</code>, <code>abs</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="c-연산자"><code class="language-plaintext highlighter-rouge">C</code> 연산자</h3>

<ul>
  <li><b><code>C</code> 연산자 종류·우선순위 : 단항 연산자 → 산술 연산자 → 시프트 연산자 → 관계 연산자 → 비트 연산자 → 논리 연산자 → 조건 연산자 → 대입 연산자 → 콤마 연산자<b>
</b></b>    <ul>
      <li><b>논리 연산자의 우선순위 : <code>NOT</code>→<code>AND</code>→<code>OR</code></b></li>
    </ul>
  </li>
</ul>

<h3 id="c-포인터"><code class="language-plaintext highlighter-rouge">C</code> 포인터</h3>

<ul>
  <li><b><code>C</code> 포인터 : 객체에 대한 참조를 하는 다른 객체를 가리키는 자료형</b>
    <ul>
      <li><b>주소 연산자 <code>&amp;</code> : 모든 변수에 대한 주소값을 구하는 연산자</b></li>
      <li><b>간접 연산자 <code>*</code> : 포인터 변수의 자료를 구하는 연산자</b></li>
    </ul>
  </li>
</ul>

<h3 id="c-배열--c-구조체"><code class="language-plaintext highlighter-rouge">C</code> 배열 / <code class="language-plaintext highlighter-rouge">C</code> 구조체</h3>

<ul>
  <li><b><code>C</code> 배열 : 배열, 구조체, 공용체</b>
    <ul>
      <li><b>구조체 : 서로 연관된 데이터를 모아놓은 것</b></li>
    </ul>
  </li>
</ul>

<h2 id="java"><code class="language-plaintext highlighter-rouge">Java</code></h2>

<h3 id="java-개요"><code class="language-plaintext highlighter-rouge">Java</code> 개요</h3>

<ul>
  <li><code>Java</code> : 객체지향 프로그래밍 언어
    <ul>
      <li><b>객체지향 구성 요소 : 클래스, 객체, 속성, 메소드, 메시지</b></li>
      <li><b>객체지향 특징 : 캡슐화, 정보은닉, 추상화, 상속성, 다형성</b></li>
    </ul>
  </li>
  <li><b>가비지 컬렉션 : <code>JVM</code>에서 불필요한 메모리 정리</b></li>
  <li><b><code>Java</code> 기본 자료형 : <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>boolean</code></b></li>
  <li><code>Java</code> 출력 메소드 : <code>System.out.print()</code> (줄바꿈 <code>X</code>), <code>System.out.printIn()</code> (줄바꿈 <code>O</code>), <code>System.out.printf()</code> (변환 문자 사용해 출력)</li>
  <li><b><code>Java</code> 변수명 작성 규칙 : 영문 대소문자, 숫자, <code>_</code>, <code>$</code> 혼용 (첫글자 숫자<code>X</code>, 예약어<code>X</code>)</b></li>
  <li><b><code>Java</code> 연산자 종류·우선순위 : 단항 연산자 → 산술 연산자 → 비트 이동 연산자 → 관계 연산자 → 비트 논리 연산자 → 논리 연산자 → 조건 연산자 → 대입 연산자<b></b></b></li>
</ul>

<h3 id="java-자료형"><code class="language-plaintext highlighter-rouge">Java</code> 자료형</h3>

<ul>
  <li><b><code>Java</code> 기본 자료형 : 논리형, 문자형, 정수형, 실수형</b></li>
  <li><b><code>Java</code> 참조 자료형 : 문자열, 배열, 클래스, 인터페이스, 열거형</b></li>
</ul>

<h3 id="java-클래스"><code class="language-plaintext highlighter-rouge">Java</code> 클래스</h3>

<ul>
  <li><b>클래스 : 객체를 정의하기 위한 틀</b>
    <ul>
      <li>클래스 선언 후 <code>new</code>로 객체 생성, 래퍼런스 변수를 선언해 객체 활용</li>
      <li>클래스 이름은 하나 이상의 문자로 (반드시 대문자로 시작해야 함)</li>
      <li>소스 파일에는 하나의 <code>public</code> 클래스만 가능</li>
      <li><code>main</code>은 실행의 시작을 위해 반드시 필요</li>
    </ul>
  </li>
  <li>추상 클래스 : 실행 코드가 없는 추상 메소드를 하나 이상 포함하는 클래스
    <ul>
      <li>추상 메소드 : 자식 클래스에서 재정의해 사용하는 메소드</li>
      <li>클래스의 형변환 : 재정의한 메소들르 부모 클래스의 객체 변수를 통해 사용하려면 부모 클래스의 객체 변수를 선언할 때 자식 클래스의 생성자를 이용해야 함 → 클래스의 다형성</li>
    </ul>
  </li>
</ul>

<h3 id="java-상속"><code class="language-plaintext highlighter-rouge">Java</code> 상속</h3>

<ul>
  <li><b>상속 : 자식 클래스가 부모 클래스의 속성과 메소드를 상속받는 것</b></li>
  <li><b>메소드 오버라이딩 : 클래스 상속 상황에섯 부모 클래스의 멤버를 자식 클래스에서 상속해 내용을 수정해 사용</b></li>
</ul>

<h3 id="java-예외-처리"><code class="language-plaintext highlighter-rouge">Java</code> 예외 처리</h3>

<ul>
  <li><b>예외 처리 : 오동작이나 실행 시간 동안 발생해 결과에 악영향을 미치는 오류</b>
    <ul>
      <li><b>예외 처리 특징 : 예외 클래스 계총 구조, <code>Checked &amp; UnChecked</code>예외, <code>try-catch-finally</code>, 다중 <code>catch</code> 블록, <code>throws &amp; throw</code>, <code>CustomException</code></b></li>
    </ul>
  </li>
</ul>

<h2 id="python"><code class="language-plaintext highlighter-rouge">Python</code></h2>

<h3 id="스크립트-언어와-python">스크립트 언어와 <code class="language-plaintext highlighter-rouge">Python</code></h3>

<ul>
  <li>스크립트 언어 : 소스 코드를 컴파일 과정 없이 실행할 수 있는 프로그래밍 언어
    <ul>
      <li><b>서버 측 스크립트 언어 : <code>ASP</code>, <code>JSP</code>, <code>PHP</code>, <code>Python</code></b></li>
      <li>클라이언트 측 스크립트 언어 : <code>JS</code></li>
    </ul>
  </li>
  <li><b><code>Python</code> : 플랫폼 독립적, 인터프리터, 객체지향적, 동적 타이핑 대화형 언어</b></li>
  <li><b><code>Python</code> 변수명 작성 규칙 : 영문 대소문자, 숫자, <code>_</code> 혼용 (첫글자 숫자<code>X</code>, 예약어<code>X</code>)</b></li>
  <li><b><code>Scrapy</code> : <code>Python</code> 웹 크롤러 프레임워크</b></li>
</ul>

<h3 id="python-자료형"><code class="language-plaintext highlighter-rouge">Python</code> 자료형</h3>

<ul>
  <li><b><code>Python</code> 숫자 자료형 : 정수형, 실수형, 복소수형</b></li>
  <li><b><code>Python</code> 시퀀스 자료형 : 문자열, 리스트, 튜플</b></li>
  <li><b><code>Python</code> 매핑 자료형 : 딕셔너리</b></li>
  <li><b><code>Python</code> 집합 자료형 : 집합</b></li>
  <li><b><code>Python</code> 부울 자료형 : 불리언</b></li>
  <li><b><code>Python</code> <code>None</code> 자료형 : <code>None</code></b></li>
</ul>

<h3 id="python-연산"><code class="language-plaintext highlighter-rouge">Python</code> 연산</h3>

<ul>
  <li><b>인덱싱 : 문자열의 각 문자에 인덱스 할당 (첫번째는 0)</b></li>
  <li><b>클래스 메소드 : 클래스에 속한 메소드 (<code>@classmethod</code> 데코레이터로 정의)</b></li>
</ul>

<h3 id="python-함수"><code class="language-plaintext highlighter-rouge">Python</code> 함수</h3>

<ul>
  <li><b><code>Python</code> 함수 : 재사용 가능한 코드 블록</b>
    <ul>
      <li><b><code>range()</code> : 0~주어진 인수 미만의 연속된 정수를 리스트 객체로 반환</b></li>
      <li><b><code>map()</code> : 주어진 함수를 순회 가능한 객체의 모든 요소에 적용해 새로운 이터레이터 반환</b></li>
      <li><b><code>split()</code> : 구분자 기준으로 분리해 분리된 각 부분을 원소로 가지는 리스틑 반환</b></li>
    </ul>
  </li>
  <li><b><code>Python</code> 조건문 : <code>if ~ elif ~ else</code></b></li>
  <li><b>지역 변수 : 함수 내에서 정의된 변수</b></li>
</ul>

<h2 id="운영체제-개론">운영체제 개론</h2>

<h3 id="운영체제-개요">운영체제 개요</h3>

<ul>
  <li>운영체제 : 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어
    <ul>
      <li>시스템 소프트웨어 : 컴퓨터의 전반적인 운영에 필요한 가장 기본적인 프로그램</li>
      <li>운영체제 평가 기준 : 처리 능력 향상, 응답 시간 단축, 신뢰도 향상, 사용 기능도 향상</li>
    </ul>
  </li>
</ul>

<h3 id="운영체제의-운영-방식">운영체제의 운영 방식</h3>

<ul>
  <li>일괄 처리 시스템 : 사용자 개입 없이 일정량 혹은 일정 시간 동안 데이터를 모아 처리</li>
  <li>다중 프로그래밍 시스템 : 2개 이상의 프로그램을 주기억장치에 기억시켜 <code>CPU</code>를 번갈아 사용
    <ul>
      <li>다중 프로그래밍 시스템 특징 : 멀티태스킹, 가상 메모리, <code>CPU</code> 리소스 사용 효율화</li>
    </ul>
  </li>
  <li>실시간 처리 시스템 : 데이터 발생 즉시 처리하여 결과 산출</li>
  <li><b>시분할 시스템 :<code>CPU</code> 전체 사용 시간을 작업 시간량으로 나눠 <code>CPU</code>를 시간량 동안만 사용</b>
    <ul>
      <li>시분할 시스템 특징 : 다중 사용자 지원, 시분할 방식, 대화식 환경</li>
    </ul>
  </li>
  <li>다중 처리 시스템 : <code>CPU</code>를 두 개 이상 두어 그 업무를 분담해 처리
    <ul>
      <li>다중 처리 시스템 특징 : 병렬 처리, 자원 분산, 확장성</li>
    </ul>
  </li>
  <li>분산 처리 시스템 : 여러 대의 컴퓨터로 작업을 나누어 처리</li>
  <li>가상화 시스템 : 하나의 물리적 시스템에서 여러 개의 가상 시스템을 구동</li>
  <li>클라우드 컴퓨팅 시스템 : 인터넷을 통해 자원을 공유받고 서비스를 제공</li>
</ul>

<h3 id="운영체제의-프로그램-구성">운영체제의 프로그램 구성</h3>

<ul>
  <li>제어 프로그램 : 컴퓨터 시스템의 하드웨어와 소프트웨어를 제어
    <ul>
      <li>제어 프로그램 기능 : 프로세스·메모리·입출력·장치·자원·보안 관리</li>
      <li><b>제어 프로그램 종류 : 감시 프로그램, 작업 제어 프로그램, 데이터 관리 프로그램</b></li>
    </ul>
  </li>
  <li>처리 프로그램 : 사용자의 응용 프로그램이나 그 작업을 실행
    <ul>
      <li>처리 프로그램 역할 : 응용 프로그램 실행, 작업 처리, 자원 관리, 결과 제공</li>
      <li>처리 프로그램 기능 : 파일·메모리·디스크·네트워크 관리, 사용자 인터페이스</li>
      <li><b>처리 프로그램 종류 : 언어 번역 프로그램, 서비스 프로그램, 문제 프로그램</b></li>
    </ul>
  </li>
</ul>

<h3 id="프로세스-관리">프로세스 관리</h3>

<ul>
  <li>프로세스 : 실행 중인 프로그램
    <ul>
      <li>프로세스 제어 블록 (<code>PCB</code>) : 운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요 정보 저장</li>
      <li><b>프로세스 상탵 전이 : 프로세스가 다양한 상태를 거치면서 실해오디는 과정 (운영체제의 스케줄러로 관리)</b>
        <ul>
          <li>프로세스 상태 전이 절차 : 생성 → 준비 상태 → 실행 상태 (디스패치, 할당 시간 종료) → 대기 상태 (블록, 웨이크 업) → 종료</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b>스레드 : 프로세스 내 작업 단위 (시스템의 여러 자원을 할당받아 실행하는 프로그램 단위)</b></li>
  <li>병행 프로세스 : 두 개 이상의 프로세스들이 동시에 실행 상태에 있는 것 → 병행 프롯세스 오류 방지
    <ul>
      <li><b>임계 영역 : 어느 시점에서 하나의 프로세스가 자원을 사용하도록 지정된 공유 영역</b></li>
      <li><b>상호 배제 : 공유 변수에 접근하고 있는 한 프로세스 외엔 모두 공유 변수를 접근하지 못하게 함</b></li>
      <li><b>세마포어 : 프로세스 간 동기를 유지하고 상호 배제의 원리 보장</b></li>
      <li><b>모니터 : 모니터의 경계에서 상호배제 시행, 모니터 외부에선 모니터 내부에 직접 액세스 불가능</b></li>
    </ul>
  </li>
</ul>

<h3 id="교착-상태">교착 상태</h3>

<ul>
  <li><b>교착 상태 : 둘 이상의 프로세스들이 서로 다른 프로세스가 차지한 자원을 요구하며 무한정 대기</b>
    <ul>
      <li>교착 상태 발생 조건 : 상호 배제, <b>점유 및 대기</b>, 비선점, 환형 대기</li>
      <li>교착 상태 해결 방법 : 예방, 회피, 발견, 회복</li>
    </ul>
  </li>
  <li>인터럽트 : 어떤 특수 상태 발생 시 현재 실행 중인 프로그램을 일시 중단하고, 그 특수 상태를 처리하는 프로그램</li>
</ul>

<h3 id="프로세스-스케줄링">프로세스 스케줄링</h3>

<ul>
  <li>프로세스 스케줄링 : 프로세스 생성 및 실행에 필요한 시스템 자원을 해당 프로세스에 할당
    <ul>
      <li>비선점 : 한 프로세스가 <code>CPU</code>를 할당받으면 다른 프로세스가 <code>CPU</code> 사용 완료까지 대기
        <ul>
          <li><b><code>FIFO</code> : 준비 상태 큐에 도착한 순서대로 <code>CPU</code> 할당</b></li>
          <li><b><code>SJF</code> : 준비 상태 큐에 기다리는 프로세스 중 가장 짧은 프로세스에 먼저 <code>CPU</code> 할당</b></li>
          <li><b><code>HRN</code> : 서비스 시간, 서비스 대기 시간으로 결정된 우선순위에 따라 <code>CPU</code> 할당</b>
            <ul>
              <li><code>HRM</code> 우선순위 계산식 = (대기 시간 + 서비스 시간) / 서비스 시간</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>선점 : 한 프로세스가 <code>CPU</code>를 할당받아도 다른 프로세스가 우선순위가 높으면 <code>CPU</code> 점유</li>
    </ul>
  </li>
</ul>

<h3 id="기억-장치-관리">기억 장치 관리</h3>

<ul>
  <li>반입 전략 : 보조 기억 장치에 보관된 프로그램이나 데이터를 주기억 장치에 언제 가져올지 결정하는 전략
    <ul>
      <li>요구 반입 : 프로세스가 실제 필요한 때만</li>
      <li>예상 반입 : 프로세스의 실행 특성 및 예측을 기반하여 미리</li>
    </ul>
  </li>
  <li>배치 전략 : 보조 기억 장치에 보관된 프로그램이나 데이터를 주기억 장치의 어디로 가져올지 결정하는 전략
    <ul>
      <li><b>최초 적합 : 주기억 장치 내에 적재 가능한 공간에 첫번째 분할 영역에 배치</b></li>
      <li><b>최적 적합 : 주기억 장치 내에 적재 가능한 공간에 가장 작은 공백이 남는 부분에 배치</b></li>
      <li><b>최악 적합 : 주기억 장치 내에 적재 가능한 공간에 가장 큰 공백이 남는 부분에 배치</b></li>
      <li><b>단편화 : 주기억 장치 내에 빈번히 기억 장소가 할당되고 반납되면서 기억 장소들이 조각들로 나뉘는 현상</b>
        <ul>
          <li>내부 단편화 : 프로세스가 필요한 크기보다 메모리가 더 커서 메모리 공간 낭비</li>
          <li>외부 단편화 : 메모리 할당 및 해제가 반복되면서 중간에 남는 메모리를 사용하지 못해 메모리 공간 낭비</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="가상-기억-장치">가상 기억 장치</h3>

<ul>
  <li><b>가상 기억 장치 할당 방식 : 주기억 장치의 부족한 용량을 해결하기 위해 보조 기억 장치를 주 기억 장치처럼 활용</b>
    <ul>
      <li>세그멘테이션 : 가상 장치에 보관된 프로그램을 다양한 크기로 나눠 적재</li>
      <li><b>페이징 : 가상 기억 장치에 보관된 프로그램과 주기억 장치의 영역을 동일하게 나눠 적재</b></li>
    </ul>
  </li>
  <li><b>페이징 부재 : 참조할 페이지가 주기억 장치에 없는 현상</b>
    <ul>
      <li><b>페이징 부재 처리 과정 : 페이지 부재 예외 처리 → 페이지 스와핑 (디스크에서 페이지 가져옴)<br />→ 페이지 테이블 가져옴 → 프로세스 재시작&lt;/br&gt;</b></li>
    </ul>
  </li>
  <li><b>워킹 셋 : 가상 기억 장치 관리에서 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합</b></li>
  <li><b>스래싱 : 한 프로세스가 작업 과정에 수행하는 기억 장치 접근에서 지나친페이지 부재가 발생해,<br />프로세스 수행 시간보다 페이지 이동에 걸리는 시간이 더 커지는 현상&lt;/br&gt;</b></li>
  <li><b>기억 장치 교체 전략 : <code>OPT</code>, <code>FIFO</code>, <code>LRU</code>, <code>NUR</code>, <code>SCR</code></b></li>
</ul>

<h3 id="디스크-스케줄링">디스크 스케줄링</h3>

<ul>
  <li>디스크 스케줄링 : 사용 데이터가 디스크 곳곳에 저장되어 있을 때, 데이터 액세스를 위해 디스크 헤드의 이동 경로 결정
    <ul>
      <li><code>FCFS</code> : <code>FIFO</code></li>
      <li><b><code>SSFT</code> : 탐색 거리가 가까운 순서대로</b></li>
      <li><code>SCAN</code> : 진행 방향 끝까지, 그리고 반대로</li>
    </ul>
  </li>
</ul>

<h3 id="정보-관리">정보 관리</h3>

<ul>
  <li>파일 시스템 : 연관된 데이터의 집합인 파일을 관리하는 시스템
    <ul>
      <li><b>파일 디스크립터 (<code>FCB</code>) : 파일 관리에 필요한 정보를 가진 제어 블록</b></li>
    </ul>
  </li>
</ul>

<h3 id="분산-운영체제">분산 운영체제</h3>

<ul>
  <li>분산 처리 시스템 : 여러 대의 컴퓨터들에 의 해 작업한 결과를 통신망으로 상호 교환할 수 있도록 연결된 시스템</li>
  <li>투명성 : 분산 처리 운영체제에서 구제적인 시스템 환경을 사용자가 알수 없도록 하는 것
    <ul>
      <li>투명성 종류 : 위치 투명성, 이주 투명성, 복제 투명성, 병행 투명성, 접근 투명성</li>
    </ul>
  </li>
</ul>

<h3 id="unix-linux"><code class="language-plaintext highlighter-rouge">UNIX</code>, <code class="language-plaintext highlighter-rouge">Linux</code></h3>

<ul>
  <li><b><code>UNIX</code> : 시분할 시스템을 위해 설계된 대화식 운영체제</b>
    <ul>
      <li><b>쉘 : 사용자가 지정한 명령들을 해석해 커널로 전달하는 명령어 해석기 (인터페이스 담당)</b></li>
    </ul>
  </li>
  <li><code>Linux</code> : <code>UNIX</code>와 호환, 멀티태스킹 및 멀티 유저 지원
    <ul>
      <li><b><code>umask</code> : 파일, 디렉터리 생성 시 초기 접근 권한 설정</b></li>
    </ul>
  </li>
  <li><b>리눅스 로그 파일 : <code>utmp</code>, <code>wtmp</code>, <code>btmp</code></b></li>
</ul>

<h2 id="네트워크-개론">네트워크 개론</h2>

<h3 id="데이터-통신-개요">데이터 통신 개요</h3>

<ul>
  <li>네트워크 : 원하는 정보를 원하는 수신자에 정확히 전송하기 위한 기반 인프라
    <ul>
      <li>네트워크 분류 : <code>LAN</code>, <code>MAN</code>, <code>WAN</code></li>
      <li>네트워크 관련 장비 : <b>리피터</b>, 허브, 스위치 (<b><code>L1</code>, <code>L2</code>, <code>L3</code>, <code>L4</code>, <code>L5</code></b>), 브리지, <b>라우터</b>, <b>게이트웨이</b></li>
    </ul>
  </li>
  <li><code>LAN</code> : 근거리 통신 네트워크
    <ul>
      <li><code>LAN</code> 토폴로지 : 성형, 링형, 버스형, 계층형, 망형</li>
      <li><code>LAN</code> 분류 : 베이스밴드, 광대역</li>
      <li>전송 매체 접근 제어 (<code>MAC</code>) : 하나의 통신 회선에 여러 컴퓨터 연결</li>
      <li><code>LAN</code> 표준 : 이더넷</li>
    </ul>
  </li>
  <li>데이터 회선망 : 전용 회선, 교환 회선
    <ul>
      <li>회선 구성 방식 : 점 대 점 방식, 다중 점 방식, 회선 다중 방식</li>
      <li>회선 교환 방식, 축적 교환 빙식 (메시지 교환 방식, 패킷 교환 방식 (가상 회선, 데이터그램))</li>
    </ul>
  </li>
</ul>

<h3 id="osi-7계층과-오류-제어-방식"><code class="language-plaintext highlighter-rouge">OSI</code> 7계층과 오류 제어 방식</h3>

<ul>
  <li><code>OSI</code> 참조 모델 : 컴퓨터 네트워크에서 여러 시스템이 데이터를 통신하도록 표준화·계층화된 인터페이스
    <ul>
      <li><b><code>DPI</code> : 전 계층의 패킷 내부 컨텐츠를 파악해 트래픽을 조장하는 패킷 분석 기술</b></li>
    </ul>
  </li>
  <li><code>OSI</code> 7계층 구조 : <code>OSI</code> 참조 모델을 구체화한 것
    <ol>
      <li><b>물리 계층 : 물리적, 기계적 통신 (<code>RS-232C</code>)</b></li>
      <li><b>데이터 링크 계층 : 두 통신 시스템 간의 링크로 전송 (<code>HDLC</code>, <code>LLC</code>)</b></li>
      <li><b>네트워크 계층 : 통신망을 통해 패킷을 목적지까지 전달 (<code>IP</code>)</b></li>
      <li><b>전송 계층 : 통신 종단 간 데이터 전송 (<code>TCP</code>, <code>UDP</code>)</b></li>
      <li><b>세션 계층 : 프로세스 간 연결 관리</b></li>
      <li><b>표현 계층 : 응용 및 세션 사이의 대화 제어 및 데이터 변환</b></li>
      <li><b>응용 계층 : 응용 서비스 제공 (<code>HTTP</code>, <code>FTP</code>, <code>DNS</code>, <code></code>SMTP)</b></li>
    </ol>
  </li>
  <li><b>자동 반복 요청 (<code>ARQ</code>) : 통신 경로에 오류가 발생하면 수신자가 오류 발생을 송신자에 통보하고, 송신자는 오류가 발생한 프레임을 재전송하는 오류 제어 방식</b>
    <ul>
      <li><code>ARQ</code> 종류 : 정지-대기 <code>ARQ</code>, 연속 <code>ARQ</code>, 선택적 재전송 <code>ARQ</code>, 적응적 <code>ARQ</code></li>
    </ul>
  </li>
  <li>패리티 검사 : 데이터 블록에 1비트의 패리티 비트를 추가해 오류 검출 (홀수 패리티, 짝수 패리티)</li>
  <li>순환 중복 검사 : 다항식 코드를 통한 에러 검사 (해밍 코드 방식)</li>
</ul>

<h3 id="tcpip-프로토콜-패킷-교환"><code class="language-plaintext highlighter-rouge">TCP/IP</code> 프로토콜, 패킷 교환</h3>

<ul>
  <li><b><code>TCP/IP</code> : 인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송수신을 돕는 표준 프로토콜</b>
    <ul>
      <li><b><code>TCP</code> : 전송 계층 (<code>L4</code>) 역할 수행 (순서·에러·흐름 제어, 전이중·스트림 데이터 서비스, 메시지 캡슐화·역캡슐화, 다중화·역다중화)</b></li>
      <li><b><code>UDP</code> : 전송 계층 (<code>L4</code>) 역할 수행 (비연결성·비신뢰성, 복구 <code>X</code>)</b></li>
      <li><b><code>IP</code> : 네트워크 계층 (<code>L3</code>) 역할 수행 (라우팅·데이터그램)</b>
        <ul>
          <li><b><code>ICMP</code> : <code>IP</code> 오류 보고 및 수정 메커니즘</b></li>
          <li><b><code>IGMP</code> : 시작지에서 여러 목적지로 전송될 때 사용</b></li>
          <li><b><code>ARP</code> : 논리 주소를 물리 주소로 변환</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><b><code>IP</code> 프로토콜 필드 : 헤더 길이 (<code>4bit</code>), 토탈 패킷 길이 (<code>16bit</code>), <code>Time-To-Live</code> (<code>8bit</code>)</b></li>
</ul>

<h3 id="ip-주소와-경로-제어"><code class="language-plaintext highlighter-rouge">IP</code> 주소와 경로 제어</h3>

<ul>
  <li><b><code>IPv4</code> : 32비트 <code>IP</code> 주소 (네트워크 주소 + 호스트 주소)</b>
    <ul>
      <li><b><code>IPV4</code> 특징 : 주소 고갈, 서브넷팅·<code>CIDR</code></b></li>
      <li><b><code>IPv4</code> 주소 체계 : 클래스 <code>A ~ E</code></b></li>
      <li><b>서브넷 마스크 : 네트워크를 작은 내부 네트워크로 분리해 이진 형태로 관리</b></li>
    </ul>
  </li>
  <li><b><code>IPv6</code> : 128비트 <code>IP</code> 주소 (16비트씩 8개 필드로 분리 표기)</b>
    <ul>
      <li><b><code>IPV6</code> 장점 : 보안성 강화, 확장 용이, 패킷 크기 제한 없음, 실시간 처리·자동 네트워크 구성 가능</b></li>
      <li><b><code>IPV6</code> 통신 방식 : 유니캐스트, 애니캐스트, 멀티캐스트</b></li>
    </ul>
  </li>
  <li>경로 제어 : 각 메시지에서 목적지까지 갈 수 있는 여러 경로 중에 한 경로를 설정
    <ul>
      <li><b>경로 제어 프로토콜 : <code>IGP</code>, <code>EGP</code>, <code>BGP</code></b></li>
    </ul>
  </li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Engineer Information Processing" /><summary type="html"><![CDATA[C]]></summary></entry><entry><title type="html">[React] 2. 클래스 컴포넌트 (Class Component)</title><link href="http://localhost:4000/react2/" rel="alternate" type="text/html" title="[React] 2. 클래스 컴포넌트 (Class Component)" /><published>2024-02-16T00:00:00+09:00</published><updated>2024-02-16T00:00:00+09:00</updated><id>http://localhost:4000/react2</id><content type="html" xml:base="http://localhost:4000/react2/"><![CDATA[<h2 id="클래스-컴포넌트-class-component--생성자와-생명주기-메소드를-통한-상태와-생명주기-관리">클래스 컴포넌트 (<code class="language-plaintext highlighter-rouge">Class Component</code>) : 생성자와 생명주기 메소드를 통한 상태와 생명주기 관리</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { Component } from 'react';

class MyClassComponent extends Component {
  constructor(props) {
    super(props);
    // 초기 상태 설정
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    // 컴포넌트가 마운트된 후 실행되는 코드
    console.log('Component mounted');
  }

  componentDidUpdate(prevProps, prevState) {
    // 상태 또는 속성이 업데이트된 후 실행되는 코드
    console.log('Component updated', prevState.count, '-&gt;', this.state.count);
  }

  componentWillUnmount() {
    // 컴포넌트가 언마운트되기 전 실행되는 코드
    console.log('Component will unmount');
  }

  handleIncrement = () =&gt; {
    // 상태 업데이트 예시
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={this.handleIncrement}&gt;Increment&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default MyClassComponent;
</code></pre></div></div>

<h3 id="생성자-constructor--메소드-내에서-컴포넌트-자체를-참조--this">생성자 (<code class="language-plaintext highlighter-rouge">Constructor</code>) : 메소드 내에서 컴포넌트 자체를 참조 → <code class="language-plaintext highlighter-rouge">this</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constructor(props) {
  super(props);
  console.log("constructor");
}
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this.state</code> : 컴포넌트의 상태를 저장 (<code class="language-plaintext highlighter-rouge">setState</code> 메소드를 사용하여 업데이트)</li>
  <li><code class="language-plaintext highlighter-rouge">this.props</code> : 컴포넌트에서 사용되는 속성에 접근</li>
</ul>

<h3 id="생명주기-메소드-lifecycle-methods--클래스-컴포넌트의-생명주기에-따라-메소드를-실행">생명주기 메소드 (<code class="language-plaintext highlighter-rouge">Lifecycle Methods</code>) : 클래스 컴포넌트의 생명주기에 따라 메소드를 실행</h3>

<blockquote>
  <p>클래스 컴포넌트의 생명주기 메소드가 실행되는 시점?</p>

  <ul>
    <li>마운트 (<code class="language-plaintext highlighter-rouge">Mount</code>) : 컴포넌트가 생성되는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Constructor</code>, <code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code>, <code class="language-plaintext highlighter-rouge">render</code>, <code class="language-plaintext highlighter-rouge">componentDidMount</code></li>
      </ul>
    </li>
    <li>업데이트 (<code class="language-plaintext highlighter-rouge">Update</code>) : 이미 생성된 컴포넌트의 내용이 변경되는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code>, <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code>, <code class="language-plaintext highlighter-rouge">render</code>, <code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code>, <code class="language-plaintext highlighter-rouge">componentDidUpdate</code></li>
      </ul>
    </li>
    <li>언마운트 (<code class="language-plaintext highlighter-rouge">Unmount</code>) : 컴포넌트가 더 이상 존재하지 않는 시점
      <ul>
        <li><code class="language-plaintext highlighter-rouge">componentWillUnmount</code></li>
      </ul>
    </li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/aec795ea-ff51-4f9d-ada3-ebca3616178f" width="80%" /></p>
</blockquote>

<h4 id="render--컴포넌트가-ui를-렌더링하기-위해-사용-마운트-업데이트-과정에서-실행"><code class="language-plaintext highlighter-rouge">render</code> : 컴포넌트가 <code class="language-plaintext highlighter-rouge">UI</code>를 렌더링하기 위해 사용 (마운트, 업데이트 과정에서 실행)</h4>

<ul>
  <li>리액트 클래스 컴포넌트의 유일한 필수 값으로 사용</li>
  <li>항상 순수해야 하며 부수 효과가 없어야 함 → <code class="language-plaintext highlighter-rouge">render</code> 내에서 <code class="language-plaintext highlighter-rouge">this.setState</code>를 호출하면 안됨</li>
</ul>

<h4 id="getderivedstatefromprops--props에-가져온-값을-상태에-넣을-때-상태나-props이-변화했을-때-실행"><code class="language-plaintext highlighter-rouge">getDerivedStateFromProps</code> : <code class="language-plaintext highlighter-rouge">props</code>에 가져온 값을 상태에 넣을 때, 상태나 <code class="language-plaintext highlighter-rouge">props</code>이 변화했을 때 실행</h4>

<h4 id="componentdidmount--클래스-컴포넌트가-마운트된-이후에-실행"><code class="language-plaintext highlighter-rouge">componentDidMount</code> : 클래스 컴포넌트가 마운트된 이후에 실행</h4>

<h4 id="shouldcomponentupdate--클래스-컴포넌트가-리렌더링을-할지-안할지-결정"><code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> : 클래스 컴포넌트가 리렌더링을 할지 안할지 결정</h4>

<h4 id="getsnapshotbeforeupdate--클래스-컴포넌트가-엄데이트되기-직전의-dom-내의-특정-값을-반환하면-그-다음의-componentdidupdate-반환"><code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code> : 클래스 컴포넌트가 엄데이트되기 직전의 <code class="language-plaintext highlighter-rouge">DOM</code> 내의 특정 값을 반환하면, 그 다음의 <code class="language-plaintext highlighter-rouge">componentDidUpdate</code> 반환</h4>

<h4 id="componentdidupdate--컴포넌트-업데이트가-일어난-이후에-실행"><code class="language-plaintext highlighter-rouge">componentDidUpdate</code> : 컴포넌트 업데이트가 일어난 이후에 실행</h4>

<h4 id="componentwillunmount--컴포넌트가-언마운트되거나-더-이상-사용되지-않기-직전에-실행"><code class="language-plaintext highlighter-rouge">componentWillUnmount</code> : 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 실행</h4>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[클래스 컴포넌트 (Class Component) : 생성자와 생명주기 메소드를 통한 상태와 생명주기 관리]]></summary></entry><entry><title type="html">[React] 1. 리액트 (React)</title><link href="http://localhost:4000/react1/" rel="alternate" type="text/html" title="[React] 1. 리액트 (React)" /><published>2024-02-16T00:00:00+09:00</published><updated>2024-02-16T00:00:00+09:00</updated><id>http://localhost:4000/react1</id><content type="html" xml:base="http://localhost:4000/react1/"><![CDATA[<h2 id="리액트-react--사용자-인터페이스를-만들기-위한-javascript-라이브러리">리액트 (<code class="language-plaintext highlighter-rouge">React</code>) : 사용자 인터페이스를 만들기 위한 <code class="language-plaintext highlighter-rouge">JavaScript</code> 라이브러리</h2>

<ul>
  <li>가상 <code class="language-plaintext highlighter-rouge">DOM</code> : 실제 <code class="language-plaintext highlighter-rouge">DOM</code>가 상호 작용하면서 웹 어플리케이션의 빠른 렌더링이 가능</li>
  <li>선언형 뷰 (<code class="language-plaintext highlighter-rouge">Declarative View</code>) : 사용자 인터페이스를 어떻게 보일지 명시적으로 선언하고, 개발자가 그 명세를 작성</li>
  <li>컴포넌트 기반 구조 : 부모-자식 관계 및 상태 (<code class="language-plaintext highlighter-rouge">State</code>)를 갖는 재사용 가능한 모듈들로 어플리케이션 구성</li>
  <li>단방향 데이터 바인딩 : 데이터의 흐름이 단일 방향으로 진행하여 디버깅 용이 → 명시적인 상태 변경이 가능</li>
  <li><code class="language-plaintext highlighter-rouge">JSX</code> : 자바스크립트 코드 내에 마크업을 작성해 가독성 향상 및 명확한 표현 가능</li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ca8780dc-5a83-45cb-972d-e66b4fea19e4" width="90%" /></p>

<blockquote>
  <p>리액트에서 자주 쓰이는 <code class="language-plaintext highlighter-rouge">JS</code> 문법?</p>

  <ul>
    <li>구조 분해 할당 (<code class="language-plaintext highlighter-rouge">Destructuring Assignment</code>) : 배열 또는 객체의 값을 분해해서 할당하는 것</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 객체 구조 분해 할당
const person = { name: 'John', age: 30 };
const { name, age } = person;

console.log(name); // 'John'
console.log(age);  // 30
</code></pre></div>  </div>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 배열 구조 분해 할당
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
</code></pre></div>  </div>

  <ul>
    <li>전개 구문 (<code class="language-plaintext highlighter-rouge">Spread Syntax</code>) : 배열이나 객체를 확장하여 개별 요소로 분리하거나 복사</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 배열의 전개 구문을 사용하여 두 배열을 병합
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const mergedArray = [...arr1, ...arr2];
console.log(mergedArray); // [1, 2, 3, 4, 5, 6]
</code></pre></div>  </div>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 객체의 전개 구문을 사용하여 두 객체를 병합
const obj1 = { x: 1, y: 2 };
const obj2 = { z: 3, w: 4 };

const mergedObject = { ...obj1, ...obj2 };
console.log(mergedObject); // { x: 1, y: 2, z: 3, w: 4 }
</code></pre></div>  </div>

  <ul>
    <li>객체 초기자 (<code class="language-plaintext highlighter-rouge">Object Shorthand Assignment</code>) : 객체를 간결히 생성하고 초기값을 설정</li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 일반적인 객체 생성 방법
const person1 = new Object();
person1.name = 'Alice';
person1.age = 25;

// 객체 초기자를 사용한 방법
const person2 = {
  name: 'Alice',
  age: 25
};

console.log(person1); // { name: 'Alice', age: 25 }
console.log(person2); // { name: 'Alice', age: 25 }

</code></pre></div>  </div>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">Array</code> 프로토타입 메소드 : <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">reduce</code>, <code class="language-plaintext highlighter-rouge">forEach</code></li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const numbers = [1, 2, 3, 4];

// map 메소드: 각 숫자를 두 배로 만듭니다.
const doubledNumbers = numbers.map((num) =&gt; num * 2);

// filter 메소드: 짝수만을 걸러냅니다.
const evenNumbers = numbers.filter((num) =&gt; num % 2 === 0);

// reduce 메소드: 모든 숫자의 합을 계산합니다.
const sum = numbers.reduce((acc, num) =&gt; acc + num, 0);

// forEach 메소드: 각 숫자를 콘솔에 출력합니다.
numbers.forEach((num) =&gt; console.log(num));

console.log('Doubled Numbers:', doubledNumbers);
console.log('Even Numbers:', evenNumbers);
console.log('Sum:', sum);
</code></pre></div>  </div>
</blockquote>

<h3 id="싱글-페이지-어플리케이션-spa--렌더링-및-라우팅에-필요한-기능들을-브라우저의-js에-의존">싱글 페이지 어플리케이션 (<code class="language-plaintext highlighter-rouge">SPA</code>) : 렌더링 및 라우팅에 필요한 기능들을 브라우저의 <code class="language-plaintext highlighter-rouge">JS</code>에 의존</h3>

<ul>
  <li>첫 페이지에서 데이터를 모두 불러온 이후, 페이지 전환을 위한 모든 작업이 <code class="language-plaintext highlighter-rouge">JS</code> 및 브라우저로 이루어짐
    <ul>
      <li>사이트 렌더링에 필요한 <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 내부 내용을 모두 <code class="language-plaintext highlighter-rouge">JS</code> 코드로 삽입한 이후에 렌더링</li>
      <li>페이지 전환 시에도 새로운 <code class="language-plaintext highlighter-rouge">HTML</code> 페이지 요청 대신, <code class="language-plaintext highlighter-rouge">JS</code>에서 다음 렌더링에 필요한 정보만 가져와 반영</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">JAM</code> 스택 : <code class="language-plaintext highlighter-rouge">JS</code>, <code class="language-plaintext highlighter-rouge">API</code>, <code class="language-plaintext highlighter-rouge">Markup</code> : <code class="language-plaintext highlighter-rouge">F/E</code>에서 <code class="language-plaintext highlighter-rouge">JS</code>와 마크업 (<code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>)을 미리 빌드해 정적으로 제공</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">JS</code> 리소스 크기가 커지면서, 웹 페이지가 로딩되어 사용자 인터렉션까지 걸리는 시간이 길어지는 문제 발생!</p>
</blockquote>

<h3 id="서버-사이드-렌더링-ssr--최초에-사용자에-보여줄-페이지를-서버에서-렌더링해-사용자에게-제공">서버 사이드 렌더링 (<code class="language-plaintext highlighter-rouge">SSR</code>) : 최초에 사용자에 보여줄 페이지를 서버에서 렌더링해 사용자에게 제공</h3>

<ul>
  <li>최초 페이지 진입이 비교적 빠름 : <code class="language-plaintext highlighter-rouge">First Contentful Paint</code>이 빠름</li>
  <li>검색 엔진, <code class="language-plaintext highlighter-rouge">SNS</code> 공유와 같은 메타데이터 제공이 쉬움</li>
  <li>누적 레이아웃 이동 (<code class="language-plaintext highlighter-rouge">Cumulative Layout Shift</code>)이 적음</li>
  <li>사용자의 디바이스 성능에 비교적 자유로움</li>
  <li>민감한 작업을 서버 내에서 진행하여 보안 위험에 더 안전함</li>
  <li>소스 코드 전반에 걸쳐 서버 환경에 대한 고려 필요</li>
  <li>사용자의 요청을 받아 렌더링을 수행할 수 있는 적절한 서버가 구축되어 있어야 함</li>
  <li>병목 현상과 같은 서비스 지연이 발생하면, 사용자에게 어떠한 정보도 제공할 수 없음</li>
</ul>

<blockquote>
  <p>리액트는 기본적으로 <code class="language-plaintext highlighter-rouge">SPA</code>이지만, <code class="language-plaintext highlighter-rouge">SSR</code>을 위한 <code class="language-plaintext highlighter-rouge">API</code> 또한 제공한다!</p>
</blockquote>

<h3 id="jsx-javascript-xml--기존-js에-html-css를-더해-리액트-컴포넌트-작성"><code class="language-plaintext highlighter-rouge">JSX</code> (<code class="language-plaintext highlighter-rouge">JavaScript XML</code>) : 기존 <code class="language-plaintext highlighter-rouge">JS</code>에 <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>를 더해 리액트 컴포넌트 작성</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JSXElement</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 엘리먼트<br />(<code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello, World!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">JSXAttribute</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 엘리먼트의 속성<br />(<code class="language-plaintext highlighter-rouge">&lt;div className="container"&gt;Hello, World!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">className="container"</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">JSXChildren</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 엘리먼트의 자식 요소<br />(<code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello, &lt;span&gt;React&lt;/span&gt;!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">Hello, &lt;span&gt;React&lt;/span&gt;!</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">JSXString</code> : <code class="language-plaintext highlighter-rouge">JSX</code> 문자열<br />(<code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello, World!&lt;/div&gt;</code>에서 <code class="language-plaintext highlighter-rouge">"Hello, World!"</code>)</li>
</ul>

<h3 id="가상-dom-virtual-dom--실제-dom-document-object-model-에-대한-가벼운-복사본">가상 <code class="language-plaintext highlighter-rouge">DOM</code> (<code class="language-plaintext highlighter-rouge">Virtual DOM</code>) : 실제 <code class="language-plaintext highlighter-rouge">DOM</code> (<code class="language-plaintext highlighter-rouge">Document Object Model</code>) 에 대한 가벼운 복사본</h3>

<ul>
  <li>리액트 파이버 (<code class="language-plaintext highlighter-rouge">React Fiber</code>) : 가상 <code class="language-plaintext highlighter-rouge">DOM</code>과 실제 <code class="language-plaintext highlighter-rouge">DOM</code>을 비교해 변경 사항을 수집
    <ul>
      <li>동기성 : 렌더링 작업을 여러 프레임에 나눠 렌더링 작업이 한 번에 실행되지 않더라도 앱이 반응적으로 유지 가능</li>
      <li>우선순위 관리 : 각 작업에 우선순위를 할당하고, 중요한 작업을 먼저 처리하여 사용자 인터랙션에 빠르게 응답 가능</li>
      <li>종료 및 재시작 가능 : 사용자 인터랙션에 우선순위를 두면서도 작업을 중단하고 다시 시작 가능</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">DOM</code>과 <code class="language-plaintext highlighter-rouge">CSSOM</code>으로 렌더링 트리가 만들어지는 과정?</p>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/95ef558e-965b-4525-873f-140e4292b29e" width="90%" /></p>

  <ol>
    <li>브라우저가 사용자가 요청한 주소를 방문해 <code class="language-plaintext highlighter-rouge">HTML</code> 파일을 다운로드</li>
    <li>브라우저의 렌더링 엔진은 <code class="language-plaintext highlighter-rouge">HTML</code>을 파싱해 <code class="language-plaintext highlighter-rouge">DOM</code> 노드로 구성된 트리를 생성</li>
    <li><code class="language-plaintext highlighter-rouge">CSS</code> 파일을 만나면, 해당 <code class="language-plaintext highlighter-rouge">CSS</code> 파일도 다운로드</li>
    <li><code class="language-plaintext highlighter-rouge">CSS</code> 파일을 파싱하여 <code class="language-plaintext highlighter-rouge">CSS</code> 노드로 구성된 트리 (<code class="language-plaintext highlighter-rouge">CSSOM</code>)를 생성</li>
    <li>사용자의 눈에 보일 <code class="language-plaintext highlighter-rouge">DOM</code> 노드만을 순회</li>
    <li>눈에 보이는 노드를 대상으로 해당 노드에 대한 <code class="language-plaintext highlighter-rouge">CSSOM</code> 정보를 찾고 <code class="language-plaintext highlighter-rouge">CSS</code> 스타일 정보를 적용
      <ul>
        <li>레이아웃 (<code class="language-plaintext highlighter-rouge">Layout</code>) : 각 노드가 브라우저 화면에 어느 좌표에 나타날지 계산하는 과정</li>
        <li>페인팅 (<code class="language-plaintext highlighter-rouge">Painting</code>) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정</li>
      </ul>
    </li>
  </ol>

  <p>… 모든 <code class="language-plaintext highlighter-rouge">DOM</code>의 변경보다 결과적으로 만들어질 <code class="language-plaintext highlighter-rouge">DOM</code>의 최종 결과물만을 제공하자!</p>
</blockquote>

<ol>
  <li>초기 렌더링 : 초기 상태에서 가상 <code class="language-plaintext highlighter-rouge">DOM</code>은 실제 <code class="language-plaintext highlighter-rouge">DOM</code>과 동일한 구조를 가짐</li>
  <li>상태 변화 감지 : 사용자 상호 작용이나 데이터 변경 등의 이벤트가 발생하면, 렌더링 엔진은 새로운 가상 <code class="language-plaintext highlighter-rouge">DOM</code> 생성</li>
  <li>가상 <code class="language-plaintext highlighter-rouge">DOM</code> 비교 : 새로운 가상 <code class="language-plaintext highlighter-rouge">DOM</code>과 이전의 가상 <code class="language-plaintext highlighter-rouge">DOM</code>을 비교하여 변경된 부분 탐색</li>
  <li>실제 <code class="language-plaintext highlighter-rouge">DOM</code> 업데이트 : 변경된 부분만을 실제 <code class="language-plaintext highlighter-rouge">DOM</code>에 적용</li>
</ol>

<h2 id="컴포넌트-component--리액트-애플리케이션에서-ui를-구성하고-재사용-가능한-모듈을-표현">컴포넌트 (<code class="language-plaintext highlighter-rouge">Component</code>) : 리액트 애플리케이션에서 <code class="language-plaintext highlighter-rouge">UI</code>를 구성하고 재사용 가능한 모듈을 표현</h2>

<ul>
  <li>속성 (<code class="language-plaintext highlighter-rouge">Props</code>) 을 받고, 상태 (<code class="language-plaintext highlighter-rouge">state</code>)와 메소드 (<code class="language-plaintext highlighter-rouge">Method</code>)를 가짐</li>
  <li>반복되는 <code class="language-plaintext highlighter-rouge">UI</code> 단위 (<code class="language-plaintext highlighter-rouge">JS Code</code> 또는 <code class="language-plaintext highlighter-rouge">HTML-JSX</code>) → 재사용성과 가독성을 위한 도구</li>
  <li>가능한 독립적으로 실행되도록 작성하고, 데이터 영역과 <code class="language-plaintext highlighter-rouge">UI</code>를 분리</li>
</ul>

<h3 id="상태-state---사용자-상호작용에-응답하거나-컴포넌트의-생명주기에-변경되는-정보를-저장하는-데에-사용">상태 (<code class="language-plaintext highlighter-rouge">State</code>) :  사용자 상호작용에 응답하거나 컴포넌트의 생명주기에 변경되는 정보를 저장하는 데에 사용</h3>

<ul>
  <li>부모의 상태가 변경되면, 그 상태를 참조하는 모든 자식 컴포넌트가 <code class="language-plaintext highlighter-rouge">Re-Rendering</code>
    <ul>
      <li>상태를 통합하면 <code class="language-plaintext highlighter-rouge">Re-Rendering</code>이 많이 일어나므로, 상태를 연관성에 맞게 분리해 좁게 사용해야 함</li>
      <li><code class="language-plaintext highlighter-rouge">Setter</code>로 값을 수신하면 <code class="language-plaintext highlighter-rouge">Dispatcher</code> 값이 세팅 → <code class="language-plaintext highlighter-rouge">re-rendering</code>을 <code class="language-plaintext highlighter-rouge">trigger</code> (<code class="language-plaintext highlighter-rouge">DOM</code> 갱신)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState('안녕하세요!');

  return (
    &lt;div&gt;
      &lt;p&gt;{message}&lt;/p&gt;
      &lt;p&gt;카운트: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre></div></div>

<blockquote>
  <p>초기화는 동기 방식이면 오래 걸리더라도 가능, <code class="language-plaintext highlighter-rouge">Promise</code>는 <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>로 처리해도 <code class="language-plaintext highlighter-rouge">Promise</code>가 세팅</p>
</blockquote>

<h3 id="속성-prop--부모-컴포넌트로부터-자식-컴포넌트로-데이터를-전달하는-데에-사용">속성 (<code class="language-plaintext highlighter-rouge">Prop</code>) : 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달하는 데에 사용</h3>

<ul>
  <li>변수나 함수와 같은 속성들을 부모에서 자식으로 전달 (<code class="language-plaintext highlighter-rouge">MyComponent.defaultProps = { ... }</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Read-Only</code> : 속성이 변경되도 <code class="language-plaintext highlighter-rouge">Re-Rendering</code>하지 않음! (값은 바꿔도 화면엔 아무런 영향 없음!)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 부모 컴포넌트
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const dataToPass = "안녕하세요!";
  
  return (
    &lt;ChildComponent message={dataToPass} /&gt;
  );
}

// 자식 컴포넌트
function ChildComponent(props) {
  return (
    &lt;div&gt;
      &lt;p&gt;{props.message}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre></div></div>

<h3 id="컴포넌트-개발-원칙--코드의-가독성-유지보수성-재사용성을-향상하여-구성-요소를-생성">컴포넌트 개발 원칙 : 코드의 가독성, 유지보수성, 재사용성을 향상하여 구성 요소를 생성</h3>

<ul>
  <li><b>가급적 순수 함수 컴포넌트 (<code>Pure Functional Component</code>)를 활용할 것!</b>
    <ul>
      <li>상태나 생명주기 메서드 없이 단순히 <code class="language-plaintext highlighter-rouge">props</code>를 받아 렌더링하는 컴포넌트 → 간결하고 재사용성이 높힐 수 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Container Component</code>와 <code class="language-plaintext highlighter-rouge">Presentational Component</code>를 분리할 것
    <ul>
      <li>데이터를 가져오는 로직과 <code class="language-plaintext highlighter-rouge">UI</code>를 그리는 로직을 분리하여 관리</li>
    </ul>
  </li>
  <li>상태를 공유하는 단위로 분리할 것
    <ul>
      <li>관련된 상태를 함께 관리하고, 필요한 경우 <code class="language-plaintext highlighter-rouge">useContext</code>를 사용하여 상태 공유를 구현</li>
    </ul>
  </li>
  <li>아주 깊은 구조로 중첩되는 <code class="language-plaintext highlighter-rouge">Container</code> 컴포넌트는 피할 것
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Context</code>를 남발하는 대신, 상태 관리 등의 용도로 필요한 경우에만 적절히 사용할 것</li>
    </ul>
  </li>
  <li>각 컴포넌트는 독립적으로 작성할 것
    <ul>
      <li>컴포넌트 간의 결합도를 최소화해 재사용성을 높이고 유지보수를 용이하게 만들어야 함</li>
    </ul>
  </li>
</ul>

<h2 id="렌더링-rendering--html-css-리소스로-웹-페이지의-ui를-그리는-과정">렌더링 (<code class="language-plaintext highlighter-rouge">Rendering</code>) : <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code> 리소스로 웹 페이지의 <code class="language-plaintext highlighter-rouge">UI</code>를 그리는 과정</h2>

<ul>
  <li>리액트의 렌더링 : 리액트 어플리케이션 트리 내의 모든 컴포넌트들이 갖고 있는 현재 상태와 속성의 값을 기반하여 어떻게<code class="language-plaintext highlighter-rouge">UI</code>를 구성하고 어떤 <code class="language-plaintext highlighter-rouge">DOM</code> 결과를 브라우저에 제공할지 계산하는 일련의 과정
    <ul>
      <li>초기 렌더링 : 사용자가 처음 어플리케이션이 진입할 때 최초로 수행</li>
      <li>리렌더링 (<code class="language-plaintext highlighter-rouge">Re-rendering</code>) : 처음 어플리케이션 이후에 발생하는 모든 렌더링들을 총칭
        <ul>
          <li>클래스 컴포넌트의 <code class="language-plaintext highlighter-rouge">setState()</code>나 <code class="language-plaintext highlighter-rouge">forceUpdate()</code>가 실행되는 경우</li>
          <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useState()</code>의 두번째 배열 요소인 <code class="language-plaintext highlighter-rouge">setter</code>가 실행되는 경우</li>
          <li>함수 컴포넌트의 <code class="language-plaintext highlighter-rouge">useReducer()</code>의 두번째 배열 요소인 <code class="language-plaintext highlighter-rouge">dispatch</code>가 실행되는 경우</li>
          <li>컴포넌트의 <code class="language-plaintext highlighter-rouge">key props</code>가 변경되는 경우</li>
          <li>부모 컴포넌트로부터 전달받는 값인 <code class="language-plaintext highlighter-rouge">props</code>가 변경되거나 부모 컴포넌트가 리렌더링될 경우</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="렌더링-프로세스-rendering-process--리액트의-재조정을-위해-변경-사항을-탐색-비교-수집하는-과정">렌더링 프로세스 (<code class="language-plaintext highlighter-rouge">Rendering Process</code>) : 리액트의 재조정을 위해 변경 사항을 탐색, 비교, 수집하는 과정</h3>

<ol>
  <li>리액트가 컴포넌트의 루트에서부터 업데이트가 필요한 모든 컴포넌트를 탐색</li>
  <li>클래스 컴포넌트는 클래스 내 <code class="language-plaintext highlighter-rouge">render()</code> 함수를, 함수 컴포넌트는 <code class="language-plaintext highlighter-rouge">FunctionComponent()</code> 자체를 호출</li>
  <li><code class="language-plaintext highlighter-rouge">JSX</code>로 구성된 렌더링 결과물을 자바스크립트로 컴파일하면 <code class="language-plaintext highlighter-rouge">React.createElement()</code>를 반환</li>
  <li><code class="language-plaintext highlighter-rouge">React.createElement()</code>가 브라우저 <code class="language-plaintext highlighter-rouge">UI</code> 구조를 설명하는 자바스크립트 객체를 반환</li>
</ol>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9ce93fdd-ed10-4a4a-84c4-58234265ffb2" width="80%" /></p>

<h4 id="1-렌더-단계-render-phase--컴포넌트를-렌더링하고-변경-사항을-계산하는-모든-작업"><code class="language-plaintext highlighter-rouge">(1)</code> 렌더 단계 (<code class="language-plaintext highlighter-rouge">Render Phase</code>) : 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업</h4>

<ol>
  <li>렌더링 프로세스에서 컴포넌트를 실행 (<code class="language-plaintext highlighter-rouge">render()</code> 또는 <code class="language-plaintext highlighter-rouge">return</code>)</li>
  <li>이전 가상 <code class="language-plaintext highlighter-rouge">DOM</code>과 결과 가상 <code class="language-plaintext highlighter-rouge">DOM</code>를 비교</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>, <code class="language-plaintext highlighter-rouge">props</code>, <code class="language-plaintext highlighter-rouge">key</code>를 비교하여, 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크</li>
</ol>

<h4 id="2-커밋-단계-commit-phase--렌더-단계의-변경-사항을-실제-dom에-적용해-사용자에게-표현"><code class="language-plaintext highlighter-rouge">(2)</code> 커밋 단계 (<code class="language-plaintext highlighter-rouge">Commit Phase</code>) : 렌더 단계의 변경 사항을 실제 <code class="language-plaintext highlighter-rouge">DOM</code>에 적용해 사용자에게 표현</h4>

<ol>
  <li>리액트가 먼저 <code class="language-plaintext highlighter-rouge">DOM</code>을 커밋 단계에서 업데이트</li>
  <li>생성된 모든 <code class="language-plaintext highlighter-rouge">DOM</code> 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트</li>
  <li>클래스 컴포넌트는 <code class="language-plaintext highlighter-rouge">componentDidMount</code>, <code class="language-plaintext highlighter-rouge">componentDidUpdate</code> 메소드를,<br />함수 컴포넌트는 <code class="language-plaintext highlighter-rouge">useLayoutEffect</code> 훅을 호출</li>
</ol>

<ul>
  <li>리액트의 렌더링이 일어난다고 무조건 <code class="language-plaintext highlighter-rouge">DOM</code> 업데이트가 일어나지 않음! (커밋 단계 생략 가능)
    <ul>
      <li>리액트의 렌더링은 가시적 변경 없이 발생 가능!! (커밋 단계가 생략되어 <code class="language-plaintext highlighter-rouge">DOM</code> 업데이트가 발생하지 않음)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>렌더링 시나리오 - 어플리케이션의 숫자 증가 버튼</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { useState } from 'react'

export default function A() {
  return (
  &lt;div className="App"&gt;
    &lt;h1&gt;Hello React!&lt;/h1&gt;
    &lt;B /&gt;
  &lt;/div&gt;
  )
}

function B() {
  const [counter, setCounter] = useState(0)

  function handleButtonClick() {
    setCounter((previous) =&gt; previous + 1)
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        &lt;C number={counter}/&gt;
      &lt;/label&gt;
      &lt;button onClick={handleButtonClick}&gt;&lt;/button&gt;
    &lt;/&gt;
  )
}

function C({number}: {number: number}) {
  return (
    &lt;div&gt;
      {number} &lt;D/&gt;
    &lt;/div&gt;
  )
}

function D() {
  return (
    &lt;&gt;
      안녕 리액트!
    &lt;/&gt;
    );
}
</code></pre></div>  </div>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트의 <code class="language-plaintext highlighter-rouge">setState</code> 호출</li>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트의 리렌더링 작업이 큐에 들어감</li>
    <li>리액트는 트리 최상단에서부터 렌더링 경로를 갱신</li>
    <li><code class="language-plaintext highlighter-rouge">A</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있지 않으므로, 커밋 단계를 생략</li>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있으므로, <code class="language-plaintext highlighter-rouge">B</code>를 리렌더링</li>
    <li><code class="language-plaintext highlighter-rouge">B</code> 컴포넌트가 <code class="language-plaintext highlighter-rouge">C</code> 컴포넌트를 반환</li>
    <li><code class="language-plaintext highlighter-rouge">C</code> 컴포넌트의 <code class="language-plaintext highlighter-rouge">props</code>인 <code class="language-plaintext highlighter-rouge">number</code>가 업데이트</li>
    <li><code class="language-plaintext highlighter-rouge">C</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있으므로, <code class="language-plaintext highlighter-rouge">C</code>를 리렌더링</li>
    <li><code class="language-plaintext highlighter-rouge">C</code> 컴포넌트가 <code class="language-plaintext highlighter-rouge">D</code> 컴포넌트를 반환</li>
    <li><code class="language-plaintext highlighter-rouge">D</code> 컴포넌트의 부모인 <code class="language-plaintext highlighter-rouge">C</code> 컴포넌트가 리렌더링이 필요한 컴포넌트로 표시되어 있으므로, <code class="language-plaintext highlighter-rouge">D</code>를 리렌더링</li>
  </ol>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="React" /><summary type="html"><![CDATA[리액트 (React) : 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리]]></summary></entry><entry><title type="html">[TS] 1. 타입스크립트 (TypeScript)</title><link href="http://localhost:4000/ts1/" rel="alternate" type="text/html" title="[TS] 1. 타입스크립트 (TypeScript)" /><published>2024-02-07T00:00:00+09:00</published><updated>2024-02-07T00:00:00+09:00</updated><id>http://localhost:4000/ts1</id><content type="html" xml:base="http://localhost:4000/ts1/"><![CDATA[<h2 id="타입스크립트-typescript--javascript을-확장하여-정적-타입을-지원하는-프로그래밍-언어">타입스크립트 (<code class="language-plaintext highlighter-rouge">TypeScript</code>) : <code class="language-plaintext highlighter-rouge">JavaScript</code>을 확장하여 정적 타입을 지원하는 프로그래밍 언어</h2>

<ul>
  <li>정적 타입 (<code class="language-plaintext highlighter-rouge">Static Type</code>) : 변수, 매개변수, 함수 반환 값 등에 대한 타입을 명시적으로 지정 가능</li>
  <li>컴파일 언어 (<code class="language-plaintext highlighter-rouge">Compile Language</code>) : <code class="language-plaintext highlighter-rouge">TypeScript</code> 컴파일러는 <code class="language-plaintext highlighter-rouge">TypeScript</code> 코드를 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드로 변환</li>
  <li>타입 검사 (<code class="language-plaintext highlighter-rouge">Type Checking</code>) : 타입을 명시하지 않아도 코드에서 사용된 패턴과 값에 기반해 타입을 추론</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm init -y
npm install -g typescript ts-node
tsc -v
tsc --init
cat tsconfig.json
ts-node temp.ts
</code></pre></div></div>

<h3 id="타입스크립트-컴파일러-tsc--typescript-코드를-javascript-코드로-변환하는-도구">타입스크립트 컴파일러 (<code class="language-plaintext highlighter-rouge">TSC</code>) : <code class="language-plaintext highlighter-rouge">TypeScript</code> 코드를 <code class="language-plaintext highlighter-rouge">JavaScript</code> 코드로 변환하는 도구</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">tsconfig.json</code> 조회 : 프로그램 설정 및 파일 실행</li>
  <li>사용 가능한 모든 파일들을 임포트 (<code class="language-plaintext highlighter-rouge">import</code>) (→ 파일들을 하나의 모듈 내에 있는 것처럼 관리)</li>
  <li>추상 구문 트리 (<code class="language-plaintext highlighter-rouge">AST; Abstract Syntax Tree</code>)를 토큰화 (<code class="language-plaintext highlighter-rouge">Tokenize</code>) 및 파싱 (<code class="language-plaintext highlighter-rouge">Parse</code>)</li>
  <li>바인더 (<code class="language-plaintext highlighter-rouge">Binder</code>)가 추상 구문 트리의 식별자를 <code class="language-plaintext highlighter-rouge">Symbol</code>로 변환</li>
  <li>바인더와 추상 구문 트리로 타입 검사를 실행</li>
  <li>프로그램에 설정한 옵션에 기반하여 추상 구문 트리를 <code class="language-plaintext highlighter-rouge">*.js</code>, <code class="language-plaintext highlighter-rouge">*.d.ts</code>의 형태로 변환</li>
</ol>

<h2 id="타입-시스템-type-system--프로그램에서-가질-수-있는-타입을-이해하는-방법에-대한-규칙-집합">타입 시스템 (<code class="language-plaintext highlighter-rouge">Type system</code>) : 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합</h2>

<ol>
  <li>코드를 읽고 존재하는 모든 타입과 값을 이해한다.</li>
  <li>각 값이 초기 선언에서 가질 수 있는 타입을 확인하고, 각 값이 추후 코드에서 어떻게 사용될 수 있는지 확인한다.</li>
  <li>모든 방법을 확인했을 때, 값의 사용법이 타입과 일치하지 않으면 사용자에게 타입 오류로 표시한다.</li>
</ol>

<blockquote>
  <p>타입 오류 vs 구문 오류?</p>

  <ul>
    <li>타입 오류 (<code class="language-plaintext highlighter-rouge">Type Error</code>) : 타입 검사기에 따라 일치하지 않는 것이 감지된 경우
      <ul>
        <li>타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생</li>
      </ul>
    </li>
    <li>구문 오류 (<code class="language-plaintext highlighter-rouge">Syntax Error</code>) : 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
      <ul>
        <li>타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="할당-가능성-assignability--함수-호출이나-변수에-값을-제공할-수-있는지-여부를-확인-가능">할당 가능성 (<code class="language-plaintext highlighter-rouge">Assignability</code>) : 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인 가능</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TypeScript</code>에선 변수나 속성에 값을 할당할 때 해당 값의 타입이 변수나 속성의 타입과 호환 가능해야함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let firstName = "Noah";
firstName = "Tom";
</code></pre></div></div>

<h3 id="타입-어노테이션-type-annotation--초기값을-할당하지-않고도-타입을-명시적으로-지정-가능">타입 어노테이션 (<code class="language-plaintext highlighter-rouge">Type Annotation</code>) : 초기값을 할당하지 않고도 타입을 명시적으로 지정 가능</h3>

<blockquote>
  <p>메모리 사이즈가 변하지 않는 변수는 타입 어노테이션을 추가하지 않는 것이 좋으나, 코드를 명확하게 문서화하거나 실수로 변수 타입이 변경되지 않도록 타입스크립트를 보호하기 위해 변수에 명시적으로 타입 어노테이션을 포함하는 것이 경우에 따라서는 유용할 수 있다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let variable: Type; // 변수의 이름 : 값의 타입
</code></pre></div></div>

<h3 id="타입-형태-type-shape--타입을-정의할-때-객체의-형태를-명시적으로-지정-가능">타입 형태 (<code class="language-plaintext highlighter-rouge">Type Shape</code>) : 타입을 정의할 때 객체의 형태를 명시적으로 지정 가능</h3>

<ul>
  <li>인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 객체의 구조를 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Person {
    name: string;
    age: number;
}

let person: Person = {
    name: "John",
    age: 25
};
</code></pre></div></div>

<ul>
  <li>타입 (<code class="language-plaintext highlighter-rouge">Type</code>) : 객체의 타입을 정의</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Point = {
    x: number;
    y: number;
};

let point: Point = {
    x: 10,
    y: 20
};
</code></pre></div></div>

<h2 id="타입-별칭-alias--자주-사용할-타입에-이름을-붙이는-것">타입 별칭 (<code class="language-plaintext highlighter-rouge">Alias</code>) : 자주 사용할 타입에 이름을 붙이는 것</h2>

<blockquote>
  <p>타입 별칭은 타입 어노테이션과 마찬가지로 자바스크립트로 컴파일되지 않으므로, 런타임 코드에서는 참조할 수 없다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Age = number;
type Name = string;

type Person = {
    name: Name;
    age: Age;
};


let person: Person = { name: "John", age: 25 };
</code></pre></div></div>

<h3 id="리터럴-타입-literal-type--원시-타입보다-더-구체적인-원시-값-자체를-타입으로-활용하는-것">리터럴 타입 (<code class="language-plaintext highlighter-rouge">Literal Type</code>) : 원시 타입보다 더 구체적인 원시 값 자체를 타입으로 활용하는 것</h3>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c9e566fc-2985-4d75-aba6-0f42082c8ab1" width="80%" /></p>

<ul>
  <li>특정 값들을 타입으로 정의하고, 해당 값들만이 유효한 값으로 간주
    <ul>
      <li>리터럴 할당 가능성 : 서로 다른 리터럴 타입은 서로 할당될 수 없음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let isString = '문자열';
let isLiteral: 'LITERAL';

isLiteral = isString;
// Error type 'string' is not assignable to type '"LITERAL"'.
</code></pre></div></div>

<h3 id="유니언-타입-union-type--값에-허용되는-타입을-두-개-이상의-가능한-타입으로-확장하는-것">유니언 타입 (<code class="language-plaintext highlighter-rouge">Union Type</code>) : 값에 허용되는 타입을 두 개 이상의 가능한 타입으로 확장하는 것</h3>

<ul>
  <li>둘 이상의 타입으로 확장된 타입에서, 일부 속성들의 조합이 하나의 타입에 할당 가능하면 유니온 타입으로 사용 가능
    <ul>
      <li>유니언으로 선언한 모든 타입에 존재하는 속성에만 접근 가능!</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Person = {
   name: string;
   age: number;
   phone: number | string; // number 또는 string 타입을 가질 수 있음
   addr?: string; // 선택적으로 사용할 수 있음
};
</code></pre></div></div>

<h3 id="내로잉-narrowing--값이-더-구체적인-타입임을-코드에서-유추하는-것">내로잉 (<code class="language-plaintext highlighter-rouge">narrowing</code>) : 값이 더 구체적인 타입임을 코드에서 유추하는 것</h3>

<ul>
  <li>타입스크립트에서 변수의 타입을 조건문을 통해 줄여나가는 것
    <ul>
      <li>값 할당 <code class="language-plaintext highlighter-rouge">ex) x = 1</code></li>
      <li><code class="language-plaintext highlighter-rouge">typeof</code> 검사 <code class="language-plaintext highlighter-rouge">ex) typeof(value)</code></li>
      <li>조건 검사 : <code class="language-plaintext highlighter-rouge">ex) if x === 'stringValue'</code></li>
      <li><code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">instanceof</code>, <code class="language-plaintext highlighter-rouge">Array.isArray</code>를 활용</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>내로잉을 수행하는 함수 또는 구문을 타입 가드 (<code class="language-plaintext highlighter-rouge">Type guard</code>)라 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Member = {
  name: string;
  address: string;
}

function inFunc (user: Member) {
  if ('name' in user) // cf. user.hasOwnProperty('name')로는 불가능
    console.log('user.name); 
}
</code></pre></div></div>

<h3 id="strictnullchecks--엄격한-null-검사-활성화-옵션"><code class="language-plaintext highlighter-rouge">strictNullChecks</code> : 엄격한 <code class="language-plaintext highlighter-rouge">null</code> 검사 활성화 옵션</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">null</code> 혹은 <code class="language-plaintext highlighter-rouge">undefined</code> 값을 참조 및 할당 했을 때, 타입 에러를 발생시킬지 여부</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// tsconfig.json 
//  {
//    "compilerOptions": {
//      "strictNullChecks": true
//    }
//  }

let un: string | undefined;
un.toLowerCase(); // Type 'undefined' is not assigned to type 'string'
un?.toLowerCase();
</code></pre></div></div>

<h2 id="객체-타입-object-type--객체의-형태를-정의하고-객체의-할당-가능성을-확인">객체 타입 (<code class="language-plaintext highlighter-rouge">Object Type</code>) : 객체의 형태를 정의하고, 객체의 할당 가능성을 확인</h2>

<ul>
  <li>타입스크립트의 타입 시스템은 타입을 구조화하여 정의하고 있음 → <code class="language-plaintext highlighter-rouge">Structured Type Definition</code>
    <ul>
      <li>타입 체크 시스템 (<code class="language-plaintext highlighter-rouge">Type Check System</code>) 을 통해 구조화된 형식을 검사</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x_user: {id: number, name: string};
x_user = {id: 1, name: 'xx'}; // OK
x_user = {id: 1}; // Error (Property 'name' missing in type)
x_user = {id: 1, name: 'xx', age: 30}; // Error ({id, name, age} is not assignable to type {id,name} )

// 타입 별칭(type alias)
type T_User = {
  id: number;
  name: string;
};

let hong: T_User;
hong = {id: 1, name: 'Hong'}; // OK
hong = {id: 1}; // Error (name property missing)
hong = {id: 1, name: 'Hong', addr: 'Pusan'}; // Error(not assignable) 
hong = {id: 1, name: 'Hong', addr: 'Pusan'} as T_User;
</code></pre></div></div>

<h3 id="타입스트립트는-covariance--contravariance를-원칙으로-하는-언어">타입스트립트는 <code class="language-plaintext highlighter-rouge">CoVariance | ContraVariance</code>를 원칙으로 하는 언어?</h3>

<ul>
  <li>공변성 (<code class="language-plaintext highlighter-rouge">CoVariance</code>) : 원래 지정된 것보다 더 파생된 형식을 사용 가능한 것<br />→ 타입 간의 계층 구조가 유지되면 변환을 허용 <code class="language-plaintext highlighter-rouge">ex)</code> 배열</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let baseArray: Animal[] = [];
let derivedArray: Dog[] = [];

// Covariant: 하위 타입인 Dog[]가 상위 타입인 Animal[]로 할당 가능
baseArray = derivedArray;
</code></pre></div></div>

<ul>
  <li>반변성 (<code class="language-plaintext highlighter-rouge">ContraVariance</code>) : 원래 지정된 것보다 덜 파생적인 형식을 사용 가능한 것<br />→ 하위 타입이 하위 타입으로 할당될 수 있음 <code class="language-plaintext highlighter-rouge">ex)</code> 함수의 매개변수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type AnimalHandler = (animal: Animal) =&gt; void;
type DogHandler = (dog: Dog) =&gt; void;

// Contravariant: 상위 타입인 AnimalHandler가 하위 타입인 DogHandler로 할당 가능
let animalHandler: AnimalHandler = (animal: Animal) =&gt; { /*...*/ };
let dogHandler: DogHandler = animalHandler;
</code></pre></div></div>

<blockquote>
  <p>타입스크립트는 <code class="language-plaintext highlighter-rouge">CoVariance</code>를 원칙이나, 함수의 매개변수처럼 <code class="language-plaintext highlighter-rouge">ContraVariance</code>가 적용되는 경우 또한 존재한다.</p>
</blockquote>

<h3 id="신선도-freshness--구조적으로-타입-호환성이-있는-객체-리터럴의-타입-검사">신선도 (<code class="language-plaintext highlighter-rouge">Freshness</code>) : 구조적으로 타입 호환성이 있는 객체 리터럴의 타입 검사</h3>

<ul>
  <li>신선도로 인한 오류는 ‘객체 리터럴을 사용한 경우에만’ 발생한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function logName(something: { name: string }) {
    console.log(something.name);
}

var person = { name: 'John', job: 'cowboy' };
var animal = { name: 'cow', description: 'element who hate John' };
var event = { note: `random` };

logName(person);
logName(animal);
logName(event); // 오류: 속성 `name` 누락 (신선도로 인한 오류 O)

function logName(something: { name: string }) {
  console.log(something.name);
}

logName({ name: 'John' });
logName({ name: 'John', job: 'cowboy' }); // 오류: 객체 리터럴은 정의된 속성만 지정해야 함. (신선도로 인한 오류 X)
</code></pre></div></div>

<blockquote>
  <p>신선도를 끄는 방법?</p>

  <ol>
    <li>변수에 할당한다.</li>
    <li>강제로 타입 캐스팅 (<code class="language-plaintext highlighter-rouge">type casting</code>)을 한다.</li>
    <li><code class="language-plaintext highlighter-rouge">union</code> 타입으로 제외시킨다.</li>
    <li><code class="language-plaintext highlighter-rouge">suppressExcessPropertyError</code>를 활성화한다.</li>
  </ol>
</blockquote>

<h2 id="함수-타입-function-type--함수가-가져야-하는-매개변수와-반환-타입을-명시">함수 타입 (<code class="language-plaintext highlighter-rouge">Function Type</code>) : 함수가 가져야 하는 매개변수와 반환 타입을 명시</h2>

<ul>
  <li>변수에 할당되거나 매개변수로 전달되는 함수의 타입을 정의
    <ul>
      <li>필수 매개변수 : 함수에 선언된 모든 매개변수를 필수라고 가정 → 타입 안정성이 강화</li>
      <li>선택 매개변수 : 타입 애너테이션의 : 앞에 <code class="language-plaintext highlighter-rouge">?</code>를 추가하여, 매개변수가 선택적이란 것을 표시</li>
      <li>기본 매개변수 : 기본적으로 값을 제공되므로, 함수 내부에 암묵적으로 <code class="language-plaintext highlighter-rouge">| undefined union type</code>이 추가<br />→ 타입스크립트는 함수의 매개변수에 대해 인수를 누락하거나 <code class="language-plaintext highlighter-rouge">undefined</code> 인수를 사용한 호출을 허용</li>
      <li>나머지 매개변수 : 함수 선언의 마지막 매개 변수에 위치한 <code class="language-plaintext highlighter-rouge">...</code> 스프레드 연산자로 표현<br />→ 해당 매개변수에서 시작해 함수에 전달된 나머지 인수가 모두 단일 배열에 저장<br />(인수 배열을 나타내기 위해 끝에 <code class="language-plaintext highlighter-rouge">[]</code> 구문이 추가)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(a: number, b: number) {
   return a + b;
}

type ANY = any;
function addY (a: ANY, b: ANY) {
  return a + b;
}

function addZ (a: ANY, b?: ANY) {
  return a + (b ?? 0);
}

addX(1, 0); addY(1, 0); addZ(1, 0);
addZ(1); // addX(1); addY(1);

const getSum = (...rest:number[]) =&gt;{
 let sum = 0;
 rest.forEach((el) =&gt; sum += el);
 return console.log(sum);
}
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">?</code>으로 표시된 선택 매개변수가 아닌 필수 매개변수는 값이 명시적으로 <code class="language-plaintext highlighter-rouge">undefined</code>이라도 항상 제공되어야 한다.</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const introduce2 = (name:string, 

height : number|undefined ) =&gt; {
   console.log(`이름 : ${name}`);

if(typeof height === 'number'){
   	console.log(`키 : ${height + 10}`)   
 	}
}

introduce2("김군"); // Error : Expected 2 arguments, but got 1.
introduce2("김군", undefined);
introduce2("김군", 170);
</code></pre></div>  </div>
</blockquote>

<ul>
  <li>함수의 반환 타입 : 함수가 반환할 수 있는 가능한 모든 값을 이해하면 함수가 반환하는 타입을 알 수 있음
    <ul>
      <li>그러나, 함수에서 반환 타입을 명시적으로 선언하는 방식이 유용할 때가 종종 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function singSongRecursive(songs : string[], count = 0) : number {
    return songs.length ? singSongRecursive(songs.slice(1), count + 1) : count;
}

const singSongsRecursive = (songs : string[], count=0) : number =&gt;
 songs.length ? singSongsRecursive(songs.slice(1), 
count + 1) : count;
</code></pre></div></div>

<ul>
  <li>함수 매개변수 타입 : 함수를 가지기 위한 매개변수 또는 변수의 타입을 선언하는 방법
    <ul>
      <li>함수 타입 구문은 화살표 함수와 유사하지만 함수 본문 대신 타입이 존재</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let nothingGivesString : () =&gt; string;

let inputAndOutput : (songs: string[], count?: number) =&gt; number;
</code></pre></div></div>

<ul>
  <li>함수 타입 괄호 : 함수 타입은 다른 타입이 사용되는 모든 곳에 배치할 수 있음 (유니온 타입 포함)
    <ul>
      <li>유니언 타입의 애너테이션에서 함수 반환 위치를 나타내거나 타입을 감싸는 부분을 표시할 때 괄호 사용</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 타입은 string | undefined 유니언을 반환하는 함수
let returnsStringOrUndefined : () =&gt; string | undefined;

// 타입은 undefined나 string 을 반환하는 함수
let maybeReturnsString : (() =&gt; string) | undefined;
</code></pre></div></div>

<ul>
  <li>매개변수 타입 추론 : 선언된 타입의 위치에 제공된 함수의 매개변수 타입을 유추할 수 있음
    <ul>
      <li>또한, 함수를 매개변수로 갖는 함수에 인수로 전달된 함수는 해당 매개변수 타입도 유추할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let singer : (song : string) =&gt; string;

singer = function(song){
    // song : string의 타입
    return `Singing : ${song.toUpperCase()}!`; // OK
}

const songs = ["One More Time", "I AM", "Cry"];

// song : string
// index : number

songs.forEach((song, index) =&gt; {
    console.log(`${song} is at index ${index}`);
});
</code></pre></div></div>

<h3 id="함수-오버로딩-function-overloading--동일한-이름에-매개-변수만-다른-함수를-여러-개-만드는-것">함수 오버로딩 (<code class="language-plaintext highlighter-rouge">Function Overloading</code>) : 동일한 이름에 매개 변수만 다른 함수를 여러 개 만드는 것</h3>

<ul>
  <li>매개변수의 형태가 다양한 여러 케이스에 대응하는 같은 이름의 함수를 만드는 것</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 서로 다른 버전의 함수들 -&gt; `오버로드 시그니처`
function func(a : number): void;
function func(a : number, b : number, c : number) : void;

// 실제 구현부 -&gt; `구현 시그니처`
function func(a:number, b?: number, c?:number) {
  if(typeof b === 'number' &amp;&amp; typeof c === 'number') {
    console.log(a + b + c);
  } else {
    console.log(a + b + c);
  }
}

func(1); func(1, 2, 3);
</code></pre></div></div>

<h2 id="인터페이스-interface--타입을-정의할-때-객체의-구조를-명시적으로-지정-가능">인터페이스 (<code class="language-plaintext highlighter-rouge">Interface</code>) : 타입을 정의할 때 객체의 구조를 명시적으로 지정 가능</h2>

<h3 id="호출-시그니처-call-signature--함수-호출-방법에-대한-타입-시스템을-설명">호출 시그니처 (<code class="language-plaintext highlighter-rouge">Call Signature</code>) : 함수 호출 방법에 대한 타입 시스템을 설명</h3>

<ul>
  <li>매개변수의 목록 (<code class="language-plaintext highlighter-rouge">with type</code>)과 반환 타입을 포함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type FunctionAlias = (input: string) =&gt; number;

interface CallSignature {
    (input: string): number;
}

const typedFunctionAlias: FunctionAlias = (input) =&gt; input.length;

const typedCallSignature: CallSignature = (input) =&gt; input.length;
</code></pre></div></div>

<blockquote>
  <p>호출 시그니처는 사용자 정의 속성을 추가로 갖는 함수를 설명하는 데에도 사용할 수 있다.</p>
</blockquote>

<h3 id="인덱스-시그니처-index-signature--임의의-키를-받고-해당-키에-대한-값의-타입을-지정">인덱스 시그니처 (<code class="language-plaintext highlighter-rouge">Index Signature</code>) : 임의의 키를 받고, 해당 키에 대한 값의 타입을 지정</h3>

<blockquote>
  <p>인덱스 시그니처를 사용하면, 프로퍼티의 존재 유무를 알 수 없다!</p>
</blockquote>

<h3 id="중첩-시그니처-nested-interface--속성의-타입이-다른-인터페이스나-객체-타입을-가질-수-있음">중첩 시그니처 (<code class="language-plaintext highlighter-rouge">Nested Interface</code>) : 속성의 타입이 다른 인터페이스나 객체 타입을 가질 수 있음</h3>

<h2 id="클래스-속성-class-attribute--클래스의-속성을-읽거나-쓰려면-명시적으로-선언해야-함">클래스 속성 (<code class="language-plaintext highlighter-rouge">Class Attribute</code>) : 클래스의 속성을 읽거나 쓰려면 명시적으로 선언해야 함</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class FieldTrip{
    destination  : string; // 불필요

    constructor(destination : string){
        this.destination = destination;
        console.log(`We're going to ${destination}!`);

    this.nonexistent = destination;
    //Error: Property 'nonexistent' does not exist on type 'FieldTrip'
    }
}
</code></pre></div></div>

<h3 id="클래스-메소드-class-method">클래스 메소드 (<code class="language-plaintext highlighter-rouge">Class Method</code>)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Greeted {
    constructor(message : string){
        console.log(`As I always say : ${message}!`);
    }
}
//Greeted 클래스의 생성자는 message:string으로 매개변수가 제공되어야 함
new Greeted("Practice makes perfect.");
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TS" /><summary type="html"><![CDATA[타입스크립트 (TypeScript) : JavaScript을 확장하여 정적 타입을 지원하는 프로그래밍 언어]]></summary></entry></feed>