<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-08T18:56:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">pocj8ur4in’s blog</title><subtitle></subtitle><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><entry><title type="html">[TIL] 2024년 01월 TIL</title><link href="http://localhost:4000/til1/" rel="alternate" type="text/html" title="[TIL] 2024년 01월 TIL" /><published>2023-12-31T00:00:00+09:00</published><updated>2024-01-03T00:00:00+09:00</updated><id>http://localhost:4000/til1</id><content type="html" xml:base="http://localhost:4000/til1/"><![CDATA[<h2 id="2024년에는-til를-작성하자">2024년에는 <code class="language-plaintext highlighter-rouge">TIL</code>를 작성하자!</h2>

<p>2023년은 내게 있어 다사다난한 해였다. 교수님 밑에서 친구들과 함께 프로젝트도 해보고, 기업에 취업하고자 여러 군데에 서류도 넣어 면접까지 진행하였다. 그리고 내가 부족하다고 느낀 부분을 메꾸기 위해 여러 도서들을 사서 정리하기도 하였으며, 주니어 개발자를 위한 여러 행사들 또한 참여하였다. 그런데 지금 올해를 회고하는 내게 있어서 아쉬운 점은 <b>내가 경험한 것들, 내가 공부한 것들, 내가 작업한 것들을 성실히 기록하지 않았다는 점</b>이다. 그래서 이제 하루 앞으로 다가온 2024년에는, 내가 매일매일 성장한 기록을 글의 형태로 남기고자 한다.<br /></p>

<p><code class="language-plaintext highlighter-rouge">TIL</code>은 <code class="language-plaintext highlighter-rouge">Today I Learned</code>의 약자로, 오늘 하루동안 배운 것 혹은 경험하고 느낀 것들을 기록하면서 회고하는 것이다. 이미 여러 개발 블로그들을 보면, <a href="https://github.com/cheese10yun/TIL">김남윤님의 <code class="language-plaintext highlighter-rouge">TIL</code></a>이나 <a href="https://wayhome25.github.io">초보몽키님의 <code class="language-plaintext highlighter-rouge">TIL</code></a>처럼 많이들 <code class="language-plaintext highlighter-rouge">TIL</code>을 쓰시는 것을 볼 수 있다. <code class="language-plaintext highlighter-rouge">TIL</code>이 정해진 양식이나 규칙 없이 자유롭게 자신의 스타일로 작성하다 보니 보고서처럼 쓰시는 분들도, 일기처럼 쓰시는 분들도 있어 정말 다양하게 쓰신다는 것을 알 수 있었다. 원래는 양식이나 규칙을 확실히 정해놓고 매일매일 쓰려고 하였는데 일단은<code class="language-plaintext highlighter-rouge">TIL</code>을 한번도 작성해본 적이 없다보니, 한 일주일 정도는 여러 형태로 글을 써보면서 나한테 적합한 글쓰기 방식을 찾아봐야할 것 같다. 대신에 내가 왜 <code class="language-plaintext highlighter-rouge">TIL</code>을 작성해야 하는지에 대해 생각해보았다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TIL</code>을 쓰는 이유 1. 내가 매일 경험한 것을 회고하기 위해<br />
  하루를 보내면서 내가 모르는 내용이나 개념을 만나는 경우가 정말 많다. 그리고 나의 솔루션이 옳은지에 대한 기술적인 고민을 하는 과정 또한 경험하게 된다. 그러나 그동안 내가 경험한 것들을 기록할 때에는, 이런 과정을 생략하고 개조식으로 글을 써서 내가 중요하다고 생각한 부분 위주로 잘 정리하고자 노력하였다. 지금 와서 내가 정리한 글들을 보면 <b>‘내가 어떤 문제 상황에서 어떻게 해결하였는지?’</b>에 대한 과정이 결여되었다는 느낌을 받았다. 하지만 <code class="language-plaintext highlighter-rouge">TIL</code>처럼 매일 내가 경험한 것들을 작성한다면, 나의 문제 해결 과정이 잘 들어난 글쓰기가 되지 않을까 생각하였다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TIL</code>을 쓰는 이유 2. 나 자신의 노력을 증명하기 위해<br />
  기업에서 원하는 주니어 개발자는 어떤 인재일까? 에 대해 고민을 많이 해보았다. 사실 시니어들의 눈에 주니어 개발자 모두가 고만고만한 실력이나 기술 스택을 가진 것처럼 보일 것 같았다. 그렇다면 내가 남들보다 더 낫다고 할 수 있는 부분은 무엇일까? 나는 그것이 <b>성장 가능성</b>이지 않을까 생각하였다. <code class="language-plaintext highlighter-rouge">TIL</code>은 내가 성장에 대한 갈망이 높고, 성실함과 꾸준함을 겸비하였음을 어필할 수 있어, 내가 남들보다 더 성장할 수 있는 사람이라는 것을 보여줄 수 있을 것이라고 기대한다.</p>
  </li>
</ul>

<h2 id="2024년-01월-01일-월">2024년 01월 01일 (월)</h2>

<ul>
  <li>신년을 맞아 앞으로 내가 해야할 일들을 아래와 같이 정리해보는 시간을 가졌다.
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Python</code>으로 알고리즘 문제를 풀면서 코딩 테스트 준비하기</li>
      <li><code class="language-plaintext highlighter-rouge">Java</code>, <code class="language-plaintext highlighter-rouge">Spring</code>과 같이 백엔드 개발자에 있어 필요한 내용을 공부해 포스트로 정리하기</li>
      <li>기획부터 배포까지의 일련의 과정을 경험할 수 있는 협업 프로젝트 진행하기</li>
      <li>정보처리기사, <code class="language-plaintext highlighter-rouge">SQLD</code>와 같이 취업에 도움이 될 수 있는 자격증 취득하기</li>
      <li>내가 목표로 하는 회사들에 지원하여 서류, 코딩 테스트, 면접과 같은 채용 프로세스 경험하기</li>
      <li>하루동안 내가 경험한 일들을 기록하는 <code class="language-plaintext highlighter-rouge">TIL</code> 작성하기</li>
      <li>자신의 기술과 역량을 보여줄 수 있는 개발자 포트폴리오 만들기</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 1장의 내용을 정리하였다.</li>
  <li><code class="language-plaintext highlighter-rouge">Goodnotes</code> 앱으로 필기하기 위해 알라딘으로 구매한 전자책을 스캔하는 <code class="language-plaintext highlighter-rouge">Automator</code> 워크플로우 파일을 작성하였다.</li>
</ul>

<h2 id="2024년-01월-02일-화">2024년 01월 02일 (화)</h2>

<ul>
  <li>어제 작성한 <code class="language-plaintext highlighter-rouge">Automator</code> 워크플로우 파일을 오전에 실행해보니 같은 파일명으로 파일을 덮어쓰는 오류가 있었다. 그래서 스크린샷을 찍어 이를 각각 다른 이름으로 저장하고, 필요한 경우에 색상 반전을 실행하는 파이썬 코드를 작성하였다.
    <ul>
      <li>사실 저장된 스크린샷 이미지들을 하나의 <code class="language-plaintext highlighter-rouge">PDF</code>로 만드는 것까지 코드로 작성하였는데, 막상 실행해보니 출력된 결과물의 화질이 그렇게 좋지 않아 이 부분은 수작업으로 진행하였다.</li>
      <li>알라딘으로 구매한 전자책 37권과 재학 기간에 스캔한 전공 서적 6권을 대상으로 진행하였다. 전자책을 스캔하는 작업과 색상 반전을 실행하는 작업 모두 내 예상보다 많은 시간이 소요되서 하루 내내 여기에만 매달린 거 같다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from PIL import ImageGrab
import time
import pyautogui


def take_screenshot(filename):
    # 로딩 시간 지연
    time.sleep(2)

    # 현재 화면 전체를 캡처
    screenshot = ImageGrab.grab()

    # 파일로 저장
    screenshot.save(filename)

    # 오른쪽 방향키 누르기
    pyautogui.press('right')


if __name__ == "__main__":
    # 초기 시간 지연
    time.sleep(5)

    for i in range(1, 256):
        file_path = "page" + str(i) + ".png"

        # 스크린샷 찍기
        take_screenshot(file_path)

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from PIL import Image


def invert_colors(image_path, output_path):
    # 이미지 열기
    image = Image.open(image_path)

    # 이미지 모드 확인 및 변경 (모드가 'RGBA' 또는 'LA'인 경우에 대비)
    if image.mode in ('RGBA', 'LA'):
        r, g, b, a = image.split()
        rgb_image = Image.merge('RGB', (r, g, b))
    else:
        rgb_image = image.convert('RGB')

    # 이미지 크기 및 모드 확인
    width, height = rgb_image.size

    # 각 픽셀의 RGB 값을 반전
    inverted_image = Image.new('RGB', (width, height))
    for x in range(width):
        for y in range(height):
            pixel = rgb_image.getpixel((x, y))
            inverted_pixel = tuple(255 - value for value in pixel)
            inverted_image.putpixel((x, y), inverted_pixel)

    # 반전된 이미지 저장
    inverted_image.save(output_path)


if __name__ == "__main__":
    for i in range(1, 256):
        input_image_path = "page" + str(i) + ".png"
        output_image_path = "pages" + str(i) + ".png"
        invert_colors(input_image_path, output_image_path)

</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 2장의 내용을 정리하였다.</li>
</ul>

<h2 id="2024년-01월-03일-수">2024년 01월 03일 (수)</h2>

<ul>
  <li>오늘 아침, 지난달에 면접을 진행한 <a href="https://hanaro.recruiter.co.kr">디지털하나路</a> 2기 금융서비스개발 분야에 합격하였다는 전화를 받았다.
    <ul>
      <li>솔직히 말하면 면접을 진행하면서 아쉬운 점들이 많았고, 경쟁률도 내 예상보다 높은 편이였기에 이렇게 합격을 하게 될 줄은 전혀 몰랐다. 6개월이라는 짧지 않은 기간에 매일 9시간씩 심도 깊게 진행되는 프로그램인 만큼, 본 과정에 열심히 참여하여 이전보다 성장할 수 있도록 노력해야겠다.</li>
      <li><a href="https://hanaro.recruiter.co.kr/career/introduce">공고문</a>에 따르면 디지털하나路 금융서비스개발의 커리큘럼은 금융의 이해, 서비스 개발의 요소, <code class="language-plaintext highlighter-rouge">FrontEnd</code> 개발, <code class="language-plaintext highlighter-rouge">BackEnd</code> 개발, 데이터베이스와 보안, 3차례의 팀 프로젝트로 구성되어 있다. 과정 하나하나가 <code class="language-plaintext highlighter-rouge">BackEnd</code> 개발자를 지망하는 내게 큰 도움이 될 것 같고, 특히 부족한 협업 경험이 아킬레스건이라 생각한 내게 있어 팀 프로젝트를 3차례 진행해보는 것은 굉장한 메리트가 될 수 있을 것이라고 생각한다.</li>
      <li>하나은행 <code class="language-plaintext highlighter-rouge">HR</code> 담당자 분들이 진행하시는 채용설명회 및 채용상담 또한, 자소서나 포트폴리오를 어떻게 작성하고 관리할지 고민이 많고 실제 면접 경험이 부족한 나에게 큰 도움이 될 것 같다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9422a984-6808-4fa6-987f-31b724c0afa9" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 3장의 내용을 정리하였다.
    <ul>
      <li>디지털하나路 일정을 감안힌다면, 보다 빠른 기획서의 작성이 필요하다. 오는 1월 13일에 인프라 매니저와의 만남을 약속하였고 1월 15일에 디지털하나路 과정이 시작될 예정이니, 1월 11일에 기획서 초안을 완성하도록 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="2024년-01월-04일-목">2024년 01월 04일 (목)</h2>

<ul>
  <li><del>내일배움카드 발급이 이렇게 오래 걸릴 줄은 몰랐다. 디지털하나路 일정이 촉박하다보니, 카드를 직접 수령하려고 은행만 세 군데 다녀왔다. 그건 그렇고 그동안 작성한 내용을 읽어보니 점점 일기장이 되는 것 같다? 그래도 일단은 괜찮겠지..?</del></li>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 4장의 내용을 정리하였다.</li>
</ul>

<h2 id="2024년-01월-05일-금">2024년 01월 05일 (금)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 5장의 내용을 정리하였다.
    <ul>
      <li>책의 내용이 7장으로 구성되어 있는데, 7장은 후일담이라 내일 6~7장의 내용을 정리해 마무리하면 될 것 같다.</li>
      <li>정리를 마무리한 다음에는 정리된 내용을 토대로 기획서의 뼈대를 잡을 계획이다. 내가 기획하고 있는 프로젝트는 기존 프로젝트의 언어 전환이 아닌 신규 서비스의 구현이긴 하지만, 실제로 어떻게 프로젝트를 관리할지에 대해 다시 한 번 생각해볼 수 있었으며 기획서에도 분명 채용할 만한 부분이 많음을 느끼고 있다.
        <ul>
          <li>기획서는 현재 1. 기획 배경, 2. 타 사이트 분석, 3. 서비스 설계의 흐름으로 작성하고 있으며, 현재 1번의 내용은 완성하고 2번의 내용을 작성하고 있는 상태이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2024년-01월-06일-토">2024년 01월 06일 (토)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vocawik</code> 기획서 작성에 참고하기 위해 <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=315185582">사례로 배우는 언어 전환 프로젝트 관리</a> 6~7장의 내용을 정리하였다.</li>
  <li>이전에 작성하였던 <a href="https://pocj8ur4in.github.io/homebrew1/">홈브류 (<code class="language-plaintext highlighter-rouge">Homebrew</code>)와 관련된 게시글</a>을 수정하여 포스팅하였다.</li>
</ul>

<h2 id="2024년-01월-07일-일">2024년 01월 07일 (일)</h2>

<ul>
  <li>이전에 작성하였던 <a href="https://pocj8ur4in.github.io/html1/"><code class="language-plaintext highlighter-rouge">HTML</code>와 관련된 게시글</a>과 <a href="https://pocj8ur4in.github.io/css1/"><code class="language-plaintext highlighter-rouge">CSS</code>와 관련된 게시글</a>을 수정하여 포스팅하였다.</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="TIL" /><summary type="html"><![CDATA[2024년에는 TIL를 작성하자!]]></summary></entry><entry><title type="html">[vocawik] 1. vocawik 프로젝트 소개</title><link href="http://localhost:4000/vocawik1/" rel="alternate" type="text/html" title="[vocawik] 1. vocawik 프로젝트 소개" /><published>2023-12-27T00:00:00+09:00</published><updated>2023-12-29T00:00:00+09:00</updated><id>http://localhost:4000/vocawik1</id><content type="html" xml:base="http://localhost:4000/vocawik1/"><![CDATA[<h2 id="0-들어가며">0. 들어가며</h2>

<p>음성 합성 (<code class="language-plaintext highlighter-rouge">Speech Synthesis</code>)은 인간의 육성 혹은 그와 비슷한 주파수를 합성하여 인공적인 음성을 자동으로 만들 수 있는 기술을 말한다. 인간의 말소리 혹은 이와 유사한 소리를 일정한 단위로 분할해 각 조각에 부호를 붙이는 방식으로 데이터화해 음성 라이브러리 (<code class="language-plaintext highlighter-rouge">Vocal Library</code>)에 저장하면, 음성 합성 엔진 (<code class="language-plaintext highlighter-rouge">Speech Synthesis Engine</code>)이 사용자의 지시에 따라 음성 라이브러리에 필요한 음성 단위를 불러오고 이를 기반으로 하여 인공적인 음성을 합성한다. 음성 합성 기술 문자를 대신 읽어주는 스크린 리더 (<code class="language-plaintext highlighter-rouge">Screen Reader</code>)로서, 1984년 애플 매킨토시 (<code class="language-plaintext highlighter-rouge">Apple Macintosh</code>)에 매킨토크 (<code class="language-plaintext highlighter-rouge">MacInTalk</code>) 기능으로 탑재된 이후 오랜 기간에 걸쳐 다양한 분야에서 활용되고 있다.<br /></p>

<p>2003년 2월 야마하 (<code class="language-plaintext highlighter-rouge">Yamaha</code>)에서 개발된 보컬로이드 (<code class="language-plaintext highlighter-rouge">VOCALOID</code>) 엔진 역시 음성 합성을 기반으로 한 소프트웨어로, 사용자가 프로그램만으로 사람의 노랫소리를 활용한 음원을 작곡하는 것을 목표로 한다. 그러나 기존 음성 합성 기술이 산업적인 용도에 초점을 맞춰져 있던 것과 달리, 보컬로이드를 비롯한 음성 합성 엔진은 음성 데이터에 다이폰 (<code class="language-plaintext highlighter-rouge">Diphone</code>), 음성의 강약, 비브라토, 숨소리 등의 부가적인 정보들을 더한 가수 라이브러리 (<code class="language-plaintext highlighter-rouge">Singer Library</code>)를 제공해 인간의 음성에 흡사한 소리를 생성할 수 있다. 또한 스코어 에디터 (<code class="language-plaintext highlighter-rouge">Score Editor</code>)는 노래의 가사나 음표만이 아닌, 음원의 억양와 높낮이 등을 가변하여 사용자가 자유롭게 음원을 조절할 수 있게끔 한다.<br /></p>

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" width="640" height="360" src="https://www.youtube.com/embed/dv_pMzr5Roo"></iframe>
<p><br /></p>

<p>야마하가 보컬로이드를 발표한 이후, 여러 기업들이 음성 제공자 (<code class="language-plaintext highlighter-rouge">Voice Provider</code>)의 목소리를 활용한 가수 라이브러리를 발표하였다. 2007년 8월 31일 크립톤 퓨처 미디어 (<code class="language-plaintext highlighter-rouge">Crypton Future Media</code>)에서 발매한 하츠네 미쿠 (<code class="language-plaintext highlighter-rouge">初音ミク</code>)는 대표적인 음성 합성 이미지 캐릭터로, 현대 일본 캐릭터 문화의 상징 중 하나로 여겨질 만큼 어마어마한 성공을 거두었다. 최근까지도 <code class="language-plaintext highlighter-rouge">Project SEKAI COLORFUL STAGE! feat. 初音ミク</code>, <code class="language-plaintext highlighter-rouge">ポケモン feat. 初音ミク Project VOLTAGE 18 Types/Songs</code>와 같은 관련 컨텐츠나 피규어, 넨도로이드 등 굿즈들이 끊임없이 나오고 있으며, <code class="language-plaintext highlighter-rouge">SONY</code>, <code class="language-plaintext highlighter-rouge">TOYOTA</code> 등 유명 회사들과의 콜라보 역시 지속적으로 이루어지고 있다.</p>

<p>음성 합성 소프트웨어를 활용한 음악 산업의 성공에는 관련 창작물들을 하나의 ‘창작 문화’로 여기면서 자발적으로 생산·유통·소비 활동에 참여하는 팬덤의 영향력이 뒷받침되었다고 본다. 아마추어 작곡가들이 가수나 밴드를 통해 자신이 작곡한 곡을 재상산하는 것은 현실적인 어려움이 존재한다. 그러나 음성 합성 소프트웨어를 통해 손쉽게 자신의 곡에 가수의 음성을 넣는 것이 가능해지면서, 음성 합성 소프트웨어를 활용한 자신의 곡을 투고하는 프로듀서 (<code class="language-plaintext highlighter-rouge">Producer</code>)들이 등장하였다. 그리고 유튜브 (<code class="language-plaintext highlighter-rouge">Youtube</code>), 니코니코 동화 (<code class="language-plaintext highlighter-rouge">ニコニコ動画</code>)와 같이 사용자가 동영상을 자유롭게 올리거나 시청할 수 있는 비디오 플랫폼을 통해 생산자와 소비자가 시공간의 제약을 넘어 자유롭게 교류할 수 있는 환경 또한 조성되었다. 거기에 더해 소비자가 단순히 컨텐츠를 즐기는 것을 넘어, 직접 프로듀서로 활동하거나 일러스트, <code class="language-plaintext highlighter-rouge">MMD</code>와 같은 2차 창작물을 생산하는 활동을 하면서 문화적 파급력을 갖게 되었다고 볼 수 있다.<br /></p>

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" width="100%" height="480" src="https://piapro.net/miku10th/"></iframe>
<p><br /></p>

<p>국내에서도 이런 음성 합성 소프트웨어를 활용한 음악 산업의 성공과 파급력에 주목하여, 한국어를 지원하는 보컬로이드 가수 라이브러리인 시유 (<code class="language-plaintext highlighter-rouge">SeeU</code>)나 유니 (<code class="language-plaintext highlighter-rouge">UNI</code>)가 출시되었고, 크리크루 (<code class="language-plaintext highlighter-rouge">CreCrew</code>)나 보카로 가사 위키 등 음성 합성 소프트웨어 관련 웹 사이트 또한 개설된 바가 있다. 그러나 음성 합성 소프트웨어가 일본이나 전세계에 미친 영향력에 비하면 국내에서의 파급력은 매우 제한적이었으며, 특히 관련 웹 사이트의 경우에는 운영되었던 사이트들이 폐쇄되면서 이용자들에게 불편함을 겪거나 수년간 축적된 데이터가 소실되는 경우가 발생하곤 하였다. 그래서 <b>음성 합성 소프트웨어를 주제로 한 지속 가능한 웹 사이트의 구현</b>을 목표로 하여 ① 국내외에서 운영되었거나 운영 중인 음성 합성과 관련된 웹 사이트의 운영 사례를 분석해보고, ② 분석한 결과를 반영해 웹 사이트를 기획하고자 한다.</p>

<h2 id="1-사이트-운영-사례">1. 사이트 운영 사례</h2>

<p>전세계적으로 많은 음원 합성 엔진를 다루는 사이트들이 개설되어 현재까지 운영 중이므로, 먼저 사례로 선정된 사이트들의 기준에 대해 언급하고자 한다. ① 음성 합성 소프트웨어에 관심이 많은 사용자들이 존재하면서, ② 음성 합성 소프트웨어와 관련된 창작 활동이 활발하게 이루어지거나, ③ 사이트에 도입할 만한 독창적인 컨텐츠가 존재하는지를 고려하였다. 다음은 사이트를 제외할 때 참고한 기준이다.</p>

<ul>
  <li><a href="https://www.vocaloid.com"><code>VOCALOID™</code></a>나 <a href="https://cevio.jp"><code>CeVIO</code></a>처럼 음성 합성 엔진이나 가수 라이브러리를 개발한 회사들이 운영하는 공식 사이트를 제외하였다. 단, 피아프로 (<code class="language-plaintext highlighter-rouge">piapro</code>)처럼 음성 합성 엔진이나 가수 라이브러리를 개발한 회사들이 설립하였더라도, 자사의 제품을 홍보하는 것이 주 목적이 아닌 사이트는 포함하였다.</li>
  <li><a href="https://namu.wiki">나무위키</a>, <a href="https://www.wikipedia.org">위키백과</a>, <a href="https://dic.nicovideo.jp">니코니코 대백과 (<code class="language-plaintext highlighter-rouge">ニコニコ大百科</code>)</a>처럼 음성 합성 소프트웨어만이 아닌 다양한 주제를 다루는 위키 (<code class="language-plaintext highlighter-rouge">wiki</code>)를 제외하였다. 물론 선정된 사이트 중에 여러 위키들이 존재하므로, 필요한 경우에 직간접적으로 언급할 것이다.</li>
  <li>동영상 공유 사이트나 컨텐츠 창작 사이트의 경우 음성 합성 소프트웨어와 관련된 창작 활동이 활발하게 이루어진 사이트들을 선정하되, <a href="http://cafe.naver.com/vocaloidempire">보컬로이드 제국</a>처럼 소셜 네트워크 플랫폼이나 커뮤니티 사이트 내에 음성 관련 엔진과 관련된 주제로 한 카페나 블로그, 게시판 등의 형태로 존재하는 경우는 제외하였다.</li>
  <li><a href="http://vocaloid4u.net">미쿠린넷</a>처럼 웹 사이트가 폐쇄된 지 오래되어, 사이트에 관한 자료가 거의 존재하지 않는 경우를 제외하였다.</li>
</ul>

<h3 id="1-니코니코-동화-ニコニコ動画">(1) <a href="https://www.nicovideo.jp">니코니코 동화 (<code class="language-plaintext highlighter-rouge">ニコニコ動画</code>)</a></h3>

<p>니코니코 동화는 2006년에 개설된 일본의 동영상 공유 사이트이다. 사용자들이 영상을 감상하면서 코멘트를 남기면 해당 시간대에 그 영상 위로 코멘트가 실시간으로 지나가는 ‘리얼타임 코멘트’ 시스템이 유명한데, 생방송이 아닌 동영상을 시청하더라도 다른 이용자들의 코멘트를 보면서 현장감을 느낄 수 있는 것이 장점이다. 이 시스템으로 니코니코 동화는 타 사이트와 차별화되는 자신만의 문화를 만들었다고 봐도 무방한데, 특정 장면에서 사용자들의 코멘트가 화면을 가득 채우는 ‘탄막’이나 코멘트를 이용하여 그림을 만들어내는 ‘코멘트 아트’ 등이 있다. 이런 니코니코 동화 특유의 문화에 보컬로이드를 위시한 여러 서브컬쳐 팬덤의 호응이 한데 어우려지면서, 한때 일본 내 웹 사이트 시장의 대부분을 잠식한 시기도 있었다. 니코니코 동화에서 10만/100만/1000만 재생 수를 달성한 영상들에 붙는 태그인 전당입성(<code class="language-plaintext highlighter-rouge">殿堂入り</code>)/전설입성(<code class="language-plaintext highlighter-rouge">伝説入り</code>)/신화입성(<code class="language-plaintext highlighter-rouge">神話入り</code>)이나, 음성 합성 소프트웨어 관련 랭킹을 매주 집계하는 주간 <code class="language-plaintext highlighter-rouge">VOCAL Character</code> 랭킹 (<code class="language-plaintext highlighter-rouge">週刊VOCAL Characterランキング</code>)이 여전히 보편적인 지표로 여겨지는 이유이다.<br />
현재 니코니코 동화는 노후화된 시스템와 정체된 컨텐츠로 인해 현재는 일본 내에서 유튜브나 틱톡에 완전히 밀려버린 상태이나, 창작자 친화 플랫폼으로의 입지를 구축하면서 어느 정도 차별화에 성공했다고 여겨진다. 2020년부터 진행중인 <code class="language-plaintext highlighter-rouge">The VOCALOID Collection</code>가 대표적인 예시인데, 행사 기간동안 투고된 작품들에 한하여 집계되는 랭킹 상위에 입상할 경우 크리에이터 지원금을 지급하거나 리듬 게임에 곡이 수록되는 혜택 등을 통해 창작자들의 참여를 도모하고 있다. 또한 재생 수나, 코멘트 수, 좋아요 수 등 데이터에 빌보드 재팬에서 개발한 계수를 곱해 음성 합성 소프트웨어를 사용한 악곡의 인기를 측정하는 차트인 니코니코 <code class="language-plaintext highlighter-rouge">VOCALOID SONGS TOP20</code> (<code class="language-plaintext highlighter-rouge">ニコニコ VOCALOID SONGS TOP20</code>)으로 다년간 축적된 웹 사이트 내의 데이터를 적극적으로 활용하는 행보 또한 보이고 있다.</p>

<h3 id="2-유튜브-youtube">(2) <a href="https://www.youtube.com">유튜브 (<code class="language-plaintext highlighter-rouge">Youtube</code>)</a></h3>

<p>유튜브는 2005년에 개설된 미국의 동영상 공유 사이트이다. 2017년 이후 니코니코 동화가 침체되면서, 대다수의 프로듀서들이 니코니코 동화만이 아닌 유튜브에도 음성 합성 소프트웨어 관련 창작물을 업로드하게 되었다. 이렇게 사용자들이 전세계적으로 분포한 유튜브에 창작물들이 업로드되면서, 해외에서 음성 합성 소프트웨어에 대해 접할 기회가 늘어나게 되었고 자연스레 해외 팬덤의 영향력 또한 커지게 되었다.</p>

<h3 id="3-비리비리-哔哩哔哩">(3) <a href="https://www.bilibili.com">비리비리 (<code class="language-plaintext highlighter-rouge">哔哩哔哩</code>)</a></h3>

<p>비리비리는 2010년에 개설된 중국의 동영상 공유 사이트이다.</p>

<h3 id="4-피아프로-piapro">(4) <a href="https://piapro.net">피아프로 (<code class="language-plaintext highlighter-rouge">piapro</code>)</a></h3>

<p>피아프로는 2007년에 개설된 일본의 컨텐츠 창작 사이트이다.</p>

<h3 id="5-크리크루-crecrew">(5) 크리크루 (<code class="language-plaintext highlighter-rouge">CreCrew</code>)</h3>

<h3 id="6-아트리-ateli">(6) <a href="https://ateli.com">아트리 (<code class="language-plaintext highlighter-rouge">ateli</code>)</a></h3>

<h3 id="7-vocaloid-amino">(7) <a href="https://aminoapps.com/c/vocaloid/info/"><code class="language-plaintext highlighter-rouge">VOCALOID Amino</code></a></h3>

<h3 id="8-vocaverse-network">(8) <a href="https://vocaverse.network"><code class="language-plaintext highlighter-rouge">VocaVerse Network</code></a></h3>

<h3 id="9-vnn">(9) <a href="https://www.vocaloidnews.net"><code class="language-plaintext highlighter-rouge">VNN</code></a></h3>

<h3 id="10-songrium">(10) <a href="https://songrium.jp"><code class="language-plaintext highlighter-rouge">Songrium</code></a></h3>

<h3 id="11-iwara">(11) <code class="language-plaintext highlighter-rouge">Iwara</code></h3>

<h3 id="12-보카로-가사-위키">(12) <a href="http://vocaro.wikidot.com">보카로 가사 위키</a></h3>

<h3 id="13-보컬로이드-위키-vocaloid-wiki">(13) <a href="https://vocaloid.fandom.com/wiki/Vocaloid_Wiki">보컬로이드 위키 (<code class="language-plaintext highlighter-rouge">VOCALOID Wiki</code>)</a></h3>

<h3 id="14-하츠네-미쿠-위키-初音ミク-wiki">(14) <a href="https://w.atwiki.jp/hmiku">하츠네 미쿠 위키 (<code class="language-plaintext highlighter-rouge">初音ミク Wiki</code>)</a></h3>

<h3 id="15-vocadb">(15) <a href="https://vocadb.net"><code class="language-plaintext highlighter-rouge">VocaDB</code></a></h3>

<h3 id="16-mikudb">(16) <a href="http://mikudb.moe"><code class="language-plaintext highlighter-rouge">MikuDB</code></a></h3>

<h3 id="17-vocaloard-chart">(17) <a href="https://vocaloard.injpok.tokyo/en/"><code class="language-plaintext highlighter-rouge">Vocaloard Chart</code></a></h3>

<h3 id="18-colorto">(18) <a href="https://colorto.netlify.app"><code class="language-plaintext highlighter-rouge">COLORTO</code></a></h3>

<h3 id="19-보카로-db-ボカロdb">(19) <a href="http://nicodb.jp/v/">보카로 DB (<code class="language-plaintext highlighter-rouge">ボカロDB</code>)</a></h3>

<h3 id="20-kiite-radar">(20) <a href="https://radar.kiite.jp"><code class="language-plaintext highlighter-rouge">Kiite Radar</code></a></h3>

<h3 id="21-vocalendar">(21) <a href="https://vocalendar.jp"><code class="language-plaintext highlighter-rouge">VOCALENDAR</code></a></h3>

<h2 id="2-vocawik-프로젝트-기획">2. <code class="language-plaintext highlighter-rouge">vocawik</code> 프로젝트 기획</h2>

<p>###</p>

<blockquote>
  <p>참고문헌</p>

  <ol>
    <li>논문
      <ul>
        <li>김도희. (2018). 보컬로이드 가상캐릭터의 특성 분석 연구. 일러스트레이션 포럼.</li>
        <li>임현정. (2012). 보컬로이드 2차 창작의 변형구조 연구. 이화여자대학교 대학원 석사학위논문.</li>
      </ul>
    </li>
    <li>기사
      <ul>
        <li><a href="https://www.newslight.kr/news/655301">안태춘, ‘한국 보컬로이드는 어떻게 나아가야할까?’</a></li>
      </ul>
    </li>
    <li>도서
      <ul>
        <li>남경호, 사례로 배우는 언어 전환 프로젝트 관리</li>
      </ul>
    </li>
  </ol>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="vocawik" /><summary type="html"><![CDATA[0. 들어가며]]></summary></entry><entry><title type="html">[MicroService] 2. MSA</title><link href="http://localhost:4000/microservice2/" rel="alternate" type="text/html" title="[MicroService] 2. MSA" /><published>2023-12-14T00:00:00+09:00</published><updated>2023-12-14T00:00:00+09:00</updated><id>http://localhost:4000/microservice2</id><content type="html" xml:base="http://localhost:4000/microservice2/"><![CDATA[<h2 id="마이크로서비스-아키텍처-msa--마이크로서비스를-접목한-아키텍처-구조">마이크로서비스 아키텍처 (<code class="language-plaintext highlighter-rouge">MSA</code>) : 마이크로서비스를 접목한 아키텍처 구조</h2>

<ul>
  <li>클라우드 인프라와 접목해 아마존, 넷플릭스에 의해 구체화 → 비즈니스 성공 사례</li>
  <li>각 서비스는 개별 프로세스에서 실행되며, <code class="language-plaintext highlighter-rouge">HTTP API</code>를 통해 통신</li>
  <li>각 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용해 독립적으로 배포</li>
</ul>

<blockquote>
  <p>마이크로서비스 아키텍처 (<code class="language-plaintext highlighter-rouge">MSA</code>)와 서비스 지향 아키텍처 (<code class="language-plaintext highlighter-rouge">SOA</code>)의 비교</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">SOA</code> : 컴포넌트를 모아 비즈니스적으로 의미있고 완결적인 서비스 단위로 모듈화
      <ul>
        <li><code class="language-plaintext highlighter-rouge">SOA</code>와 <code class="language-plaintext highlighter-rouge">MSA</code>의 공통점 : 비즈니스 서비스의 집합으로 시스템을 개발</li>
        <li><code class="language-plaintext highlighter-rouge">SOA</code>와 <code class="language-plaintext highlighter-rouge">MSA</code>의 차이점 : 이론적인 <code class="language-plaintext highlighter-rouge">SOA</code>와 달리, <code class="language-plaintext highlighter-rouge">MSA</code>는 클라우드 인프라와 접목해 구체화</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MSA</code> 내부 아키텍처 : <code class="language-plaintext highlighter-rouge">API</code>, 비즈니스 로직, 이벤트 발행, 데이터 처리의 구조화 등 <code class="language-plaintext highlighter-rouge">MSA</code> 내부 구조를 정의한 것</li>
  <li><code class="language-plaintext highlighter-rouge">MSA</code> 외부 아키텍처 : 인프라, 플랫폼, 어플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것</li>
</ul>

<h3 id="리액티브-선언-the-reactive-manifesto--어플리케이션이-요청에-즉각-응답하고-가동되길-기대">리액티브 선언 (<code class="language-plaintext highlighter-rouge">The Reactive Manifesto</code>) : 어플리케이션이 요청에 즉각 응답하고 가동되길 기대</h3>
<ul>
  <li>응답성 (<code class="language-plaintext highlighter-rouge">Responsive</code>) : 사용자에게 신뢰성 있는 응답을 빠르고 적절히 제공하는 능력</li>
  <li>탄력성 (<code class="language-plaintext highlighter-rouge">Resilient</code>) : 장애가 발생하더라도 시스템 전체에 영향을 주지 않고 복구하는 능력</li>
  <li>유연성 (<code class="language-plaintext highlighter-rouge">Elastic</code>) : 사용량에 변화가 있더라도 그에 비례해 자원을 조절해 균일한 응답성을 제공하는 능력</li>
  <li>메시지 기반 (<code class="language-plaintext highlighter-rouge">Message Driven</code>) : 비동기 메시지로 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향</li>
</ul>

<p>→ 4가지 요건을 만족하는 시스템을, 급변하는 상황을 적응할 수 있는 리엑티브 시스템 (<code class="language-plaintext highlighter-rouge">Reactive System</code>)이라 정의</p>

<h3 id="강결합에서-약결합의-아키텍처로의-변화">강결합에서 약결합의 아키텍처로의 변화</h3>
<ul>
  <li>소프트웨어 아키텍처 : 소프트웨어를 구성하는 요소와 그 구성 요소 간의 관계를 정의한 것
    <ul>
      <li>아키텍처를 정의하는 과정 : 시스템 구축을 위한 여러 비기능 요건들을 만족하는 해결 방법을 찾는 과정
        <ul>
          <li>비기능 요건 : 시스템 성능, 시스템 가용성, 보안, 유지보수성, 확장성 등</li>
        </ul>
      </li>
      <li>마이크로서비스 아키텍처는 ‘클라우드’라는 가상화된 인프라를 활용한 것이므로, 이를 고려해 설계해야 함</li>
    </ul>
  </li>
  <li>아키텍처 유연성 (<code class="language-plaintext highlighter-rouge">Architecture Flexibility</code>) : 시스템 자체가 변화 및 확장에 언제든지 대응할 수 있는 능력
    <ul>
      <li>시스템을 구성하는 구성 요소 간의 관계들이 느슨하게 결합되어 언제든지 대체되거나 확장될 수 있음</li>
      <li>리액티브 시스템이 리액티브하기 위해서 반드시 갖춰야 할 특성 중 하나</li>
      <li>클라우드 인프라 자체가 유연성과 확장성을 갖추므로, 어플리케이션 아키텍처 또한 아키텍처 유연성이 필요</li>
    </ul>
  </li>
</ul>

<iframe width="90%" height="350" style="border:none" src="https://landscape.cncf.io/?category=automation-configuration&amp;grouping=category&amp;fullscreen=yes"></iframe>

<ul>
  <li>과거 : 아키텍처 구성 요소들이 특정 벤더의 제품에 전적으로 의존
    <ul>
      <li>유명한 제품군을 사용함으로 품질이 보장될 수 있음</li>
      <li>특정 기술에 락인 (<code class="language-plaintext highlighter-rouge">lock-in</code>)되어 시스템을 쉽게 변경하거나 확장하기 어려움</li>
    </ul>
  </li>
  <li>현재 : 클라우드 환경 아래에서 사용하는 오픈 소스 기반 제품들이 충분한 기능, 품질, 호환성을 제공
    <ul>
      <li>아키텍처 설계가 필요한 레이어에서 적절한 솔루션을 선택하고 이를 조합하는 개방적 방식으로 변화</li>
      <li>클라우드 기반 어플리케이션의 구축에 필요한 인프라 및 어플리케이션 영역에 다양한 제품들이 등장</li>
    </ul>
  </li>
</ul>

<h2 id="msa-패턴--msa의-문제-영역에-대해-여러-사람들에-의해-검증되어-정리된-스타일-혹은-패턴"><code class="language-plaintext highlighter-rouge">MSA</code> 패턴 : <code class="language-plaintext highlighter-rouge">MSA</code>의 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 스타일 혹은 패턴</h2>
<ul>
  <li>인프라 구성 요소 : 마이크로서비스를 지탱하는 인프라스트럭처를 구축하는 데에 필요한 구성 요소</li>
  <li>플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴</li>
  <li>어플리케이션 패턴 : 마이크로서비스 어플리케이션을 구성하는 데에 필요한 패턴</li>
</ul>

<h3 id="인프라-구성-요소를-서비스-유형별로-나누어-해당되는-제품-중-하나를-의사결정--클라우드-인프라">인프라 구성 요소를 서비스 유형별로 나누어 해당되는 제품 중 하나를 의사결정 → 클라우드 인프라</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IaaS</code> (<code class="language-plaintext highlighter-rouge">Infrastructure as a Service</code>) : 가상 머신, 스트리지, 네트워크 등 인프라 제공
    <ul>
      <li>고객이 관리할 수 있는 범위가 가장 넓은 클라우드 컴퓨팅 서비스</li>
      <li><code class="language-plaintext highlighter-rouge">AWS</code> 등 퍼플릭 클라우드 공급 업체 (<code class="language-plaintext highlighter-rouge">CSP</code>)가 준비한 환경을 고객이 선택할 수 있음</li>
      <li>가상화된 물리적 자원을 <code class="language-plaintext highlighter-rouge">UI</code> 형태의 대시보드 혹은 <code class="language-plaintext highlighter-rouge">API</code> 형태로 제공</li>
      <li>고객은 서버와 스트리지에 접근할 수 있지만, 클라우드 내 가상 데이터 센터를 통해 리소스를 전달받는 형태</li>
      <li>개발자는 운영체제와 어플리케이션을 직접 관리해야 함 : 개발자와 인프라 관리자의 역할이 분담</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">AWS EC2</code>, <code class="language-plaintext highlighter-rouge">AWS S3</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CaaS</code> (<code class="language-plaintext highlighter-rouge">Container as a Service</code>) : 업로드, 구성, 실행, 확장, 중지할 수 있는 컨테이너 제공
    <ul>
      <li>가상 머신이 아닌 컨테이너를 기본 리소스로 활용해 어플리케이션을 개발, 실행, 관리</li>
      <li>컨테이너화된 어플리케이션을 빌드하고 배포하는 개발 환경은 퍼플릭 클라우드 공급 업체 (<code class="language-plaintext highlighter-rouge">CSP</code>)가 제공</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">Kubernetes Service</code>, <code class="language-plaintext highlighter-rouge">AWS ECS</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PaaS</code> (<code class="language-plaintext highlighter-rouge">Platform as a Service</code>) : 어플리케이션에 미들웨어, 런타임까지 탑재한 플랫폼을 제공
    <ul>
      <li>가상화된 클라우드 위에 원하는 서비스를 개발할 수 있도록 개발 환경을 미리 구축해 서비스 형태로 제공</li>
      <li>고객은 개발 환경을 고려할 필요 없이 어플리케이션 자체에 집중할 수 있음</li>
      <li>어플리케이션이 플랫폼에 종속되어 개발되므로, 다른 플랫폼으로의 이식이 어려울 수도 있음</li>
      <li>예시 : <code class="language-plaintext highlighter-rouge">Lambda</code>, <code class="language-plaintext highlighter-rouge">AWS Elastic Beanstalk</code></li>
    </ul>
  </li>
</ul>

<h3 id="시스템의-기반이-되는-인프라-레이어의-구축--베어메탈-장비-혹은-가상-인프라-환경을-통한-구축">시스템의 기반이 되는 인프라 레이어의 구축 → 베어메탈 장비 혹은 가상 인프라 환경을 통한 구축</h3>
<ul>
  <li>가상 인프라 환경 : 하이퍼바이저 (<code class="language-plaintext highlighter-rouge">Hypervisor</code>)의 사용 여부 및 게스트 OS 유무에 따라 나뉨
    <ul>
      <li>가상 머신 (<code class="language-plaintext highlighter-rouge">Virtual Machine</code>) : 하이퍼바이저를 통해 하나의 시스템에서 여러 운영체제를 사용
        <ul>
          <li>운영체제 패치 및 관련 라이브러리 설치로 인한 오버헤드가 지속적으로 발생</li>
        </ul>
      </li>
      <li>컨테이너 (<code class="language-plaintext highlighter-rouge">Container</code>) : 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성
        <ul>
          <li>도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 제어
            <ul>
              <li>이식성 : 도커만 실행할 수 있으면 호스트 커널에 상관없이 동일하게 사용</li>
              <li>신속성 : 크기가 작고 가벼워 빠른 배포가 가능 + 문제 발생 시 다시 가동하면 됨</li>
              <li>재사용성 : 동일한 환경을 재사용해 쉽게 설정 가능 → 서버 환경 구축이 쉬워짐</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>컨테이너 오케스트레이션 (<code class="language-plaintext highlighter-rouge">Container Orchestration</code>) : 컨테이너 관리 기술
        <ul>
          <li>컨테이너 배치 및 복제, 확장 및 축소, 장애 복구 컨테이너 간 통신, 로드밸런싱 등</li>
          <li>쿠버네티스 (<code class="language-plaintext highlighter-rouge">Kubernetes</code>) : <code class="language-plaintext highlighter-rouge">Pod</code>, <code class="language-plaintext highlighter-rouge">Deployment</code>, <code class="language-plaintext highlighter-rouge">Replica Sets</code> 정보 확인 가능
            <ul>
              <li>각 컨테이너가 요구하는 자원을 쿠버네티스에 요청하면 노드에 맞춰 자동 배치</li>
              <li>컨테이너 이상을 점검해, 실패하면 컨테이너를 자동으로 교체하고 리스케줄링</li>
              <li>일정량의 <code class="language-plaintext highlighter-rouge">CPU</code> 및 메모리 사용량을 초과하면 자동으로 수평 확장</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="마이크로서비스의-운영과-관리를-지원할-클라우드-플랫폼-미들웨어의-구축--플랫폼-패턴">마이크로서비스의 운영과 관리를 지원할 클라우드 플랫폼 (미들웨어)의 구축 → 플랫폼 패턴</h3>
<ul>
  <li>데비옵스 (<code class="language-plaintext highlighter-rouge">DevOps</code>) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화
    <ul>
      <li>소프트웨어를 빠르게 개발하게끔 지원하는 빌드, 테스트, 배포를 위한 자동화 환경</li>
      <li>지속적 제공 (<code class="language-plaintext highlighter-rouge">CI</code>) : 빌드된 소스 코드의 실행 파일을 실행 환경에 반영하기 전에 진행</li>
      <li>지속적 배포 (<code class="language-plaintext highlighter-rouge">CD</code>) : 저장소에 빌드한 소스 코드의 실행 파일을 실행 환경까지 자동으로 배포</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>자동 빌드 및 배포 절차</p>
  <ol>
    <li>매일 자신이 작성한 소스 코드와 이를 테스트할 테스트 코드를 형상관리 시스템에 보낸다. (<code class="language-plaintext highlighter-rouge">Push</code>)</li>
    <li>매일 빌드 도구에서 형상관리 서버의 코드를 가져와 (<code class="language-plaintext highlighter-rouge">Pull</code>) 통합하고, 자동으로 빌드하고 테스트를 수행한다.</li>
    <li>테스트 수행 결과를 리포트에 기록하고, 빌드된 소스 코드를 스테이징 환경에 자동으로 배포한다.</li>
    <li>테스터가 스테이징 환경에서 테스트를 수행할 때 혹은 리포트 결과에 문제가 있으면, 소스 코드를 수정한다.</li>
  </ol>
</blockquote>

<ul>
  <li>빌드·배포 파이프라인의 설계 : 빌드·배포 과정동안 수행해야 할 업무 (<code class="language-plaintext highlighter-rouge">task</code>)를 정의한 것
    <ul>
      <li>리포지토리에서 소스 코드를 가져와 빌드해 실행 파일을 만드는 작업</li>
      <li>이전 작업이 성공하면, 다음 작업이 자동으로 수행히게끔 위의 작업들을 관리하는 작업</li>
      <li>실행할 어플리케이션을 실행 환경에 배포하는 작업</li>
    </ul>

    <p>→ <code class="language-plaintext highlighter-rouge">IaaS</code>를 통해 빌드·배포 파이프라인의 절차를 완벽하게 자동화할 수 있음</p>
  </li>
</ul>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[마이크로서비스 아키텍처 (MSA) : 마이크로서비스를 접목한 아키텍처 구조]]></summary></entry><entry><title type="html">[MicroService] 1. MicroService</title><link href="http://localhost:4000/microservice1/" rel="alternate" type="text/html" title="[MicroService] 1. MicroService" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-14T00:00:00+09:00</updated><id>http://localhost:4000/microservice1</id><content type="html" xml:base="http://localhost:4000/microservice1/"><![CDATA[<h2 id="비즈니스-민첩성--자신의-특화된-서비스를-빠르게-제공하고-피드백을-반영해-서비스를-빠르게-개선">비즈니스 민첩성 : 자신의 특화된 서비스를 빠르게 제공하고, 피드백을 반영해 서비스를 빠르게 개선</h2>

<ul>
  <li>빠른 배포 주기 : 비즈니스 민첩성을 간접적으로 보여주는 지표 → 어떻게 빠른 비즈니스 속도를 가질 수 있을까?</li>
</ul>

<h3 id="클라우드-인프라-cloud-infra의-등장--아마존의-aws-구글의-구글-클라우드-플랫폼">클라우드 인프라 (<code class="language-plaintext highlighter-rouge">Cloud Infra</code>)의 등장 : 아마존의 <code class="language-plaintext highlighter-rouge">AWS</code>, 구글의 구글 클라우드 플랫폼</h3>
<ul>
  <li>비용 측면 : 클라우드의 사용량에 따라 비용을 유연하게 조정할 수 있음 → 사용한 만큼만 비용을 지불</li>
  <li>어플리케이션 측면 : 어플리케이션을 여러 개의 블록처럼 관리해 효율성을 극대화
    <ul>
      <li>사용량 증가에 따른 성능 및 가용성을 <code class="language-plaintext highlighter-rouge">Scale-up</code>, <code class="language-plaintext highlighter-rouge">Scale-out</code> → 특정 부분만 탄력성 있게 확장 가능</li>
    </ul>
  </li>
</ul>

<h3 id="어떤-서비스가-클라우드-인프라에-적합할까--클라우드-프랜들리-클라우드-네이티브">어떤 서비스가 클라우드 인프라에 적합할까 : 클라우드 프랜들리? 클라우드 네이티브?</h3>
<ul>
  <li>클라우드 프렌들리 (<code class="language-plaintext highlighter-rouge">Cloud Friendly</code>) : 시스템을 하나의 큰 덩어리로 만들어 클라우드 인프라에 올리는 것</li>
  <li>클라우드 네이티브 (<code class="language-plaintext highlighter-rouge">Cloud Native</code>) : 시스템을 여러 개의 블록 단위로 나누어 클라우드 인프라에 올리는 것</li>
</ul>

<h2 id="마이크로서비스-microservice--여러-서비스-인스턴스가-하나의-비즈니스-어플리케이션-구성">마이크로서비스 (<code class="language-plaintext highlighter-rouge">MicroService</code>) : 여러 서비스 인스턴스가 하나의 비즈니스 어플리케이션 구성</h2>
<ul>
  <li>서비스가 갖는 저장소가 각각 다르므로 업무 단위로 모듈 경계가 명확하게 구분
    <ul>
      <li>확장하거나 변경할 때에는 특정 기능별로 독립적으로 작업한 뒤에 빌드해서 배포하면 됨</li>
      <li>각 서비스가 독립적이기에 서로 다른 언어, 데이터, 기술로도 개발 가능 → 폴리글랏 (<code class="language-plaintext highlighter-rouge">Polyglot</code>)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>마이크로서비스 이전에는? : 모노리스 (<code class="language-plaintext highlighter-rouge">Monolith</code>)</p>
  <ul>
    <li>전체 시스템이 하나의 단위로 개발되는 일체식 어플리케이션</li>
    <li>일반적으로 클라이언트, 어플리케이션, 데이터베이스의 <code class="language-plaintext highlighter-rouge">3-tier</code> 시스템으로 구성</li>
    <li>아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 함</li>
    <li>단일 프로세스에서 실행되므로, 확장이 필요할 경우에 전체 어플리케이션을 동시에 확장해야 함
      <ul>
        <li>로드밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 스케일 아웃</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="마이크로서비스를-위한-조건은-무엇인가">마이크로서비스를 위한 조건은 무엇인가?</h3>

<ol>
  <li>
    <h4 id="업무-기능-중심-팀">업무 기능 중심 팀</h4>
    <ul>
      <li>콘웨이 법칙 (<code class="language-plaintext highlighter-rouge">Conway’s law</code>) : 시스템을 개발할 때 항상 시스템의 모양이 팀 의사소통 구조를 반영
        <ul>
          <li>마이크로서비스를 만드는 팀은 역할이나 기술이 아닌, 업무 기능을 중심으로 한 팀이 되어야 함</li>
        </ul>
      </li>
      <li>기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자, 테스터 등 다양한 역할의 인원으로 구성
        <ul>
          <li>서비스를 처음부터 끝까지 만들기 위한 모든 단계의 역할을 갖추고 있음</li>
          <li>같은 공간, 같은 시간을 공유하기에 의사소통이 원활하고 빠르게 진행할 수 있음</li>
          <li>여러 기능들이 모여 있다는 의미에서 다기능 팀 (<code class="language-plaintext highlighter-rouge">Cross-Functional Team</code>)이라고도 부름</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="자율적인-분권-거버넌스">자율적인 분권 거버넌스</h4>
    <ul>
      <li>각 마이크로서비스 팀은 빠르게 서비스를 만드는 것을 최우선 목적으로 함
        <ul>
          <li>중앙의 강력한 표준이나 절차 준수를 강요받지 않음</li>
          <li>스스로 효율적인 방법론과 도구, 기술을 찾아 적용 → 폴리글랏 프로그래밍, 폴리글랏 저장소</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="제품-중심의-생명-주기">제품 중심의 생명 주기</h4>
    <ul>
      <li>개발 모델이 프로젝트 단위가 아니라 제품 단위로 구성됨 → 개발 조직과 운영 조직이 결합</li>
      <li>소프트웨어를 완성해야 할 기능들의 집합이 아닌, 비즈니스를 제공하는 제품 (<code class="language-plaintext highlighter-rouge">Product</code>)로 봄
        <ul>
          <li>우선 빠르게 개발한 뒤에 반응을 보고 개선하는 방식으로 개발</li>
          <li>프로젝트 형태의 워터풀 (<code class="language-plaintext highlighter-rouge">WaterFall</code>) 개발 방식이 아닌, 제품 중심의 에자일 (<code class="language-plaintext highlighter-rouge">Agile</code>) 개발 방식 채용</li>
          <li>2~3주 단위의 스프린트 (<code class="language-plaintext highlighter-rouge">Sprint</code>)를 통해 소프트웨어에 피드백을 즉각적으로 반영</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="cicd-파이프라인의-자동화"><code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인의 자동화</h4>
    <ul>
      <li>개발과 운영을 동시에 수행하는 데비옵스 (<code class="language-plaintext highlighter-rouge">DevOps</code>)를 궁극적으로 가능하게 함</li>
      <li>각각의 <code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인 프로세스는 <code class="language-plaintext highlighter-rouge">CI/CD</code> 파이프라인 도구를 통해 자동화가 이루어짐
        <ul>
          <li>‘<code class="language-plaintext highlighter-rouge">Infrastructure as Code</code>’ : 코드를 이용해 인프라 구성부터 어플리케이션 빌드 및 배포를 정의</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="분권-데이터-관리">분권 데이터 관리</h4>
    <ul>
      <li>폴리글랏 저장소 (<code class="language-plaintext highlighter-rouge">Polyglot Persistence</code>) 접근법 : 서비스별로 데이터베이스를 갖도록 설계
        <ul>
          <li>각각의 저장소가 서비스별로 분산되어 있으며, 다른 서비스에 <code class="language-plaintext highlighter-rouge">API</code>를 통해 접근함</li>
        </ul>
      </li>
      <li>결과적 일관성 (<code class="language-plaintext highlighter-rouge">Eventual Consistency</code>) : 일시적으로 다른 두 서비스의 데이터가 결국엔 동일해짐
        <ul>
          <li>여러 트랜잭션을 하나로 묶지 않고, 별도의 로컬 트랙잭션을 수행</li>
          <li>각 저장소 내 데이터의 비즈니스 정합성을 위해 데이터 일관성이 다른 부분을 보상 트랙잭션으로 맞춤</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="내결함성을-고려한-설계">내결함성을 고려한 설계</h4>
    <ul>
      <li>내결함성 (<code class="language-plaintext highlighter-rouge">Fault Tolerance</code>) : 시스템은 언제든 실패할 수 있는 가능성이 존재한다.
        <ul>
          <li>시스템이 실패해서 더는 진행할 수 없을 때에도, 자연스럽게 대응할 수 있도록 설계하여야 함</li>
        </ul>
      </li>
      <li>다양한 실패에 대비해 완벽히 테스트할 수 있는 환경을 마련해야 함</li>
      <li>시스템의 실패를 감지하고 대응하기 위한 실시간 모니터링 체계 또한 갖춰야 함</li>
      <li>장애를 일부러 발생시키는 카오스 몽키 (<code class="language-plaintext highlighter-rouge">Chaos Monkey</code>)를 만들어 아키텍처 동작을 점검하기도 함</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>Reference</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="MicroService" /><summary type="html"><![CDATA[비즈니스 민첩성 : 자신의 특화된 서비스를 빠르게 제공하고, 피드백을 반영해 서비스를 빠르게 개선]]></summary></entry><entry><title type="html">[JPA] 1. JPA</title><link href="http://localhost:4000/jpa1/" rel="alternate" type="text/html" title="[JPA] 1. JPA" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/jpa1</id><content type="html" xml:base="http://localhost:4000/jpa1/"><![CDATA[<h2 id="개발자가-sql을-직접-다룰-때의-문제">개발자가 <code class="language-plaintext highlighter-rouge">SQL</code>을 직접 다룰 때의 문제</h2>

<ol>
  <li>
    <h3 id="db는-객체-구조와는-다른-데이터-중심의-구조를-가져-객체를-db에서-직접-저장하거나-조회할-수-없음"><code class="language-plaintext highlighter-rouge">DB</code>는 객체 구조와는 다른 데이터 중심의 구조를 가져 객체를 DB에서 직접 저장하거나 조회할 수 없음</h3>
    <ul>
      <li>개발자가 객체지향 어플리케이션과 <code class="language-plaintext highlighter-rouge">DB</code> 중간에서 <code class="language-plaintext highlighter-rouge">SQL</code>과 <code class="language-plaintext highlighter-rouge">JDBC API</code>를 이용해 변환해야 함</li>
      <li>객체를 DB에 CRUD하기 위해서 너무 많은 <code class="language-plaintext highlighter-rouge">SQL</code>과 <code class="language-plaintext highlighter-rouge">JDBC API</code>를 코드로 작성해야 함</li>
    </ul>
  </li>
  <li>
    <h3 id="dao를-이용해-sql를-은닉해도-결국엔-sql에-의존적인-개발이-될-수-밖에-없음"><code class="language-plaintext highlighter-rouge">DAO</code>를 이용해 <code class="language-plaintext highlighter-rouge">SQL</code>를 은닉해도 결국엔 <code class="language-plaintext highlighter-rouge">SQL</code>에 의존적인 개발이 될 수 밖에 없음</h3>
    <ul>
      <li>개발자가 엔티티를 신뢰하고 사용할 수 없음… 이게 진정한 계층 분할?</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>그럼, <code class="language-plaintext highlighter-rouge">JPA</code>는 어떻게 문제를 해결하였는가?</p>

  <ul>
    <li>객체를 <code class="language-plaintext highlighter-rouge">DB</code>에 저장하고 관리할 때 <code class="language-plaintext highlighter-rouge">JPA</code>가 제공하는 <code class="language-plaintext highlighter-rouge">API</code> 사용
      <ul>
        <li>저장 → <code class="language-plaintext highlighter-rouge">persist()</code> : 객체를 DB에 저장하면, <code class="language-plaintext highlighter-rouge">INSERT SQL</code>를 생성해서 <code class="language-plaintext highlighter-rouge">DB</code>에 전달</li>
        <li>조회 → <code class="language-plaintext highlighter-rouge">find()</code> : 객체 하나를 DB에서 조회하면, <code class="language-plaintext highlighter-rouge">SELECT SQL</code>를 생성해서 <code class="language-plaintext highlighter-rouge">DB</code>에 전달</li>
        <li>수정 → 객체를 조회해 값을 변경하면, 트랜잭션을 커밋할 때 <code class="language-plaintext highlighter-rouge">UPDATE SQL</code>를 생성해 <code class="language-plaintext highlighter-rouge">DB</code>에 전달</li>
        <li>연관 객체 조회 → 연관된 객체를 사용하는 시점에 <code class="language-plaintext highlighter-rouge">SELECT SQL</code>를 실행</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="객체와-관계형-데이터베이스의-패러다임-불일치">객체와 관계형 데이터베이스의 패러다임 불일치</h2>
<ul>
  <li>객체지향 프로그래밍 : 추상화, 캡슙화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치 제공</li>
  <li>비즈니스 요구사항을 정의한 도메인 모델 또한 객체로 모델링 → 객체와 관계형 데이터베이스는 지향하는 바가 다르다!</li>
</ul>

<ol>
  <li>
    <h3 id="상속--객체는-상속이라는-기능을-가지지만-테이블은-상속이라는-기능이-없음">상속 : 객체는 상속이라는 기능을 가지지만, 테이블은 상속이라는 기능이 없음</h3>
    <ul>
      <li>데이터베이스 모델링의 슈퍼타입-서브타입 관계를 이용한다고 해도, 매번 2가지 <code class="language-plaintext highlighter-rouge">SQL</code>를 만들어야 함</li>
    </ul>
  </li>
  <li>
    <h3 id="연관관계--객체는-참조를-사용해-다른-객체와-연관관계를-가지고-참조에-접근해서-조회">연관관계 : 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조에 접근해서 조회</h3>
    <ul>
      <li>그러나 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 이용해서 연관된 테이블을 조회</li>
      <li>그럼 객체를 테이블에 맞추어 모델링하면? : 외래 키와 참조의 예 → 객체지향의 장점을 잃어버릴 수 있다!</li>
    </ul>
  </li>
  <li>
    <h3 id="객체-그래프-탐색--객체에서-회원이-소속된-팀을-조회할-때에는-참조를-사용해-연관된-팀을-탐색">객체 그래프 탐색 : 객체에서 회원이 소속된 팀을 조회할 때에는 참조를 사용해 연관된 팀을 탐색</h3>
    <ul>
      <li>그런데 참조를 통해 팀을 탐색할 수 있을지 없을지 알 수 없음 → 너무나 큰 제약사항
        <ul>
          <li>결국 <code class="language-plaintext highlighter-rouge">DAO</code>를 통해 <code class="language-plaintext highlighter-rouge">SQL</code>을 직접 확인하기 위해 상황에 따른 여러 메소드를 만들어야 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h3 id="비교--데이터베이스는-기본-키의-값으로-각-row를-구분하지만-객체는-동일성-비교-동등성-비교를-활용">비교 : 데이터베이스는 기본 키의 값으로 각 <code class="language-plaintext highlighter-rouge">row</code>를 구분하지만, 객체는 동일성 비교, 동등성 비교를 활용</h3>
    <ul>
      <li>동일성 비교 (<code class="language-plaintext highlighter-rouge">==</code>) : 객체 인스턴스의 주소 값을 비교, 동등성 비교 (<code class="language-plaintext highlighter-rouge">equals()</code>) : 객체 내부의 값을 비교
        <ul>
          <li>기본 키 값이 같은 객체를 2번 조회했을 때, 이 객체들이 다른 인스턴스면 동등하되 동일하지 않다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>그럼, <code class="language-plaintext highlighter-rouge">JPA</code>는 어떻게 문제를 해결하였는가?</p>

  <ul>
    <li>상속 → 자바 컬렉션에 객체를 저장하듯이 <code class="language-plaintext highlighter-rouge">JPA</code>에 객채를 저장하면 이를 두 테이블에 나눠 저장</li>
    <li>연관관계 → 개발자가 관계를 설정해 객체를 저장하면, 참조를 외래 키로 변환해 <code class="language-plaintext highlighter-rouge">INSERT SQL</code> 전달</li>
    <li>객체 그래프 탐색 : 실제 객체를 사용하는 시점까지 <code class="language-plaintext highlighter-rouge">DB</code> 조회를 미루는 지연 로딩 이용</li>
    <li>비교 : 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장</li>
  </ul>
</blockquote>

<h2 id="jpa-java-persistence-api--자바-진영의-orm-기술-표준"><code class="language-plaintext highlighter-rouge">JPA</code> (<code class="language-plaintext highlighter-rouge">Java Persistence API</code>) : 자바 진영의 <code class="language-plaintext highlighter-rouge">ORM</code> 기술 표준</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ORM</code> (<code class="language-plaintext highlighter-rouge">Object-Relational Mapping</code>) : 객체와 관계형 <code class="language-plaintext highlighter-rouge">DB</code>를 매핑</li>
</ul>

<h3 id="왜-jpa를-사용해야-하는가">왜 <code class="language-plaintext highlighter-rouge">JPA</code>를 사용해야 하는가?</h3>
<ol>
  <li>생산성 : 반복되는 <code class="language-plaintext highlighter-rouge">CRUD</code>용 <code class="language-plaintext highlighter-rouge">SQL</code> 코드를 작성하는 대신, 자바 컬렉션에 객체를 저장하듯 <code class="language-plaintext highlighter-rouge">JPA</code>에 객체를 전달하면 됨</li>
  <li>유지보수 : 매번 <code class="language-plaintext highlighter-rouge">SQL</code>과 <code class="language-plaintext highlighter-rouge">JDBC API</code> 코드를 변경할 필요 없음</li>
  <li>패러다임의 불일치 해결 : <code class="language-plaintext highlighter-rouge">ORM</code> 프레임워크가 상속, 연관관계, 객체 그래프 탐색, 비교 등의 문제를 대신 해결</li>
  <li>성능 : 어플리케이션과 <code class="language-plaintext highlighter-rouge">DB</code> 사이에서 동작하면서 다양한 성능 최적화 기회를 제공</li>
  <li>데이터 접근 추상화 및 벤더 독립성 : <code class="language-plaintext highlighter-rouge">DB</code> 접근 계층을 제공해서 특정 <code class="language-plaintext highlighter-rouge">DB</code> 기술에 종속되지 않음</li>
</ol>

<blockquote>
  <p>References</p>

  <ul>
    <li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62681446">자바 ORM 표준 JPA 프로그래밍</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="JPA" /><summary type="html"><![CDATA[개발자가 SQL을 직접 다룰 때의 문제]]></summary></entry><entry><title type="html">[Docker] 4. Docker File</title><link href="http://localhost:4000/docker4/" rel="alternate" type="text/html" title="[Docker] 4. Docker File" /><published>2023-12-08T00:00:00+09:00</published><updated>2023-12-08T00:00:00+09:00</updated><id>http://localhost:4000/docker4</id><content type="html" xml:base="http://localhost:4000/docker4/"><![CDATA[<h2 id="도커-파일-dockerfile--서버-운영-기록을-코드로-저장한-파일을-특정-시점의-도커-이미지로-빌드">도커 파일 (<code class="language-plaintext highlighter-rouge">Dockerfile</code>) : 서버 운영 기록을 코드로 저장한 파일을 특정 시점의 도커 이미지로 빌드</h2>

<blockquote>
  <ul>
    <li>눈송이 서버 (<code class="language-plaintext highlighter-rouge">Snowflakes Server</code>) : 각 서버마다 운영 기록이 달라 서로 모양이 다른 서버들이 공존하는 상황</li>
  </ul>

  <p>… 서버 간의 운영체제, 컴파일러, 설치된 패키지 등의 차이로 발생하는 문제 개선을 위해 서버 운영 기록을 저장하자!</p>
</blockquote>

<h3 id="도커-파일을-생성하는-과정은-테스트-주도-개발의-순환에-부합하다고-볼-수-있다">도커 파일을 생성하는 과정은 테스트 주도 개발의 순환에 부합하다고 볼 수 있다.</h3>
<ul>
  <li>테스트 주도 개발 (<code class="language-plaintext highlighter-rouge">Test Driven Development</code>) : 선 테스트 후 개발 사이클을 반복하는 개발 방법론</li>
</ul>

<div style="color: white; padding: 2% 1% 1% 1%; background-color: black;">
<ol>
  <li>테스트를 작성한다. → 도커 파일을 만든다.</li>
  <li>테스트에 실패하고 코드를 수정한다. → 도커 이미지의 빌드에 실패하고 도커 파일을 수정한다.</li>
  <li>테스트에 성공한다면, 코드를 리펙터링한다. → 도커 이미지의 빌드에 성공한다면, 도커 파일의 내용을 리펙터링한다.</li>
  <li>처음으로 되돌아간다.</li>
</ol>
</div>

<h3 id="dsl-domain-specific-language--도커-파일을-작성할-때-쓰는-언어-도커-이미지의-생성-과정-표현"><code class="language-plaintext highlighter-rouge">DSL</code> (<code class="language-plaintext highlighter-rouge">Domain-Specific Language</code>) : 도커 파일을 작성할 때 쓰는 언어 (도커 이미지의 생성 과정 표현)</h3>
<blockquote>
  <p>생성 과정을 표현? : 도커 파일은 일련의 인스트럭션을 실행된 결과로 도커 이미지를 생성한다.</p>
  <ul>
    <li>도커 파일의 인스트럭션과 이미지 레이어는 <code class="language-plaintext highlighter-rouge">1:1</code>의 관계를 가진다.</li>
  </ul>
</blockquote>

<iframe width="80%" height="700" style="border:none" src="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#what-is-a-dockerfile"></iframe>

<ul>
  <li>
    <h4 id="from--다른-컨테이너-이미지를-빌드의-시작점으로-지정"><code class="language-plaintext highlighter-rouge">FROM</code> : 다른 컨테이너 이미지를 빌드의 시작점으로 지정</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">AS</code>: 컨테이너에 이름을 붙일 수 있음</li>
    </ul>
  </li>
  <li>
    <h4 id="env--컨테이너-내에서-사용될-환경-변수를-지정"><code class="language-plaintext highlighter-rouge">ENV</code> : 컨테이너 내에서 사용될 환경 변수를 지정</h4>
  </li>
  <li>
    <h4 id="workdir--컨테이너-이미지의-파일-시스템에-디렉터리를-만들고-해당-디렉터리를-작업-디렉터리로-지정"><code class="language-plaintext highlighter-rouge">WORKDIR</code> : 컨테이너 이미지의 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정</h4>
  </li>
  <li>
    <h4 id="copy--로컬의-파일-시스템-내-파일-디렉터리를-컨테이너-이미지로-복사"><code class="language-plaintext highlighter-rouge">COPY</code> : 로컬의 파일 시스템 내 파일, 디렉터리를 컨테이너 이미지로 복사</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">--from=</code> : 해당 파일이 호스트 컴퓨터가 아닌 다른 컨테이너의 파일임을 알려줌</li>
    </ul>
  </li>
  <li>
    <h4 id="cmd--도커가-이미지로부터-컨테이너를-실행했을-때-실행할-명령을-지정"><code class="language-plaintext highlighter-rouge">CMD</code> : 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정</h4>
  </li>
  <li>
    <h4 id="run--빌드-과정에서-컨테이너-안에서-명령을-실행한-다음에-그-결과를-이미지-레이어에-저장"><code class="language-plaintext highlighter-rouge">RUN</code> : 빌드 과정에서 컨테이너 안에서 명령을 실행한 다음에 그 결과를 이미지 레이어에 저장</h4>
  </li>
</ul>

<h3 id="q-도커-파일을-쓰는-이유">Q. 도커 파일을 쓰는 이유?</h3>

<h4 id="a1-동일한-환경에서-어플리케이션을-실행-가능하게-한다">A1. 동일한 환경에서 어플리케이션을 실행 가능하게 한다.</h4>
<ul>
  <li>모든 빌드 과정은 도커 컨테이너 내부에서 이루어지며, 각 컨테이너는 모든 도구를 정확한 버전으로 갖추고 있다.
    <ul>
      <li>신규 개발자의 적응 기간, 빌드 서버의 관리 부담, 개발자 간의 도구 버전의 차이로 인한 빌드 실패를 줄일 수 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="a2-멀티-스테이지-환경에서-각-단계는-자신만의-캐시를-가져-성능을-향상시킬-수-있다">A2. 멀티 스테이지 환경에서 각 단계는 자신만의 캐시를 가져 성능을 향상시킬 수 있다.</h4>
<ul>
  <li>도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.
    <ul>
      <li>만약 해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당하는 단계 안으로 국한된다.</li>
      <li>이어지는 다음 단계는 캐시를 재사용하면서 시작되므로, 캐시 재사용을 통해 빌드 단계에서 시간 절약이 가능하다.</li>
    </ul>
  </li>
</ul>

<h4 id="a3-멀티-스테이지-스크립트를-통해-최종-산출물의-크기를-가능한-한-작게-유지할-수-있다">A3. 멀티 스테이지 스크립트를 통해 최종 산출물의 크기를 가능한 한 작게 유지할 수 있다.</h4>
<ul>
  <li>최종 산출물인 도커 이미지에 불필요한 도구를 제외하여 어플리케이션의 의존 모듈 자체를 줄일 수 있다.</li>
</ul>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 파일 (Dockerfile) : 서버 운영 기록을 코드로 저장한 파일을 특정 시점의 도커 이미지로 빌드]]></summary></entry><entry><title type="html">[Docker] 3. Docker Container</title><link href="http://localhost:4000/docker3/" rel="alternate" type="text/html" title="[Docker] 3. Docker Container" /><published>2023-12-07T00:00:00+09:00</published><updated>2023-12-08T00:00:00+09:00</updated><id>http://localhost:4000/docker3</id><content type="html" xml:base="http://localhost:4000/docker3/"><![CDATA[<h2 id="도커-컨테이너-docker-container--도커에서-제공하는-컨테이너-기술">도커 컨테이너 (<code class="language-plaintext highlighter-rouge">Docker Container</code>) : 도커에서 제공하는 컨테이너 기술</h2>

<blockquote>
  <p><a href="https://pocj8ur4in.github.io//docker1/#컨테이너-container--소프트웨어-패키지-software-package의-추상화">해당 부분</a>에서 이어지는 내용입니다. 이전 내용에서는 가상화의 한 종류인 컨테이너 기술에 대해 서술하였다면, 이번에는 도커를 중심으로 하여 컨테이너에 대해 다뤄보겠습니다.</p>
</blockquote>

<h3 id="도커-컨테이너는-도커가-관리하는-독립적인-가상-리소스를-가진다">도커 컨테이너는 도커가 관리하는 독립적인 가상 리소스를 가진다.</h3>
<ul>
  <li>컨테이너 안에는 어플리케이션과 그 어플리케이션의 실행 환경 (호스트명, <code class="language-plaintext highlighter-rouge">IP</code> 주소, 디스크 드라이브 등)이 들어있음
    <ul>
      <li>각 컨테이너는 독립적인 환경을 가지되, 실행되는 컴퓨터의 <code class="language-plaintext highlighter-rouge">CPU</code>, 메모리, 운영체제를 공유함
        <ul>
          <li>격리 (<code class="language-plaintext highlighter-rouge">isolation</code>)와 밀집 (<code class="language-plaintext highlighter-rouge">density</code>)의 조건을 동시에 충족</li>
          <li>빌드 - 공유 - 실행의 <code class="language-plaintext highlighter-rouge">workflow</code>으로 소프트웨어 배포를 단순화하기에 적합</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/29e20ccf-68e2-417e-82aa-deffbab42585" /></p>

<ol>
  <li>컨테이너 내부 어플리케이션이 실행중이여야 컨테이너의 상태도 실행 중이 된다.
    <ul>
      <li>컨테이너가 <code class="language-plaintext highlighter-rouge">Existed</code>인 상태에서는 <code class="language-plaintext highlighter-rouge">CPU</code> 자원이나 메모리를 사용하지 않는다.</li>
    </ul>
  </li>
  <li>컨테이너가 종료되어도, 컨테이너는 사라지지 않고 그대로 남아있다.
    <ul>
      <li>나중에 다시 컨테이너를 실행하거나, 내부 파일이나 로그를 확인해볼 수 있다.</li>
      <li>컨테이너를 백그라운드에서 계속 동작하도록 하려면, <code class="language-plaintext highlighter-rouge">-d</code> (<code class="language-plaintext highlighter-rouge">--detach</code>)</li>
    </ul>
  </li>
  <li>컨테이너는 기본적으로 외부 환경에 노출되지 않는다.
    <ul>
      <li>도커는 호스트 컴퓨터의 네트워크 계층에 끼어들어 네트워크 트래픽 중 필요한 것을 컨테이너에 전달</li>
      <li>컨테이너의 포트를 호스트 컴퓨터에 공개하려면, <code class="language-plaintext highlighter-rouge">--publish</code>
        <ul>
          <li>도커가 호스트 컴퓨터를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너에 전달</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="도커-컨테이너-또한-별도의-환경-변수-environment-variable를-가질-수-있다">도커 컨테이너 또한 별도의 환경 변수 (<code class="language-plaintext highlighter-rouge">Environment variable</code>)를 가질 수 있다.</h3>
<ul>
  <li>호스트 운영체제의 것을 가져오는 것이 아닌, <code class="language-plaintext highlighter-rouge">IP</code> 주소나 호스트 이름처럼 도커로부터 부여받음</li>
</ul>

<h2 id="도커-이미지-docker-image--컨테이너의-실행에-필요한-모든-파일과-설정값-정보를-포함">도커 이미지 (<code class="language-plaintext highlighter-rouge">Docker Image</code>) : 컨테이너의 실행에 필요한 모든 파일과 설정값 정보를 포함</h2>
<ul>
  <li>상태값을 가지지 않음 (변하지 않는 값들을 저장) ↔ 컨테이너 : 이미지가 실행된 살태 (변하는 값들을 저장)</li>
  <li>이미지 레이어 : 도커 이미지는 여러 <code class="language-plaintext highlighter-rouge">Read-Only</code> 레이어로 구성되고, 파일 추가 및 생성 시 새로운 레이어 생성
    <ul>
      <li>이미지 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일로, 여러 이미지와 컨테이너에서 공유함</li>
      <li>유니온 파일 시스템 (<code class="language-plaintext highlighter-rouge">Union File Systems</code>)읕 통해 여러 개의 레이어를 하나의 파일 시스템으로 활용</li>
    </ul>
  </li>
</ul>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">docker image ls</code>에서 도커 이미지의 <code class="language-plaintext highlighter-rouge">SIZE</code>는 논리적 용량이지 실제로 차지하는 디스크 용량이 아니다!</li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/9ea0b979-d07d-4a66-900a-e3ecd0c3142b" /></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">docker system df</code>를 통해 이미지 전체 용량의 총합을 볼 수 있다.</li>
  </ul>

  <p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/7c554710-303b-4e28-81df-e699a9fbbe89" /></p>
</blockquote>

<ul>
  <li>컨테이너 레이어 : 컨테이너가 실행되면 이미지 레이어 위에 읽기-쓰기 (<code class="language-plaintext highlighter-rouge">Read-Write</code>) 레이어를 추가
    <ul>
      <li>컨테이너를 실행하면서 생성되거나 변경된 내용을 저장</li>
    </ul>
  </li>
  <li>이미지 경로 : <code class="language-plaintext highlighter-rouge">URL</code> 방식으로 관리 -&gt; 뒤에 태그 (<code class="language-plaintext highlighter-rouge">/tag</code>)를 붙임</li>
</ul>

<h3 id="q-도커-이미지를-쓰는-이유--도커-이미지와-도커-컨테이너들을-클래스나-인스턴스처럼-활용한다">Q. 도커 이미지를 쓰는 이유? : 도커 이미지와 도커 컨테이너들을 클래스나 인스턴스처럼 활용한다.</h3>
<ul>
  <li>도커는 해시 값 (= 컨테이너 ID)과 임의의 이름 (= 컨테이너 이름)를 통해 컨테이너를 구분하고 이들을 환경변수로 관리</li>
</ul>

<div style="color: white; padding: 3% 2% 2% 2%; background-color: black;">
운영자가 지금까지 운영한 서버를 도커 이미지로 배포하고 도커 컨테이너에 설치한다면,
<ul>
  <li>도커 파일 : 지금까지 서버를 운영한 기록</li>
  <li>도커 이미지 (도커 파일 + 실행 시점) : 지금부터 설치된 서버가 가질 초기값</li>
  <li>도커 컨테이너 (도커 파일 + 환경 변수) : 지금부터 설치된 서버가 운영될 장소</li>
</ul>
</div>
<ul>
  <li>도커 안에서는 서버 역시 하나의 소프트웨어처럼 사용할 수 있고, 생성할 수 있는 컨테이너의 개수에도 제한이 없다.</li>
</ul>

<h3 id="도커-허브-docker-hub--도커-이미지를-서버에-공유하는-도커-레지스트리-서비스"><a href="https://hub.docker.com">도커 허브 (<code class="language-plaintext highlighter-rouge">Docker Hub</code>)</a> : 도커 이미지를 서버에 공유하는 도커 레지스트리 서비스</h3>

<ul>
  <li>도커 허브 계정을 생성한 후, 터미널을 통해 도커 허브에 접속</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker login --username pocj8ur4in
Password:
Login Succeeded
</code></pre></div></div>

<ul>
  <li>도커 이미지의 다운로드를 위한 이미지 참조 (<code class="language-plaintext highlighter-rouge">Image Reference</code>)는 네 개의 요소로 구성
    <ol>
      <li>이미지가 저장된 레지스트리 도메인 (기본값은 도커 허브)</li>
      <li>이미지 작성자 계정 <code class="language-plaintext highlighter-rouge">ID</code></li>
      <li>이미지 레포지토리 <code class="language-plaintext highlighter-rouge">ID</code></li>
      <li>이미지 태그 (기본값은 <code class="language-plaintext highlighter-rouge">latest</code>)</li>
    </ol>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker.io/diamol/golang:latest
</code></pre></div></div>

<ul>
  <li>이미지에 새로운 이미지 참조를 부여하여, 한 이미지에 여러 개의 참조를 갖게 할 수도 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image tag new-tag pocj8ur4in/vw-api:latest
</code></pre></div></div>

<h3 id="사설-도커-레지스트리-private-docker-registry--로컬에-전용-레지스트리를-설치-및-운영"><a href="https://waspro.tistory.com/532">사설 도커 레지스트리 (<code class="language-plaintext highlighter-rouge">Private Docker Registry</code>) : 로컬에 전용 레지스트리를 설치 및 운영</a></h3>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 컨테이너 (Docker Container) : 도커에서 제공하는 컨테이너 기술]]></summary></entry><entry><title type="html">[Docker] 2. Docker</title><link href="http://localhost:4000/docker2/" rel="alternate" type="text/html" title="[Docker] 2. Docker" /><published>2023-12-05T00:00:00+09:00</published><updated>2023-12-05T00:00:00+09:00</updated><id>http://localhost:4000/docker2</id><content type="html" xml:base="http://localhost:4000/docker2/"><![CDATA[<h2 id="도커-docker--컨테이너-기반-가상화-container-based-virtualization">도커 (<code class="language-plaintext highlighter-rouge">Docker</code>) : 컨테이너 기반 가상화 (<code class="language-plaintext highlighter-rouge">Container-based Virtualization</code>)</h2>

<p><img src="https://pyrasis.com/assets/images/Docker-HOWTO/docker-containerized-appliction-blue-border_2.png.webp" width="50%" /></p>

<h3 id="q-도커를-쓰는-이유--비교적-효율적인-가상화-방식--통일된-개발-환경--배포의-동시성">Q. 도커를 쓰는 이유? : 비교적 효율적인 가상화 방식 + 통일된 개발 환경 + 배포의 동시성</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Virtualization</code> : 응용 프로그램 실행 시 운영체제 수준 가상화 방식이 성능 손실이 더 적고 빠르게 동작한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Development</code> : 운영체제에 상관없이 같은 환경에서 개발할 수 있게 해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">Deployment</code> : 서비스 환경과 응용 프로그램을 같이 배포할 수 있게 한다.</li>
</ol>

<blockquote>
  <ul>
    <li>분산 어플리케이션을 클라우드 환경으로 이주한다고 가정하면,
      <ul>
        <li><code class="language-plaintext highlighter-rouge">IaaS</code> : 서비스로서의 인프라
          <ul>
            <li>어플리케이션을 구성하는 각 컴포넌트가 모두 가상 머신에서 독립적으로 동작</li>
            <li>이주 과정은 쉽지만, 가상 머신의 성능을 모두 활용하지 못하며 운영비가 비쌈</li>
          </ul>
        </li>
        <li><code class="language-plaintext highlighter-rouge">PaaS</code> : 서비스로서의 플랫폼
          <ul>
            <li>어플리케이션을 구성하는 각 컴포넌트가 클라우드 서비스 제공자의 매니지드 서비스에 종속</li>
            <li>운영비가 저렴하고 관리가 쉬우나, 이주 과정이 복잡함</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <p>… 도커를 활용한다면? : 각 컴포넌트를 컨테이너로 이주하고, 쿠버네티스 등으로 전체 어플리케이션 관리 가능</p>
</blockquote>

<ul>
  <li><a href="https://www.docker.com">공식 홈페이지</a>에서 <code class="language-plaintext highlighter-rouge">.dmg</code> 파일을 다운로드 후 설치</li>
  <li>터미널 창에 다음 명령어를 입력해 도커가 정상적으로 설치되었는지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker version // 현재 도커의 버전 확인

Client:
 Cloud integration: ~
 Version:           ~
 API version:       ~
 Go version:        ~

Server: ~
 Engine:
  Version:          ~
  API version:      ~
  Go version:       ~
</code></pre></div></div>
<blockquote>
  <p>Q. 클라이언트와 서버의 버전 정보가 따로 구성되어 있는 이유?</p>
  <ul>
    <li>도커가 클라이언트와 서버의 역할을 각각 수행할 수 있음
      <ul>
        <li>리눅스 터미널에 도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 출력</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="도커-컴포넌트-docker-component--도커-엔진을-중심으로-여러-컴포넌트를-조합해-구성">도커 컴포넌트 (<code class="language-plaintext highlighter-rouge">Docker Component</code>) : 도커 엔진을 중심으로 여러 컴포넌트를 조합해 구성</h2>

<ul>
  <li>
    <h3 id="도커-엔진-docker-engine--도커-이미지를-생성하고-컨테이너를-관리">도커 엔진 (<code class="language-plaintext highlighter-rouge">Docker Engine</code>) : 도커 이미지를 생성하고 컨테이너를 관리</h3>
    <ul>
      <li>로컬 이미지 캐시 담당 : 새로운 이미지가 필요할 때 이미지를 다운로드하거나, 기존 이미지를 사용</li>
      <li><code class="language-plaintext highlighter-rouge">Docker API</code>을 통해 맡은 기능 수행 → 도커 명령행 인터페이스 (<code class="language-plaintext highlighter-rouge">Docker CLI</code>)에서 도커 <code class="language-plaintext highlighter-rouge">API</code> 호출</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-레지스트리-docker-registry--도커-이미지를-공개하고-공유">도커 레지스트리 (<code class="language-plaintext highlighter-rouge">Docker REgistry</code>) : 도커 이미지를 공개하고 공유</h3>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Docker</code> 공식 레지스트리 서비스로 <code class="language-plaintext highlighter-rouge">Docker Hub</code>가 있음</li>
      <li>클라우드 사업자 또한 <code class="language-plaintext highlighter-rouge">AWS ECR</code>, <code class="language-plaintext highlighter-rouge">GCP Artifact Registry</code> 등의 컨테이너 레지스트리 제공</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-컴포즈-docker-compose--여러-컨테이너를-하나의-서비스로-정의해-컨테이너의-묶음으로-관리">도커 컴포즈 (<code class="language-plaintext highlighter-rouge">Docker Compose</code>) : 여러 컨테이너를 하나의 서비스로 정의해 컨테이너의 묶음으로 관리</h3>
    <ul>
      <li>여러 개의 컨테이너 구성 정보를 코드로 정의한 파일을 읽어 컨테이너를 순차적으로 생성</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-머신-docker-machine--가상-호스트에-도커-엔진을-설치하여-호스트를-관리">도커 머신 (<code class="language-plaintext highlighter-rouge">Docker Machine</code>) : 가상 호스트에 도커 엔진을 설치하여 호스트를 관리</h3>
    <ul>
      <li>여러 운영체제나 클라우드 환경에서 도커를 동일하게 실행하기 위해 도커의 실행 환경을 자동으로 생성</li>
    </ul>
  </li>
  <li>
    <h3 id="도커-스왐-docker-swarm--여러-도커-호스트를-클러스터화해-관리">도커 스왐 (<code class="language-plaintext highlighter-rouge">Docker Swarm</code>) : 여러 도커 호스트를 클러스터화해 관리</h3>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Manger</code>가 클러스트를 관리하거나 <code class="language-plaintext highlighter-rouge">API</code>를 제공하고, <code class="language-plaintext highlighter-rouge">Node</code>가 컨테이너를 실행</li>
    </ul>
  </li>
</ul>

<h2 id="도커-명령어-docker-command--docker-command-형식으로-구성">도커 명령어 (<code class="language-plaintext highlighter-rouge">Docker Command</code>) : <code class="language-plaintext highlighter-rouge">docker &lt;command&gt;</code> 형식으로 구성</h2>
<ul>
  <li>리눅스 터미널에 도커 명령어를 입력하면 도커 서버에서 이에 해당되는 작업 수행</li>
  <li>항상 <code class="language-plaintext highlighter-rouge">root</code> 권한으로 실행되기에 <code class="language-plaintext highlighter-rouge">$ sudo</code>를 앞에 붙어야 함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo usermod -aG docker $USER # 현재 사용자를 docker 그룹에 추가
</code></pre></div></div>

<div style="text-align: center;">
    <table>
        <thead>
            <tr>
                <td>docker 명령어</td>
                <td>명령어 형식</td>
                <td>명령어 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>docker search</td>
                <td>$ docker search [이미지]</td>
                <td>도커 허브에서 이미지 검색</td>
            </tr>
            <tr>
                <td>docker pull</td>
                <td>$ docker pull [사용자명/] 이미지 [:태그]</td>
                <td>도커 허브에서 이미지 다운로드<br />사용자명을 지정해 도커 허브에서 해당 사용자가 올린 이미지을 다운로드<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker images</td>
                <td>$ docker images</td>
                <td>사용 가능한 모든 이미지 목록 확인</td>
            </tr>
            <tr>
                <td>docker rmi</td>
                <td>$ docker rmi 이미지 [:태그]</td>
                <td>다운로드한 이미지 삭제<br />태그로 버전을 지정해 다운로드 (latest : 최신 버전)</td>
            </tr>
            <tr>
                <td>docker run</td>
                <td>$ docker run [옵션] [실행할 이미지]</td>
                <td>이미지를 컨테이너로 생성한 뒤 컨테이너 실행<br />입력받은 이미지가 현재 없다면, 해당 이미지를 도커 허브에서 다운로드<br />실행할 파일을 지정해 직접 실행 가능 (여기서 빠져나오면 컨테이너가 정지)<br /><div style="text-align: center; font-size: 120%; padding: 2% 0% 0% 0%">
    <table>
        <thead>
            <tr>
                <td>docker run 옵션</td>
                <td>옵션 설명</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>-d</td>
                <td>백그라운드 모드 (detached mode)</td>
            </tr>
            <tr>
                <td>-p [호스트 포트:컨테이너 포트]</td>
                <td>호스트와 컨테이너의 포트를 연결 (port forwarding)<br />http://호스트 IP:호스트 포트로 컨테이너의 포트 접속</td>
            </tr>
            <tr>
                <td>-v [호스트의 디렉터리]</td>
                <td>호스트의 디렉터리를 컨테이너의 디렉터리에 연결 (mount)</td>
            </tr>
            <tr>
                <td>-e [환경변수]</td>
                <td>컨테이너 내에서 사용할 환경변수 설정 (environment variable)</td>
            </tr>
            <tr>
                <td>--name [컨테이너 이름]</td>
                <td>컨테이너 이름 설정 (container name)</td>
            </tr>
            <tr>
                <td>-rm</td>
                <td>프로세스 종료 시 컨테이너 자동으로 제거 (remove container)</td>
            </tr>
            <tr>
                <td>-link [컨테이너 이름:주소]</td>
                <td>컨테이너와 컨테이너 연결 (link container)<br />[주소:포트번호]로 컨테이너에 접속</td>
            </tr>
            <tr>
                <td>-it</td>
                <td>리눅스 터미널 입력을 위한 옵션 (interactive / Pseudo-tty)</td>
            </tr>
         </tbody>
    </table>
</div></td>
            </tr>
            <tr>
              <td>docker ps</td>
              <td>$ docker ps [옵션]</td>
              <td>실행중인 모든 컨테이너 목록 확인<br />-a 옵션으로 정지된 컨테이너까지 모두 검색</td>
            </tr>
            <tr>
              <td>docker start</td>
              <td>$ docker start [컨테이너 이름 | 컨테이너 ID]</td>
              <td>정지된 컨테이너 재시작</td>
            </tr>
            <tr>
              <td>docker stop</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너 정지</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker exec</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]<br />[명령] [매개 변수]</td>
              <td>컨테이너 외부에서 컨테이너 내의 명령 실행</td>
            </tr>
            <tr>
              <td>docker diff</td>
              <td>$ docker diff [컨테이너 이름 | 컨테이너 ID]</td>
              <td>컨테이너가 실행되면서 변경된 파일 목록 확인<br />A : 추가된 파일<br />C : 변경된 파일<br />D : 삭제된 파일</td>
            </tr>
            <tr>
              <td>docker cp</td>
              <td>$ docker cp [컨테이너 이름 | 컨테이너 ID]<br />[:컨테이너 경로] [호스트 경로]</td>
              <td>컨테이너의 파일을 호스트의 디렉토리로 복사</td>
            </tr>
            <tr>
              <td>docker attach</td>
              <td>$ docker attach [컨테이너 이름 | 컨테이너 ID]</td>
              <td>실행 중인 컨테이너에 접속</td>
            </tr>
            <tr>
              <td>docker rm</td>
              <td>$ docker exec [컨테이너 이름 | 컨테이너 ID]</td>
              <td>생성된 컨테이너 삭제</td>
            </tr>
            <tr>
              <td>docker commit</td>
              <td>$ docker commit [옵션] [컨테이너 이름 | 컨테이너 ID]<br />[이미지 이름] [:태그]</td>
              <td>컨테이너를 이미지 파일로 생성</td>
            </tr>
            <tr>
              <td>docker build</td>
              <td>$ docker build [옵션] [도커 파일 경로]<br />[--tag 이미지 이름 : 이미지 태그] </td>
              <td>도커 파일에 설정된 내용대로 도커 이미지 생성<br />--tag 뒤에 이미지 이름와 이미지 태그를 설정할 수 있음</td>
            </tr>
            <tr>
              <td>docker history</td>
              <td>$ docker history [이미지 이름 | 이미지 ID] [:태그]</td>
              <td>도커 파일에 설정된 내용대로 이미지 히스토리 생성</td>
            </tr>
            <tr>
              <td>docker inspect</td>
              <td>$ docker inspect<br />[이미지나 컨테이너 이름 | 이미지나 컨테이너 ID]</td>
              <td>이미지나 컨테이너의 세부 정보 출력</td>
            </tr>
         </tbody>
    </table>
</div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Docker" /><summary type="html"><![CDATA[도커 (Docker) : 컨테이너 기반 가상화 (Container-based Virtualization)]]></summary></entry><entry><title type="html">[Github Pages] 6. Github Pages 블로그 기능 추가</title><link href="http://localhost:4000/blog6/" rel="alternate" type="text/html" title="[Github Pages] 6. Github Pages 블로그 기능 추가" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-10-06T00:00:00+09:00</updated><id>http://localhost:4000/blog6</id><content type="html" xml:base="http://localhost:4000/blog6/"><![CDATA[<blockquote>
  <p>이 게시물은 Github Pages 블로그, 혹은 Minimal Mistakes 테마에 없는 기능들을 추가해나간 기록들이다. html이나 css를 다룰 줄 알면 금방 할 수 있는, 혹은 다 구글링하면 나오는 내용들이긴 하지만 내가 어떻게 문제를 인식하여 어떤 과정을 거쳐 이를 해결하였는지, 에 대해 자세히 쓰고 싶었다. 그래서 이 게시물은 다른 게시물들과 달리, 내가 블로그에서 부족하다고 느낀 점들을 계속 조금씩이라도 보충해나갈 계획이다.</p>
</blockquote>

<h2 id="1-블로그-댓글-feat-disqus-giscus">1. 블로그 댓글 (feat. disqus, giscus)</h2>
<p>앞서 서술한 게시물을 보면 Github Pages는 정적 웹 사이트 호스팅 서비스라는 말이 있다. 모든 웹 페이지를 미리 생성하고, 방문자로부터 요청이 들어오면 미리 만든 웹 페이지를 그대로 응답한다는 건데, 사용자와 동적으로 정보를 주고받아야 하는 댓글 등의 기능은 불가능하다는 것이다.<br /></p>

<p>그래서 처음에는 댓글 플랫폼인 <a href="https://disqus.com">disqus</a>를 통해 이를 해결하고자 하였다. 방법은 간단한데, 사이트에 가입하고 무료 플랜을 구독한 다음에 <code class="language-plaintext highlighter-rouge">_config.yml</code>를 다음과 같이 수정해주기만 하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>comments:
  provider               : "disqus" # 댓글 제공자 지정
  disqus:
    shortname            :          # disqus ID 지정
</code></pre></div></div>

<p>그런데 disqus에서 제공하는 기능인 ‘SNS로 댓글 달기’은 개발자 친화적인 기능은 아니였고, 또 나중에는 광고가 노출되기 시작했다. 그래서 대안으로 찾은 게 <a href="https://giscus.app/ko">giscus</a>인데, GitHub Discussions로 작동하고, 마크다운도 지원하면서 대댓글이나 반응과 같은 자잘한 기능들이 마음에 들었다.</p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/d0db9e9a-29a3-4529-918e-f9ae0ddc9b65" width="100%" /></p>

<p>적용하는 방법도 Github 앱을 저장소에 설치한 뒤에 html 파일에 아래의 스크립트를 넣어주기만 하면 되는데, 나 같은 경우에는 Minimal Mistakes 테마에서 <code class="language-plaintext highlighter-rouge">_includes/social_share.html</code> 파일에 해당 구문을 넣어 적용시켰다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;section class="page__share"&gt;
  &lt;script src="https://giscus.app/client.js"
    data-repo="pocj8ur4in/pocj8ur4in.github.io"
    data-repo-id="R_kgDOICGarA"
    data-category="Q&amp;A"
    data-category-id="DIC_kwDOICGarM4CZ65L"
    data-mapping="pathname"
    data-strict="1"
    data-reactions-enabled="0"
    data-emit-metadata="1"
    data-input-position="top"
    data-theme="dark_dimmed"
    data-lang="ko"
    data-loading="lazy"
    crossorigin="anonymous"
    async&gt;
  &lt;/script&gt;
&lt;/section&gt;
</code></pre></div></div>

<h2 id="2-블로그-google-검색-노출-및-검색-설정">2. 블로그 Google 검색 노출 및 검색 설정</h2>
<p>아무래도 블로그를 운영하다 보면 다른 사람들의 반응이 궁금할 때가 많은데, 아무것도 설정하지 않은 블로그는 검색되지 않는다는 사실을 깨닫고 해결책을 찾아보았다. <a href="https://search.google.com/search-console/about">Google Search Console</a>에서 내 도메인을 입력한 다음에 소유권 확인을 위해 다운받은 <code class="language-plaintext highlighter-rouge">.HTML</code>파일을 <code class="language-plaintext highlighter-rouge">root</code>에 위치시키만 하면 며칠 안으로 아래와 같이 적용된다.</p>

<p><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5876c2af-191d-47d7-ab9e-f3c2c55bde32" width="70%" /></p>

<p>추가로 블로그 포스트들이 검색 엔진에 검색되는 것을 가능하도록 진행할 작업들이 있는데, 먼저 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일에서 아래 설정들을 <code class="language-plaintext highlighter-rouge">true</code>로 설정한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>search                   : # 블로그 검색 여부 지정
search_full_content      : # 블로그의 내용 검색 여부 지정
</code></pre></div></div>

<p>그리고 웹 크롤링을 위해 <a href="https://github.com/pocj8ur4in/pocj8ur4in.github.io/blob/main/sitemap.yml"><code class="language-plaintext highlighter-rouge">sitemap.yml</code></a>과 <code class="language-plaintext highlighter-rouge">robots.txt</code> 파일을 생성해 <code class="language-plaintext highlighter-rouge">root</code>에 위치시키면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: *
Allow: /

# 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 차단
User-agent: *
Disallow: /

# 구글 검색 로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: Googlebot
Disallow: /

# 네이버 검색로봇만 차단하고, 다른 모든 웹 사이트 컨텐츠에 대한 모든 웹 크롤러의 접근 허용
User-agent: Yeti
Disallow: /

Sitemap: https://pocj8ur4in.github.io/sitemap.xml
</code></pre></div></div>

<p>만약에 블로그의 방문자 수 통계를 보고 싶다면, <a href="https://analytics.google.com/analytics/web/provision/#/provision">Google Analytics</a>를 가입한 후 애널리틱스 데이터 스트림을 설정하면 된다. 이때, 측정 ID를 복사한 후 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일을 다음과 같이 수정하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Analytics
analytics:
  provider               : "google-gtag"
  google:
    tracking_id          : "(측정 ID)"
</code></pre></div></div>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Github Pages" /><summary type="html"><![CDATA[이 게시물은 Github Pages 블로그, 혹은 Minimal Mistakes 테마에 없는 기능들을 추가해나간 기록들이다. html이나 css를 다룰 줄 알면 금방 할 수 있는, 혹은 다 구글링하면 나오는 내용들이긴 하지만 내가 어떻게 문제를 인식하여 어떤 과정을 거쳐 이를 해결하였는지, 에 대해 자세히 쓰고 싶었다. 그래서 이 게시물은 다른 게시물들과 달리, 내가 블로그에서 부족하다고 느낀 점들을 계속 조금씩이라도 보충해나갈 계획이다.]]></summary></entry><entry><title type="html">[Github Pages] 5. Github Pages 블로그 설정 &amp;amp; 포스트</title><link href="http://localhost:4000/blog5/" rel="alternate" type="text/html" title="[Github Pages] 5. Github Pages 블로그 설정 &amp;amp; 포스트" /><published>2023-04-05T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/blog5</id><content type="html" xml:base="http://localhost:4000/blog5/"><![CDATA[<blockquote>
  <p>솔직히 블로그 설정을 건드는 부분은 내가 아는 정보들을 그대로 나열할 수 밖에 없다고 생각한다… 그래도 내가 시행착오를 겪었던 경험을 떠올리면서 하나하나 풀어서 작성하려 하였으니, 미숙한 글이지만 남들에게 도움이 되었으면 정말 좋겠다… 그리고 Github Pages이나 Minimal Mistakes으로 처음 블로그를 운영하시는 분들의 시선에 맞춰 html, css에 대한 자세한 내용은 다른 포스트로 옮겼으니 참고해주셨으면 한다.</p>
</blockquote>

<h2 id="1-블로그-기본-설정">1. 블로그 기본 설정</h2>
<p><img width="228" alt="blog1-1" src="https://user-images.githubusercontent.com/105341168/229804167-bbb75af4-6ec4-4683-9753-0f2cbf7d97bb.png" /></p>

<p>위의 디렉터리에서 <code class="language-plaintext highlighter-rouge">_config.yml</code>이라는 파일을 열어보면 다음과 같이 구성되어 있는데, 오른쪽의 주석을 참조해서 나만의 블로그를 커스텀마이징해보자. 이걸 어떻게 적용하는지 잘 모르겠다, 싶은 사람은 <a href="https://github.com/pocj8ur4in/pocj8ur4in.github.io/blob/main/_config.yml">내 블로그에 적용된 것</a>을 예시로 보면서 작업해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minimal_mistakes_skin    :         # 블로그의 전체적인 스킨 지정 
                                   # (Minimal Mistakes에서 기본적으로 제공)
                                   # "default" "air", "aqua", "contrast", "dark"
                                   # "dirt", "neon", "mint", "plum", "sunrise"

# Site Settings
locale                   : "ko-KR" # 블로그에 쓰일 로컬 언어 지정
title                    :         # 메타 태그에 들어갈 블로그의 제목 지정
subtitle                 :         # 블로그의 제목 하단에 위치할 부제목 지정
name                     :         # 블로그 저자 이름 지정
description              :         # SEO 향상을 위한 meta description 태그 지정
url                      :         # 블로그 url 
                                   # "https://(github ID).github.io"
repository               :         # github repository url
                                   # "https://github.com/(github ID)/(github ID).github.io"
teaser                   :         # 관련 포스트나 검색 등에 들어갈 미리보기 이미지 지정
                                   # ("assets/images/"로 연결)
logo                     :         # 블로그의 제목 옆에 들어갈 로고 이미지 지정
                                   # ("assets/images"로 연결)
masthead_title           :         # 블로그 프로필 상단에 위치할 사이트 제목 지정
breadcrumbs              : true    # 브래드크럼 사용 여부 지정
words_per_minute         : 200     # 포스트를 읽는 데 걸리는 시간을 계산히기 위한 분당 읽는 글자의 지정
</code></pre></div></div>

<h2 id="2-블로그-레이아웃-설정">2. 블로그 레이아웃 설정</h2>
<p>이제 조금은 삭막한(?) 블로그의 레이아웃을 뜯어고칠 차례이다. 우선은 이전처럼 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일을 아래와 같이 자신이 원하는 대로 수정하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 블로그 좌측 사이드바에 위치할 프로필 설정
author:
  name             :       # 저자 이름 지정
  avatar           :       # 저자 이미지 지정
  bio              :       # 저자 바이오그래피 지정
  location         :       # 저자 위치 지정
  email            :       # 저자 이메일 지정
  links:                   # 저자 관련 사이트 링크 지정
    - label:               # 사이트 분류 지정
      icon:                # 사이트 아이콘 지정
      url:                 # 사이트 url 지정

## 블로그 하단에 위치할 꼬리말 설정
footer:
  links:                   # 블로그 관련 사이트 링크 지정
    - label:               # 사이트 분류 지정
      icon:                # 사이트 아이콘 지정
      url:                 # 사이트 url 지정
</code></pre></div></div>

<h3 id="1-네비게이션-바">(1) 네비게이션 바</h3>

<p>다음은 기본 테마를 보면서 혹은 자기가 기능을 적용하면서 불편한 점들을 확인하고, 직접 테마의 요소들을 뜯어고치는 건데… 이건 사람마다 달라서 뭐라고 말을 못하겠다. 그래서 나 같은 경우에 어떤 부분이 불편했고, 그래서 수정했는지 얘기해보고자 한다. 우선은 블로그 상단의 네비게이션 바에 내가 보기에 불필요한 카테고리들이 있었다. 그래서 카테고리, 태그만 남기기 위해  <code class="language-plaintext highlighter-rouge">_data/navigation.yml</code> 파일을 수정하였다.  <code class="language-plaintext highlighter-rouge">_pages</code> 디렉토리를 보면 여기에 적용할 수 있는 여러 요소들이 있는데, 직접 입맛에 맛게 적용해보면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
  - title: (카테고리)        # 화면에 보여질 세부 항목의 이름 지정
    url: /(카테고리)/        # _pages 내에 정해진 양식 파일이나 특정 링크로 연결
</code></pre></div></div>

<h3 id="2-블로그-너비-및-폰트-크기">(2) 블로그 너비 및 폰트 크기</h3>

<p>그리고 블로그에 포스트를 쓸 때에 한쪽에는 VS Code를, 다른 쪽에는 로컬에서 호스팅한 블로그를 보기 위한 사파리 브라우저를 띄워 놓곤 했는데, 그때마다 기본으로 설정된 블로그 너비랑 폰트 크기가 글을 읽기에 굉장히 불편했다. 그래서 <code class="language-plaintext highlighter-rouge">_sass/minimal_mistakes/_variables.scss</code> 파일과 <code class="language-plaintext highlighter-rouge">_sass/minimal_mistakes/_reset.scss</code> 파일을 다음과 같이 수정해보았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 블로그 너비 설정
/*
   Grid
   ========================================================================== */

$right-sidebar-width-narrow: 200px !default;    // default 200px
$right-sidebar-width: 300px !default;           // default 300px
$right-sidebar-width-wide: 400px !default;      // default 400px
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 블로그 폰트 크기 설정
html {
  /* apply a natural box layout model to all elements */
  box-sizing: border-box;
  background-color: $background-color;
  font-size: 16px;                    // Default 16px;

  @include breakpoint($medium) {
    font-size: 16px;                  // Default 18px;
  }

  @include breakpoint($large) {
    font-size: 16px;                  // Default 20px;
  }

  @include breakpoint($x-large) {
    font-size: 16px;                  // Default 22px;
  }

  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
</code></pre></div></div>

<h3 id="3-블로그-아이콘">(3) 블로그 아이콘</h3>

<p>또 블로그 주소 창에 같이 뜰 아이콘이 아무것도 안 뜨니 뭔가 내 블로그 같다는 느낌이 안들었다. 그래서 이것 또한 <code class="language-plaintext highlighter-rouge">_includes/_head/custom.html</code> 파일에 내가 원하는 아이콘을 넣었다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- start custom head snippets --&gt;

&lt;!-- insert favicons. use https://realfavicongenerator.net/ --&gt;
&lt;link rel="apple-touch-icon" sizes="180x180" href="/assets/logo.ico/apple-touch-icon.png"&gt;
&lt;link rel="icon" type="image/png" sizes="32x32" href="/assets/logo.ico/favicon-32x32.png"&gt;
&lt;link rel="icon" type="image/png" sizes="16x16" href="/assets/logo.ico/favicon-16x16.png"&gt;
&lt;link rel="mask-icon" href="/assets/logo.ico/safari-pinned-tab.svg" color="#ffffff"&gt;
&lt;meta name="msapplication-TileColor" content="#ffffff"&gt;
&lt;meta name="theme-color" content="#ffffff"&gt;
</code></pre></div></div>

<p>내가 수정한 것은 이정도? 인데 자잘하게 더 파고들면 커스텀마이징할 레이아웃 요소가 정말 많다. html, css, yml 파일을 건드는 것이라 그리 어렵지도 않고, 한번 배워두면 생각보다 쓸 때도 많다. 아래는 Minimal Mistakes Themes의 디렉토리 구조에 주석을 단 것인데, 커스텀마이징이 필요할 때 이를 참고하기 좋은 것 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minimal-mistakes
├── _data                                 # 테마를 커스터마이징하기 위한 파일을 저장하는 디렉터리 
| |                                       # (yml, yaml, json, csv, tsv 파일을 자동으로 읽어들어 site.data로 사용)
| ├── navigation.yml                      # 상단 메뉴바를 커스터마이징하기 위한 파일
| └── ui-text.yml                         # 언어별로 어떤 텍스트로 표시되는지 나열하는 파일
|
├── _site                                 # 재사용되는 html 파일을 저장하는 디렉터리 (공통된 컴포넌트들 보관)
| ├── search                              # 검색 엔진을 커스터마이징한 내용을 저장하는 디렉터리
| ├── analytics-providers
| └── custom.html                         # 분석 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일
| ├── comments-providers
| └── custom.html                         # 댓글 플랫폼 공급자를 커스터마이징한 내용을 저장하는 파일
| ├── head
| └── custom.html                         # head를 커스터마이징한 내용을 저장하는 파일
| ├── footer
| └── custom.html                         # footer를 커스마이징한 내용을 저장하는 파일
| ├── nav_list                            # 메뉴 상단바의 리스트에 대한 helper 파일
| ├── archive-single.html                 # 아카이브 문서에서 단일 문서를 표현하는 방법을 저장하는 파일
| ├── author-profiles.html                # author profile link애 대한 내용을 저장하는 파일
| ├── author-profile-custom-links.html    # author profile link를 커스마이징한 내용을 저장하는 파일
| ├── breadcrumbs.html                    # breadcrumbs에 대한 내용을 저장하는 파일
| ├── single-page
| ├── page__taxonomy.html                 # 단일 문서에서 태그와 카테고리를 표현하는 방법을 저장하는 파일
| ├── tag-list.html                       # 단일 문서에서 태그 리스트를 표현하는 방법을 저장하는 파일
| └── category-list.html                  # 단일 문서에서 카테고리 리스트를 표현하는 방법을 저장하는 파일
├── _posts                                # 블로그에 포스트한 md 파일을 저장하는 디렉터리
├── _includes
├── _layouts                              # 각 문서의 디자인과 직접적으로 연결된 전체적인 레이아웃 디렉토리
├── _sass                                 # minimal-mistakes.scss에 임포트할 수 있는 scss 파일을 저장하는 스타일시트 디렉터리
├── assets                                # css, js, 이미지 파일을 저장하는 디렉터리
| ├── _css
| ├── _images
| └── _js 
├── _config.yml                           # 블로그를 구성하기 위한 기본적인 설정값을 설정하는 yml 파일
├── Gemfile                               # 사용할 gem 플러그인 목록
├── index.html                            # 블로그 처음 홈 페이지
└── package.json
</code></pre></div></div>

<h2 id="3-블로그-포스트-작성-및-머릿말-작성">3. 블로그 포스트 작성 및 머릿말 작성</h2>
<p><code class="language-plaintext highlighter-rouge">_posts</code> 폴더에 <code class="language-plaintext highlighter-rouge">XXXX(YEAR)-XX(MONTH)-XX(DAY)-(NAME).md</code>을 생성해보자. 이때 YEAR, MONTH, DAY는 포스트가 작성된 연도, 월, 일이 되고 NAME은 포스트의 경로가 된다. 그리고 파일 상단에 위치할 머릿말을 작성하기 위해 아래와 같이 <code class="language-plaintext highlighter-rouge">---</code>에 둘러싸인 내용을 작성해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
title: "[Blog] macOS에서 Minimal Mistakes로 깃허브 블로그 만들기"

categories:
    - Github.io

tag:
    [HTML, JavaScript, SCSS, Ruby]

toc: true
toc_sticky: true

date: 2022-09-26
lastmod: 2022-09-26
---
</code></pre></div></div>

<table>
    <thead>
        <tr>
            <th>양식 이름</th>
            <td>양식 설명</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>title</th>
            <td>포스트 제목</td>
        </tr>
        <tr>
            <th>categories</th>
            <td>포스트 카테고리</td>
        </tr>
        <tr>
            <th>tags</th>
            <td>포스트 태그</td>
        </tr>
        <tr>
            <th>toc</th>
            <td>우측 상단의 목차</td>
        </tr>
        <tr>
            <th>toc_label</th>
            <td>목차 이름</td>
        </tr>
        <tr>
            <th>toc_icon</th>
            <td>목차 아이콘</td>
        </tr>
        <tr>
            <th>toc_sticky</th>
            <td>목차 고정 여부</td>
        </tr>
        <tr>
            <th>date</th>
            <td>포스트 작성일</td>
        </tr>
        <tr>
            <th>lastmod</th>
            <td>포스트 수정일</td>
        </tr>
        <tr>
            <th>author_profile</th>
            <td>프로필 창 표시 여부</td>
        </tr>
    </tbody>
</table>

<p>우리가 글을 작성하는 데에 사용할 <a href="https://www.markdownguide.org/getting-started/">Markdown</a>은 텍스트 기반의 마크업 (MarkUp) 언어로, 특수기호와 문자를 활용한 매우 간단한 구조의 문법을 사용해 보다 빠르게 컨텐츠를 작성할 수 있다! Github의 <code class="language-plaintext highlighter-rouge">README.md</code>가 대표적인 예시인데, Github Pages 역시 이를 활용해 문서를 작성하는 데에 사용한다. 마크다운 문법은 <a href="https://www.markdownguide.org">여기서</a> 상세히 설명하고 있으니 참고하자.</p>

<h2 id="4-블로그-포스트-내에-문자-박스-양식-넣어보기">4. 블로그 포스트 내에 문자 박스 양식 넣어보기</h2>
<p>추가로 <code class="language-plaintext highlighter-rouge">minimal-mistakes theme</code>의 css로 설정된 스타일 요소를 class로 불러와 적용할 수 있는데, 그중 하나인 상자 양식을 활용해보자. Markdown (<code class="language-plaintext highlighter-rouge">.md</code>) 파일이니까 html 태그들을 쓰면 그대로 화면에 표현할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p class="notice--primary"&gt;
  &lt;strong&gt;
    이 항목은 현재 작성중입니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--info"&gt;
  &lt;strong&gt;
    이 항목은 macOS 기반으로 작성되었습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--danger"&gt;
  &lt;strong&gt;
    이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.
&lt;/p&gt;

&lt;p class="notice--warning"&gt;
  &lt;strong&gt;
    이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.
  &lt;/strong&gt;&lt;br&gt;
    &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.
&lt;/p&gt;
</code></pre></div></div>

<div style="background-color: black; padding: 2% 2% 2% 2%">
  <p class="notice--primary">
    <strong>
      이 항목은 현재 작성중입니다.
    </strong><br />
      &gt; 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.
  </p>

  <p class="notice--info">
    <strong>
      이 항목은 macOS 기반으로 작성되었습니다.
    </strong><br />
      &gt; 프로그램, 단축키 설정 등이 다른 OS 환경과는 호환이 안되는 경우가 많으니 유의하시기 바랍니다.
  </p>

  <p class="notice--danger">
    <strong>
      이 항목은 최신의 내용을 담고 있지 않을 수 있습니다.
    </strong><br />
      &gt; 맨 아래의 항목 업데이트 날짜와 OS나 프로그램의 버전 정보를 꼭 확인해주시기 바랍니다.
  </p>

  <p class="notice--warning">
    <strong>
      이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.
    </strong><br />
      &gt; 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.
  </p>
</div>

<blockquote>
  <p>Reference</p>
  <ul>
    <li><a href="http://jekyllrb-ko.github.io/docs/structure/">Jekyll 디렉토리 구조 (번역)</a></li>
  </ul>
</blockquote>]]></content><author><name>pocj8ur4in</name><email>pocj8ur4in@gmail.com</email></author><category term="Github Pages" /><summary type="html"><![CDATA[솔직히 블로그 설정을 건드는 부분은 내가 아는 정보들을 그대로 나열할 수 밖에 없다고 생각한다… 그래도 내가 시행착오를 겪었던 경험을 떠올리면서 하나하나 풀어서 작성하려 하였으니, 미숙한 글이지만 남들에게 도움이 되었으면 정말 좋겠다… 그리고 Github Pages이나 Minimal Mistakes으로 처음 블로그를 운영하시는 분들의 시선에 맞춰 html, css에 대한 자세한 내용은 다른 포스트로 옮겼으니 참고해주셨으면 한다.]]></summary></entry></feed>