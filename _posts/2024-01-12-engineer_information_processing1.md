---
title: "[Engineer Information Processing] 1. 소프트웨어 설계"

tags:
    - Engineer Information Processing

toc: true
toc_sticky: true

date: 2024-01-12
last_modified_at: 2024-02-22
---

## 소프트웨어 공학과 개발 방법론

### 소프트웨어 개념과 소프트웨어 공학

- 소프트웨어 : 프로그램, 자료구조, 개발 문서
  - 소프트웨어의 특징 : 상품성, 복잡성, 변경 가능성, 복제성, 순응성, 비가시성
  - 소프트웨어의 분류 : 시스템 소프트웨어, 응용 소프트웨어, 미들웨어 소프트웨어
- <b>시스템의 기본 요소 : 입력, 처리, 출력, 제어, 피드백</b>
- <b>소프트웨어 공학 : 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 체계</b>
  - 소프트웨어의 등장 배경 : <b>소프트웨어의 위기 (개발 비용 및 기간 증가, 개발 인력 부족, 성능 및 신뢰성 부족)</b>
  - 소프트웨어 공학의 분류 : 개발 생명주기 모형, 프로세스 모형, 품질 관리, 유지보수
  - <b>소프트웨어 공학의 기본 원칙 : 최신 기술·언어, 높은 신뢰성·편리성·유지보수성·안정성·보안, 낮은 비용, 문서화</b>
  - 소프트웨어 공학의 계층 구조 : 도구, 방법론, 프로세스
  - <b>소프트웨어 공학의 목표 : 최소 비용으로 단기간에 시스템에 적합한 소프트웨어 개발, 품질·생상성·신뢰성 향상</b>

### 소프트웨어 재공학

- 재공학 : 소프트웨어 위기를 개발 생산성이 아닌 유지보수의 생상성으로 해결
  - <b>재공학의 장점 : 개발 시간·비용·실패 감소, 품질·생산성 향상, 개발 지식 공유 가능</b>
  - <b>재공학의 과정 : 분석 → 재구성 → 역공학 → 이식</b>
    1. 분석 : 기존 소프트웨어 명세서 확인 및 동작 이해를 통한 재공학 대상 선정
    2. 재구성 : 소프트웨어 구조를 향상시키기 위해 코드를 재구성
    3. <b>역공학 : 원시 코드를 분석해 소프트웨어 관계 파악 및 기존 시스템의 정보 재발견</b>
    4. 이식 : 기존 소프트웨어 시스템을 새로운 기술 및 환경에 맞게 변환
- <b>재사용의 기본 기술 : 생성 중심 (모듈화), 합성 중심 (모델화)</b>
- <b>리팩토링 : 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 동작 변환 없이 내부 구조 변경</b>
- <b><code>CASE</code> : 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사, 디버깅 과정을 자동화</b>
  - <b><code>CASE</code> 기능 : 빠른 개발, 품질 향상, 생명 주기 통합·자동화, 문서화·명세화를 위한 그래픽, 자료 흐름도·개발 모형</b>
  - <b><code>CASE</code>의 분류 : 상위 <code>CASE</code> (요구 분석·설계 지원), 하위 <code>CASE</code> (코드 작성 및 테스트 지원), 통합 <code>CASE</code></b>
  - 요구사항 분석과 ```CASE``` 도구 : ```SREM``` (```RSL```, ```REVS```, ```PSL/PSA```)
    - <b><code>SADT</code> : 구조적 요구 분석을 위한 블록 다이어그램 채택</b>

### 소프트웨어 설계 방법론

- 소프트웨어 생명 주기 (```SDLC```) : <b>요구 분석 → 설계 → 구현 → 테스트 → 운용 및 유지보수</b>
  - <b>폭포수 모형 : 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 고전적 생명주기 모형</b>
  - <b><code>HIPO</code> : 입력, 처리, 출력으로 구성되는 설계 및 문서화를 위한 구조적 분석 및 설계 방법론 기법<br>(가시적 도표, 총체적 다이어그램, 세부적 다이어그램)</b>
  - <b>나선형 모형 : 나선을 따라 돌면서 각 개발 순서를 반복하여 수행하는 점증적 생명주기 모형<br>계획 수립 → 위험 분석 → 개발과 검증 → 고객 평가 및 다음 단계 수립</b>
  - <b>프로토타입 모형 : 실제 개발될 시스템의 시제품을 미리 만들어 최종 결과물을 예측</b>
  - <b>상향식 설계<code>vs</code>하향식 설계 : 쉬운 기능 추가 및 높은 모듈 독립성<code>vs</code>쉬운 통합 및 명확한 설계</b>
  - <b><code>V-Model</code> : 폭포수 모형에 세부적인 시스템 검증과 테스트 작업을 강조</b>
- <b>에자일 개발 방법론 : 소프트웨어 개발 중 설계 변경에 신속히 대응해 요구 사항 수용</b>
  - 에자일의 목표 : 소프트웨어가 잘 실행되는 것을 가치를 두며, 소프트웨어 배포 시차를 최소화하고자 함
  - 에자일의 특징 : 짧은 릴리즈, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션의 변화
  - <b>에자일의 종류 : <code>XP</code>, <code>SCRUM</code>, 린 (<code>Lean</code>), 동적 시스템 개발 방법론 (<code>DSDM</code>), 기능 중심 개발 (<code>FDD</code>), 크리스탈 (<code>Crystal</code>), 적응형 소프트웨어 개발 방법론 (<code>ASD</code>), 학습 에자일 배포 (<code>DAD</code>) 칸반 (<code>Kanban</code>)</b>
  - <b>에자일 선언문 : 절차·도구 < 소통·피드백, 문서 < 소프트웨어, 계약 협상 < 고객과의 협업, 계획 < 변경 대응</b>

### 익스트림 프로그래밍 (```XP```)와 스크럼 (```SCRUM```)

- <b><code>XP</code> : 요구에 맞는 양질의 소프트웨어를 신속히 제공하는 것을 목표 (예측성 < 적응성)</b>
  - <b><code>XP</code> 핵심 가치 : 의사소통, 단순성, 피드백, 용기와 존중</b>
  - ```XP``` 절차 : 사용자 절차, 릴리즈 계획 수립, 주가, 승인 검사, 소규모 릴리즈<br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3c2895a0-fcc9-4d80-ac10-f46d5e5258f6" width="60%">
  - <b><code>XP</code>의 12가지 프랙티스 : <code>Pair Programming</code>, <code>Planning Game</code>, <code>Test-Driven Development</code>, <code>Whole Team</code>, <code>Continuous Process</code>, <code>Small Releases</code>, <code>Coding Standards</code>, <code>Collective Code Ownership</code>, <code>Simple Design</code>, <code>System Metaphor</code>, <code>Sustainable Pace</code></b>
- ```SCRUM``` : 요구사항 변경에 신속히 대처할 수 있는  반복적이고 점진적인 팀 중심 소프트웨어 개발 방법론
  - ```SCRUM``` 5가지 가치 : 확약, 전념, 정직, 존중, 용기
  - <b><code>SCRUM</code> 역할 : 제품 책임자, 스크럼 마스터, 스크럼 팀</b>
  - <b><code>SCRUM</code> 절차 : 제품 백로그, 스프린트, 스프린트 데일리 미팅, 스프린트 플래닝 미팅, 스프린트 리뷰, 스프린트 회고<br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/15aa64aa-e1eb-46ba-8eb3-95257eefbe53" width="70%"></b>
    - <b>스프린트 : 작은 단위의 개발 업무를 단기간에 개발, 2~4주마다 이해 관계자에 진척도 보고</b>

## 현행 시스템 분석과 요구 분석

### 현행 시스템 분석

- 현행 시스템 분석 : 어떤 하위 시스템으로 구성되어 있는지 파악하는 절차
  - 현행 시스템 분석의 목적 : 개발 시스템의 개발 범위를 확인하고 이행하기 위한 방향성 설정
  - 시스템 아키텍처 : 상위 시스템과 하위 시스템이 어떤 관계로 상호 작용하는지 각 동작 원리와 구성을 표현한 것
  - <b>현행 시스템 파악 절차 : 시스템 및 인터페이스 →  소프트웨어 아키텍처 → 하드웨어 및 네트워크 구성</b>
    - 시스템 구성 : 기간 업무, 지원 업무로 구분
    - 시스템 기능 : 주요 기능과 하부 기능으로 계층형으로 표시
    - <b>인터페이스 현황 : 단위 업무 시스템 및 시스템 간 통신하는 데이터를 명시</b>
    - 소프트웨어 현황 : 소프트웨어 라이선스 적용 방식 (사이트, 서버, 프로세서, 코어, 사용자 수)
    - 하드웨어 현황 : 서버 사양, 서버 이중화 여부 파악
    - 네트워크 현황 : 시스템의 네트워크 구성 형태를 그림으로 표현
    - 개발 기술 환경 분석 : 플랫폼, ```OS```, ```DBMS```, 미들웨어 분석
- 플랫폼 : 응용 프로그램을 실행하기 위한 하드웨어와 소프트웨어의 결합
  - 플랫폼의 종류 : 운영체제, 어플리케이션, 클라우드, 데이터베이스, 개발, 모바일, ```IoT```, 인터넷 서비스, 개발...
  - <b>플랫폼 성능 특성 분석 항목 : 경과 시간, 사용률, 응답 시간, 가용성</b>
  - 플랫폼 성능 특성 분석 방법 : 성능 테스트, 사용자 인터뷰, 문서 점검
  - 플랫폼 사용할 때의 이점 : 개발·운영·유지보수 비용 감소, 안정성·보안성 향상, 여러 플랫폼·커뮤니티 지원
- ```OS``` : ```HW·SW``` 자원 관리 및 공통 서비스 제공, 사용자와의 인터페이스 제공
  - ```OS``` 분석 항목 : 종류, 버전, 패치 일자, 백업 주기 분석
  - ```OS``` 고려 사항 : 가용성, 성능, 기술 지원, 주변 기기, 구축 비용
  - ```OS``` 메모리 누수 : 실행 소프트웨어가 정상 종료되지 않고 남아있는 증상
- 오픈소스 라이선스 : ```GNU```, ```GNU GPLv1```, ```BSD```, ```Apache 2.0```, ```GNU Affero General Public License v3.0```, ```Eclipse Public License 2.0```, ```Mozilla Public License 2.0```, ```Creative Commons```
- ```DBMS``` : 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리
  - ```DBMS``` 목적 : 종속성 및 중복성 문제를 해결하기 위해 제안
  - ```DBMS``` 종류 : ```Oracle```, ```MSSQL```, ```MySQL```, ```SQLite```, ```MongoDB```, ```Redis```
  - <b><code>DBMS</code> 분석 항목 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용</b>

### 요구사항 개발

- 요구공학 : 사용자 요구가 반영된 시스템 개발을 위해 사용자 요구를 추출, 분석, 명세, 검증, 관리
  - 요구사항 베이스라인 : 이해 당사자 간의 명시적 합의, 프로젝트 목표 달성 여부를 확인하는 기준
  - <b>요구사항 분류 : 기능 요구사항과 비기능 요구사항을 구분하고 우선순위 여부를 확인</b>
    - <b>기술 내용에 따른 분류 : 기능 요구사항 (사용자가 원하는 기능)<code>vs</code>비기능 요구사항 (수행 환경, 제약 조건)</b>
    -  기술 관점 및 대상에 따른 분류 : 시스템 요구사항<code>vs</code>사용자 요구사항
- ```SWEBOK``` 기반 요구사항 개발 프로세스 : <b>도출 → 분석 → 명세 → 검증</b>
  - 요구사항 도출 : 현재 상태를 파악하고 문제를 정의하고 목표를 도출
  - <b>요구사항 분석 : 소프트웨어가 어떻게 상호 작용하는지 이해하고, 요구사항 정의를 도출 및 문서화</b>
    - <b>분석 기법 : 사용자 의견 청취, 사용자 인터뷰, 문서 및 모델 분석, 설문 조사</b>
    - 분석 단계 : 문제 인식 → 전개 → 평가 및 종합 → 검토 → 문서화
  - 요구사항 명세 : 시스템 정의 및 요구사항, 소프트웨어 요구사항을 문서화
    - <b>명세 기법 : 정형 명세 (수학적 + 정확한 표현, 명세·구현의 일치)<code>vs</code>비정형 명세 (자연어 + 작성·이해 용이, 다양한 전달 방법)</b>
  - 요구사항 확인 : 문서로 만들어진 내용을 확인 및 검증
  - 요구사항 관리 : 요구사항 명세서와 관련된 변경 사항을 추적 및 관리
- <b>요구사항 관리 도구의 필요성 : 프로세스 효율성 재고 및 관리·분석·추적·평가·의사소통 용이</b>
- 요구사항 할당 : 요구사항을 만족시키기 위한 아키텍처 구성 요소를 식별

### 요구사항 확인 기법과 ```FTR```

- 요구사항 확인 기법 : 인터뷰, 설문 조사, 시나리오, 스토리보드, 워크숍, 브레인스토밍, 분석 모델링
  - <b>프로토타이핑 : 도출된 요구사항을 토대로 시제품을 제작해 대상 시스템과 바교하여 추가 요구사항을 지속적으로 재작성</b>
    - 프로토 타이핑 절차 : 요구사항 수집 및 분석 → 설계 → 개발 → 검토 및 피드백 → 프로토타입 정제 → 요구사항 검증
  - 모델 검증 : 분석 단계에서 개발된 모델의 품질을 검증
    - 정적 분석 : 객체 모델에서 객체 간에 존재하는 의사소통 경로를 검증하기 위해 명세의 일관성 및 정확성을 확인
    - 동적 분석 : 직접 실행하여 모델을 검증하기 위해 작성된 소스 코드를 실행해 메모리 누수 현황 및 스레드 결함 분석
  - 요구사항 검토 : 여러 검토자자가 에러, 잘못된 가정, 불명확성, 표준과의 차이를 탐색
  - <b>인수 테스트 : 소프트웨어가 요구사항을 만족하는지 확인하기 위한 테스트</b>
    - 인수 테스트 종류 : 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사, 사용자 인수 테스트, 운영 인수 테스트
    - 인수 테스트 절차 : 계획 → 설계 → 구현 → 검토 → 수행 → 완료
  - <b>정형 기술 검토 : 소프트웨어 개발 산출물 대상 요구사항 일치 여부, 표준 준수 및 결합 발생 여부를 검토하는 정적 분석 기법</b>
    - 정형 기술 검토 특징 : 구조화된 절차, 전문가의 참여 필요, 개발 초기 적용 가능, 문서화의 중요성
    - <b>정형 기술 검토 지침 : 의제 및 범위 유지, 참가자 수 제한, 체크리스트 및 일정 할당, 검토에 집중, 논쟁 제한, 명확한 문제 영역</b>

### ```UML```과 럼바우 분석 기법

- 개념 모델링 : 요구사항을 이해하기 쉽도록 실 세계의 상황을 단순화하여 개념적으로 표현한 모델을 생성하는 과정
  - 개발 대상 도메인의 엔티티 및 관계와 종속성을 반영
- <b><code>UML</code> : 객체지향 소프트웨어 개발 과정의 모델링 기술 및 방법론을 통합한 범용 모델링 언어</b>
  - ```UML``` 특성 : 시각화, 문서화, 명세화, 구축, 확장성, 표준화된 언어
  - <b><code>UML</code> 관점 : 기능적 관점 (유스케이스 다이어그램), 정적 관점 (클래스 다이어그램), 동적 관점 (시퀀스 다이어그램, 상태 다이어그램)</b>
  - <b><code>UML</code> 구성 : 사물 (객체 간의 관계 형성 대상), 관계 (객체 간의 연관성 표현), 다이어그램 (격체의 관계 도식화)</b>
    - <b>스테레오타입 : <code>UML</code> 구성 외에 추가적인 확장 요소를 표현 (<code><<>></code>으로 포현)</b>
    - <code>UML</code> 접근 제어자 : ```public``` (```+```), ```private``` (```-```), ```protected``` (```#```), ```package``` (```~```)
    - <code>UML</code> 표현 : ```1``` (```1``` 객체 연결), ```*``` 또는 ```0..*``` (0이나 0 이상 객체 연결), ```1..*``` (1이거나 1 이상 객체 연결), ```0..1``` (0이거나 1 객체 연결), ```1, 3, 5``` (1이거나 3이거나 6 객체 연결), ```n``` (```n```개 객체 연결), ```m..*``` (```m```이거나 ```m```개 이상 객체 연결)``
- <b>럼바우 객체지향 분석 (= 객체 모델링 기법) : 소프트에어 구성 요소를 그래픽으로 모형화</b>
  - <b>럼바우 객체지향 분석 절차 및 도구 : 객체 모델링 (객체 다이어그램) → 동적 모델링 (상태도) → 기능 모델링 (자료 흐름도)</b>
    - 객체 모델링 : 시스템에서 요구되는 객체를 찾아 속성, 연산, 관계를 규정하여 객체를 다이어그램으로 표시
    - 동적 모델링 : 제어 흐름, 상호 작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램으로 표시
    - 기능 모델링 : 여러 프로세스 간의 자료 흐름을 표시 (어떤 데이터를 입력해 어떤 결과를 가져올 수 있을지 표현)

### ```UML``` 다이어그램

- <b>구조 다이어그램 : 시스템 구조와 구성 요소 간의 관계를 시각적으로 표현</b>
  - <b>클래스 다이어그램 : 시스템 내의 클래스나 인터페이스 및 그 관계를 시각적으로 표현, 클래스 속성 및 메소드로 구현 정보 제공</b>
  - 객체 다이어그램 : 특정 시점에서의 객체 간의 관계 및 상태를 표현, 클래스들이 어떻게 실제로 인스턴스화되는지 표현
  - 복합체 구조 다이어그램 : 시스템의 복잡한 구조를 모델링하기 위해 객체의 내부 구조 및 상호 작용을 표현
  - 배치 다이어그램 : 시스템의 물리적 배치 및 구성, 하드웨어와 소프트웨어 간의 관계를 표현
  - <b>컴포넌트 다이어그램 : 소프트웨어 시스템의 컴포넌트의 구조 및 관계 표현, 어떤 기능을 수행하는지 나타내 모듈화 및 재사용에 유용</b>
  - 패키지 다이어그램 : 시스템을 구성하는 여러 개체를 그룹화하여 표현하여 모듈화나 구조화를 표현
- <b>행위 다이어그램 : 시스템 내 상호작용, 메시지 흐름, 객체 간의 상호 작용와 같은 시스템의 동작을 그래픽으로 표현</b>
  - 유스케이스 다이어그램 : 시스템 및 시스템과 사용자 간의 상호 작용을 시각적으로 표현
  - <b>액티비티 다이어그램 : 시스템 내부 프로세스나 작업 흐름을 시각적으로 표현</b>
  - 상태 머신 다이어그램 : 객체의 생명주기와 상태 변화를 상태, 이벤트, 전이로 구성하여 표현
  - 협력 다이어그램 : 객체들이 서로 메시지를 주고받는 과정을 객체, 메시지로 표현
  - 상호 작용 다이어그램 : 유스케이스를 수행하기 위해 객체들이 어떻게 상호 작용하는지 객체 간에 주고받는 메시지를 통해 표현
    - <b>순차 다이어그램 : 유스케이스를 위해 시스템 구성 요소들이 어떻게 상호 작용하는지 객체, 생명선, 실행, 메시지, 시간으로 표현</b>
    - 통신 다이어그램 : 시스템에서 객체 간의 통신을 객체 간의 관계 및 역할, 메시지 흐름, 시간 흐름으로 표현
- <b>클래스 다이어그램 : 시스템을 구성하는 객체 간의 관계를 추상화한 모델을 논리적 구조로 표현</b><br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0842a7a0-a60e-4c7a-a964-043614230779" width="40%">
- 유스케이스 다이어그램 : 사용자 요구를 기능적 측면에서 기술하기 위해 액터와 유스케이스로 구성하여 표현<br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8def48e8-5e55-4e90-ba27-202f86864479" width="50%">
  - <b>유스케이스 다이어그램 요소 : 시스템 경계, 액터, 유스케이스, 관계 (연관, 포함, 확장, 일반화)</b>
  - 유스케이스 다이어그램 작성 단계 : 액터 식별 → 유스케이스 식별 → 관계 정의 → 유스케이스 구조화
  - 유스케이스 다이어그램 관계 표현 : ```UML``` 관계를 통해 표현<br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f2afd2fc-10a6-4fe9-8940-45eef3f7bd2e" width="60%">
    - ```UML``` 연관 관계 : 한 사물의 객체가 다른 사물의 객체와 연결된 것을 표현 (연관 관계명, 역할명)
    - <b><code>UML</code> 의존 관계 : 연관 관계와 동일하나, 메소드드를 사용할 때처럼 짧은 시간만을 유지</b>
    - <b><code>UML</code> 일반화 관계 : 객체지향의 상속 관계를 표현 (하위 클래스와 상위 클래스 간의 관계를 표현)</b>
    - ```UML``` 집합 관계 : 전체 객체와 부분 객체 간의 관계를 표현
    - ```UML``` 포함 관계 : 부분 객체가 전체 객체에 속하는 강한 집합 연관의 관계를 표현
    - <b><code>UML</code> 실체화 관계 : 인터페이스와 실제 구현된 일반 클래스 간의 관계로 존재하는 행동에 대한 구현을 표현</b>

## <code>UI</code> 설계

### <code>UI</code> 환경 분석

- <code>UI</code> 표준을 위한 환경 분석
  - 사용자 경향 분석 : 기존 <code>UI</code> 경향을 숙지해 현재 <code>UI</code>의 단점 작성
  - 기능 및 설계 분석 : 기능 조작성, 오류 방지, 최소한의 조작응로 업무 처리가 가능한지, <code>UI</code>의 정보 전달력이 어떤지 분석
- <code>UI</code> 요구사항 요소 : 데이터 요구, 기능 요구, 제품 및 서비스 품질, 제약 사항
- 정황 시나리오 : 개발하는 서비스의 초기 모양을 상상 (사용자의 관점에서 높은 수준 및 낙관적 상황을 가정해 기초 시나리오 작성)

### <code>UI</code> 표준과 지침

- <code>UI</code> : 인간, 디지털 기기, 소프트웨어 간에 의사소통이 가능하도록 만든 매개체
  - <code>UI</code> 분야 : 표현, 정보 제공 및 전달, 기능 → 웹 디자인, 모바일 앱 디자인, 게임 디자인, 산업 디자인, 기계 학습 인터페이스
  - <b><code>UI</code> 개발 시스템이 가져야할 기능 : 사용자의 입력 검증, 에러 및 에러 메시지 처리, 도움과 프롬프트 제공</b>
- <b><code>UI</code> 설계 원칙 : 직관성, 유효성, 학습성, 유연성</b>
- <b><code>UI</code> 설계 지침 : 사용자 중심, 일관성, 단순성, 가시성, 표준화, 접근성, 결과 예측 가능, 명확성, 오류 발생 해결</b>
- <code>UI</code> 구현 표준 : 화면 구성, 화면 이동과 같이 화면에서 공통적으로 갖춰어야 할 최소의 <code>UI</code> 요소 및 배치 규칙
  - <code>UI</code> 설계 시 오류 지침 : 명확하고 이해하기 쉬운 메시지, 문제 해결 방법 제공, 시각적 강조 및 사용자 경험 고려
  - <code>UI</code> 표준 구성 : 전체적인 <code>UX</code> 원칙, 정책 및 철학, <code>UI</code> 스타일 가이드, <code>UI</code> 패턴 모델 정의, <code>UI</code> 표준 수립을 위한 조직 구성
- <code>UX</code> : 제품을 대상으로 직·간접적으로 사용하면서 느끼고 생각하는 지각·반응·행동과 같은 모든 경험

### <code>UI</code> 설계

- <code>UI</code> 설계 단계 : 문제 정의 → 사용자 모델 정의 → 작업 분석 → 컴퓨터 오브젝트 및 기능 정의 → 사용자 인터페이스 정의 → 디자인 평가
  - <code>UI</code> 메뉴 구조 설계, 내부 및 외부 화면과 폼 설계, <code>UI</code> 검토 수행
  - <code>UI</code> 요구사항 정의 : 시스템 구조, 사이트맵, 프로세스 정의, 화면 설계
- <b><code>UI</code>의 종류 : <code>CLI</code>, <code>GUI</code>, <code>NUI</code>, <code>OUI</code>, <code>TUI</code>, <code>WUI</code>, <code>Touch UI</code></b>
- <code>UI</code> 설계 도구 : 

## 소프트웨어 설계

### 소프트웨어 설계 모델링



### 구조적 분석 도구



### 모듈



### 재사용



### 소프트웨어 아키텍처



### 소프트웨어 아키텍처 패턴



### 코드 설계



## 객체지향 설계와 디자인 패턴

### 소프트웨어 설계 기법과 객체지향 프로그래밍



### 객체지향 설계 원칙



### 디자인 패턴



### ```GOF``` 패턴



## 시스템 인터페이스 설계

### 시스템 인터페이스 요구사항 확인



### 시스템 인터페이스 대상 식별



### 미들웨어 솔루션

