---
title: "[Engineer Information Processing] 1. 소프트웨어 설계"

tags:
    - Engineer Information Processing

toc: true
toc_sticky: true

date: 2024-01-12
last_modified_at: 2024-02-22
---

## 소프트웨어 공학과 개발 방법론

### 소프트웨어 개념과 소프트웨어 공학

- 소프트웨어 : 프로그램, 자료구조, 개발 문서
  - 소프트웨어의 특징 : 상품성, 복잡성, 변경 가능성, 복제성, 순응성, 비가시성
  - 소프트웨어의 분류 : 시스템 소프트웨어, 응용 소프트웨어, 미들웨어 소프트웨어
- <b>시스템의 기본 요소 : 입력, 처리, 출력, 제어, 피드백</b>
- <b>소프트웨어 공학 : 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 체계</b>
  - 소프트웨어의 등장 배경 : <b>소프트웨어의 위기 (개발 비용 및 기간 증가, 개발 인력 부족, 성능 및 신뢰성 부족)</b>
  - 소프트웨어 공학의 분류 : 개발 생명주기 모형, 프로세스 모형, 품질 관리, 유지보수
  - <b>소프트웨어 공학의 기본 원칙 : 최신 기술·언어, 높은 신뢰성·편리성·유지보수성·안정성·보안, 낮은 비용, 문서화</b>
  - 소프트웨어 공학의 계층 구조 : 도구, 방법론, 프로세스
  - <b>소프트웨어 공학의 목표 : 최소 비용으로 단기간에 시스템에 적합한 소프트웨어 개발, 품질·생상성·신뢰성 향상</b>

### 소프트웨어 재공학

- 재공학 : 소프트웨어 위기를 개발 생산성이 아닌 유지보수의 생상성으로 해결
  - <b>재공학의 장점 : 개발 시간·비용·실패 감소, 품질·생산성 향상, 개발 지식 공유 가능</b>
  - <b>재공학의 과정 : 분석 → 재구성 → 역공학 → 이식</b>
    1. 분석 : 기존 소프트웨어 명세서 확인 및 동작 이해를 통한 재공학 대상 선정
    2. 재구성 : 소프트웨어 구조를 향상시키기 위해 코드를 재구성
    3. <b>역공학 : 원시 코드를 분석해 소프트웨어 관계 파악 및 기존 시스템의 정보 재발견</b>
    4. 이식 : 기존 소프트웨어 시스템을 새로운 기술 및 환경에 맞게 변환
- <b>재사용의 기본 기술 : 생성 중심 (모듈화), 합성 중심 (모델화)</b>
- <b>리팩토링 : 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 동작 변환 없이 내부 구조 변경</b>
- <b><code>CASE</code> : 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사, 디버깅 과정을 자동화</b>
  - <b><code>CASE</code> 기능 : 빠른 개발, 품질 향상, 생명 주기 통합·자동화, 문서화·명세화를 위한 그래픽, 자료 흐름도·개발 모형</b>
  - <b><code>CASE</code>의 분류 : 상위 <code>CASE</code> (요구 분석·설계 지원), 하위 <code>CASE</code> (코드 작성 및 테스트 지원), 통합 <code>CASE</code></b>
  - 요구사항 분석과 ```CASE``` 도구 : ```SREM``` (```RSL```, ```REVS```, ```PSL/PSA```)
    - <b><code>SADT</code> : 구조적 요구 분석을 위한 블록 다이어그램 채택</b>

### 소프트웨어 설계 방법론

- 소프트웨어 생명 주기 (```SDLC```) : <b>요구 분석 → 설계 → 구현 → 테스트 → 운용 및 유지보수</b>
  - <b>폭포수 모형 : 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 고전적 생명주기 모형</b>
  - <b><code>HIPO</code> : 입력, 처리, 출력으로 구성되는 설계 및 문서화를 위한 구조적 분석 및 설계 방법론 기법<br>(가시적 도표, 총체적 다이어그램, 세부적 다이어그램)</b>
  - <b>나선형 모형 : 나선을 따라 돌면서 각 개발 순서를 반복하여 수행하는 점증적 생명주기 모형<br>계획 수립 → 위험 분석 → 개발과 검증 → 고객 평가 및 다음 단계 수립</b>
  - <b>프로토타입 모형 : 실제 개발될 시스템의 시제품을 미리 만들어 최종 결과물을 예측</b>
  - <b>상향식 설계<code>vs</code>하향식 설계 : 쉬운 기능 추가 및 높은 모듈 독립성<code>vs</code>쉬운 통합 및 명확한 설계</b>
  - <b><code>V-Model</code> : 폭포수 모형에 세부적인 시스템 검증과 테스트 작업을 강조</b>
- <b>에자일 개발 방법론 : 소프트웨어 개발 중 설계 변경에 신속히 대응해 요구 사항 수용</b>
  - 에자일의 목표 : 소프트웨어가 잘 실행되는 것을 가치를 두며, 소프트웨어 배포 시차를 최소화하고자 함
  - 에자일의 특징 : 짧은 릴리즈, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션의 변화
  - <b>에자일의 종류 : <code>XP</code>, <code>SCRUM</code>, 린 (<code>Lean</code>), 동적 시스템 개발 방법론 (<code>DSDM</code>), 기능 중심 개발 (<code>FDD</code>), 크리스탈 (<code>Crystal</code>), 적응형 소프트웨어 개발 방법론 (<code>ASD</code>), 학습 에자일 배포 (<code>DAD</code>) 칸반 (<code>Kanban</code>)</b>
  - <b>에자일 선언문 : 절차·도구 < 소통·피드백, 문서 < 소프트웨어, 계약 협상 < 고객과의 협업, 계획 < 변경 대응</b>

### 익스트림 프로그래밍 (```XP```)와 스크럼 (```SCRUM```)

- <b><code>XP</code> : 요구에 맞는 양질의 소프트웨어를 신속히 제공하는 것을 목표 (예측성 < 적응성)</b>
  - <b><code>XP</code> 핵심 가치 : 의사소통, 단순성, 피드백, 용기와 존중</b>
  - ```XP``` 절차 : 사용자 절차, 릴리즈 계획 수립, 주가, 승인 검사, 소규모 릴리즈<br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3c2895a0-fcc9-4d80-ac10-f46d5e5258f6" width="60%">
  - <b><code>XP</code>의 12가지 프랙티스 : <code>Pair Programming</code>, <code>Planning Game</code>, <code>Test-Driven Development</code>, <code>Whole Team</code>, <code>Continuous Process</code>, <code>Small Releases</code>, <code>Coding Standards</code>, <code>Collective Code Ownership</code>, <code>Simple Design</code>, <code>System Metaphor</code>, <code>Sustainable Pace</code></b>
- ```SCRUM``` : 요구사항 변경에 신속히 대처할 수 있는  반복적이고 점진적인 팀 중심 소프트웨어 개발 방법론
  - ```SCRUM``` 5가지 가치 : 확약, 전념, 정직, 존중, 용기
  - <b><code>SCRUM</code> 역할 : 제품 책임자, 스크럼 마스터, 스크럼 팀</b>
  - <b><code>SCRUM</code> 절차 : 제품 백로그, 스프린트, 스프린트 데일리 미팅, 스프린트 플래닝 미팅, 스프린트 리뷰, 스프린트 회고<br><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/15aa64aa-e1eb-46ba-8eb3-95257eefbe53" width="70%"></b>
    - <b>스프린트 : 작은 단위의 개발 업무를 단기간에 개발, 2~4주마다 이해 관계자에 진척도 보고</b>

## 현행 시스템 분석과 요구 분석

### 현행 시스템 분석

- 현행 시스템 분석 : 어떤 하위 시스템으로 구성되어 있는지 파악하는 절차
  - 현행 시스템 분석의 목적 : 개발 시스템의 개발 범위를 확인하고 이행하기 위한 방향성 설정
  - 시스템 아키텍처 : 상위 시스템과 하위 시스템이 어떤 관계로 상호 작용하는지 각 동작 원리와 구성을 표현한 것
  - <b>현행 시스템 파악 절차 : 시스템 및 인터페이스 →  소프트웨어 아키텍처 → 하드웨어 및 네트워크 구성</b>
    - 시스템 구성 : 기간 업무, 지원 업무로 구분
    - 시스템 기능 : 주요 기능과 하부 기능으로 계층형으로 표시
    - <b>인터페이스 현황 : 단위 업무 시스템 및 시스템 간 통신하는 데이터를 명시</b>
    - 소프트웨어 현황 : 소프트웨어 라이선스 적용 방식 (사이트, 서버, 프로세서, 코어, 사용자 수)
    - 하드웨어 현황 : 서버 사양, 서버 이중화 여부 파악
    - 네트워크 현황 : 시스템의 네트워크 구성 형태를 그림으로 표현
    - 개발 기술 환경 분석 : 플랫폼, ```OS```, ```DBMS```, 미들웨어 분석
- 플랫폼 : 응용 프로그램을 실행하기 위한 하드웨어와 소프트웨어의 결합
  - 플랫폼의 종류 : 운영체제, 어플리케이션, 클라우드, 데이터베이스, 개발, 모바일, ```IoT```, 인터넷 서비스, 개발...
  - <b>플랫폼 성능 특성 분석 항목 : 경과 시간, 사용률, 응답 시간, 가용성</b>
  - 플랫폼 성능 특성 분석 방법 : 성능 테스트, 사용자 인터뷰, 문서 점검
  - 플랫폼 사용할 때의 이점 : 개발·운영·유지보수 비용 감소, 안정성·보안성 향상, 여러 플랫폼·커뮤니티 지원
- ```OS``` : ```HW·SW``` 자원 관리 및 공통 서비스 제공, 사용자와의 인터페이스 제공
  - ```OS``` 분석 항목 : 종류, 버전, 패치 일자, 백업 주기 분석
  - ```OS``` 고려 사항 : 가용성, 성능, 기술 지원, 주변 기기, 구축 비용
  - ```OS``` 메모리 누수 : 실행 소프트웨어가 정상 종료되지 않고 남아있는 증상
- 오픈소스 라이선스 : ```GNU```, ```GNU GPLv1```, ```BSD```, ```Apache 2.0```, ```GNU Affero General Public License v3.0```, ```Eclipse Public License 2.0```, ```Mozilla Public License 2.0```, ```Creative Commons```
- ```DBMS``` : 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리
  - ```DBMS``` 목적 : 종속성 및 중복성 문제를 해결하기 위해 제안
  - ```DBMS``` 종류 : ```Oracle```, ```MSSQL```, ```MySQL```, ```SQLite```, ```MongoDB```, ```Redis```
  - <b><code>DBMS</code> 분석 항목 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용</b>

### 요구사항 개발

- 요구공학 : 사용자 요구가 반영된 시스템 개발을 위해 사용자 요구를 추출, 분석, 명세, 검증, 관리
  - 요구사항 베이스라인 : 이해 당사자 간의 명시적 합의, 프로젝트 목표 달성 여부를 확인하는 기준
  - <b>요구사항 분류 : 기능 요구사항과 비기능 요구사항을 구분하고 우선순위 여부를 확인</b>
    - <b>기술 내용에 따른 분류 : 기능 요구사항 (사용자가 원하는 기능)<code>vs</code>비기능 요구사항 (수행 환경, 제약 조건)</b>
    -  기술 관점 및 대상에 따른 분류 : 시스템 요구사항<code>vs</code>사용자 요구사항

### 요구사항 확인 기법과 ```FTR```



### ```UML```과 럼바우 분석 기법



### ```UML``` 다이어그램



## ```UI``` 설계

### ```UI``` 환경 분석



### ```UI``` 표준과 지침



### ```UI``` 설계



## 소프트웨어 설계



### 소프트웨어 설계 모델링



### 구조적 분석 도구



### 모듈



### 재사용



### 소프트웨어 아키텍처



### 소프트웨어 아키텍처 패턴



### 코드 설계



## 객체지향 설계와 디자인 패턴

### 소프트웨어 설계 기법과 객체지향 프로그래밍



### 객체지향 설계 원칙



### 디자인 패턴



### ```GOF``` 패턴



## 시스템 인터페이스 설계

### 시스템 인터페이스 요구사항 확인



### 시스템 인터페이스 대상 식별



### 미들웨어 솔루션

