---
title: "[HongikChallenge] 04/13 진행 내용"

categories:
    - HongikChallenge

tag:

toc: true
toc_sticky: true

date: 2023-04-13
last_modified_at: 2023-04-13
---

## <a href="https://github.com/Hongik-Challenge/hc-backend/commit/88323d82fb594e174cba2de93f1f329301716732">#11</a>, <a href="https://github.com/Hongik-Challenge/hc-backend/commit/c2397d05610ab2cdef3f1950edbe69bf79fba56f">#12</a>. chore:sonarqube 설정
- <a href="https://kdevkr.github.io/static-analysis-performed-by-sonarqube-and-github-action/#소나큐브-시스템-구성">해당 게시글</a>을 참고해, Jacoco와 비슷한 코드 커버리지 도구인 sonarqube를 프로젝트 내에 도입하였다.
  - 프로그램을 실제 환경이나 가상 환경에서 실행하면서 동적으로 분석하는 Jacoco와 달리, sonarqube는 프로그램을 실행하지 않은 상태에서 소스 코드나 컴파일된 코드를 이용해 프로그램을 정적으로 분석한다. 현재 계획은 풀 리퀘스트가 종료되면서 개발 서버에 빌드 파일이 배포되기 전에 소나큐브가 실행되는 것을 목표로 한다.
  - 이를 반영하기 위해 github workflow의 내용을 수정하였다. 이때 ci, api라는 다소 불분명하게 정의된 파일 이름을 pull_request_opened와 같은 트리거에 대한 것으로 수정하였다. <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">해당 문서</a>에 Github Actions에 대한 트리거 리스트가 잘 정리되어 있어 이를 참고하였다.
  - sonarqube에 대한 yml 파일을 작성하던 중에 빌드한 파일을 저장소에 업로드하는 upload-artifact이라는 기능에 대해 알게 되어, <a href="https://kotlinworld.com/396">해당 게시글</a>을 참고해 이를 반영하였다.
  - Github Workflow 역시 소나큐브를 반영해 작업이 이루어질 수 있도록 하였다.

## <a href="https://github.com/Hongik-Challenge/hc-backend/commit/8d271922631c5b24bf620707daea803c4807c149">#13</a>. docs:Example 도메인 작성
- 다른 팀원들이 도메인, API, 예외 처리에 대한 코드를 작성할 때 참고할 수 있도록 Example 코드를 작성하였다. 작성한 내용은 다음과 같다. (Example 코드인만큼 실제 코드가 어떤 역할을 하는지보다는, 해당 코드의 역할에 대한 개념을 설명하는 데에 초첨을 맞춰 서술한다.)
<br>
- Domain/ExampleEntity : 엔티티는 데이터베이스에 쓰일 필드와 여러 엔티티 간 연관관계를 정의한다. 아래의 2차원 테이블을 하나의 엔티티로 생각해보자. 우리는 이 테이블에 서비스에 필요한 정보를 활용할 수 있다. 이때 세로의 파란색 열 부분이 Column이 되고, 빨간색 부분과 같은 가로의 행 하나하나가 엔티티 객체라 볼 수 있다. 필드는 각각의 Column을 의미하는데, 엔티티 클래스에서 하나의 객체로 표현된다.

<table style="text-align: center">
	<thead>
		<tr>
			<td></td><td>a</td><td bgcolor="blue">b</td><td>c</td><td>d</td><td>e</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
		<tr bgcolor="red">
			<td>2</td><td></td><td></td><td></td><td></td><td></td>
		</tr>
		<tr>
			<td>3</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
		<tr>
			<td>4</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
    <tr>
			<td>5</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
		<tr>
			<td>6</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
		<tr>
			<td>7</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
		<tr>
			<td>8</td><td></td><td bgcolor="blue"></td><td></td><td></td><td></td>
		</tr>
	</tbody>
</table>

```
@GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    private Long example_id;

    private String example_content;
```

- Domain/ExampleRepository : 엔티티는 위에서처럼 DB 구조를 표현한다면, 실제 DB의 값은 어떻게 접근할 수 있을까? 그리고 DB 값에 대한 CRUD는 어떻게 동작하는 것일까? 우리는 이를 위한 ExampleRepository를 인터페이스로 선언하고, JpaRepository를 상속하므로써 DB에 대한 접근 및 동작을 가능하게 해줄 예정이다.

```
public interface ExampleRepository extends JpaRepository<ExampleEntity, Long> {}
```

- Domain/ExampleDomainService : 이제 데이터베이스에서 값을 받아왔으니, 실제 도메인에서 이루어지는 서비스를 정의할 차례이다. 당연히 DB에 접근할 수 있어야 할 것이고, Repository의 메서드를 활용한 서비스를 정의해야 한다. 여기서는 Example이므로 Repository에서 값을 찾아올 수 없는 오류를 일으키고, 정의한 오류 내용이 제대로 출력되는지 확인해보았다.

```
public class ExampleDomainService {
    private final ExampleRepository exampleRepository;

    public void exampleException() {
      ...
    }

    public ExampleEntity exampleQuery(Long id) {
      return exampleRepository
                .findById(id)
                .orElseThrow(() -> new ExampleCodeException(400, "샘플 오류!", "Example 도메인에서 발생한 샘플 오류입니다."));
    }

    public ExampleEntity exampleSave(String content) {
      ...
    }
}
```

- Common/Exception/ExampleException : 위 내용을 실제로 출력될 수 있도록 오류에 대한 포맷을 만들어보았다.

```
public class ExampleCodeException extends RuntimeException {
    private int status;
    private String code;
    private String message;
}
```

- Api/ExampleApiService : 위의 내용이 내부에서 동작하는 도메인 모듈에서 이루어지는 작업이었다면, 이제 외부로 출력할 수 있게끔 Api 모듈에서 작업할 차례이다. 그런데 왜 서비스가 나오는지 의아할 수 있는데, 이 서비스는 사실 DomainService와 MVC, DTO 사이에 존재하는 서비스로, DomainService를 재활용할 수 있도록 해당 Api 계층에 의존하는 내용을 분리시킨 것이다.

```
public class ExampleApiService {
    private final ExampleDomainService exampleDomainService;

    public ExampleResponse getExample() {
        ExampleEntity query = exampleDomainService.exampleQuery(1L);

        return ExampleResponse.from(query);
    }

    public ExampleResponse createExample(){
        ExampleEntity qwer = exampleDomainService.exampleSave("qwer");
        return ExampleResponse.from(qwer);
    }
}
```

- Api/ExampleResponse : 요청 데이터 또는 응답 데이터를 하나의 객체로 주고받을 수 있는 DTO 클래스이다. 각 HandlerMethod에 대한 패러미터의 개수가 많아질 수 있고, 또 도메인 객체를 컨트롤러에서 분리하기 위해 사용하였다.

```
public class ExampleResponse {
    private final Long id;
    private final String content;

    public static ExampleResponse from(ExampleEntity exampleEntity) {
        return new ExampleResponse(
                exampleEntity.getExample_id(), exampleEntity.getExample_content());
    }
}
```

- Api/ExampleController : 클라이언트의 요청을 직접 받을 엔드포인트 역할을 할 컨트롤러이다.

```
public class ExampleController {
    private final ExampleApiService exampleApiService;

    @GetMapping
    public ExampleResponse get(){
        return exampleApiService.getExample();
    }

    @PostMapping
    public ExampleResponse create(){
        return exampleApiService.createExample();
    }
}
```

## <a href="https://github.com/Hongik-Challenge/hc-backend/commit/6209c2c954d5efd23d921c284ed13e1e37b764c3">#14</a>. feat/domain:BaseTimeEntity 추가
- 생성 시간과 수정 시간을 자동으로 설정해주기 위해 JPA Auditing의 세부 기능 중 하나인 BaseTimeEntity를 추가하고, 이를 Example 도메인에 적용했다.
  - JPA Auditing은 데이터베이스에 데이터를 누가, 언제 데이터를 생성했는지, 수정했는지를 저장하는 업무를 담당한다. JPA Auditing을 이용하면 엔티티별로 동일한 필드명을 달고, 데이터를 넣어주는 코드를 중복적으로 짜지 않아도 된다.

## <a href="chore:git hook과 gradle을 통한 spotless 자동화">#15</a>. chore:git hook과 gradle을 통한 spotless 자동화
- #4. <a href="https://github.com/Hongik-Challenge/hc-backend/commit/069fa4775751134ab9971924ebf9b02392537783">chore:spotless 적용</a>의 연장선상에서 진행되는 내용이다.
- spotless를 적용하긴 했는데, 사실 이거는 코드를 작성하고 커밋하다보면 까먹기 쉬운 작업이다. 실제로 Example 도메인을 작성할 때 적용하지 않고 원격에 푸시해버려 풀 리퀘스트가 이루어지지 않는 경우가 발생했다. 그래서 <a href="https://techblog.woowahan.com/2530/">이 게시글</a>처럼 git hook으로 커밋을 하기 전에 spotless를 적용하는 것을 자동화하였다.
- 그런데 ```.git```는 사실 처음에 ```.gitignore``` 파일에 제외하기로 한 디렉토리이다. 나 혼자 작업한다면 위의 내용으로 충분하겠지만, 협업에서는 모두가 같은 내용을 적용하는 것이 중요하다. 그래서 root에 ```pre-commit``` 파일을 두고, gradle task로 이를  ```.git```에 이동하는 것을 추가하였다.