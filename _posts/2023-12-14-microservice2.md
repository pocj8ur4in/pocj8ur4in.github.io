---
title: "[MicroService] 2. MSA"

tags:
    - MicroService

toc: true
toc_sticky: true

date: 2023-12-14
last_modified_at: 2023-12-14
---

## 마이크로서비스 아키텍처 (```MSA```) : 마이크로서비스를 접목한 아키텍처 구조

- 클라우드 인프라와 접목해 아마존, 넷플릭스에 의해 구체화 → 비즈니스 성공 사례
- 각 서비스는 개별 프로세스에서 실행되며, ```HTTP API```를 통해 통신
- 각 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용해 독립적으로 배포

> 마이크로서비스 아키텍처 (```MSA```)와 서비스 지향 아키텍처 (```SOA```)의 비교
> - ```SOA``` : 컴포넌트를 모아 비즈니스적으로 의미있고 완결적인 서비스 단위로 모듈화
>   - ```SOA```와 ```MSA```의 공통점 : 비즈니스 서비스의 집합으로 시스템을 개발
>   - ```SOA```와 ```MSA```의 차이점 : 이론적인 ```SOA```와 달리, ```MSA```는 클라우드 인프라와 접목해 구체화

- ```MSA``` 내부 아키텍처 : ```API```, 비즈니스 로직, 이벤트 발행, 데이터 처리의 구조화 등 ```MSA``` 내부 구조를 정의한 것
- ```MSA``` 외부 아키텍처 : 인프라, 플랫폼, 어플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것

### 리액티브 선언 (```The Reactive Manifesto```) : 어플리케이션이 요청에 즉각 응답하고 가동되길 기대
- 응답성 (```Responsive```) : 사용자에게 신뢰성 있는 응답을 빠르고 적절히 제공하는 능력
- 탄력성 (```Resilient```) : 장애가 발생하더라도 시스템 전체에 영향을 주지 않고 복구하는 능력
- 유연성 (```Elastic```) : 사용량에 변화가 있더라도 그에 비례해 자원을 조절해 균일한 응답성을 제공하는 능력
- 메시지 기반 (```Message Driven```) : 비동기 메시지로 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향

→ 4가지 요건을 만족하는 시스템을, 급변하는 상황을 적응할 수 있는 리엑티브 시스템 (```Reactive System```)이라 정의

### 강결합에서 약결합의 아키텍처로의 변화
- 소프트웨어 아키텍처 : 소프트웨어를 구성하는 요소와 그 구성 요소 간의 관계를 정의한 것
  - 아키텍처를 정의하는 과정 : 시스템 구축을 위한 여러 비기능 요건들을 만족하는 해결 방법을 찾는 과정
    - 비기능 요건 : 시스템 성능, 시스템 가용성, 보안, 유지보수성, 확장성 등
  - 마이크로서비스 아키텍처는 '클라우드'라는 가상화된 인프라를 활용한 것이므로, 이를 고려해 설계해야 함
- 아키텍처 유연성 (```Architecture Flexibility```) : 시스템 자체가 변화 및 확장에 언제든지 대응할 수 있는 능력
  - 시스템을 구성하는 구성 요소 간의 관계들이 느슨하게 결합되어 언제든지 대체되거나 확장될 수 있음
  - 리액티브 시스템이 리액티브하기 위해서 반드시 갖춰야 할 특성 중 하나
  - 클라우드 인프라 자체가 유연성과 확장성을 갖추므로, 어플리케이션 아키텍처 또한 아키텍처 유연성이 필요

<iframe width="90%" height="350" style="border:none" src="https://landscape.cncf.io/?category=automation-configuration&grouping=category&fullscreen=yes"></iframe>

- 과거 : 아키텍처 구성 요소들이 특정 벤더의 제품에 전적으로 의존
  - 유명한 제품군을 사용함으로 품질이 보장될 수 있음
  - 특정 기술에 락인 (```lock-in```)되어 시스템을 쉽게 변경하거나 확장하기 어려움
- 현재 : 클라우드 환경 아래에서 사용하는 오픈 소스 기반 제품들이 충분한 기능, 품질, 호환성을 제공
  - 아키텍처 설계가 필요한 레이어에서 적절한 솔루션을 선택하고 이를 조합하는 개방적 방식으로 변화
  - 클라우드 기반 어플리케이션의 구축에 필요한 인프라 및 어플리케이션 영역에 다양한 제품들이 등장

## ```MSA``` 패턴 : ```MSA```의 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 스타일 혹은 패턴
- 인프라 구성 요소 : 마이크로서비스를 지탱하는 인프라스트럭처를 구축하는 데에 필요한 구성 요소
- 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴
- 어플리케이션 패턴 : 마이크로서비스 어플리케이션을 구성하는 데에 필요한 패턴

### 인프라 구성 요소를 서비스 유형별로 나누어 해당되는 제품 중 하나를 의사결정 → 클라우드 인프라
- ```IaaS``` (```Infrastructure as a Service```) : 가상 머신, 스트리지, 네트워크 등 인프라 제공
  - 고객이 관리할 수 있는 범위가 가장 넓은 클라우드 컴퓨팅 서비스
  - ```AWS``` 등 퍼플릭 클라우드 공급 업체 (```CSP```)가 준비한 환경을 고객이 선택할 수 있음
  - 가상화된 물리적 자원을 ```UI``` 형태의 대시보드 혹은 ```API``` 형태로 제공
  -  고객은 서버와 스트리지에 접근할 수 있지만, 클라우드 내 가상 데이터 센터를 통해 리소스를 전달받는 형태
  - 개발자는 운영체제와 어플리케이션을 직접 관리해야 함 : 개발자와 인프라 관리자의 역할이 분담
  - 예시 : ```AWS EC2```, ```AWS S3```
- ```CaaS``` (```Container as a Service```) : 업로드, 구성, 실행, 확장, 중지할 수 있는 컨테이너 제공
  - 가상 머신이 아닌 컨테이너를 기본 리소스로 활용해 어플리케이션을 개발, 실행, 관리
  - 컨테이너화된 어플리케이션을 빌드하고 배포하는 개발 환경은 퍼플릭 클라우드 공급 업체 (```CSP```)가 제공
  - 예시 : ```Kubernetes Service```, ```AWS ECS```
- ```PaaS``` (```Platform as a Service```) : 어플리케이션에 미들웨어, 런타임까지 탑재한 플랫폼을 제공
  - 가상화된 클라우드 위에 원하는 서비스를 개발할 수 있도록 개발 환경을 미리 구축해 서비스 형태로 제공
  - 고객은 개발 환경을 고려할 필요 없이 어플리케이션 자체에 집중할 수 있음
  - 어플리케이션이 플랫폼에 종속되어 개발되므로, 다른 플랫폼으로의 이식이 어려울 수도 있음
  - 예시 : ```Lambda```, ```AWS Elastic Beanstalk```

### 시스템의 기반이 되는 인프라 레이어의 구축 → 베어메탈 장비 혹은 가상 인프라 환경을 통한 구축
- 가상 인프라 환경 : 하이퍼바이저 (```Hypervisor```)의 사용 여부 및 게스트 OS 유무에 따라 나뉨
  - 가상 머신 (```Virtual Machine```) : 하이퍼바이저를 통해 하나의 시스템에서 여러 운영체제를 사용
    - 운영체제 패치 및 관련 라이브러리 설치로 인한 오버헤드가 지속적으로 발생
  - 컨테이너 (```Container```) : 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성
    - 도커 (```Docker```) : 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 제어
      - 이식성 : 도커만 실행할 수 있으면 호스트 커널에 상관없이 동일하게 사용
      - 신속성 : 크기가 작고 가벼워 빠른 배포가 가능 + 문제 발생 시 다시 가동하면 됨
      - 재사용성 : 동일한 환경을 재사용해 쉽게 설정 가능 → 서버 환경 구축이 쉬워짐
  - 컨테이너 오케스트레이션 (```Container Orchestration```) : 컨테이너 관리 기술
    - 컨테이너 배치 및 복제, 확장 및 축소, 장애 복구 컨테이너 간 통신, 로드밸런싱 등
    - 쿠버네티스 (```Kubernetes```) : ```Pod```, ```Deployment```, ```Replica Sets``` 정보 확인 가능
      - 각 컨테이너가 요구하는 자원을 쿠버네티스에 요청하면 노드에 맞춰 자동 배치
      - 컨테이너 이상을 점검해, 실패하면 컨테이너를 자동으로 교체하고 리스케줄링
      - 일정량의 ```CPU``` 및 메모리 사용량을 초과하면 자동으로 수평 확장

### 마이크로서비스의 운영과 관리를 지원할 클라우드 플랫폼 (미들웨어)의 구축 → 플랫폼 패턴
- 데비옵스 (```DevOps```) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화
  - 소프트웨어를 빠르게 개발하게끔 지원하는 빌드, 테스트, 배포를 위한 자동화 환경
  - 지속적 제공 (```CI```) : 빌드된 소스 코드의 실행 파일을 실행 환경에 반영하기 전에 진행
  - 지속적 배포 (```CD```) : 저장소에 빌드한 소스 코드의 실행 파일을 실행 환경까지 자동으로 배포

> 자동 빌드 및 배포 절차
> 1. 매일 자신이 작성한 소스 코드와 이를 테스트할 테스트 코드를 형상관리 시스템에 보낸다. (```Push```)
> 2. 매일 빌드 도구에서 형상관리 서버의 코드를 가져와 (```Pull```) 통합하고, 자동으로 빌드하고 테스트를 수행한다.
> 3. 테스트 수행 결과를 리포트에 기록하고, 빌드된 소스 코드를 스테이징 환경에 자동으로 배포한다.
> 4. 테스터가 스테이징 환경에서 테스트를 수행할 때 혹은 리포트 결과에 문제가 있으면, 소스 코드를 수정한다.

- 빌드·배포 파이프라인의 설계 : 빌드·배포 과정동안 수행해야 할 업무 (```task```)를 정의한 것
  - 리포지토리에서 소스 코드를 가져와 빌드해 실행 파일을 만드는 작업
  - 이전 작업이 성공하면, 다음 작업이 자동으로 수행히게끔 위의 작업들을 관리하는 작업
  - 실행할 어플리케이션을 실행 환경에 배포하는 작업

  → ```Infrastructure as Code```를 통해 빌드·배포 파이프라인의 절차를 완벽하게 자동화할 수 있음

- ```Infrastructure as Code``` : 인프라 구성을 프로그래밍하는 것처럼 처리해 많은 컨테이너 배포 처리를 함
  - 형상관리 리포지토리에서 소스 코드를 가져와 빌드하여 실행 파일을 만드는 작업
  - 실행 파일을 실행 환경에서 배포하는 작업
  - 작업들을 통제하고 연결해서 모든 작업이 성공하면 다음 작업이 자동으로 수행되도록 연계하는 작업

### 마이크로서비스가 실제 구동되는 환경에서 동작될 수 있도록 운영 관리 요소 → 운영 관리 패턴
- 마이크로서비스의 발전 과정에서 아키텍처의 문제 영역들이 지속적으로 논의되었고, 이에 따른 해결책을 모색해옴
  - 1999년 ```XP``` 방법론, 2001년 에자일 선언을 통해 빠른 실패와 피드백을 기반하는 실용적인 실천법 적용 
  - 2010년 넷플릭스가 ```AWS EC2```로 인프라를 전환하면서 발생한 문제점들을 해결하기 위한 넷플릭스 ```OSS``` 개발
    - 여러 마이크로서비스 간의 라우팅을 위한 줄 (```Zuul```)
    - 적절한 부하 분산을 하는 로드밸런싱을 위한 리본 (```Ribbon```)
    - 모니터링을 위한 히스트릭스 (```Hystrix```)
    - 서비스 등록을 위한 유레카 (```Eureka```)
  - 2013년 마이크로서비스를 쉽게 개발할 수 있는 스프링부트 (```SpringBoot```) 프레임워크가 발표
  - 2013년 도커, 2014년 쿠버네티스와 같은 컨테이너 기반 기술들이 개발

  → 클라우드 환경, 넷플릭스 ```OSS```, 프레임워크, 컨테이너 기반 기술이 아울러져 마이크로서비스 생태계를 계속 발전시킴

- 스프링 클라우드 : 스프링부트 + 넷플릭스 ```OSS```
  - 스프링 진영에서 기존 스프링 프레임워크에 넷플릭스 ```OSS```들이 더 잘 돌아갈 수 있도록 통합하여 발표

> 마이크로서비스 서비스와 스프링 클라우드 서비스의 연계 흐름
> 1. 스프링 클라우드를 포함한 모든 마이크로서비스가 인프라에 종속되지 않도록 ```DB```, 파일 등에 저장된 설정 정보를 형상관리 시스템에 연계된 ```Config``` 서비스에서 가져와 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩
> 2. 로딩과 동시에 '서비스 레지스트리'에 자신의 서비스 이름과 클라우드 인프라로부터 할당받은 물리 주소를 매핑
> 3. 클라이언트가 '```API``` 게이트웨이'를 통해 마이크로서비스에 접근하면, ...
>   - ```API``` 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드밸런싱을 수행
>   - ```API``` 게이트웨이'는 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 '서비스 레지스트리' 검색을 통해 서비스의 위치를 가져옴
>   - '```API``` 게이트웨이'는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 확인하기 위해 '권한 서비스'와 연계해 인증 및 인가 처리를 수행
> 6. 모든 마이크로서비스 간의 호출 흐름은 '모니터링 서비스'와 '추적 서비스'에 의해 모니터링되고 추적됨

#### 다양한 서비스의 등록 및 탐색 → 서비스 레지스트리, 서비스 디스커버리 패턴

- 예시 : 넷플릭스 ```OSS```의 유레카 (```Eureka```), 스프링 유레카 (```Spring Eureka```), 쿠버네티스 ```DNS``` 및 서비스

> - 프런트엔드 클라이언트가 여러 백엔드 마이크로서비스를 어떻게 호출해야 할까?
> - 스케일 아웃을 통해 인스턴스가 여러 개로 복제되었을 때 어떻게 부하를 적절히 분산할 수 있을까? 
>
>   → 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드밸런싱 기능이 제공되어야 한다!
>
> - 라우터가 최적 경로를 탐색하려면 서비스 이름에 해당하는 ```IP``` 주소를 알아야 함
>   - 그런데 이러한 라우팅 정보를 클라이언트가 가진다면, 클라우드 환경에서 동적으로 변경되는 백엔드의 유동 ```IP``` 정보를 매번 전송받아 변경해야 함 → 제3의 공간이 필요
>
>   → 마이크로서비스의 이름과 유동적인 백엔드의 유동 ```IP``` 정보를 보관할 저장소를 제공하자!

- 각 서비스 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 ```IP``` 주소를 레지스트리에 등록
- 클라이언트가 해당 서비스 이름을 호출할 때, 라우터가 레지스트리 서비스를 검색해 매핑된 ```IP``` 주소를 호출
- 즉, 레지스트리는 모든 마이크로서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소
- 모든 마이크로서비스가 처음 가동될 때 자신의 위치 정보를 레지스트리에 저장하고, 서비스가 종료될 때 삭제
- 레지스트리는 ```Config```, 모니터링, 추적과 같이 관리와 운영을 위한 기반 서비스의 주소 또한 함께 보관

#### 서비스 단일 진입 → ```API``` 게이트웨이 패턴

- 예시 : 스프링 클라우드 ```Spring API Gateway```, 쿠버네티스의 인그레스 리소스 (```Ingress Resources```) 및 서비스

> - 여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하면 호출 관계가 매우 복잡해짐
> 
>   → 이러한 복잡한 호출 관계를 통제할 수 있는 방법이 필요하다!

- ```API``` 게이트웨이 (```Gateway```) : 다양한 클라이언트가 다양한 서비스에 접근하기 위한 단일 진입점
  - ```L4``` 하드웨어 장비나 소프트웨어로 구현된 서비스 흐름 제어를 위한 서비스 라우팅 기능을 수행
    - 다른 유형의 클라이언트에게 서로 다른 ```API``` 조합을 제공할 수 있음
    - 각 서비스에 접근할 때 필요한 인증 및 인가 기능을 한번에 처리할 수 있음
    - 서비스에 문제가 발생해 요청에 대한 응답 지연이 발생할 때 다른 서비스로 요청 경로를 변경할 수 있음
  - 레지스트리 서비스와 연계하여 여러 인스턴스로 부하를 분산하는 동적 라우팅이나 로드밸런싱이 가능
  - 권한 서비스와 연계하여 인증 및 인가 처리를 수행할 수 있음
  - 로그 집계 서비스와 연계하여 요청 및 응답 데이터 등에 대한 로깅이 가능
  - 에러율, 평균/최고 지연 시간, 호출 빈도와 같이 시간에 따른 환경 변화를 추적할 수 있는 메트릭 (```Metric```) 데이터를 시계열 형태로 저장할 수 있음
  - 트래킹 ```ID``` 추적과 같이 트레이싱 서비스와 연계하여 서비스 추적이 가능
  - 모니터링 서비스와 연계해 장애 격리가 가능 → 서킷 브레이커 패턴

#### 다양한 클라이언트에 대한 특화된 처리 → ```BFF``` 패턴

- 진입점을 하나로 두는 ```API``` 게이트웨이와 달리, 프런트엔드의 유형에 따라 각각의 진입점을 둠
- 프런트엔드를 위한 백엔드라는 의미에서 ```Backend for Frontend```
- 각 프런트엔드에 대한 처리만 수행하는 ```BFF``` 이후에 통합 ```API``` 게이트웨이를 두어, 공통 처리를 통제할 수도 있음

#### 마이크로서비스 어플리케이션 구성 정보의 관리 → 외부 구성 저장소 패턴

> - 클라우드 인프라를 사용할 때, 어플리케이션이 마이크로서비스가 사용하는 자원의 설정 정보를 포함하면? 
>   - 자원의 설정 정보이 변경될 때 어플리케이션이 반드시 재배포해야 하므로 서비스가 중단되어야 함
>   - 여러 마이크로서비스가 동일한 구성 정보를 사용한다면 이를 일일이 변경하기가 어려움
>   - 여러 마이크로서비스를 변경하는 시점에 일부 마이크로서비스의 구성 정보가 불일치할 수도 있음
>
>    → 마이크로서비스가 사용하는 자원의 설정 정보를 쉽고 일관되게 변경 가능하도록 관리해야 한다!

- 외부 저장소 : ```DB``` 연결 정보, 파일 스토리지 정보와 같이 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 관리
- ```Config``` 원칙 : ```Staging```, ```Dev```, ```Test```처럼 어플리케이션 배포 환경은 매번 달라지니, 코드와 설정 정보는 분리돼야 함 

> Reference
>
> - <a href="https://www.aladin.co.kr/m/mproduct.aspx?ItemId=285280054">도메인 주도 설계로 시작하는 마이크로서비스 개발</a>