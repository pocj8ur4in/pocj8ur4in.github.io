---
title: "[CS] 1. 운영체제 (Operation System)"

tags:
    - Computer Science

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2022-12-12
---

## 운영체제 (```Operation System```) : 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어
- 컴퓨터 시스템 자원의 효율적인 관리 (```Performance```) : 하드웨어 자원을 각각의 사용자 응용 프로그램에 적절히 분배
  - 하드웨어 자원 (```Hardware Resource```) : CPU 시간, 기억 장치 및 디스크 영역, I/O 장치
- 사용자 편의성 제공 (```Convenience```) : 사용자가 더 편리하게 사용할 수 있는 환경을 구성

<div style="color: white; padding: 2% 0% 2% 0%; background-color: black;">
<ul>
  <li>프로세스 관리 (Process Management)</li>
  <li>메인 메모리 관리 (Main Memory Management)</li>
  <li>파일 관리(File Management)</li>
  <li>저장 장치 관리 (Storage Management)</li>
  <li>I/O 장치 관리 (I/O Device Management)</li>
  <li>시스템 호출 (System call)</li>
</ul>
</div>

### 부팅 (```Booting```) : 컴퓨터를 시작할 때 자기 자신을 구동시킬 프로그램을 스스로 불러내는 동작
- 메인 메모리 (```Main Memory```) : 즉시 필요한 데이터를 저장하는 주 기억 장치
  - ```RAM``` : 휘발성 주 기억 장치 (전원이 꺼지면 모든 내용이 지워짐)
    - 코드 영역 (```Code Area```) : 실행할 프로그램의 코드가 저장되는 영역
      - CPU는 이 영역에 저장된 명령어를 하나씩 호출해 수행함
    - 데이터 영역 (```Data Area```) : 실행할 프로그램의 전역 변수와 정적 변수가 저장된 영역
      - 프로그램 시작 시 할당, 프로그램 종료 시 소멸
    - 스택 영역 (```Stack Area```) : 실행할 프로그램의 함수 호출과 관련된 지역 변수와 매개 변수가 정적으로 저장된 영역
      - 후입선출 (```Last-In, First-Out```) 방식에 따른 동작 : ```PUSH```로 데이터를 저장하고, ```POP```로 데이터를 인출 
      - 메모리의 높은 주소에서 메모리의 낮은 주소의 방향으로 할당 
      - 함수 호출 시 할당, 함수 호출 종료 시 소멸
    - 힙 영역 (```Heap Area```) : 사용자에 의해 동적으로 할당되고 해제되는 전역 변수가 저장되는 영역
      - 할당되는 변수의 크기 제한이 없음 : 크기 제한이 존재하는 스택에 비해 액세스 속도가 상대적으로 느림
      - CPU에 의해 효율적으로 관리되는 스택 영역과 달리, 사용자가 힙 영역을 관리해야 함
        - 메모리 단편화 (```Memory Fragmentation```) : 사용 가능한 메모리가 존재하지만, 할당이 불가능한 상태
      - 메모리의 낮은 주소에서 메모리의 높은 주소의 방향으로 할당
  - ```ROM``` : 비휘발성 주 기억 장치 (전원이 꺼져도 그 안의 내용이 계속 유지)
    - ```POST``` (```Power-On Self-Test```) : (부팅 시 가장 처음 실행되는 프로그램) 현재 컴퓨터의 상태 검사
    - 부트 로더 (```Boot Loader```) : (```POST``` 다음에 실행되는 프로그램) 보조 기억 장치의 운영체제를 탐색 후 ```RAM```에 할당
      - 보조 기억 장치에서 ```RAM```으로 할당된 운영체제는 컴퓨터 전원이 꺼질 때까지 상주 (```Resident```)
- ```SSD```/```HDD``` : 운영체제가 저장된 보조 기억 장치
  - 커널 (```Kernel```) : 운영체제가 수행하는 모든 작업이 저장
  - 명령어 해석기 (```Shell```) : 사용자가 요청하는 명령어를 해석해 커널에 요청하고 결과를 출력
    - 응용 프로그램 (```Application```) : 운영체제 위에서 수행되며, 운영체제가 지원하는 자원만을 사용 가능

### 일괄 처리 시스템 (```Batch Processing System```) : 프로그램 수행 과정의 자동화
- ```Resident Monitor``` : 프로세서에 할당하기 위해 (컴파일 -> 링크 -> 로딩)의 과정을 하나의 프로그램으로 작성

### 시분할 시스템 (```Time-sharing System```) : CPU가 프로그램을 수행하는 시간을 제한
- 스위칭 (```Switching```) : 프로그램이 일정 시간 실행되면 ```Time Out```을 발생시켜 다음 프로그램으로 넘어가게 함
- 다중 작업 (```Multitasking```) : CPU가 짧은 시간 내에 여러 프로그램을 스위칭해 동시에 작업하는 것처럼 보이게 함
  - CPU 스케줄링 (```CPU Scheduling```) : CPU가 어느 프로그램을 실행할지 선택하는 작업

### 다중 프로그래밍 시스템 (```Multiprogramming System```) : 메모리에 여러 응용 프로그램을 적재시켜 idle 상태 최소화
- 프로그램 실행 시에 계산을 담당하는 ```CPU```와 입출력을 담당하는 ```I/O``` 장치가 교대로 실행
  - ```idle```상태 : I/O 장치가 실행되는 동안 CPU가 아무런 작업도 하지 않는 상태

### 인터럽트 기반 시스템 (```Interrupt-based System```) : 인터럽트 발생 시 ```ISR```에 맞는 처리 수행
- 인터럽트 (```Interrupt```) : 프로그램 실행 중에 예기치 않은 상황이 발생할 경우 이를 CPU에 알리는 전기 신호
  - 외부 인터럽트 (```Eternal Interrupt```) = 하드웨어 인터럽트 (```Hardware Interrupt```)
  - 내부 인터럽트 (```Internal Interrupt```) = 소프트웨어 언터럽트 (```Software Interrupt```)
    - 예외 (```Exception```)
    - 시스템 호출 (```System call```)
- 인터럽트 서비스 루틴 (```Interrupt Service Routine```) : 인터럽트 신호를 처리하기 위한 방법을 내포한 운영체제 내의 코드

### 이중 모드 (```Dual Mode Execution```) : 유저 (```User```) 모드와 커널 (```Kernel```) 모드를 나눔

> ! 문제 : 어떤 작업이 자원을 계속해서 점유하는 일과 같이 컴퓨터의 작업 효율을 저해하는 행위로부터 보호할 수단을 필요

- CPU 내 레지스터 (```Register```)의 ```Mode-Bit```를 플래그 (```flag```)로 활용해 나타냄 (커낼 모드 : ```0```, 유저 모드 : ```1```)
- 각 명령어에 ```Mode-Bit```를 넣어 시스템 내의 ```Mode-Bit```와 같을 시에만 명령어 수행
- 특권 명령어 (```Privileged Instruction```) : 커널 모드에서만 내릴 수 있는 명령어
  - ```STOP```, ```HALT```, ```RESET```, ```SET_TIMER``` 등
  - 유저 모드에서는 특권 명령어를 내릴 수 없음 (내부 인터럽트를 발생해 해당 명령어를 요청한 프로그램을 강제 종료)
- 시스템 호출 (```System Call```) : ```Mode-Bit```를 바꾸는 행위 (```INT 80```)
  - 사용자가 하드웨어의 자원에 접근할 때, 프로그램에서 시스템 호출을 발생시켜 운영체제에 위임해 커널 모드로 처리

> - 컴퓨터가 부팅되는 과정 : 커널 모드
> - 응용 프로그램이 실행되는 과정 : 커널 모드
> - 응용 프로그램이 실행되는 중일 때 : 유저 모드
> - 인터럽트가 발생한 후 처리하는 과정 : 커널 모드
> - 인터럽트를 처리한 후 : 유저 모드

#### 하드웨어 보호 (```H/W Protection```) : 잘못된 명령이나 접근으로부터 보호하기 위해 운영체제에서 내부 인터럽트를 발생

> ! 문제 : 정보들이 여러 I/O 장치를 통해 컴퓨터로 입출력되는 과정에서 장치 간 혹은 데이터 간의 혼선이 발생할 수 있음

##### 입출력 장치 보호 (```I/O Protection```) : ```in```, ```out```과 같은 입출력 명령을 특권 명령으로 지정해 운영체제를 통해 수행
- 입출력 수행 시에는 관리자 모드로 전환해 특권 명령을 내림
  - ```Privileged Instruction Violation``` : 사용자가 입출력 명령을 직접 내린 경우 프로그램을 강제 종료 

> ! 문제 : 다른 사용자나 운영체제에 할당된 메모리 영역에 접근해 정보나 프로그램을 해킹할 수 있음

##### 메모리 보호 (```Memory Protection```) : CPU와 메인 메모리 간 주소 버스에 ```MMU``` (```Memory Management Unit```)를 설치
- 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장
- 사용자에 할당된 메모리 영역을 벗어난 주소값을 가져오지 못하게 함
- ```MMU``` 설정은 운영체제만 변경 가능
  - ```Segment Violation``` : 만약 사용자에 할당된 메모리 영역을 벗어난 주소값이 ```MMU```에 들어오면 내부 인터럽트를 발생시킴

> ! 문제 : 프로그램에서의 무한 루프로 인해 CPU가 독점되어 다른 프로그램이 수행되지 못할 수 있음

##### CPU 보호 (```CPU Protection```) : 타이머 (```Timer```)를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킴
- 타이머 (```Timer```) : 무한 루프나 자원 독점을 막기 위해 특정 시간이 지나면 타이머 인터럽트를 발생시킴
  - 타이머 인터럽트 (```Timer Interrupt```) : 해당 인터럽트의 ISR에서 CPU는 각 프로그램의 CPU 점유 시간을 측정해 분배
  - 운영체제는 타이머가 끝난 작업을 종료시키고 스케줄링 (```Scheduling```) 이전에 타이머 실행

## 프로세스 (```Process```) : 실제 메인 메모리에 할당되어 실행 중인 프로그램
- 프로그램은 보조 기억 장치에서 아무런 동작을 하지 않은 상태
- 어떤 요청에 의해 메인 메모리에 할당되어 CPU를 사용하면서 실행
- 각각의 프로세스는 CPU에 의해 샐행된 후 ...를 생성 (메인 메모리를 효율적으로 사용해야 함)
  - 프로세스 테이블 엔트리 = 프로세스 컨트롤 블록 (```Process Control Block```)
  - 주소 공간 (```Address Space```)
    - 코드 세그먼트 (```Code Segment```) : 프로그램 소스 코드가 저장
    - 데이터 세그먼트 (```Data Segment```) : 전역 변수가 저장
    - 스택 세그먼트 (```Stack Segment```) : 지역변수와 매개변수가 저장

> 지역변수와 매개 변수가 후입선출의 방식을 따른 스택에 저장되기에, 전역 변수를 먼저 선언해 메인 메모리의 공간 절약 가능

### 프로세스의 생성과 종료 (```Creation and Destruction of Process```)
- 최초의 프로세스인 ```Init```의 생성은 부팅된 운영체제가 처음 수행하는 작업 중 하나
- 생성된 프로세스가 다른 프로세스를 생성하는 과정을 반복
  - 프로세스의 생성을 위한 시스템 호출 : ```fork()```
  - 프로세스의 종료를 위한 시스템 호출 : ```exit()```
- 생성된 모든 프로세스는 자신을 식별할 수 있는 고유의 정수값인 ```PID```을 가짐
  - 생성된 모든 프로세스는 자신을 생성한 사용자 고유의 ```UID``` 값 또한 가짐 (부모와 자식이 동일한 값)

<img src="https://i.stack.imgur.com/6RGIe.jpg" width="30%" style="margin-left: 2%">

- 프로세스 트리 (```Process Tree```) : 부모 프로세스인 A에서 자식 프로세스인 B, C, D가 파생되어 생성
  - 부모 프로세스 : 프로세스를 생성한 프로세스
  - 자식 프로세스 : 프로세스로부터 생성된 프로세스
  - 형제 프로세스 : 같은 부모 프로세스에서 파생된 자식 프로세스

### 프로세스 컨트롤 블록 (```Process Control Block```) : 프로세스에 대한 모든 정보를 저장하는 곳
- CPU는 여러 프로세스를 빈번히 전환하면서 수행하기에 각 프로세스의 데이터를 저장해야 작업을 이어서 수행할 수 있음
- 운영체제 내에서 프로세스를 관리하는 코드 부분에 저장
  - 프로세스 컨트롤 블록에 데이터를 저장하고 복원하는 시간 역시 다중 작업을 위해 각 프로세스에 할당되는 시간에 포함
- 프로세스 상태 (```Process Status```), 프로그램 카운터 (```Program Counter```), 스택 포인터 (```Stack Pointer```), 파일 디스크립터 (```File Descriptors```) 등의 정보 포함

<img src="https://user-images.githubusercontent.com/34755287/70577652-12841080-1bef-11ea-8f1c-5c0e0d94c132.png" width="80%" style="margin-left: 2%">

#### 프로세스 상태 (```Process Status```) : 각 단계들에서 상태 전이가 일어나 다음 단계로 넘어감
- ```New``` : 프로그램이 메인 메모리에 할당된 상태
- ```Ready``` : 프로세스가 언제든 실행 가능한 상태; 할당된 프로그램이 실행되기 위한 모든 준비를 마친 상태로 대기된 상태
  - n개의 작업이 있을 때, CPU의 프로세서는 스케줄러의 0~(n-1)번, 즉 n개의 작업을 번갈아 처리
- ```Running``` : CPU가 해당 프로세스를 실제로 실행중인 상태
- ```Waiting```=```Blocked``` : ```Running```이 불가능한 상태
  - 프로세스가 끝나지 않은 시점에 해당되는 I/O 정보가 없어 작업할 수 없음
  - ```Waiting```가 끝나면 다시 CPU에 실행되기 위해 ```Ready```로 돌아가야 함
- ```Terminated``` : 프로세스가 완전히 종료된 상태

<img src="https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png"  width="80%" style="margin-left: 2%">

> - I/O 작업으로 인한 상태 변화 : ```Running``` -> ```Waiting``` -> ```Ready``` -> ```Running```
> - 시간 초과로 인터럽트에 의한 상태 변화 : ```Running``` -> ```Ready``` -> ```Running```

### 프로세스 큐 (```Process Queue```) : 커널이 프로세스 스케줄링을 위해 데이터 영역에서 관리하는 큐
- ```Ready Queue``` : 프로세스 상태가 ```Ready```인 프로세스들이 CPU 제어를 기다리는 큐
  - 어떤 CPU 스케줄링 알고리즘을 선택하는지에 따라 CPU 제어 순서가 달라짐
- ```Job Queue``` : 보조 기억 장치의 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐
  - 시스템 내의 모든 프로세스 관리 : ```Ready Queue```, ```Device Queue```에 속한 모든 프로세스 포함
- ```Device Queue``` : 프로세스 상태가 ```Waiting```인 프로세스들이 CPU 외의 자원을 기다리는 큐
  - 기다리는 자원들마다 큐가 할당되며, 해당 자원이 사용되면 인터럽트를 발생시키고 ```Ready Queue```로 이동

<img src="https://user-images.githubusercontent.com/34755287/53879660-5ccdd500-4052-11e9-972d-11ba3faeb3e3.png" width="80%" style="margin-left: 2%">

- 각 큐는 프로세스의 프로세스 컨트롤 블록을 가리키는 포인터 방식으로 연결 리스트를 구현

#### 스케줄러 (```CPU Scheduler```) : 프로세스 순서를 정해 프로세스 큐에 올릴 것을 결정하는 커널의 코드
- 장기 스케줄러 (```Long-term Scheduler```) : 생성된 프로세스 중 어떤 것을 ```Job Queue```에서 ```Ready Queue```으로 이동시킬지 선택
  - 장기 스케줄러는 현재 메모리에 할당된 프로세스의 개수 (```Degree of multiprogramming```)를 제어
  - 장기 스케줄러는 ```I/O bound Process```,```CPU bound Process```를 메인 메모리에 적절히 할당해야 함
    - ```I/O bound Process``` : I/O 작업 (입출력) 비중이 높은 프로세스
    - ```CPU bound Process``` : CPU 작업 (계산) 비중이 높은 프로세스
- 중기 스케줄러 (```Medium-term Scheduler```) : 실행 중인 프로세스 중 보조 저장 장치로 옮길 것을 주기적으로 검사
  - ```Swapping``` (```Swap-out```↔```Swap-in```) : ```Swap-in```할 때 이전 공간으로 재할당되는 것은 보장되지 않음
    - ```Swap-out``` : 메인 메모리에서 우선 순위가 은 프로세스를 통째로 보조 기억 장치로 저장
    - ```Swap-in``` : 나중에 해당 프로세스가 다시 사용되려 할 때 보조 기억 장치에서 메인 메모리에 다시 할당
  - 중기 스케줄러 또한 현재 메모리에 할당된 프로세스의 개수 (```Degree of multiprogramming```)를 제어
- 단기 스케줄러 (```Short-term Scheduler```) : ```Ready Queue``` 내에서 프로세스들 중 어떤 것을 다음에 실행시킬지 선택
  - CPU 스케줄러 (```CPU Scheduler```) 라고도 부르며, 시분할 시스템에서 ```Time Out```이 발생하면 호출

##### 문맥 전환 (```Context Switching```) : CPU가 실행중인 프로세스를 멈추고 다른 프로세스를 실행하는 작업
- 문맥 (```Context```) : 각 프로세스 컨트롤 블록 내에서 표현
  - 하드웨어 문맥 : 프로그램 카운터 정보와 레지스터 정보를 저장
  - 프로세스 주소 공간 : 각 프로세스가 갖고 있는 독자적인 주소 공간에 위치
- CPU 스케줄러 : CPU가 어느 프로세스를 다음에 실행할지 지정
- 디스패쳐 (```Dispatcher```) : 문맥 전환이 발생하면 ```Ready```에서 ```Running```으로 상태 전이
  - 문맥 전환 오버헤드 (```Context Switching Overhead```) : 문맥 전환이 발생할 때마다 디스패쳐를 매번 실행시킴<br><br>

1. CPU에서 실행중인 프로세스의 데이터는 해당 프로세스의 프로세스 컨트롤 블록에 갱신
2. 새로 시작될 프로세스의 프로세스 컨트롤 블록를 CPU로 복원
3. 캐시와 ```Translation Lookup Buffer```를 재설정
  
> - 시스템 호출로 인한 인터럽트 발생 시 :
>   - 실행 중인 프로세스의 문맥을 프로세스 컨트롤 블록에 갱신하나, 문맥 전환은 이루어지지 않음

## CPU 스케줄링 (```CPU Scheduling```) : CPU 스케줄러에서 어느 프로세스를 다음에 실행할지 지정
- 선점 (```Preemptive```) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 강제로 점유할 수 있음
- 비선점 (```Non-Preemptive```) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 점유할 수 없음 (예외 : ```I/O``` 발생)

### CPU 스케줄링 척도 (```CPU Scheduling Criteria```) : CPU 스케줄링의 효율을 분석하는 기준
- CPU 점유율 (```CPU Utilization```) : 현재 CPU가 작업을 수행하는 비율 -> 높을수록 좋음
- 처리율 (```Throughput```) : 단위 시간 당 완료되는 프로세스의 개수 -> 많을수록 좋음
- 소요 시간 (```Turnaround Time```) : 프로세스가 생성된 시간부터 종료되는 데까지 걸린 시간 -> 짧을수록 좋음
- 대기 시간 (```Waiting Time```) : CPU 제어를 위해 ```Ready Queue```에서"만" 대기한 시간 -> 짧을수록 좋음
  - 평균 대기 시간 (```Average Waiting Time```) : (각 프로세스들의 대기 시간의 합) / (프로세스들의 개수)
- 응답 시간 (```Response Time```) : ```Interactive System```에서 입력에 대한 반응 시간 -> 짧을수록 좋음

### 선입선출 (```First-Come, First-Served```) 스케줄링 : 가장 먼저 작업을 요청한 프로세스를 먼저 수행
- 비선점 (```Non-Preemptive```)
- 들어온 순서대로 작업을 수행한다고 해도 그것이 반드시 효율적이지 않음
  - ```Convoy Effect``` : CPU를 많이 점유하는 프로세스가 먼저 수행되어 나머지 프로세스들이 그만큼 오래 대기하는 것

> <table style="text-align: center">
>  	<thead>
> 		<tr>
> 			<th>Process</th>
> 			<th>Burst Time (msec)</th>
> 		</tr>
> 	</thead>
>    	<tbody>
>       <tr>
>         <td>P1</td>
>         <td>3</td>
>       </tr>
>       <tr>
>         <td>P2</td>
>         <td>3</td>
>       </tr>
>       <tr>
>         <td>P3</td>
>         <td>24</td>
>       </tr>
>     </tbody>
> </table>
> - FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.
>   - Average Waiting Time : (0 + 3 + 6) / 3 = 3msec

> <table style="text-align: center">
>  	<thead>
> 		<tr>
> 			<th>Process</th>
> 			<th>Burst Time (msec)</th>
> 		</tr>
> 	</thead>
>    	<tbody>
>       <tr>
>         <td>P1</td>
>         <td>24</td>
>       </tr>
>       <tr>
>         <td>P2</td>
>         <td>3</td>
>       </tr>
>       <tr>
>         <td>P3</td>
>         <td>3</td>
>       </tr>
>     </tbody>
> </table>
> - FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3 순으로 처리한다.
>   - Average Waiting Time : (0 + 24 + 27) / 3 = 17msec
> - CPU를 오래 점유하는 P3로 인해 상대적으로 빠른 처리가 가능한 P1과 2가 오래 대기하는 Convoy Effect이 발생!

### 최단작업 (```Shortest-Job-First```) 스케줄링 : 시간이 가장 짧게 수행되는 프로세스를 먼저 수행
- 비선점 (```Non-Preemptive```), 선점 (```Preemptive```)
- 일반적으로 가장 빠른 평균 대기 시간을 가지나, 현실에서는 각 프로세스의 CPU 점유 시간이 주어져 있지 않기에 비현실적

> <table style="text-align: center">
>  	<thead>
> 		<tr>
> 			<th>Process</th>
> 			<th>Burst Time (msec)</th>
> 		</tr>
> 	</thead>
>    	<tbody>
>       <tr>
>         <td>P1</td>
>         <td>6</td>
>       </tr>
>       <tr>
>         <td>P2</td>
>         <td>8</td>
>       </tr>
>       <tr>
>         <td>P3</td>
>         <td>7</td>
>       </tr>
>       <tr>
>         <td>P4</td>
>         <td>3</td>
>       </tr>
>     </tbody>
> </table>
> - FCFS Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, P4 순으로 처리한다.
>   - Average Waiting Time : (0 + 6 + 14 + 21) / 4 = 10.25msec
> - SJF Scheduling : (작업 시간이 짧은 순서대로) P4, P1, P3, P2 순으로 처리한다.
>   - Average Waiting Time : (0 + 3 + 9 + 16) / 4 = 7msec

### 우선순위 (```Priority```) 스케줄링 : 우선순위가 가장 높은 프로세스를 먼저 수행
- 비선점 (```Non-Preemptive```), 선점 (```Preemptive```)
- 우선순위는 정수값으로 표현되며, 값이 작을수록 우선순위가 높음

> <table style="text-align: center">
>  	<thead>
> 		<tr>
> 			<th>Process</th>
> 			<th>Burst Time (msec)</th>
>       <th>Priority</th>
> 		</tr>
> 	</thead>
>    	<tbody>
>       <tr>
>         <td>P1</td>
>         <td>10</td>
>         <td>3</td>
>       </tr>
>       <tr>
>         <td>P2</td>
>         <td>1</td>
>         <td>1</td>
>       </tr>
>       <tr>
>         <td>P3</td>
>         <td>2</td>
>         <td>4</td>
>       </tr>
>       <tr>
>         <td>P4</td>
>         <td>1</td>
>         <td>5</td>
>       </tr>
>       <tr>
>         <td>P5</td>
>         <td>5</td>
>         <td>2</td>
>       </tr>
>     </tbody>
> </table>
> - Priority Scheduling : (우선순위가 높은 순서대로) P2, P5, P1, P3, P4 순으로 처리한다.
>   - Average Waiting Time : (0 + 1 + 6 + 16 + 18) / 5 = 8.2 msec 

### 라운드 로빈 (```Round-Robin```) 스케줄링 : 원 모양으로 모든 프로세스를 돌아가면서 수행
- 선점 (```Preemptive```)
- 시분할 시스템에서 CPU가 한 프로세스를 일정 시간 수행한 후, 이를 대기 상태로 보내고 다음 프로세스를 수행하는 것을 반복
  - ```Time Quantum``` : CPU가 한 프로세스를 수행하는 시간 -> 스케줄리의 효율성이 ```Time Quantum```의 크기에 의존 

> <table style="text-align: center">
>  	<thead>
> 		<tr>
> 			<th>Process</th>
> 			<th>Burst Time (msec)</th>
>       <th>Time Quantum</th>
> 		</tr>
> 	</thead>
>    	<tbody>
>       <tr>
>         <td>P1</td>
>         <td>7</td>
>         <td rowspan="3">4msec</td>
>       </tr>
>       <tr>
>         <td>P2</td>
>         <td>4</td>
>       </tr>
>       <tr>
>         <td>P3</td>
>         <td>4</td>
>       </tr>
>     </tbody>
> </table>
> - RP Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, 그리고 (완료하지 못한) P1 순으로 처리한다.
>   - Average Waiting Time : (4 + 8 + 12) / 3 = 8 msec

> <table style="text-align: center">
>  	<thead>
> 		<tr>
> 			<th>Process</th>
> 			<th>Burst Time (msec)</th>
>       <th>Time Quantum</th>
> 		</tr>
> 	</thead>
>    	<tbody>
>       <tr>
>         <td>P1</td>
>         <td>7</td>
>         <td rowspan="3">3msec</td>
>       </tr>
>       <tr>
>         <td>P2</td>
>         <td>4</td>
>       </tr>
>       <tr>
>         <td>P3</td>
>         <td>4</td>
>       </tr>
>     </tbody>
> </table>
> - RP Scheduling : (CPU에 요청받은 순서대로) P1, P2, P3, (완료하지 못한) P1, P2, P3, 그리고 P1 순으로 처리한다.
>   - Average Waiting Time : (12 + 13 + 14) / 3 = 13 msec

### 멀티레벨 큐 (```Multi-level Queue```) 스케줄링 : 각 프로세스 그룹에 따른 큐를 두어 수행
- 프로세스 그룹 : 프로세스를 기준에 따라 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치
  - ```Interactive Process``` : 유저 수준 > 데이터를 바로바로 처리 (```I/O bound Process```)
  - ```Batch Process``` : 유저 수준 > 일정 시간에 데이터를 한번에 처리 (```CPU bound Process```)
- 우선순위에 따라 대기할 큐를 지정할 수 있고, 각 큐마다 서로 다른 스케줄링 방식을 사용 가능

### 멀티레벨 피드백 큐 (```Multi-level Feedback Queue```) 스케줄링 : 멀테레벨 큐에 피드백 추가 
- 멀티레벨 큐처럼 프로세스를 여러 그룹으로 나누고, 각 그룹에 따른 큐 배치
  - 모든 프로세스들은 처음에는 무조건 우선순위가 가장 높은 큐에서 대기 (vs 멀티레벨 큐 : 우선순위에 따른 큐 지정 가능)
- 피드백 (```Feedback```) : ```time out```이 발생한 프로세스를 보다 낮은 우선순위의 큐로 격하
  - 우선순위와 ```CPU burst```가 반비례 : ```I/O bound Process```는 높은 우선순위, ```CPU bound Process```는 낮은 우선순위

## 프로세스 간 통신 (```Inter-Process Communication```) : 프로세스들 간에 서로 데이터를 주고받는 행위
- 독립 프로세스 (```Independent Process```) : (단일 처리 시스템에서) 다른 프로세스에 독립적으로 실행되는 동기적 프로세스
- 협력 프로세스 (```Cooperating Process```) : 실행중인 다른 프로세스와의 상호 작용을 통해 수행되는 비동기적 프로세스

### 공유 메모리 (```Shared Memory```) : 협력 프로세스 간 하나의 공유 메모리 영역을 만들어 상호 통신
> 공유 메모리 세그먼트 : 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치

- 장점 : 커널 의존성이 낮아 속도가 빠르고, 유저 레벨에서의 IPC가 가능해 자유로운 통신이 가능
- 단점 : 자원과 데이터를 공유하기에 동기화 문제가 발생

### 메시지 패싱 (```Message Passing```) : 협력 프로세스 간 각자의 메시지를 운영 체제에 전달해 통신
- 장점 : 별도의 구축 없이 커널만을 이용하기에 비교적 구현이 쉬움
- 단점 : 커널을 이용할 때마다, 시스템 호출에 따른 문맥 전환이 매번 발생 (문맥 복사 2번 수행, 문맥 전환 오버헤드 발생)

## 쓰레드 (```Thread```) : 프로세스 내부의 흐름
- CPU를 구성하는 기본 단위로, 일반적으로 하나의 프로세스은 하나의 쓰레드가 존재
- 하나의 쓰레드는 고유한 ```Thread ID```, ```Program Counter```, ```Register Set``` 및 ```Stack```을 가짐

### 다중 쓰레드 (```Multi-Threads```) :  하나의 프로세스에 쓰레드가 2개 이상 존재
-  ```Concurrent``` : 한 프로세스에서 여러 쓰레드가 빠른 시간 간격으로 스위칭되어 동시에 실행되는 것처럼 보임
   - 여러 쓰레드들이 하나의 프로세스 안에 속하면서 ```code```, ```data``` 메모리 공간과 프로세스 자원 ```file```과 ```I/O``` 공유
   - 메시지 패싱 X (운영 체제를 거치지 않고도 통신 가능), 공유 메모리 X (공유 메모리를 만들지 않아도 됨)
     - 멀티 프로세스에 비해 문맥 전환 시간이 짧고, 메모리와 자원의 할당이 더 효율적
- 운영체제가 다중 쓰레드를 지원 : 현대 운영체제에서의 문맥 전환은 프로세스가 아닌 쓰레드 단위로 이루어짐
  - 하나의 프로세스 안에서 여러 쓰레드가 수행되다가 다른 프로세스로 넘어가 그 프로세스의 쓰레드를 수행함
    - 웹 브라우저 : 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 따로 수행

### 다중 쓰레드 모델 (```Multi-Threads Models```) :  2개 이상의 쓰레드로 구성된 모델
- 유저 쓰레드 (```User Thread```) : 유저 레벨의 쓰레드 라이브러리를 통해 관리되는 쓰레드
- 커널 쓰레드 (```Kernel Thread```) :  운영체제가 제공하고 직접 관리하는 쓰레드

#### ```Many-to-One``` 모델 : 한 커널 쓰레드가 여러 유저 쓰레드 처리
- 병목 현상 : 시스템 호출이 발생하면, 모든 유저 쓰레드가 대기해야 함

#### ```One-to-One``` 모델 : 유저 쓰레드 한 개당 커널 쓰레드를 대응시켜 처리
- 커널 쓰레드가 과도하게 생성되어 비효율적임

#### ```Many-to-Many``` 모델 : 여러 유저 쓰레드가 여러 커널 쓰레드 처리
- 커널 쓰레드의 수는 유저 쓰레드의 수보다 작거나 같게 해야 함

#### ```Two-Level``` 모델 : 중요한 작업은 ```One-to-One```으로, 나머지는 ```Many-to-One```으로 처리

## 메인 메모리 관리 (```Main Memory Management```)
- 메모리 공간은 기본적으로 주소 (```address```)와 데이터 (```data```)로 구성되어 있음
  - ```CPU```는 주소를 가지고 메인 메모리에 요청을 하거나 해당 주소에 계산 결과를 저장
  - 메인 메모리는 ```CPU```가 요구하는 주소에 저장되어 있는 데이터를 ```CPU```에게 전달

<img src="https://user-images.githubusercontent.com/34755287/54821877-d74f5380-4ce6-11e9-8888-e63816796f65.png"  width="80%" style="margin-left: 2%">

- 프로그램의 빌드는 소스 파일, 목적 파일, 실행 파일 순서로 생성
  - 소스 파일 (```Source file```) : 고수준 언어 또는 어셈블리어
    - 컴파일 단계 : 소스 파일은 컴파일러 또는 어셈블러에 의해 컴파일 또는 어셈블하여 목적 파일 생성
  - 목적 파일 (```Object file```) : 컴파일된 결과 또는 어셈블된 결과
    - 링크 단계 : 목적 파일은 링커 (```Linker```)에 의해 하드 디스크의 라이브러리을 찾아 정보를 추가해 실행 파일 생성
  - 실행 파일 (```Executable file```) : 링크된 결과
    - 로드 단계 : 실행 파일은 로더 (```Loader```)에 의해 메인 메모리에 할당

<img src="https://user-images.githubusercontent.com/34755287/54821878-d74f5380-4ce6-11e9-98e8-a43b086a4837.png"  width="80%" style="margin-left: 2%">

- 빌드된 프로그램은 ```code```, ```data```, ```stack``` 영역으로 구분됨
  - 단순히 생성된 프로그램은 ```code```, ```data``` 영역만 존재
  - 로드 단계에서 프로그램이 실행을 위해 메모리에 적재되었을 때, 운영체제에 의해 ```stack``` 영역이 추가됨

### 메모리 계층 (```Memory hierarchy```) : 각각의 특징이 있는 저장 장치를 혼용해 효율성 극대화
- 메모리 매니저 (```Memory Manager```) : 메모리 하이라키를 관리하는 관리 시스템의 일부분


<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9986554C5C76482528" width="80%" style="margin-left: 2%">

- 캐시 (```Cash```) : 빠르고, 비싸고, 휘발성
- 메인 메모리 (```Main Memory```) : 캐시보다 느리고, 캐시보다 싸고, 휘발성
- 디스크 스토리지 (```Disk Storage```) : 메인 메모리보다 느리고, 메인 메모리보다 싸고, 비휘발성

> 메모리 계층 구조를 통해 프로그래머가 사용하기 좋은 모델로 <b>추상화</b>하고, 운영체제를 통해 이 추상회된 객체를 관리한다.

### Q. ```CPU```가 한 번에 한 프로세스를 수행하면? : ```Mono-Programming```

- 메인 프레임 (```mainframe```) : ```RAM``` 위의 ```OS```에 유저 프로그램이 주소로 연결되어 존재
- 임베디드 시스템 (```Embedded System```) : ```OS```가 위치한 ```ROM``` 아래에 유저 프로그램이 주소로 연결되어 존재
- 퍼스널 컴퓨터 (```personal computer```) : 메인 프레임 + ```ROM``` 위 장치 관리자가 유저 프로그램 위에서 ```OS```의 관리를 받음

> 하단 내용은, ```CPU```가 여러 프로세스를 돌아가면서 수행하는 ```Multi-Programming``` 환경이라 가정한다.

### Q. 만약 메모리 추상화를 사용하지 않는다면? : 모든 프로그램이 물리 메모리를 직접 사용
- 프로그래머에게 제공되는 메모리 영역 : 실제 물리 메모리 (0 ~ (실제 물리 메모리의 크기))
  - 각 주소는 ```n```비트로 구성된 셀 (```Cell```)로 정의
- 하드웨어의 도움 없이 두 프로그램이 동시에 메모리에서 실행된다는 것은 불가능
  - 메모리의 프로세스를 이미지 형태로 디스크에 저장하고, 실행할 프로그램을 메모리로 스와핑 (```Swapping```)할 수는 있음

> ! 메모리 추상화를 사용하지 않는다고 했으니, 메모리 계층 구조 또한 존재하지 않는거네?
> - <b>아니다.</b> 메모리를 추상화하는 방법 중 하나로, <b>메모리 추상화를 사용하지 않는 것</b>이다.
>   - { a, b, c, d, ... } 를 추상화하는 방법 (1) := alphabetic
>   - { a, b, c, d, ... } 를 추상화하는 방법 (2) := { a, b, c, d, ... }
> 
> ... 운영체제는 메모리 계층 구조를 이루는 캐시, 메인 메모리, 디스크 스토리지를 이에 해당하는 물리 주소를 통해 직접 접근한다.
> - 그런데, 물리 주소를 직접 접근하는 방법에는 ```Protection & Relocation``` 이슈가 존재한다.

#### P1. 프로텍션 (```Protection```) : 한 프로세스가 운영체제나 다른 프로세스의 파티션을 침범하지 못하게 해야 함
- ```IBM360```모델 : 프로텍션 코드 (```Protection code```)
  - 프로세스의 ```PSW```에는 ```4bit``` 키 (```key```)가 포함 / 메모리를 ```2KB``` 블럭 단위로 나누고, 각 블록에 ```4bit``` 프로텍션 코드 할당
  - 수행되는 프로세스는 자신의 ```PSW``` 키와 액세스하고 있는 블럭의 프로텍션 코드를 비교해, 일치하지 않으면 트랩 발생

#### P2. 리로케이트 (```Relocation```) : 변수 주소나 프로시저 주소에 대한 접근에 차이가 발생
- 컴파일된 ```.exe``` 파일을 파티션에 로드해 실행할 때, 바이너리 파일에 명시된대로 접근하는 대신 파티션을 기준으로 접근해야 함
  - 컴파일된 ```.exe``` 파일을 파티션 A와 B에 각각 로드해 실행할 때, 각 파티션을 기준으로 접근해야 함

> 컴파일된 ```.exe``` 파일의 첫번째 명령어가 100번지에 있는 프로시저 콜이라고 가정하면...
> - 해당 파일을 파티션에 로드해 실행했을 때 : <del>0 + 100번지로 접근</del> (파티션의 시작 주소) + 100번지로 접근

- ```IBM360```모델 : 정적 재배치 (```Static Relocation```)
  - 프로그램이 메모리에 로드될 때, 파티션을 기준으로 접근하도록 명령어 수정
    - 링커가 프로그램의 어떤 부분이 리로케이트되어야 하는지 알아야 함

### 주소 바인딩 (```Address Binding```) : 프로세스의 논리적 주소를 물리적 메모리 주소로 연결
- 주소 공간 (```address space```) : 프로세스가 메모리에 접근할 때 사용하는 주소들의 집합
  - 각 프로세스들은 자신들만의 주소 공간을 가짐 -> ```logical address```
- 프로그램이 어떤 주소를 사용해도, 메인 메모리에 할당된 주소를 찾아가도록 해야 함
  - 논리 주소 (```logical address```) : CPU에서 사용하는 주소. 메모리 내 프로세스의 독립적인 공간
  - 물리 주소 (```physical address```) : 메인 메모리에서 사용하는 주소. 하드웨어에 의해 정해진 주소 공간

> ... 그러므로 프로그램이 할당된 실제 메모리 주소 공간의 위치는 프로그램을 실행하는 ```CPU```에 전혀 영향을 미치지 않음
> - 그럼 어떻게 각각의 프로세스들에게 서로 다른 주소 공간을 제공할 수 있을까?

#### ```MMU```의 재배치 레지스터 (```Relocation Register```) : 각 프로세스의 논리 공간을 메모리의 물리 공간으로 연속해 매핑
- 동적 재배치 (```Dynamic relocation```) : 프로세스의 논리 주소를 메모리의 물리 주소으로 변경
  - 베이스 레지스터 (```Base Register```) : (파티션의 시작 주소)
  - 리미트 레지스터 (```Limit Register```) : (파티션의 크기)

<img src="https://user-images.githubusercontent.com/34755287/54821880-d7e7ea00-4ce6-11e9-944e-3be89338213f.png" width="80%" style="margin-left: 2%">

1. 현재 프로그램이 파티션에 로드되었을 때, 프로그램이 로드된 파티션의 크기를 리미트 레지스터의 값에 저장
2. ```CPU```는 메인 메모리에서 주소가 사용 가능한지 여부를 생각하지 않고, 명시된 그대로 물리 주소를 사용하려고 함
3. ```CPU```가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더해 수행 (```Relocation```)
4. ```CPU```가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소가 리미트 레지스터의 값과 동일하거나 큰지 확인 (```Protection```)
  - O : 프로텍션 바이오레이션 (```Protection Violation```) 발생시켜 메모리 참조를 중단
  - X : 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더한 값을 메모리 버스에 보냄

> Q. 그럼 베이스 레지스터 & 리미트 레지스터를 사용하면 이젠 더 이상 문제가 없는걸까?
> - 모든 메모리 참조마다 덧셈과 비교 연산이 요구되기에, 비교적 시간이 오래 걸림 : 특히 덧셈 연산이!
>   - 블로트웨어 (```Bloatware```) : 메모리의 크기를 증가하는 속도를 소프트웨어의 크기가 증가하는 속도가 역전
> 
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fe9a93b26-58ff-4ab0-8b6b-2a8b3cb3cdfd%2F정적재배치2.PNG" width="80%" style="margin-left: 2%">
> 
> - 정적 메모리 파티션 (```Fixed memory partitions```) : 메모리를 파티션 여러 개로 미리 나누고 프로세스 할당
>   - ```Multiple input Queues``` : 도착한 작업을 크기에 맞는 가장 작은 파티션에 넣음
>   - ```Single input Queue``` : 도착한 작업을 수용할 큐를 하나만 배정해 먼저 도착한 작업을 먼저 실행하게끔 함
> 
> <img src="https://examradar.com/wp-content/uploads/2019/02/fixed-memory-partition.png" width="80%" style="margin-left: 2%">
>
> > 정적 메모리 파티션은 메모리가 시스템이 구동할 모든 프로세스를 적재할 만큼의 용량을 가져야 성립한다. 그러나,
> > - 시스템이 구동할 모든 프로세스들이 필요한 메모리의 전체 크기는 실제 ```RAM``` 용량보다 크다.
> > - 프로그램이 시작하기 전에 이미 실행 중인 프로세스들이 적재되어 있다.
>
> ... <b>모든 프로세스들을 계속 적재하기엔, 물리 메모리 크기에 한계가 있다</b>는 문제를 해결하기 위해 2가지 해결책이 제시되었다.
> - ```Swapping``` : 한 프로세스의 전체 이미지가 메모리로 적재되어 실행되다가 더 이상 실행되지 않으면 디스크로 이동
> - ```Virtual Memory``` : 한 프로세스의 전체 이미지가 아닌 일부만 메모리에 있어도 프로세스의 실행이 가능

### 스와핑 (```Swapping```) : 메모리에 로드된 프로세스 중에 장기간 미사용된 프로세스를 하드 디스크에 이미지 형태로 저장
- 프로세스 이미지 (```Process Image```) : 프로그램이 메모리에 로드되고 실행되어 데이터가 변경된 프로세스
  - 하드 디스크에 존재하는 ```.exe```, ```.app```에 데이터가 변경되었기에 이를 하드 디스크의 ```backing store```에 저장
    - ```swap-out``` : 메인 메모리 -> ```Backing store```
    - ```swap-in``` : ```Backing store``` -> 메인 메모리

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F79e932b4-c55f-4e27-aaaf-381605691e27%2F스와핑1.PNG" width="80%" style="margin-left: 2%">

> ... ```backing store```는 메인 메모리의 모든 프로세스가 ```swap-out```될 때 데어터의 소실 없이 저장할 수 있어야 한다.
> - 그러므로, 하드 디스크에서 ```backing store```이 할당받는 크기는 <b>최소 메인 메모리의 크기</b>라 예상할 수 있다.

<img src="https://miro.medium.com/max/1200/1*QnOhzkY2mIXFKM-SoXh_8w.jpeg" width="80%" style="margin-left: 2%">

- (a) 각 프로그램의 데이터 세그먼트가 늘어날 공간을 미리 확보
- (b) 각 프로그램의 세그먼트를 프로그램 텍스트 / 데이터 세그먼트 / 스택 세그먼트로 나눔
  - 프로그램 텍스 위의 데이터 세그먼트와 스택 세그먼트가 서로를 향해 자라게끔 함
    - 힙 (```Heap```) 영역 (```Room for growth```) : 사용자가 동적으로 할당할 영역
      - ```malloc```, ```calloc``` 등의 명령어로 관리

#### 동적 메모리 파티션 (```Dynamic memory partitions```) : 프로그램이 메모리에 로드될 때마다 파티션을 나누고 할당
- 운영체제가 동적으로 할당된 프로세스를 관리 : 힙 영역이 커지므로, 프로세스의 확장을 위한 공간이 할당되어야 함

<img src="https://examradar.com/wp-content/uploads/2019/03/Memory-Management-with-Bitmap.png"  width="66%" style="margin-left: 2%">

- (b) ```Bit Maps``` 사용 : 맵에 ```X```비트를 관장할 ```Y```개의 할당 단위 (```allocation unit```)
  - 단위 유닛이 메모리에 할당되어 있으면 유닛의 값을 1, 할당되어 있지 않으면 0 (```flag bit```)

> - 할당 단위가 작아지면? : 유닛의 개수 ```Y```가 커진다.
>   - ```Y```를 표현할 ```flag bit```가 많이 필요하므로, 맵의 크기가 커져 맵을 탐색할 때의 성능이 저하된다.
> - 할당 단위가 커지면? : 유닛의 개수 ```Y```가 작아진다.
>   - ```Y```를 표현할 ```flag bit```가 적게 필요하므로, 비트맵의 공간이 작아진다.
>   - 마지막 프로세스에 빈 공간 역시 커져 더 많은 메모리 공간이 낭비될 가능성이 있다.
>
> ... ```Bit Maps```의 문제점 : 프로세스가 ```k```개의 할당 단위를 요구할 때, 맵에서 ```k```개의 0비트를 연속해서 찾아야 한다.

- (c) ```Linked Lists``` 사용 : 메모리의 낮은 주소부터 링크드 리스트의 노드가 있음
  - 각 엔트리는 ```P``` (프로세스) or ```H``` (홀)을 표현하는 ```flag``` / 시작 주소 / 길이 / 다음 엔트리를 가리키는 포인터로 구성

> - 프로세스 종료 시 ```Linked Lists```를 업데이트하는 방법
>   - 종료되는 프로세스는 일반적으로 2개의 이웃을 가짐 : 이웃은 다른 프로세스가 차지한 공간이거나 빈 공간임
> 
> <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQL0MnsZnPlU2O0BnlViAvrs8Ge5bJtE5VhIQ&usqp=CAU" width="66%" style="margin-left: 2%">
>
> - (a) ```X```에 해당되는 엔트리를 ```X```에서 ```H```로 바꿔 갱신
> - (b), (c) 2개의 엔트리를 통합해 하나로 표현
> - (d) 3개의 엔트리를 통합해 하나로 표현

#### ```Contiguous Memory Allocation``` : 메모리에 새로 생성된 프로세스들을 위한 메모리 공간 할당
- 메모리 단편화 (```Memory fragmentation```) : 메인 메모리에 흩어진 홀들이 불연속적으로 할당된 상태 (```scattered holes```)
  - 홀 (```Hole```) : 메인 메모리에서 프로세스가 할당되지 않은 영역
- 외부 단편화 (```External fragmentation```) : 프로세스를 할당할 크기가 충분하나, 메모리 단편화로 할당이 불가능한 상태
 
<img src="https://user-images.githubusercontent.com/34755287/54821882-d8808080-4ce6-11e9-8ff3-193fa79c04a3.png" width="80%" style="margin-left: 2%">

- ```First-fit``` : 프로세스 크기보다 크거나 같은 홀을 탐색하는 순서 중에서 가장 먼저 찾은 홀에 프로세스 할당

<img src="https://user-images.githubusercontent.com/34755287/54821883-d8808080-4ce6-11e9-8c2d-c84b878d21ea.png" width="80%" style="margin-left: 2%">

- ```Best-fit``` : 할당할 프로세스 크기와 홀의 크기 차이가 가장 작은 홀에 프로세스 할당

<img src="https://user-images.githubusercontent.com/34755287/54821885-d8808080-4ce6-11e9-9473-db032d7eeb3a.png"  width="80%" style="margin-left: 2%">

- ```Worst-fit``` : 할당할 프로세스 크기와 홀의 크기 차이가 가장 큰 홀에 프로세스 할당
  - ```Best-fit```을 사용하였다가 다른 프로세스가 쓰지 못할 정도의 홀이 생겼을 때를 위한 대안

<img src="https://user-images.githubusercontent.com/34755287/54821887-d9191700-4ce6-11e9-9b00-fa92272b8b7d.png"  width="80%" style="margin-left: 2%">

- ```Compaction``` : 메모리 여러 곳에 흩어져있는 홀들을 강제로 하나로 병합
  - 홀을 옮기는 오버헤드가 매우 크고, 어느 홀을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않음

> 일반적으로 할당 속도는 ```First-fit```가 가장 빠르고, 메모리 이용률은 ```First-fit```와 ```Best-fit```이 비슷한 성능을 보인다.
> - 하지만 ```Best-fit```을 사용하더라도, 외부 단편화로 인해 여전히 전체 메모리의 1/3 정도를 낭비한다. 

## 페이징 (```Paging```) : 프로그램과 메모리를 일정한 크기로 나눔
- 가상 주소 (```Virtual address```) : 프로그램이 가상 메모리에서 참조하는 주소
  - 가상 메모리 (```Virtual Memory```)가 있다면, 각 프로그램은 자신의 고유한 가상 주소 공간을 가짐
    - 가상 메모리 사용 ```O``` : 가상 주소가 그대로 메모리 버스에 실려 물리 주소가 됨
    - 가상 메모리 사용 ```X``` : 가상 주소가 ```MMU```에 의해 물리 주소로 매핑

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F77cc13d2-02da-4be4-9ff6-369f0dbc4b26%2F페이징2.PNG"  width="66%" style="margin-left: 2%">

- 가상 주소 공간과 물리 주소 공간은 고정된 크기 단위의 유닛들로 동일하게 나뉜다.
  - 가상 페이지 (```Virtual Page```) : 가상 주소 공간을 나눈 조각. 각 페이지는 연속된 주소를 가짐
  - 페이지 프레임 (```Page Frame```) : 물리 메모리를 나눈 조각.

> - 다음 그림에서는 가상 주소 공간을 ```64KB```, 물리 메모리 공간을 ```32KB```, 유닛 크기는 ```4KB```로 가정하고 있다.
> 
> <img src="https://d2vlcm61l7u1fs.cloudfront.net/media%2F814%2F8145fa33-a835-4aec-b761-957da632ac81%2FphpBxgNnp.png" width="80%" style="margin-left: 2%">
> - 논리 주소 (```logical address```) : 세그먼트 (```segment```) + 오프셋 (```offset```)
>   - 세그먼트 (```segment```) : ```64KB```의 고정된 길이와 시작 위치으로만 구성
>   - 오프셋 (```offset```) : 세그먼트의 시작 지점에서 실제 주소까지 떨어진 거리
> - 가상 주소 (```virtual address```) : ```single 32-bit unsigned integer```
>   - 가상 페이지는 ```16```진수로 표현 (```16bit```) : ```0x00000000``` ~ ```0xffffffff```의 범위 (```4096bit```=```4KB```)
> - 물리 주소 (```physical address```) : 물리 메모리에서 각각의 셀 (```cell```)의 주소
>   - 페이지 프레임은 가상 페이지가 매핑되는 물리 메모리의 일부분(```4096bit```=```4KB```)
>
> > 명령어 ```MOV REG, 0```을 수행한다고 가정해보자.
> > - 이 명령어에서 접근하는 가상 주소 0는 MMU로 전달된다.
> > - MMU는 해당 가상 주소가 가상 페이지 0에 속한 것임을 확인한다.
> > - MMU는 가상 페이지 0에 매핑된 물리 주소의 페이지 프레임이 2임을 계산한다.
> > - 가상 주소 0은 물리 주소 8192로 변환되고, 이 물리 주소가 메모리 버스에 실린다.
>
> ... MMU가 가상 페이지를 페이지 프레임에 매핑하는 것만으론 가상 주소 공간이 물리 주소 공간보다 큰 문제를 해결하지 못한다.

### 페이지 폴트 (```Page Fault```) : 페이지가 메모리에 매핑되어 있지 않음을 파악하면 ```CPU```에서 트랩 발생
- ```present``` 비트 : 어떤 페이지가 실제 메모리에 존재하는지 표현하는 비트 (가상 페이지에 ```X```로 표현)
  - 페이지가 메모리에 매핑되어 있지 않으면, ```CPU```에서 트랩을 발생시켜 운영체제에 이를 알림
- ```Page Fault```가 발생하면, 운영체제는 적게 사용되고 있는 페이지 프레임을 하나 선택
  - 선택한 페이지가 수정되었다면 (```dirty``` 상태) 이를 디스크에 기록하고, 수정되지 않았다면 (```clean``` 상태) 디스크에 존재하는 것과 동일하니 기록하지 않음
  - 선택한 기존 페이지의 내용을 지우고, 참조하려는 페이지의 내용을 페이지 프레임에 적재
  - 선택한 기존 페이지 프레임을 ```X```로, 참조한 페이지 프레임을 숫자로 매핑시켜 가상 페이지 맵 수정
  - 트랩이 발생한 명령어를 다시 실행

> 명령어 ```MOV REG, 24576```을 수행하였을 때 ```Page Fault```가 발생해 OS에서 페이지 프레임 1을 교체하려 한다고 가정해보자.
> - 가상 페이지 1이 더 이상 매핑되지 않음 (```X```)을 표시한다.
> - 가상 페이지 7이 페이지 프레임 1에 매핑되었음을 표시한다.

### 페이징 테이블 (```Page Table```) : 가상 페이지 번호 (```VPN```)를 페이지 프레임 번호 (```PFN```)로 매핑

> 위의 매핑 정보를 바탕으로 가상 주소 ```8196```를 물리 주소 ```24580```로 변환하는 과정을 가정해 살펴보자.
> 
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F1e02251d-f340-4f21-a40a-ece83ef34966%2F페이지테이블1.PNG" width="80%" style="margin-left: 2%">
>
> - 16비트 크기를 갖는 가상 주소는 ```VPN```와 오프셋으로 구분된다.
>   - 페이지 번호는 페이지 테이블의 인덱스로 사용된다.
> - 페이지 테이블에는 ```VPN```에 대응되는 ```PFN```이 기록되어 있다.
>   - ```present``` 비트가 1이면, 페이지 테이블의 ```PFN``` 3비트와 가상 주소의 오프셋 12비트가 결합해 물리 주소가 된다.
> - 물리 주소를 주소 출력 레지스터를 통해 메모리 버스로 전달해 참조한다.
>
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F3e57db8f-32a6-4eb8-9aae-401f58178f5a%2F페이징주소변환.PNG" width="80%" style="margin-left: 2%">

- 페이지 테이블엔 디스크에 존재하는 페이지의 디스크 주소에 대한 정보가 없음 (```Page Fault``` : 운영체제 내부에서 처리)
  - 메모리에 존재하는 페이지 주소에 대한 정보만 존재 : 하드웨어가 가상 주소를 물리 주소로 변경할 때 사용

<img src="https://examradar.com/wp-content/uploads/2019/03/page-table-entry.png" width="80%" style="margin-left: 2%">

- 페이지 테이블의 각 페이지에 존재하는 정보
  - 페이지 프레임 번호 (```PFN```) : 가상 주소를 물리 주소로 매핑
    - 해당 페이지가 매핑된 물리 주소 결정
  - ```Present``` 비트 : ```PFN```이 유효한지 아닌지 결정 (가상 주소가 사용될 때마다 확인)
    - 0 (```X```)이면 해당 엔트리에 대응되는 페이지가 물리 메모리에 존재하지 않는 상태 (트랩 발생)
  - ```Protection``` 비트 : 어떤 접근이 허용되는지 표시
    - ```write```, ```read```, ```execute```
  - ```Modify``` 비트 : 페이지가 수정되었는지 아닌지 확인
    - 페이지의 내용이 ```write```되면, 하드웨어가 자동으로 비트를 1로 세팅
      - ```Modify``` 비트가 1 (```dirty```)이면, 페이지 프레임이 교체될 때 디스크에 기록되어야 함
      - ```Modify``` 비트가 0 (```clean```)이면, 페이지 프레임이 교체될 때 새로운 내용으로 덮어씌워도 됨
  - ```Reference``` 비트 : 해당 페이지가 ```write``` 또는 ```read```로 접근되었을 때 설정
    - 운영체제가 ```Page Fault```의 처리를 위해 교체할 페이지 프레임을 선택할 때 사용
  - ```Cashing Disabled``` 비트 : 해당 페이지가 캐싱될 수 있는지 여부
    - 페이지가 메모리가 아닌 장치 레지스터에 매핑되어 있을 때 실행

> > - ```64bit``` 주소를 사용하는 컴퓨터는 가상 주소 공간이 ```2^64byte```
> > - 가상 주소 공간의 한 페이지가 ```4KB = 2^12byte```이면,
> >   - 페이지 테이블의 엔트리 개수는 전체 공간을 한 페이지로 나눈 ```2^52```개
> >   - 엔트리 하나당 ```4byte```의 크기를 가진다면, 페이지 테이블의 크기는 ```2^52 * 4byte```
> 
> ... 페이징은 다음 두 가지 문제를 해결해야 한다.
> - 가상 주소 공간이 커지면, 페이지 테이블의 크기 (= 페이지 테이블 엔트리의 개수) 또한 증가한다.
>   - 페이지 테이블을 유지하기 위해 필요한 메모리의 크기가 클 수 있음
> - 가상 주소에서 물리 주소로의 변환이 빠르게 이루어져야 한다.
>   - 메모리를 참조하는 오버헤드가 작아야 함

### ```TLBs``` (```Translation Lookaside Buffers```) : 페이징의 속도를 높이고, 큰 가상 주소 공간을 지원하는 기법

> 대부분의 프로그램들은 적은 개수의 페이지를 집중적으로 참조하는 경향이 있다.
> - 페이지 테이블의 일부 엔트리만이 높은 빈도로 참조되고, 나머지 엔트리는 낮은 빈도로 참조된다.

- ```TLB``` : 페이지 테이블의 참조 없이 가상 주소를 물리 주소로 매핑할 수 있는 작은 크기의 메모리
  - ```MMU``` 내부에 존재하며, 적은 개수의 엔트리를 가짐
    - 각각의 ```TLB``` 엔트리는 한 페이지에 대한 정보를 포함

> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F8b9807f3-f9d5-437a-8110-25ff5a9aad4a%2FTLB2.PNG" width="80%" style="margin-left: 2%">
>
> 1. ```MMU```는 주소 변환을 할 때 요청된 가상 페이지가 ```TLB```에 있는지 검색
> 2. 가상 페이지가 존재하고 보호코드를 위반하지 않으면, 대응되는 페이지 프레임을 사용하여 주소 변환을 실행
> 3. ```TLB```가 존재하지 않으면, ```TLB miss``` 발생. ```MMU```는 페이지 테이블에서 해당 페이지 테이블 엔트리를 검색
> 4. 그리고 ```TLB``` 엔트리 중 하나를 선택해 그 내용을 교체. 페이지 테이블에 없는 수정 비트는 페이지 테이블에 기록
> 5. 찾은 페이지 테이블 엔트리를 ```TLB``` 엔트리에 기록 (이때 다시 참조한다면 ```TLB hit```로 처리)
> 6. 새로운 정보가 적재될 때는 페이지 테이블 엔트리에 있는 내용이 적재

- 메모리 계층 구조에서 발생할 수 있는 ```miss```의 경우의 수 : ```2^3```가지 ```->``` 실제 발생 가능한 경우의 수 : ```5```가지
<div style="text-align: center;">
  <table>
	  <thead>
		  <tr>
			  <td>Cache</td>
        <td>TLB</td>
        <td>Virtual Memory</td>
        <td>발생 가능 여부</td>
			  <td>설명</td>
		  </tr>
	  </thead>
	  <tbody>
		  <tr>
			  <td>hit</td>
        <td>hit</td>
        <td>hit</td>
        <td>가능 (최선)</td>
			  <td>(1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X)<br>(2) Cache가 hit이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 있음</td>
		  </tr>
		  <tr>
			  <td>miss</td>
        <td>hit</td>
        <td>hit</td>
        <td>가능</td>
			  <td>(1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X)<br>(2) Cache가 miss이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 없음<br>(3) Virtual Memory가 hit이므로, 캐시에 데이터를 불러오기 위해 메모리에 접근하면 데이터를 가져올 수 있음<br>(4) 메모리에서 캐시로 가져온 데이터를 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>hit</td>
        <td>miss</td>
        <td>hit</td>
        <td>가능</td>
			  <td>(1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O)<br>(2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환<br>(3) Cache가 hit이므로, 변환한 물리 주소로 캐시에 접근해 캐시에 있는 데이터를 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>miss</td>
        <td>miss</td>
        <td>hit</td>
        <td>가능</td>
			  <td>(1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O)<br>(2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환<br>(3) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음<br>(4) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>miss</td>
        <td>miss</td>
        <td>miss</td>
        <td>가능 (최악)</td>
			  <td>(1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O)<br>(2) Virtual Memory가 miss이므로 (Page fault), 하드 디스크에서 데이터를 직접 가져와 페이지 테이블을 업데이트<br>(3) 이제 TLB가 miss > hit이므로, 가상 주소를 물리 주소로 변환 가능.<br>(4) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음<br>(5) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>miss</td>
        <td>hit</td>
        <td>miss</td>
        <td>불가능</td>
			  <td>메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음</td>
		  </tr>
      <tr>
			  <td>hit</td>
        <td>hit</td>
        <td>miss</td>
        <td>불가능</td>
			  <td>메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음</td>
		  </tr>
      <tr>
			  <td>hit</td>
        <td>miss</td>
        <td>miss</td>
        <td>불가능</td>
			  <td>메모리 계층 구조 위반 : Page fault인데 Cache가 hit일 수 없음 (캐시에 데이터가 있을 수 없음)</td>
		  </tr>
	  </tbody>
  </table>
</div>

> - ```TLB miss```인 경우 : 페이지 테이블에는 정보가 있지만, ```TLB```에 그 정보가 들어있지 않을 때
>   - 해결책 : 페이지 테이블의 페이지 엔트리 내 데이터를 가져와 ```TLB```에 넣음
> - ```Page fault```인 경우 : ```TLB```에도 정보가 없고, 페이지 테이블에도 그 정보가 없을 때
>   - 운영체제는 권한을 받아 하드 디스크의 데이터를 페이지 테이블에 가져오고, ```TLB```에 가져온 데이터를 넣음

### 다단계 페이지 테이블 (```Multi-level Page Table```)
- 페이지 테이블을 페이지 프레임 크기로 나눔
  - 해당 페이지 테이블의 페이지가 ```invalid```하면 메모리에 할당하지 않음
  - 기존의 단일한 페이지 테이블을 트리 구조로 연결
- 페이지 디렉토리 (```Page Dictionary```) : 페이지 프레임의 유무를 확인하는 자료구조
  - 적어도 하나의 ```PFN```이 ```valid```하다면, 페이지 디렉토리의 해당 엔트리는 존재함

> <img src="https://mblogthumb-phinf.pstatic.net/MjAxOTAyMTlfOCAg/MDAxNTUwNTA2MjIzODAw.Wv_UIJMhp3-_COSDHBtsqEz0OCp91j4zEc3Vr4lmWHQg.qFb-bL0s7WgeO7btb1857Ifsk_KZqW063BUihRmZd-wg.PNG.babobigi/Page_Table_비교.png?type=w2" width="80%" style="margin-left: 2%">
>
> - 기존의 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있음
> - 다단계 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있지 않음
>
> 다단계 페이지 테이블에서의 모든 페이지 테이블은 항상 메모리에 유지될 필요가 없다.

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fcf85f3b3-985d-4872-9030-eb337ae7dbbe%2F2단계페테2.PNG" width="80%" style="margin-left: 2%">

- 필요한 페이지 테이블만 메모리에 할당해 절약, 페이지 디렉토리로 물리 메모리의 빈 공간에 페이지 테이블 엔트리 생성 가능
- 기존의 ```TLB Miss```가 2번 늘어나 주소 변환이 2번 필요하고, ```TLB Miss```를 처리해 메모리를 최적화하는 로직이 복잡해짐

### 역 페이지 테이블 (```Inverted Page Table```)
- 빠른 하드웨어 레지스터로 구성된 단일한 페이지 테이블 사용
  - 페이지 테이블의 각 엔트리는 하나의 메모리 프레임에 대응
- 크기가 고정된 페이지 테이블에 프로세스를 맵핑
  - 프로세스 실행 시 운영체제는 메모리에 존재하는 프로세스의 페이지 테이블 전체를 하드웨어 레지스터 배열에 적재
- 논리 주소는 ```PID```, ```PFN```, ```offset```으로 구성
- 물리 주소는 ```MFN```와 ```offset```으로 구성

<img src="https://i0.wp.com/blog.skby.net/wp-content/uploads/2020/03/역페이지테이블-구성도.png" width="80%" style="margin-left: 2%">

1. 논리 주소의 ```PID```와 ```PFN``` 정보를 바탕으로 페이지 테이블에서 동일한 엔트리 탐색
2. 페이지 테이블에서 ```PID```와 ```PFN```가 일치하는 (```MFN```)번째 항목을 발견
3. ```MFN```과 ```Offset``` 정보를 바탕으로 확인된 메모리 주소에 접근


> - ```64bit``` 주소를 사용하는 컴퓨터에서 ```256MB```의 물리 메모리가 ```4KB``` 페이지 프레임 ```2^18```개로 구성되었다고 가정하자.
>   - 페이지 테이블을 사용할 때의 페이지 테이블의 엔트리 개수는,
>     - 가상 주소 공간인 ```2^64byte```을 한 페이지 프레임의 크기 ```4KB = 2^12byte```로 나눈 ```2^52```개
>   - 역 페이지 테이블을 사용할 때의 페이지 테이블의 엔트리 개수는 물리 메모리의 페이지 프레임의 개수와 같으므로,
>     - 물리 메모리 크기 ```256MB = 2^28byte```를 한 페이지 프레임의 크기 ```4KB = 2^12byte```로 나눈 ```2^16```개

- 프로세스 실행 중엔 페이지 테이블을 위한 추가적인 메모리 참조가 필요 없음 (프로세스 확장이 페이지 테이블과 무관)
- 페이지 테이블이 커질수록 구현을 위한 비용이 증가하고, 최악의 경우 페이지 테이블 전체를 적재해야 함 ex) 문맥 교환

## 페이지 교체 알고리즘 (```Page Replacement Algorithm```) : 페이지 폴트 발생 시 교체할 페이지를 선택
- 교체한 페이지가 다시 필요해져 페이지 폴트가 발생하는 비율을 줄여야 함 : 자주 사용되지 않을 페이지를 선택해야 함
  - 제거할 페이지 중 최고의 페이지는 가장 긴 시간동안 접근하지 않을 페이지

### 최적 페이지 교체 알고리즘 (```Optimal Page Replacement Algorithm```) : 가장 오래 사용되지 않을 페이지 교체
- 운영체제가 모든 페이지 참조를 수집했다고 가정하면, 각 페이지들이 몇개의 명령어 뒤에 처음으로 참조되는지 알 수 있음
- 그 중 가장 많은 명령어 뒤에 참조되는 페이지를 교체

> 페이지 폴트가 발생했을 때, 운영체제가 각 페이지들이 어느 시점에 참조되는지 알 수 없음
> - 프로세스를 처음 돌린 뒤에 수집된 정보를 바탕으로 사용 가능

### ```NRU``` (```Not Recently Used```) 페이지 교체 알고리즘 : 최근에 사용되지 않은 페이지를 교체
- 가상 메모리를 지원할 때, 각 페이지마다 운영체제가 페이지 사용 정보를 수집하기 위한 2개의 상태 비트를 유지
  - ```R``` (```Reference``` 비트) : 페이지가 참조될 때마다 설정 (```read```/```write```)
  - ```M``` (```Modify``` 비트) : 페이지가 수정될 때 마다 설정 (```clean```/```dirty```)
- 최근에 참조되지 않은 페이지를 참조된 페이지와 구별하기 위해 주기적으로 (```clock tick```마다) ```R```비트를 0으로 초기화
- 페이지를 4개의 클래스로 분류
  - 클래스 0 : ```R = 0, M = 0```
  - 클래스 1 : ```R = 0, M = 1```
  - 클래스 2 : ```R = 1, M = 0```
  - 클래스 3 : ```R = 1, M = 1```
- 페이지 폴트가 발생했을 때, 낮은 클래스에 있는 페이지 중 하나를 랜덤으로 교체
  - 참조도, 수정도 안된 클래스 3에 속한 페이지가 있으면 내쫓고,
  - 없으면 최소 한 사이클에서 참조되지 않은 클래스 2에 속한 페이지가 있으면 내쫓고,
  - 없으면 자주 참조되지만 수정되지 않은 클래스 1에 속한 페이지가 있으면 내쫓고,
  - 없으면 참조도, 수정도 이루어진 클래스 0에 속한 페이지가 있으면 내쫓는다.

> 가장 최근에 참조되지 않은, 변경된 페이지를 교체하는 것이 집중적으로 참조된, 변경되지 않은 페이지를 교체하는 것보다 좋음

### ```FIFO``` 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지를 교체
- 메모리에 페이지들이 들어온 순서대로 링크드 리스트를 ```sorting```
- 페이지 폴트가 발생하면, 맨 앞에 들어온 것을 교체  

> - 메모리에 오래 있던 페이지가 자주 사용되는 페이지일 수 있음
>
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fc2b04476-5991-4656-a6d9-88aa883fa467%2Ffifo.PNG" width="80%" style="margin-left: 2%">
>
> - 벨레이디의 모순 (```Belady's anomaly```) : 페이지 프레임이 늘어나면, 페이지 폴트의 개수가 오히려 늘어나는 경우
>
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fe11c56af-54cc-45e8-93de-579d7b35e4e4%2F파이포.PNG" width="80%" style="margin-left: 2%">

### ```Second-Chance``` 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지의 ```R```을 검사한 후 교체
- 메모리에 페이지들이 들어온 순서대로 링크드 리스트를 ```sorting```
- 페이지 폴트가 발생하면, 가장 오래된 페이지의 ```R```을 검사
  - ```R = 0```이면, 이 페이지는 최근에 사용되지 않은 페이지이므로 교체해도 됨
  - ```R = 1```이면, 이 페이지를 맨 뒤로 옮기고, ```R```를 0으로 초기화 (적재 시간도 현재시간으로 갱신)하고 다시 검사

> 자주 참조되는 페이지를 교체할 가능성이 있는 ```FIFO```를 개선
> - 하지만, 페이지를 리스트 맨 뒤로 이동시켜아 하기 때문에 동작의 효율성이 떨어질 수 있음

### ```Clock``` 페이지 교체 알고리즘 : 시계 모양 원형 리스트를 구성하고, 화살표가 가리키는 페이지의 ```R```을 검사한 후 교체
- 메모리에 페이지들이 들어온 순서대로 원형 리스트를 ```sorting```
- 페이지 폴트가 발생하면, 화살표가 가리키는 페이지의 ```R```을 검사
  - ```R = 0```이면, 최근에 사용되지 않은 페이지이므로 이 페이지 대신 새로운 페이지 삽입 후 화살표를 다음 페이지로 이동
  - ```R = 1```이면, 이 페이지의 ```R```를 0으로 초기화하고 그 다음 페이지를 검사

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fdcdc8fb8-202a-4637-a819-b7429c6b47ff%2F클록페이지교체.PNG" width="80%" style="margin-left: 2%">

### ```LRU``` 페이지 교체 알고리즘 : 가장 오랫동안 사용되지 않은 페이지를 교체
- 메모리에 페이지들이 들어온 순서대로 링크드 리스트를 ```sorting```
  - 가장 최근에 사용된 것을 리스트의 맨 앞에, 가장 오래된 것을 리스트의 맨 뒤에 오게끔 배치
- 페이지 폴트가 발생하면, 가장 맨뒤에 있는 페이지를 추출
  
> 모든 메모리의 참조마다 리스트를 갱신해야 함 : 리스트에서 페이지를 탐색, 삭제, 이동하는 작업은 오래 걸림

#### ```LRU```의 하드웨어 구현 1 : ```64bit``` 카운터
- 카운터가 명령을 실행할 때마다 ```C```값을 1씩 증가
- 각 페이지 테이블 엔트리는 카운터 값을 저장할 수 있는 공간을 가짐
- 메모리가 참조될 때마다 참조된 메모리를 담고 있는 페이지를 가리키는 페이지 테이블 엔트리에 ```C```값 저장
- 페이지 폴트가 발생하면, 모든 페이지 테이블 엔트리의 ```C```값을 조사해 가장 적은 값을 갖는 페이지를 교체
<br><br>

#### ```LRU```의 하드웨어 구현 2 : ```N*N bit```로 구성된 행렬을 갖는 ```LRU``` 하드웨어
- ```N```개의 페이지 프레임 -> ```N*N bit```로 구성된 행렬 : 행렬의 모든 값의 초기값은 ```0```
- 페이지 프레임 ```k```가 참조되면, ```LRU``` 하드웨어는
  - 행렬에서 ```k```번째 행의 모든 비트를 ```1```로 설정
  - ```k```번째 열의 모든 비트를 ```0```으로 설정
- 행의 이진 값이 가장 작은 행에 대응되는 페이지 프레임이 가장 과거에 참조된 것

> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Ffae59bc5-f57f-4328-9afc-aea0bbccdfcc%2Flrumatrix.PNG" width="80%" style="margin-left: 2%">
>
> 페이지가 ```0,1,2,3,2,1,0,3,2,3``` 순으로 참조되었다고 가정하자. 
> 1. 일단 ```1```행을 모두 ```1```로 ```0```열을 ```0```으로 초기화
> 2. ```1```행을 모두 ```1```로, ```1```열을 모두 ```0```으로 초기화
> 3. 페이지 폴트가 발생하면, 행 값이 제일 낮은 프레임을 교체 
> - 만약 그림 ```j```에서 페이지 폴트가 발생하였으면, ```2```행이 가장 낮으므로 프레임 ```2```를 교체

#### ```LRU```의 소프트웨어 구현 1 : ```NFU``` (```Not Frequently Used```)
- 각 페이지마다 각 페이지들이 얼마나 자주 참조되었는지 알려줄 소프트웨어 카운터를 유지 (카운터의 초기값은 0)
- 클록 인터럽트가 발생할 때마다 운영체제는 메모리의 모든 페이지를 검사하여 ```R```의 값을 소프트웨어 카운터에 더함
- 페이지 폴트가 발생하면, 가장 적은 카운터 값을 갖는 페이지가 교체

> ```NFU```에는 잊어버리는 기능이 부재되어 있다.
> - 다중 패스 컴파일러의 경우 : 패스 1에서 자주 참조된 페이지들은 높은 카운터 값을 가지고, 이는 패스 2에서도 유지
> - 만일 패스 1이 그 이후 다른 패스들보다 더 긴 실행 시간을 가진다면 혹은 패스 1에서 더 많은 참조가 일어난다면, 패스 1에서 실행된 페이지들은 그 이후 패스에서 사용되는 페이지들에 비해 더 큰 카운터 값을 가짐
> - 그러므로 패스 1에서 사용되던 더 이상 사용되지 않는 페이지가 아닌, 현재 패스에서 사용하는 유용한 페이지들을 교체

#### ```LRU```의 소프트웨어 구현 2 : 에이징 (```Aging```)
- ```NFU```를 기반으로, 다음의 사항을 변경한다.
1. ```R```를 더하기 전에 오른쪽으로 1비트 시프트한다.
2. ```R```는 오른쪽 비트가 아닌 왼쪽 최상위 비트에 추가된다.

> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Feec8658e-0cbd-4fe7-b748-0792f10fa9dc%2FAGING.PNG" width="80%" style="margin-left: 2%">
> - 시간 순서를 구별할 정보를 기록
>   - ```LRU``` : 오직 하나의 비트로 참조 여부만 기록했기에, 페이지 3과 5 중 어떤 페이지가 더 먼저 참조되었는지 모른다.
>   - 에이징 : 시간 순서를 구별할 정보를 기록했기에, 2번의 클록 틱 전에 1번 더 참조된 페이지 5 대신 3을 교체한다.
> - 과거에 대한 정보를 제한
>   - ```NFU``` : 과거에 대한 정보를 모두 기억하기에 10번째 전에 참조되었는지, 100번 전에 참조되었는지 알 수 없다.
>   - 에이징 : 최대 ```N```번 전에 정보를 기록할 ```N```비트만이 존재해, 과거에 대한 정보를 제한된다.

#### 워킹 세트 알고리즘 (```The Working Set Page Replacement Algorithm```) : 페이지 집합을 관리

> - 스레싱 (```Thrashing```) : 멀티 프로그래밍의 정도가 높아져 페이지 폴트가 계속 발생해 페이지 교체 시간이 길어지는 현상
>   - 멀티 프로그래밍의 정도가 높은 경우 : 여러 프로세스를 동시에 많이 돌려 프로세스가 충분한 페이지를 가지지 못함
>     - 어느 순간부터 ```CPU``` 점유율이 하락한다. (프로세스는 스와핑하느라 바쁜데, ```CPU```는 아무것도 안한다.)
>
> <img src="https://mblogthumb-phinf.pstatic.net/MjAxODExMDRfMjQ0/MDAxNTQxMzE5Mjc3ODM1.bCiSuD2-2aXc04gk2DAj-JDCsK_x9DU4qbT8oxnDboMg.b6_rzAgTlHnGXp01pLYY2MXkldo5oXJ3lihOgoDxk7Ug.PNG.qbxlvnf11/7eDqXQF.png?type=w800" width="80%" style="margin-left: 2%">
> 
> - ```Demand Paging``` : 실제로 필요할 때 (요청이 있으면) 그 page를 메모리에 올린다.
>   - 프로세스가 시작될 때 메모리에는 어떤 페이지도 존재하지 않음
>   - ```CPU```가 첫 명령어를 ```fetch```하면 페이지 폴트를 통해 운영체제가 로드
> - 참조의 지역성 (```Locality of reference```) : 프로세스는 작은 페이지만을 집중적으로 참조하는 경향이 있음
>   - ```locality set``` : 집중적으로 참조되는 해당 페이지의 집합

- 워킹 세트 (```Working Set```) ```W(K, T)``` : 프로세스가 현재 사용하고 있는 페이지의 집합
  - 워킹 세트에서의 ```locality set``` : 프로세스가 일정 시간 원활히 수행되기 위해 한꺼번에 올라와야 하는 페이지들의 집합

> 워킹 세트를 (시간 ```T```)에 대해, 가장 최근에 (횟수 ```K```번) 발생한 메모리 참조에 의해 사용된 페이지의 집합이라 가정하면,
> - 뒤의 페이지가 앞의 페이지를 포함하니 ```K```를 늘리수록 커지다가, (가상 페이지의 개수가 한정되어 있어) 한 곳에 수렴
>
> <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSg1a1RbKAR6Xz4RjQ0lNoOr_jPwb1u1lXW1w&usqp=CAU" width="50%" style="margin-left: 2%">

- 워킹 세트 모델 (```Working Set```)
  - ```PrePaging``` : 각 프로세스의 워킹 세트를 추적하다가, 프로세스가 실행되기 전에 그 프로세스의 워킹 세트를 미리 로드
  - 주기적인 인터럽트가 ```R```을 일정 시간마다 초기화
  - 페이지 폴트가 발생하면, 페이지 테이블을 스캔해서 쫓아낼 페이지를 탐색
  - 해당 프로세스의 워킹 세트 전체를 한꺼번에 메모리에 올라갈 수 있는 경우에만 메모리에 할당
    - 그렇지 않을 경우, 모든 페이지 프레임들을 모두 반납시키고 디스크로 ```swap-out``` (스레싱 방지)
<br><br>

- 워킹 세트 윈도우 (```Working Set Window```) : 올라올 워킹 세트를 결정 (워킹 세트 윈도우의 크기 : ```T```)
  - 페이지가 참조된 시점부터 ```T``` 시간 동안 메모리에 유지하고, 그 시점이 지나면 메모리에서 지움
- 메모리에 있는 프로세스들의 워킹 세트 크기의 합이 페이지 프레임의 수보다 클 경우 : 일부 프로세스를 ```swap-out```
  - 남은 프로세스의 워킹 세트가 메모리에 모두 올라가게 해 이를 우선적으로 충족 (멀티프로그래밍의 정도를 줄임)
- 워킹 세트를 모두 할당한 후에도 페이지 프레임이 남을 때, ```swap-out```된 프로세스를 다시 메모리에 올려서 워킹 세트를 재할당

> - 현재 가상 시간 (```Current virtual time```) : 프로세스가 시작된 후에 CPU를 실제 사용한 시간
> - 마지막으로 사용한 시간 (```Time of last use```)
> 
> <img src="https://camo.githubusercontent.com/d45e4dee2f521e74871e7a94b7af0510f03e27256546b5aaef4892cb6cee44ef/68747470733a2f2f736c696465706c617965722e636f6d2f736c6964652f313635393339362f372f696d616765732f32342f576f726b696e672b7365742b616c676f726974686d2b6167652b2533442b63757272656e742b7669727475616c2b74696d652b2545322538302539332b74696d652b6f662b6c6173742b7573652e6a7067" width="80%" style="margin-left: 2%">
>
> - 페이지의 현재 가상 시간이 ```2204```일 때 페이지 폴트가 발생하면,
>   -  페이지 테이블을 모두 스캔하면서 ```R```을 체크한다.
>     - ```R = 1``` : 마지막으로 페이지를 사용한 시간을 현재 가상 시간으로 바꾼다.
>     - ```R = 0``` : ```age``` = (현재 가상 시간 - 마지막으로 페이지를 사용한 시간)와 ```T``` 비교
>       - ```age > T``` : 워킹 세트에 그 페이지가 포함되어 있지 않으므로, 그 페이지를 지우고 게속 스캔한다.
>       - ```age <= T``` : 가장 큰 ```age```를 만드는 페이지를 기억하고 계속 스캔한다.
>   - 마지막까지 스캔했을 때 (모든 엔트리가 ```age <= T```이면), 가장 큰 ```age```를 만드는 페이지를 지운다.
>   - 모든 엔트리가 ```R = 1```이면 (가장 큰 ```age```를 만드는 페이지를 기억하지 않는다면), 한 페이지를 랜덤으로 지운다.

### 세그멘테이션 (```Segmentation```) : 하나의 가상 주소를 제공하는 페이징과 달리, 여러 개의 가상 주소 제공
- 프로세스를 논리적 내용을 기반으로 나누어서 메모리에 배치
  - 세그멘테이션 기법에서의 프로세스는 세그멘트 (```segment```)의 집합
    - 각 세그먼트는 자기만의 선형적인 주소 공간을 가짐
  - 페이징 기법에서는 주소 공간이 서로 충돌될 수 있지만, 세그멘테이션에서는 동적으로 테이블이 커지거나 줄어듬
<br><br>

- 세그먼트 테이블 : 각 엔트리의 논리 주소는 ```<segment-number, offset>```
  - 페이징과 달리 세그먼트의 크기는 일정하지 않기에 테이블에 ```limit``` 정보가 추가로 담겨 있음
  - 만약 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 프로세스가 강제 종료

> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fol2eM%2FbtrnC38FGmG%2FKv5nbXQG2rCUeck0pRS8I0%2Fimg.png" width="80%" style="margin-left: 2%">
>
> - 논리 주소 (2, 100) : 물리 주소 4400번지
> - 논리 주소 (1, 500) : 인터럽트로 인해 프로세스가 강제로 종료 (범위 벗어남)

- 세그멘테이션의 장점
  - 보호 : 세그먼테이션도 페이징처럼 ```r, w, x```를 테이블에 추가하는데, 프로세스를 논리적으로 나눠 비트 설정이 간단
  - 공유 : 세그먼테이션은 정확히 code 영역만 나누기에 다른 영역을 포함할 확률이 높은 페이징보다 더 효율적

> ...하지만 세그멘테이션은 외부 단편화 문제를 해결하지 못해, 현재는 페이징 기법을 대부분 사용한다.
>
> - 외부 단편화 : 메모리 할당을 처음 시작할 때 크기가 서로 다른 프로세스로 인해 다양한 크기의 홀이 발생 (```checkerboarding```)
>   - 세그먼트를 논리적인 단위로 나눈 세그멘테이션 역시 외부 단편화로 인해 메모리 낭비가 큼
> - 세그멘테이션을 페이징 (```Paged segmentation```) : 펜티엄 (```Pentium```)
>   - ```cs```, ```ds```, ```ss```를 각각의 세그먼트가 아닌 하나의 주소 공간으로 통일해서 사용
>     - 그러므로 ```cs```, ```ds```, ```ss```는 다 같은 셀렉터 값을 가짐
>   - 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 2번
>     - ```CPU```의 세그먼트 테이블에서 주소 변환, 그리고 다음 페이지 테이블에서 주소 변환