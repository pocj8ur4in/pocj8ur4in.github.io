---
title: "[OS] 1. 운영체제 (Operation System)"

tags:
    - OS

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2024-07-30
---

## 운영체제 (Operation System) : 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어

운영체제는 컴퓨터 시스템 자원의 효율적인 관리와 사용자 편의성 제공을 목표로 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어한다. 컴퓨터 시스템 자원의 효율적인 관리는 하드웨어 자원을 각 사용자 응용 프로그램에 적절히 분배하는 것을 포함한다. 운영체제가 활용하는 하드웨어 자원에는 CPU 시간, 기억 장치 및 디스크 영역, I/O 장치 등이 있다.

<div style="color: white; padding: 2% 0% 2% 0%; border: 4px solid #00CED1;">
    <ul>
        <li>프로세스 관리 (Process Management)</li>
        <li>메인 메모리 관리 (Main Memory Management)</li>
        <li>파일 관리(File Management)</li>
        <li>저장 장치 관리 (Storage Management)</li>
        <li>I/O 장치 관리 (I/O Device Management)</li>
        <li>시스템 호출 (System call)</li>
    </ul>
</div>

### 부팅 (Booting)
부팅은 컴퓨터를 시작할 때 자신을 구동시킬 프로그램을 스스로 불러내는 동작이다. 부팅 과정에서 메인 메모리는 즉시 필요한 데이터를 저장하는 주 기억 장치로 활용된다.

- **RAM**: 휘발성 주 기억 장치로, 전원이 꺼지면 모든 내용이 지워진다.
  - **코드 영역**: 실행할 프로그램의 코드가 저장되는 영역이다. CPU는 이 영역에 저장된 명령어를 하나씩 호출해 프로그램 실행 흐름을 제어한다. 주로 실행 파일의 명령어들이 로드되며, 프로그램의 주요 논리와 제어 구조가 이곳에 위치한다.
  - **데이터 영역**: 실행할 프로그램의 전역 변수와 정적 변수가 저장되는 영역이다. 프로그램이 시작될 때 할당되고 프로그램이 종료될 때 소멸된다. 이 영역에서 프로그램 전체에 접근 가능한 데이터를 저장하며, 프로그램의 상태와 관련된 중요한 정보를 유지한다. 전역 변수와 정적 변수는 프로그램 실행 내내 동일한 값을 유지할 수 있다.
  - **스택 영역**: 프로그램의 함수 호출과 관련된 지역 변수와 매개 변수가 저장되는 영역이다. 후입선출(LIFO) 방식에 따라 동작하며, 함수 호출 시 할당되고 호출 종료 시 소멸된다. 이 영역은 함수 호출과 복귀 주소, 매개 변수, 지역 변수를 관리한다. 함수가 호출될 때마다 새로운 스택 프레임이 생성되고, 함수 종료 시 해당 프레임이 제거된다.
  - **힙 영역**: 사용자에 의해 동적으로 할당되고 해제되는 전역 변수가 저장되는 영역이다. 할당되는 변수의 크기에 제한이 없어 유연하게 메모리를 사용할 수 있지만, 메모리 단편화 문제를 유발할 수 있다. 힙 영역의 메모리는 사용자가 직접 관리해야 하며, 동적 메모리 할당을 통해 프로그램이 실행 중 필요한 메모리를 유연하게 사용할 수 있게 한다. 동적 배열이나 링크드 리스트 등의 데이터 구조가 힙 영역에 저장된다.

- **ROM**: 비휘발성 주 기억 장치로, 전원이 꺼져도 그 안의 내용이 계속 유지된다.
  - **POST (Power-On Self-Test)**: 부팅 시 가장 처음 실행되는 검사 루틴으로, 하드웨어 장치들이 정상적으로 작동하는지 검사한다. CPU, 메모리, 디스크 드라이브 등 주요 하드웨어 구성 요소를 점검하여 문제를 식별하고, 문제가 발견되면 부팅 과정을 중단하고 오류 메시지를 표시한다.
  - **부트 로더 (Boot Loader)**: POST가 완료된 후 실행된다. 부트 로더는 보조 기억 장치(HDD 또는 SSD)에 저장된 운영체제를 탐색하여 RAM으로 불러온다. 부트 로더는 컴퓨터의 기본 입력/출력 시스템(BIOS) 또는 통합 확장 펌웨어 인터페이스(UEFI)에 의해 로드된다. 부트 로더는 다음과 같은 단계로 동작한다:
    1. **MBR/GPT 로드**: 부트 로더는 먼저 하드 디스크의 첫번째 섹터(MBR; Master Boot Record) 또는 GPT(GUID Partition Table)를 읽어서 파티션 정보를 확인한다. MBR은 디스크의 첫 512바이트 섹터로, 파티션 테이블과 부트스트랩 코드가 포함되어 있다. GPT는 이보다 더 최신의 파티션 테이블 형식으로, 대용량 디스크와 다수의 파티션을 지원하여 더 신뢰성이 높다.
    2. **파티션 탐색**: 부트 로더는 운영체제가 저장된 파티션을 탐색하고, 해당 파티션의 부트 섹터를 로드한다. 이 과정에서는 부트 로더가 특정 파티션을 식별하고, 그 파티션에서 커널을 찾기 위해 파일 시스템을 이해할 수 있어야 한다. 대부분의 현대 부트 로더는 여러 파일 시스템을 지원하여 이 과정을 원활하게 수행한다.
    3. **커널 로드**: 부트 로더는 운영체제의 커널을 RAM으로 불러온다. 커널은 하드웨어와 소프트웨어 간 상호 작용을 관리한다. 커널 로드가 완료되면 시스템은 커널의 제어하에 들어가게 되며, 커널은 운영체제의 나머지 부분과 사용자 프로그램을 실행할 준비를 완료하게 된다. 커널을 로드하는 과정은 일반적으로 커널 이미지 파일을 메모리로 복사하고, 커널의 진입점을 설정하는 단계를 포함한다.
    4. **커널 실행**: 커널이 메모리에 로드되면, 부트 로더는 제어를 커널에 넘기고, 커널은 시스템 초기화를 시작한다. 이 단계에서 다양한 드라이버를 로드하고 시스템 서비스를 시작하며, 최종적으로 사용자 인터페이스를 초기화한다. 커널은 메모리, 프로세서, 디스크, 네트워크와 같은 주요 하드웨어 컴포넌트를 초기화하고, 시스템 로그를 생성하며, 런레벨(runlevel)에 따라 초기화 스크립트를 실행한다. 이러한 초기화 과정이 완료되면, 사용자 로그인 화면 또는 그래픽 사용자 인터페이스(GUI)가 표시되며, 사용자가 시스템을 사용할 수 있게 된다.

운영체제는 SSD 또는 HDD와 같은 보조 기억 장치에 저장된다. 운영체제는 커널과 명령어 해석기를 포함하며, 커널은 운영체제가 수행하는 모든 작업을 저장하고, 명령어 해석기는 사용자가 요청하는 명령어를 해석해 커널에 요청하고 결과를 출력한다. 응용 프로그램은 운영체제 위에서 수행되며, 운영체제가 지원하는 자원만을 사용 가능하다.

### 일괄 처리 시스템 (Batch Processing System)
일괄 처리 시스템은 프로그램 수행 과정을 자동화하는 시스템이다. 이 시스템에서는 여러 프로그램이 일괄적으로 처리된다. 사용자는 작업(Job)을 제출하면, 시스템은 이를 순서대로 처리한다. 일괄 처리 시스템의 주요 구성 요소 중 하나는 Resident Monitor이다. Resident Monitor는 컴파일, 링크, 로딩의 과정을 하나의 프로그램으로 작성하여 프로세서에 할당한다. 이렇게 하면 사용자 개입 없이도 프로그램이 연속적으로 실행될 수 있다. 일괄 처리 시스템은 작업 효율성을 높이기 위해 개발되었으며, 대량의 데이터를 처리하는 데 적합하다.

### 시분할 시스템 (Time-sharing System)
시분할 시스템은 CPU가 프로그램을 수행하는 시간을 제한하는 시스템이다. 이 시스템에서는 여러 사용자가 동시에 컴퓨터를 사용할 수 있는 환경을 제공한다. 프로그램이 일정 시간 실행되면 Time Out을 발생시켜 다음 프로그램으로 넘어가게 하는 스위칭 방식으로 동작한다. 이를 통해 여러 사용자가 동시에 컴퓨터를 사용하는 것처럼 보이게 된다. 시분할 시스템의 핵심 요소는 다중 작업(Multitasking)이다. 다중 작업은 CPU가 짧은 시간 내에 여러 프로그램을 스위칭해 동시에 작업하는 것처럼 보이게 한다. CPU 스케줄링은 CPU가 어느 프로그램을 실행할지 선택하는 작업으로, 시분할 시스템의 효율성을 높이는 데 중요한 역할을 한다.

### 다중 프로그래밍 (Multiprogramming)
다중 프로그래밍은 메모리에 여러 응용 프로그램을 적재해 idle 상태를 최소화하는 방식이다. 이 시스템에서는 프로그램 실행 시 계산을 담당하는 CPU와 입출력을 담당하는 I/O 장치가 교대로 실행된다. 예를 들어, 하나의 프로그램이 I/O 작업을 수행하는 동안 다른 프로그램은 CPU를 사용할 수 있다. 이렇게 하면 I/O 장치가 실행되는 동안 CPU가 아무런 작업도 하지 않는 idle 상태를 방지할 수 있다. 다중 프로그래밍은 시스템 자원의 활용도를 높이고 처리량을 증가시키는 데 효과적이다.

### 인터럽트 기반 시스템 (Interrupt-based System)
인터럽트 기반 시스템은 인터럽트 발생 시 ISR(Interrupt Service Routine)에 맞는 처리를 수행하는 시스템이다. 인터럽트는 프로그램 실행 중에 예기치 않은 상황이 발생할 경우 이를 CPU에 알리는 전기 신호이다. 인터럽트는 외부 인터럽트와 내부 인터럽트로 나뉜다.

- **외부 인터럽트 (External Interrupt)**: 키보드 입력, 마우스 클릭, 타이머 신호 등 외부 장치에서 발생하는 하드웨어 인터럽트이다.
- **내부 인터럽트 (Internal Interrupt)**: 프로그램 실행 중 발생하는 예외나 시스템 호출 등이 포함되는 소프트웨어 인터럽트이다.

인터럽트 서비스 루틴(ISR)은 인터럽트 신호를 처리할 방법을 내포한 운영체제 내의 코드이다. 인터럽트가 발생하면 CPU는 현재 작업을 중단하고 ISR을 실행하여 인터럽트를 처리한다. 인터럽트가 처리된 이후에 CPU는 중단된 작업을 재개한다.

### 이중 모드 (Dual Mode Execution)
운영체제는 유저 모드와 커널 모드로 나뉘어 동작한다. 어떤 작업이 자원을 계속해서 점유하는 일과 같이 컴퓨터의 작업 효율을 저해하는 행위로부터 보호할 수단이 필요하다. 이를 위해 CPU 내 레지스터의 Mode-Bit를 플래그로 활용해 나타내며, 커널 모드는 0, 유저 모드는 1로 설정된다. 각 명령어에 Mode-Bit를 넣어 시스템 내의 Mode-Bit와 같을 시에만 명령어를 수행할 수 있다.

특권 명령어는 커널 모드에서만 내릴 수 있는 명령어로, STOP, HALT, RESET, SET_TIMER 등이 포함된다. 유저 모드에서는 특권 명령어를 내릴 수 없으며, 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제 종료한다. 시스템 호출은 Mode-Bit를 바꾸는 행위로, 사용자가 하드웨어 자원에 접근할 때 프로그램에서 시스템 호출을 발생시켜 운영체제에 위임해 커널 모드로 처리한다.

> 컴퓨터가 부팅되는 과정 : 커널 모드
> 응용 프로그램이 실행되는 과정 : 커널 모드
> 응용 프로그램이 실행되는 과정 : 유저 모드
> 인터럽트가 발생한 후에 처리되는 과정 : 커널 모드
> 인터럽트를 처리한 후에 치리되는 과정 : 유저 모드

### 하드웨어 보호 (H/W Protection)
잘못된 명령이나 접근에 대비해 운영체제는 내부 인터럽트를 발생시켜 보호한다. 정보들이 여러 I/O 장치를 통해 컴퓨터로 입출력되는 과정에서 장치 간 혹은 데이터 간의 혼선이 발생할 수 있다.

#### 입출력 장치 보호 (I/O Protection)
입출력 명령을 특권 명령으로 지정해 운영체제를 통해 수행하며, 입출력 수행 시에는 관리자 모드로 전환해 특권 명령을 내린다. 사용자가 입출력 명령을 직접 내린 경우 Privileged Instruction Violation이 발생해 프로그램을 강제 종료한다.

> ! 문제 : 다른 사용자나 운영체제에 할당된 메모리 영역에 접근해 정보나 프로그램을 해킹할 수 있음

#### 메모리 보호 (Memory Protection)
CPU와 메인 메모리 간 주소 버스에 Memory Management Unit(MMU)를 설치해, 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다. 사용자에 할당된 메모리 영역을 벗어난 주소값을 가져오지 못하게 하며, MMU 설정은 운영체제만 변경 가능하다. 사용자에 할당된 메모리 영역을 벗어난 주소값이 MMU에 오면 내부 인터럽트를 발생시켜 Segment Violation을 일으킨다.

> ! 문제 : 프로그램에서의 무한 루프로 인해 CPU가 독점되어 다른 프로그램이 수행되지 못할 수 있음

#### CPU 보호 (CPU Protection)
타이머를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킨다. 타이머 인터럽트는 인터럽트의 ISR에서 CPU가 프로그램의 CPU 점유 시간을 측정해 분배하며, 운영체제는 타이머가 끝난 작업을 종료시키고 스케줄링 이전에 타이머를 실행한다.