---
title: "[B/E] 운영체제"

categories:
    - Backend

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2022-10-23
---

<p class="notice--primary"><strong>이 항목은 현재 작성중입니다.</strong><br>> 아직 미완성된 코드나 문장 구조가 정확하지 않은 내용이 있을 수 있으니 유의하시기 바랍니다.</p>

<p class="notice--warning"><strong>이 항목은 검증되지 않은, 편향된, 혹은 잘못된 내용을 포함할 수 있습니다.</strong><br>> 작성자 역시 공부하는 학생이기에 해당 부분을 댓글이나 이메일을 통해 지적해주신다면 정말 감사할 것 같습니다.</p>

## 운영체제 (```Operation System```) : 사용자가 컴퓨터에서 실행한 프로그램을 관리하고 제어
- 컴퓨터 시스템 자원의 효율적인 관리 (```Performance```) : 하드웨어 자원을 각각의 사용자 응용 프로그램에 적절히 분배
  - 하드웨어 자원 (```Hardware Resource```) : CPU 시간, 기억 장치 및 디스크 영역, I/O 장치
- 사용자 편의성 제공 (```Convenience```) : 사용자가 더 편리하게 사용할 수 있는 환경을 구성

<div style="color: white; padding: 2% 0% 2% 0%; background-color: black;">
<ul>
  <li>프로세스 관리 (Process Management)</li>
  <li>메인 메모리 관리 (Main Memory Management)</li>
  <li>파일 관리(File Management)</li>
  <li>저장 장치 관리 (Storage Management)</li>
  <li>I/O 장치 관리 (I/O Device Management)</li>
  <li>시스템 호출 (System call)</li>
</ul>
</div>

### 부팅 (```Booting```) : 컴퓨터를 시작할 때 자기 자신을 구동시킬 프로그램을 스스로 불러내는 동작
- 메인 메모리 (```Main Memory```) : 즉시 필요한 데이터를 저장하는 주 기억 장치
  - ```RAM``` : 휘발성 주 기억 장치 (전원이 꺼지면 모든 내용이 지워짐)
    - 코드 영역 (```Code Area```) : 실행할 프로그램의 코드가 저장되는 영역
      - CPU는 이 영역에 저장된 명령어를 하나씩 호출해 수행함
    - 데이터 영역 (```Data Area```) : 실행할 프로그램의 전역 변수와 정적 변수가 저장되는 영역
      - 프로그램 시작 시 할당, 프로그램 종료 시 소멸
    - 스택 영역 (```Stack Area```) : 실행할 프로그램의 함수의 호출과 관련된 지역 변수와 매개 변수가 정적으로 저장되는 영역
      - 후입선출 (```Last-In, First-Out```) 방식에 따른 동작 : ```PUSH```로 데이터를 저장하고, ```POP```로 데이터를 인출 
      - 메모리의 높은 주소에서 메모리의 낮은 주소의 방향으로 할당 
      - 함수 호출 시 할당, 함수 호출 종료 시 소멸
    - 힙 영역 (```Heap Area```) : 사용자에 의해 동적으로 할당되고 해제되는 전역 변수가 저장되는 영역
      - 할당되는 변수의 크기 제한이 없음 : 크기 제한이 존재하는 스택에 비해 액세스 속도가 상대적으로 느림
      - CPU에 의해 효율적으로 관리되는 스택 영역과 달리, 사용자가 힙 영역을 관리해야 함
        - 메모리 단편화 (```Memory Fragmentation```) : 사용 가능한 메모리가 존재하지만, 할당이 불가능한 상태
      - 메모리의 낮은 주소에서 메모리의 높은 주소의 방향으로 할당
  - ```ROM``` : 비휘발성 주 기억 장치 (전원이 꺼져도 그 안의 내용이 계속 유지)
    - ```POST``` (```Power-On Self-Test```) : (부팅 시 가장 처음 실행되는 프로그램) 현재 컴퓨터의 상태 검사
    - 부트 로더 (```Boot Loader```) : (```POST``` 다음에 실행되는 프로그램) 보조 기억 장치의 운영체제를 탐색 후 ```RAM```에 할당
      - 보조 기억 장치에서 ```RAM```으로 할당된 운영체제는 컴퓨터 전원이 꺼질 때까지 상주 (```Resident```)
- ```SSD```/```HDD``` : 운영체제가 저장된 보조 기억 장치
  - 커널 (```Kernel```) : 운영체제가 수행하는 모든 작업이 저장
  - 명령어 해석기 (```Shell```) : 사용자가 요청하는 명령어를 해석해 커널에 요청하고 결과를 출력
    - 응용 프로그램 (```Application```) : 운영체제 위에서 수행되며, 운영체제가 지원하는 자원만을 사용 가능

## 운영체제의 동작 원리

### 일괄 처리 시스템 (```Batch Processing System```) : 프로그램 수행 과정의 자동화
- ```Resident Monitor``` : 프로세서에 할당하기 위해 (컴파일 -> 링크 -> 로딩)의 과정을 하나의 프로그램으로 작성

### 시분할 시스템 (```Time-sharing System```) : CPU가 프로그램을 수행하는 시간을 제한
- 스위칭 (```Switching```) : 프로그램이 일정 시간 실행되면 ```Time Out```을 발생시켜 다음 프로그램으로 넘어가게 함
- 다중 작업 (```Multitasking```) : CPU가 짧은 시간 내에 여러 프로그램을 스위칭해 동시에 작업하는 것처럼 보이게 함
  - CPU 스케줄링 (```CPU Scheduling```) : CPU가 어느 프로그램을 실행할지 선택하는 작업

### 다중 프로그래밍 시스템 (```Multiprogramming System```) : 메모리에 여러 응용 프로그램을 적재시켜 idle 상태 최소화
- 프로그램 실행 시에 계산을 담당하는 ```CPU```와 입출력을 담당하는 ```I/O``` 장치가 교대로 실행
  - ```idle```상태 : I/O 장치가 실행되는 동안 CPU가 아무런 작업도 하지 않는 상태

### 인터럽트 기반 시스템 (```Interrupt-based System```) : 인터럽트 발생 시 ```ISR```에 맞는 처리 수행
- 인터럽트 (```Interrupt```) : 프로그램 실행 중에 예기치 않은 상황이 발생할 경우 이를 CPU에 알리는 전기 신호
  - 외부 인터럽트 (```Eternal Interrupt```) = 하드웨어 인터럽트 (```Hardware Interrupt```)
  - 내부 인터럽트 (```Internal Interrupt```) = 소프트웨어 언터럽트 (```Software Interrupt```)
    - 예외 (```Exception```)
    - 시스템 호출 (```System call```)
- 인터럽트 서비스 루틴 (```Interrupt Service Routine```) : 인터럽트 신호를 처리하기 위한 방법을 내포한 운영체제 내의 코드

### 이중 모드 (```Dual Mode Execution```) : 유저 (```User```) 모드와 커널 (```Kernel```) 모드를 나눔

> ! 문제 : 어떤 작업이 자원을 계속해서 점유하는 일과 같이 컴퓨터의 작업 효율을 저해하는 행위로부터 보호할 수단을 필요

- CPU 내 레지스터 (```Register```)의 ```Mode-Bit```를 플래그 (```flag```)로 활용해 나타냄 (커낼 모드 : ```0```, 유저 모드 : ```1```)
- 각 명령어에 ```Mode-Bit```를 넣어 시스템 내의 ```Mode-Bit```와 같을 시에만 명령어 수행
- 특권 명령어 (```Privileged Instruction```) : 커널 모드에서만 내릴 수 있는 명령어
  - ```STOP```, ```HALT```, ```RESET```, ```SET_TIMER``` 등
  - 유저 모드에서는 특권 명령어를 내릴 수 없음 (내부 인터럽트를 발생해 해당 명령어를 요청한 프로그램을 강제 종료)
- 시스템 호출 (```System Call```) : ```Mode-Bit```를 바꾸는 행위 (```INT 80```)
  - 사용자가 하드웨어의 자원에 접근할 때, 프로그램에서 시스템 호출을 발생시켜 운영체제에 위임해 커널 모드로 처리

> - 컴퓨터가 부팅되는 과정 : 커널 모드
> - 응용 프로그램이 실행되는 과정 : 커널 모드
> - 응용 프로그램이 실행되는 중일 때 : 유저 모드
> - 인터럽트가 발생한 후 처리하는 과정 : 커널 모드
> - 인터럽트를 처리한 후 : 유저 모드

#### 하드웨어 보호 (```H/W Protection```) : 잘못된 명령이나 접근으로부터 보호하기 위해 운영체제에서 내부 인터럽트를 발생

> ! 문제 : 정보들이 여러 I/O 장치를 통해 컴퓨터로 입출력되는 과정에서 장치 간 혹은 데이터 간의 혼선이 발생할 수 있음

##### 입출력 장치 보호 (```I/O Protection```) : ```in```, ```out```과 같은 입출력 명령을 특권 명령으로 지정해 운영체제를 통해 수행
- 입출력 수행 시에는 관리자 모드로 전환해 특권 명령을 내림
  - ```Privileged Instruction Violation``` : 사용자가 입출력 명령을 직접 내린 경우 프로그램을 강제 종료 

> ! 문제 : 다른 사용자나 운영체제에 할당된 메모리 영역에 접근해 정보나 프로그램을 해킹할 수 있음

##### 메모리 보호 (```Memory Protection```) : CPU와 메인 메모리 간 주소 버스에 ```MMU``` (```Memory Management Unit```)를 설치
- 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장
- 사용자에 할당된 메모리 영역을 벗어난 주소값을 가져오지 못하게 함
- ```MMU``` 설정은 운영체제만 변경 가능
  - ```Segment Violation``` : 만약 사용자에 할당된 메모리 영역을 벗어난 주소값이 ```MMU```에 들어오면 내부 인터럽트를 발생시킴

> ! 문제 : 프로그램에서의 무한 루프로 인해 CPU가 독점되어 다른 프로그램이 수행되지 못할 수 있음

##### CPU 보호 (```CPU Protection```) : 타이머 (```Timer```)를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킴
- 타이머 (```Timer```) : 무한 루프나 자원 독점을 막기 위해 특정 시간이 지나면 타이머 인터럽트를 발생시킴
  - 타이머 인터럽트 (```Timer Interrupt```) : 해당 인터럽트의 ISR에서 CPU는 각 프로그램의 CPU 점유 시간을 측정해 분배
  - 운영체제는 타이머가 끝난 작업을 종료시키고 스케줄링 (```Scheduling```) 이전에 타이머 실행

## 프로세스 (```Process```) : 실제 메인 메모리에 할당되어 실행 중인 프로그램
- 프로그램은 보조 기억 장치에서 아무런 동작을 하지 않은 상태
- 어떤 요청에 의해 메인 메모리에 할당되어 CPU를 사용하면서 실행
- 각각의 프로세스는 CPU에 의해 샐행된 후 ...를 생성 (메인 메모리를 효율적으로 사용해야 함)
  - 프로세스 테이블 엔트리 = 프로세스 컨트롤 블록 (```Process Control Block```)
  - 주소 공간 (```Address Space```)
    - 코드 세그먼트 (```Code Segment```) : 프로그램 소스 코드가 저장
    - 데이터 세그먼트 (```Data Segment```) : 전역 변수가 저장
    - 스택 세그먼트 (```Stack Segment```) : 지역변수와 매개변수가 저장

> 지역변수와 매개 변수가 후입선출의 방식을 따른 스택에 저장되기에, 전역 변수를 먼저 선언해 메인 메모리의 공간 절약 가능

### 프로세스의 생성과 종료
- 최초의 프로세스인 ```Init```의 생성은 부팅된 운영체제가 처음 수행하는 작업 중 하나
- 생성된 프로세스가 다른 프로세스를 생성하는 과정을 반복
  - 프로세스의 생성을 위한 시스템 호출 : ```fork()```
  - 프로세스의 종료를 위한 시스템 호출 : ```exit()```
- 생성된 모든 프로세스는 자신을 식별할 수 있는 고유의 정수값인 ```PID```을 가짐
  - 생성된 모든 프로세스는 자신을 생성한 사용자 고유의 ```UID``` 값 또한 가짐 (부모와 자식이 동일한 값)

<img src="https://i.stack.imgur.com/6RGIe.jpg" width="30%" style="margin-left: 2%">

- 프로세스 트리 (```Process Tree```) : 부모 프로세스인 A에서 자식 프로세스인 B, C, D가 파생되어 생성
  - 부모 프로세스 : 프로세스를 생성한 프로세스
  - 자식 프로세스 : 프로세스로부터 생성된 프로세스
  - 형제 프로세스 : 같은 부모 프로세스에서 파생된 자식 프로세스

#### ex) 프로세스 관리를 위한 시스템 호출

```
while (true) {
  type_prompt();
  read_command(command, parameters);
if (fork() != 0){
    /* Parent Code */
    waitpid(-1, &status, 0);
  }
else {
    /* Child Code */
    execve (command, parameters, 0);
  } 
}
```
- ```brk```시스템은 데이터 세그먼트가 끝나는 시점에서 새로운 주소를 명시화해 ```malloc``` 라이브러리는 공간을 동적으로 할당받음

### 프로세스 컨트롤 블록 (```PCB``` = ```Process Control Block```) : 프로세스에 대한 모든 정보를 저장하는 곳
- CPU는 여러 프로세스를 빈번히 전환하면서 수행하기에 각 프로세스의 데이터를 저장해야 작업을 이어서 수행할 수 있음
- 운영체제 내에서 프로세스를 관리하는 코드 부분에 저장
  - 프로세스 컨트롤 블록에 데이터를 저장하고 복원하는 시간 역시 다중 작업을 위해 각 프로세스에 할당되는 시간에 포함
- 프로세스 상태 (```Process Status```), 프로그램 카운터 (```Program Counter```), 스택 포인터 (```Stack Pointer```), 파일 디스크립터 (```File Descriptors```) 등의 정보 포함

<img src="https://user-images.githubusercontent.com/34755287/70577652-12841080-1bef-11ea-8f1c-5c0e0d94c132.png" width="80%" style="margin-left: 2%">

#### 프로세스 상태 (```Process Status```) : 각 단계들에서 상태 전이가 일어나 다음 단계로 넘어감
- ```New``` : 프로그램이 메인 메모리에 할당된 상태
- ```Ready``` : 프로세스가 언제든 실행 가능한 상태; 할당된 프로그램이 실행되기 위한 모든 준비를 마친 상태로 대기된 상태
  - n개의 작업이 있을 때, CPU의 프로세서는 스케줄러의 0~(n-1)번, 즉 n개의 작업을 번갈아 처리
- ```Running``` : CPU가 해당 프로세스를 실제로 실행중인 상태
- ```Waiting```=```Blocked``` : ```Running```이 불가능한 상태
  - 프로세스가 끝나지 않은 시점에 해당되는 I/O 정보가 없어 작업할 수 없음
  - ```Waiting```가 끝나면 다시 CPU에 실행되기 위해 ```Ready```로 돌아가야 함
- ```Terminated``` : 프로세스가 완전히 종료된 상태

<img src="https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png"  width="80%" style="margin-left: 2%">

> - I/O 작업으로 인한 상태 변화 : ```Running``` -> ```Waiting``` -> ```Ready``` -> ```Running```
> - 시간 초과로 인터럽트에 의한 상태 변화 : ```Running``` -> ```Ready``` -> ```Running```

### 프로세스 큐 (```Process Queue```) : 커널이 프로세스 스케줄링을 위해 데이터 영역에서 관리하는 큐
- ```Ready Queue``` : 프로세스 상태가 ```Ready```인 프로세스들이 CPU 제어를 기다리는 큐
  - 어떤 CPU 스케줄링 알고리즘을 선택하는지에 따라 CPU 제어 순서가 달라짐
- ```Job Queue``` : 보조 기억 장치의 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐
  - 시스템 내의 모든 프로세스 관리 : ```Ready Queue```, ```Device Queue```에 속한 모든 프로세스 포함
- ```Device Queue``` : 프로세스 상태가 ```Waiting```인 프로세스들이 CPU 외의 자원을 기다리는 큐
  - 기다리는 자원들마다 큐가 할당되며, 해당 자원이 사용되면 인터럽트를 발생시키고 ```Ready Queue```로 이동

<img src="https://user-images.githubusercontent.com/34755287/53879660-5ccdd500-4052-11e9-972d-11ba3faeb3e3.png" width="80%" style="margin-left: 2%">

- 각 큐는 프로세스의 프로세스 컨트롤 블록을 가리키는 포인터 방식으로 연결 리스트를 구현

#### 스케줄러 (```CPU Scheduler```) : 프로세스 순서를 정해 프로세스 큐에 올릴 것을 결정하는 커널의 코드
- 장기 스케줄러 (```Long-term Scheduler```) : 생성된 프로세스 중 어떤 것을 ```Job Queue```에서 ```Ready Queue```으로 이동시킬지 선택
  - 장기 스케줄러는 현재 메모리에 할당된 프로세스의 개수 (```Degree of multiprogramming```)를 제어
  - 장기 스케줄러는 ```I/O bound Process```,```CPU bound Process```를 메인 메모리에 적절히 할당해야 함
    - ```I/O bound Process``` : I/O 작업 (입출력) 비중이 높은 프로세스
    - ```CPU bound Process``` : CPU 작업 (계산) 비중이 높은 프로세스
- 중기 스케줄러 (```Medium-term Scheduler```) : 실행 중인 프로세스 중 보조 저장 장치로 옮길 것을 주기적으로 검사
  - ```Swapping``` (```Swap-out```↔```Swap-in```) : ```Swap-in```할 때 이전 공간으로 재할당되는 것은 보장되지 않음
    - ```Swap-out``` : 메인 메모리에서 우선 순위가 은 프로세스를 통째로 보조 기억 장치로 저장
    - ```Swap-in``` : 나중에 해당 프로세스가 다시 사용되려 할 때 보조 기억 장치에서 메인 메모리에 다시 할당
  - 중기 스케줄러 또한 현재 메모리에 할당된 프로세스의 개수 (```Degree of multiprogramming```)를 제어
- 단기 스케줄러 (```Short-term Scheduler```) : ```Ready Queue``` 내에서 프로세스들 중 어떤 것을 다음에 실행시킬지 선택
  - CPU 스케줄러 (```CPU Scheduler```) 라고도 부르며, 시분할 시스템에서 ```Time Out```이 발생하면 호출

## 문맥 전환 (```Context Switching```) : CPU가 실행중인 프로세스를 멈추고 다른 프로세스를 실행하는 작업
- 문맥 (```Context```) : 각 프로세스 컨트롤 블록 내에서 표현
  - 하드웨어 문맥 : 프로그램 카운터 정보와 레지스터 정보를 저장
  - 프로세스 주소 공간 : 각 프로세스가 갖고 있는 독자적인 주소 공간에 위치
- CPU 스케줄러 : CPU가 어느 프로세스를 다음에 실행할지 지정
- 디스패쳐 (```Dispatcher```) : 문맥 전환이 발생하면 ```Ready```에서 ```Running```으로 상태 전이
  - 문맥 전환 오버헤드 (```Context Switching Overhead```) : 문맥 전환이 발생할 때마다 디스패쳐를 매번 실행시킴<br><br>

1. CPU에서 실행중인 프로세스의 데이터는 해당 프로세스의 프로세스 컨트롤 블록에 갱신
2. 새로 시작될 프로세스의 프로세스 컨트롤 블록를 CPU로 복원
3. 캐시와 ```Translation Lookup Buffer```를 재설정
  
> 시스템 호출로 인한 인터럽트 발생 시 : 실행중인 프로세스의 문맥을 프로세스 컨트롤 블록에 갱신하나, 문맥 전환은 일어나지 않음

## CPU 스케줄링 (```CPU Scheduling```) : CPU 스케줄러에서 다음에 실행할 프로세스를 선택하는 작업
- 선점 (```Preemptive```) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 강제로 점유할 수 있음
- 비선점 (```Non-Preemptive```) : 한 프로세스가 CPU를 점유하는 동안, 다른 프로세스가 CPU를 점유할 수 없음 (예외 : ```I/O``` 발생)

### CPU 스케줄링 척도 (```CPU Scheduling Criteria```) : CPU 스케줄링의 효율을 분석하는 기준
- CPU 점유율 (```CPU Utilization```) : 현재 CPU가 작업을 수행하는 비율 -> 높을수록 좋음
- 처리율 (```Throughput```) : 단위 시간 당 완료되는 프로세스의 개수 -> 많을수록 좋음
- 소요 시간 (```Turnaround Time```) : 프로세스가 생성된 시간부터 종료되는 데까지 걸린 시간 -> 짧을수록 좋음
- 대기 시간 (```Waiting Time```) : CPU 제어를 위해 ```Ready Queue```에서"만" 대기한 시간 -> 짧을수록 좋음
- 응답 시간 (```Response Time```) : ```Interactive System```에서 입력에 대한 반응 시간 -> 짧을수록 좋음