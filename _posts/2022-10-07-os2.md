---
title: "[Operation System] 2. Process"

tags:
    - Operation System

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2022-12-12
---

## 프로세스 (```Process```) : 실제 메인 메모리에 할당되어 실행 중인 프로그램

- 프로그램은 보조 기억 장치에서 아무런 동작을 하지 않은 상태
- 어떤 요청에 의해 메인 메모리에 할당되어 CPU를 사용하면서 실행
- 각각의 프로세스는 CPU에 의해 샐행된 후 ...를 생성 (메인 메모리를 효율적으로 사용해야 함)
  - 프로세스 테이블 엔트리 = 프로세스 컨트롤 블록 (```Process Control Block```)
  - 주소 공간 (```Address Space```)
    - 코드 세그먼트 (```Code Segment```) : 프로그램 소스 코드가 저장
    - 데이터 세그먼트 (```Data Segment```) : 전역 변수가 저장
    - 스택 세그먼트 (```Stack Segment```) : 지역변수와 매개변수가 저장

> 지역변수와 매개변수가 후입선출을 따른 스택에 저장되므로, 전역 변수를 먼저 선언해 메인 메모리의 공간 절약 가능

### 프로세스의 생성과 종료 (```Creation and Destruction of Process```)
- 최초의 프로세스인 ```Init```의 생성은 부팅된 운영체제가 처음 수행하는 작업 중 하나
- 생성된 프로세스가 다른 프로세스를 생성하는 과정을 반복
  - 프로세스의 생성을 위한 시스템 호출 : ```fork()```
  - 프로세스의 종료를 위한 시스템 호출 : ```exit()```
- 생성된 모든 프로세스는 자신을 식별할 수 있는 고유의 정수값인 ```PID```을 가짐
  - 생성된 모든 프로세스는 자신을 생성한 사용자 고유의 ```UID``` 값 또한 가짐 (부모와 자식이 동일한 값)

<img src="https://i.stack.imgur.com/6RGIe.jpg" width="30%" style="margin-left: 2%">

- 프로세스 트리 (```Process Tree```) : 부모 프로세스인 A에서 자식 프로세스인 B, C, D가 파생되어 생성
  - 부모 프로세스 : 프로세스를 생성한 프로세스
  - 자식 프로세스 : 프로세스로부터 생성된 프로세스
  - 형제 프로세스 : 같은 부모 프로세스에서 파생된 자식 프로세스

### 프로세스 컨트롤 블록 (```Process Control Block```) : 프로세스에 대한 모든 정보를 저장하는 곳
- CPU는 여러 프로세스를 빈번히 전환하면서 수행하기에 각 프로세스의 데이터를 저장해야 작업을 이어서 수행할 수 있음
- 운영체제 내에서 프로세스를 관리하는 코드 부분에 저장
  - 프로세스 컨트롤 블록에 데이터를 저장 및 복원하는 시간 역시 다중 작업을 위해 프로세스에 할당되는 시간에 포함
- 프로세스 상태, 프로그램 카운터, 스택 포인터, 파일 디스크립터 등의 정보 포함

<img src="https://user-images.githubusercontent.com/34755287/70577652-12841080-1bef-11ea-8f1c-5c0e0d94c132.png" width="80%" style="margin-left: 2%">

#### 프로세스 상태 (```Process Status```) : 각 단계들에서 상태 전이가 일어나 다음 단계로 넘어감
- ```New``` : 프로그램이 메인 메모리에 할당된 상태
- ```Ready``` : 프로세스가 언제든 실행 가능한 상태; 할당된 프로그램이 실행되기 위한 모든 준비를 마친 상태로 대기된 상태
  - n개의 작업이 있을 때, CPU의 프로세서는 스케줄러의 0~(n-1)번, 즉 n개의 작업을 번갈아 처리
- ```Running``` : CPU가 해당 프로세스를 실제로 실행중인 상태
- ```Waiting```=```Blocked``` : ```Running```이 불가능한 상태
  - 프로세스가 끝나지 않은 시점에 해당되는 I/O 정보가 없어 작업할 수 없음
  - ```Waiting```가 끝나면 다시 CPU에 실행되기 위해 ```Ready```로 돌아가야 함
- ```Terminated``` : 프로세스가 완전히 종료된 상태

<img src="https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png"  width="80%" style="margin-left: 2%">

> - I/O 작업으로 인한 상태 변화 : ```Running``` -> ```Waiting``` -> ```Ready``` -> ```Running```
> - 시간 초과로 인터럽트에 의한 상태 변화 : ```Running``` -> ```Ready``` -> ```Running```

### 프로세스 큐 (```Process Queue```) : 커널이 프로세스 스케줄링을 위해 데이터 영역에서 관리하는 큐
- ```Ready Queue``` : 프로세스 상태가 ```Ready```인 프로세스들이 CPU 제어를 기다리는 큐
  - 어떤 CPU 스케줄링 알고리즘을 선택하는지에 따라 CPU 제어 순서가 달라짐
- ```Job Queue``` : 보조 기억 장치의 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐
  - 시스템 내의 모든 프로세스 관리 : ```Ready Queue```, ```Device Queue```에 속한 모든 프로세스 포함
- ```Device Queue``` : 프로세스 상태가 ```Waiting```인 프로세스들이 CPU 외의 자원을 기다리는 큐
  - 기다리는 자원들마다 큐가 할당되며, 해당 자원이 사용되면 인터럽트를 발생시키고 ```Ready Queue```로 이동

<img src="https://user-images.githubusercontent.com/34755287/53879660-5ccdd500-4052-11e9-972d-11ba3faeb3e3.png" width="80%" style="margin-left: 2%">

- 각 큐는 프로세스의 프로세스 컨트롤 블록을 가리키는 포인터 방식으로 연결 리스트를 구현

#### 스케줄러 (```CPU Scheduler```) : 프로세스 순서를 정해 프로세스 큐에 올릴 것을 결정하는 커널의 코드
- 장기 스케줄러 (```Long-term Scheduler```) : 생성된 프로세스 중 ```Job Queue```에서 ```Ready Queue```에 이동시킬 것 선택
  - 장기 스케줄러는 현재 메모리에 할당된 프로세스의 개수 (```Degree of multiprogramming```)를 제어
  - 장기 스케줄러는 ```I/O bound Process```,```CPU bound Process```를 메인 메모리에 적절히 할당해야 함
    - ```I/O bound Process``` : I/O 작업 (입출력) 비중이 높은 프로세스
    - ```CPU bound Process``` : CPU 작업 (계산) 비중이 높은 프로세스
- 중기 스케줄러 (```Medium-term Scheduler```) : 실행 중인 프로세스 중 보조 저장 장치로 옮길 것을 주기적으로 검사
  - ```Swapping``` (```Swap-out```↔```Swap-in```) : ```Swap-in```할 때 이전 공간으로 재할당되는 것은 보장되지 않음
    - ```Swap-out``` : 메인 메모리에서 우선 순위가 은 프로세스를 통째로 보조 기억 장치로 저장
    - ```Swap-in``` : 나중에 해당 프로세스가 다시 사용되려 할 때 보조 기억 장치에서 메인 메모리에 다시 할당
  - 중기 스케줄러 또한 현재 메모리에 할당된 프로세스의 개수 (```Degree of multiprogramming```)를 제어
- 단기 스케줄러 (```Short-term Scheduler```) : ```Ready Queue``` 내에서 프로세스들 중 어떤 것을 다음에 실행시킬지 선택
  - CPU 스케줄러 (```CPU Scheduler```) 라고도 부르며, 시분할 시스템에서 ```Time Out```이 발생하면 호출

##### 문맥 전환 (```Context Switching```) : CPU가 실행중인 프로세스를 멈추고 다른 프로세스를 실행하는 작업
- 문맥 (```Context```) : 각 프로세스 컨트롤 블록 내에서 표현
  - 하드웨어 문맥 : 프로그램 카운터 정보와 레지스터 정보를 저장
  - 프로세스 주소 공간 : 각 프로세스가 갖고 있는 독자적인 주소 공간에 위치
- CPU 스케줄러 : CPU가 어느 프로세스를 다음에 실행할지 지정
- 디스패쳐 (```Dispatcher```) : 문맥 전환이 발생하면 ```Ready```에서 ```Running```으로 상태 전이
  - 문맥 전환 오버헤드 (```Context Switching Overhead```) : 문맥 전환이 발생할 때마다 디스패쳐를 매번 실행시킴<br><br>

1. CPU에서 실행중인 프로세스의 데이터는 해당 프로세스의 프로세스 컨트롤 블록에 갱신
2. 새로 시작될 프로세스의 프로세스 컨트롤 블록를 CPU로 복원
3. 캐시와 ```Translation Lookup Buffer```를 재설정
  
> - 시스템 호출로 인한 인터럽트 발생 시 :
>   - 실행 중인 프로세스의 문맥을 프로세스 컨트롤 블록에 갱신하나, 문맥 전환은 이루어지지 않음