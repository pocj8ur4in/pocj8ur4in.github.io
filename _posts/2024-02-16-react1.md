---
title: "[React] 1. 리액트 (React)"

tags:
    - React

toc: true
toc_sticky: true

date: 2024-02-16
last_modified_at: 2024-02-16
---

## 리액트 (```React```) : 사용자 인터페이스를 만들기 위한 ```JavaScript``` 라이브러리

- 가상 ```DOM``` : 실제 ```DOM```가 상호 작용하면서 웹 어플리케이션의 빠른 렌더링이 가능
- 선언형 뷰 (```Declarative View```) : 사용자 인터페이스를 어떻게 보일지 명시적으로 선언하고, 개발자가 그 명세를 작성
- 컴포넌트 기반 구조 : 부모-자식 관계 및 상태 (```State```)를 갖는 재사용 가능한 모듈들로 어플리케이션 구성
- 단방향 데이터 바인딩 : 데이터의 흐름이 단일 방향으로 진행하여 디버깅 용이 → 명시적인 상태 변경이 가능
- ```JSX``` : 자바스크립트 코드 내에 마크업을 작성해 가독성 향상 및 명확한 표현 가능

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/ca8780dc-5a83-45cb-972d-e66b4fea19e4" width="90%">

> 리액트에서 자주 쓰이는 ```JS``` 문법?
>
> - 구조 분해 할당 (```Destructuring Assignment```) : 배열 또는 객체의 값을 분해해서 할당하는 것
>
> ```
> // 객체 구조 분해 할당
> const person = { name: 'John', age: 30 };
> const { name, age } = person;
> 
> console.log(name); // 'John'
> console.log(age);  // 30
> ```
> ```
> // 배열 구조 분해 할당
> const numbers = [1, 2, 3, 4, 5];
> const [first, second, ...rest] = numbers;
>
> console.log(first); // 1
> console.log(second); // 2
> console.log(rest); // [3, 4, 5]
> ```
>
> - 전개 구문 (```Spread Syntax```) : 배열이나 객체를 확장하여 개별 요소로 분리하거나 복사
>
> ```
> // 배열의 전개 구문을 사용하여 두 배열을 병합
> const arr1 = [1, 2, 3];
> const arr2 = [4, 5, 6];
>
> const mergedArray = [...arr1, ...arr2];
> console.log(mergedArray); // [1, 2, 3, 4, 5, 6]
> ```
> ```
> // 객체의 전개 구문을 사용하여 두 객체를 병합
> const obj1 = { x: 1, y: 2 };
> const obj2 = { z: 3, w: 4 };
> 
> const mergedObject = { ...obj1, ...obj2 };
> console.log(mergedObject); // { x: 1, y: 2, z: 3, w: 4 }
> ```
>
> - 객체 초기자 (```Object Shorthand Assignment```) : 객체를 간결히 생성하고 초기값을 설정
>
> ```
> // 일반적인 객체 생성 방법
> const person1 = new Object();
> person1.name = 'Alice';
> person1.age = 25;
> 
> // 객체 초기자를 사용한 방법
> const person2 = {
>   name: 'Alice',
>   age: 25
> };
> 
> console.log(person1); // { name: 'Alice', age: 25 }
> console.log(person2); // { name: 'Alice', age: 25 }
> 
> ```
>
> - ```Array``` 프로토타입 메소드 : ```map```, ```filter```, ```reduce```, ```forEach```
>
> ```
> const numbers = [1, 2, 3, 4];
>
> // map 메소드: 각 숫자를 두 배로 만듭니다.
> const doubledNumbers = numbers.map((num) => num * 2);
> 
> // filter 메소드: 짝수만을 걸러냅니다.
> const evenNumbers = numbers.filter((num) => num % 2 === 0);
>
> // reduce 메소드: 모든 숫자의 합을 계산합니다.
> const sum = numbers.reduce((acc, num) => acc + num, 0);
> 
> // forEach 메소드: 각 숫자를 콘솔에 출력합니다.
> numbers.forEach((num) => console.log(num));
> 
> console.log('Doubled Numbers:', doubledNumbers);
> console.log('Even Numbers:', evenNumbers);
> console.log('Sum:', sum);
> ```

### ```JSX``` (```JavaScript XML```) : 기존 ```JS```에 ```HTML```, ```CSS```를 더해 리액트 컴포넌트 작성

- ```JSXElement``` : ```JSX``` 엘리먼트<br>(```<div>Hello, World!</div>```에서 ```<div>```)
- ```JSXAttribute``` : ```JSX``` 엘리먼트의 속성<br>(```<div className="container">Hello, World!</div>```에서 ```className="container"```)
- ```JSXChildren``` : ```JSX``` 엘리먼트의 자식 요소<br>(```<div>Hello, <span>React</span>!</div>```에서 ```Hello, <span>React</span>!```)
- ```JSXString``` : ```JSX``` 문자열<br>(```<div>Hello, World!</div>```에서 ```"Hello, World!"```)

### 가상 ```DOM``` (```Virtual DOM```) : 실제 ```DOM``` (```Document Object Model```) 에 대한 가벼운 복사본

- 리액트 파이버 (```React Fiber```) : 가상 ```DOM```과 실제 ```DOM```을 비교해 변경 사항을 수집
  - 동기성 : 렌더링 작업을 여러 프레임에 나눠 렌더링 작업이 한 번에 실행되지 않더라도 앱이 반응적으로 유지 가능
  - 우선순위 관리 : 각 작업에 우선순위를 할당하고, 중요한 작업을 먼저 처리하여 사용자 인터랙션에 빠르게 응답 가능 
  - 종료 및 재시작 가능 : 사용자 인터랙션에 우선순위를 두면서도 작업을 중단하고 다시 시작 가능

> ```DOM```과 ```CSSOM```으로 렌더링 트리가 만들어지는 과정?
>
> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/95ef558e-965b-4525-873f-140e4292b29e" width="90%">
>
> 1. 브라우저가 사용자가 요청한 주소를 방문해 ```HTML``` 파일을 다운로드
> 2. 브라우저의 렌더링 엔진은 ```HTML```을 파싱해 ```DOM``` 노드로 구성된 트리를 생성
> 3. ```CSS``` 파일을 만나면, 해당 ```CSS``` 파일도 다운로드
> 4. ```CSS``` 파일을 파싱하여 ```CSS``` 노드로 구성된 트리 (```CSSOM```)를 생성
> 5. 사용자의 눈에 보일 ```DOM``` 노드만을 순회
> 6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 ```CSSOM``` 정보를 찾고 ```CSS``` 스타일 정보를 적용
>   - 레이아웃 (```Layout```) : 각 노드가 브라우저 화면에 어느 좌표에 나타날지 계산하는 과정
>   - 페인팅 (```Painting```) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
>
> ... 모든 ```DOM```의 변경보다 결과적으로 만들어질 ```DOM```의 최종 결과물만을 제공하자!

1. 초기 렌더링 : 초기 상태에서 가상 ```DOM```은 실제 ```DOM```과 동일한 구조를 가짐
2. 상태 변화 감지 : 사용자 상호 작용이나 데이터 변경 등의 이벤트가 발생하면, 렌더링 엔진은 새로운 가상 ```DOM``` 생성
3. 가상 ```DOM``` 비교 : 새로운 가상 ```DOM```과 이전의 가상 ```DOM```을 비교하여 변경된 부분 탐색
4. 실제 ```DOM``` 업데이트 : 변경된 부분만을 실제 ```DOM```에 적용 

## 컴포넌트 (```Component```) : 리액트 애플리케이션에서 ```UI```를 구성하고 재사용 가능한 모듈을 표현

- 속성 (```Props```) 을 받고, 상태 (```state```)와 메소드 (```Method```)를 가짐
- 반복되는 ```UI``` 단위 (```JS Code``` 또는 ```HTML-JSX```) → 재사용성과 가독성을 위한 도구
- 가능한 독립적으로 실행되도록 작성하고, 데이터 영역과 ```UI```를 분리

### 상태 (```State```) :  사용자 상호작용에 응답하거나 컴포넌트의 생명주기에 변경되는 정보를 저장하는 데에 사용

- 부모의 상태가 변경되면, 그 상태를 참조하는 모든 자식 컴포넌트가 ```Re-Rendering```
  - 상태를 통합하면 ```Re-Rendering```이 많이 일어나므로, 상태를 연관성에 맞게 분리해 좁게 사용해야 함
  - ```Setter```로 값을 수신하면 ```Dispatcher``` 값이 세팅 → ```re-rendering```을 ```trigger``` (```DOM``` 갱신)

```
import React, { useState } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState('안녕하세요!');

  return (
    <div>
      <p>{message}</p>
      <p>카운트: {count}</p>
    </div>
  );
}
```

> 초기화는 동기 방식이면 오래 걸리더라도 가능, ```Promise```는 ```async```/```await```로 처리해도 ```Promise```가 세팅

### 속성 (```Prop```) : 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달하는 데에 사용

- 변수나 함수와 같은 속성들을 부모에서 자식으로 전달 (```MyComponent.defaultProps = { ... }```)
  - ```Read-Only``` : 속성이 변경되도 ```Re-Rendering```하지 않음! (값은 바꿔도 화면엔 아무런 영향 없음!)

```
// 부모 컴포넌트
import React from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const dataToPass = "안녕하세요!";
  
  return (
    <ChildComponent message={dataToPass} />
  );
}

// 자식 컴포넌트
import React from 'react';

function ChildComponent(props) {
  return (
    <div>
      <p>{props.message}</p>
    </div>
  );
}
```

### 렌더링 (```Rendering```) : ```HTML```, ```CSS``` 리소스로 웹 페이지의 ```UI```를 그리는 과정

- 리액트에서의 렌더링 : 리액트 어플리케이션 트리 내에서의 모든 컴포넌트들이 갖고 있는 현재 상태와 속성의 값을 기반하여 어떻게```UI```를 구성하고 어떤 ```DOM``` 결과를 브라우저에 제공할지 계산하는 일련의 과정
  - 최초 렌더링 : 사용자가 처음 어플리케이션이 진입할 때 최초로 수행
  - 리렌더링 : 처음 어플리케이션 이후에 발생하는 모든 렌더링들을 총칭
    - 클래스 컴포넌트의 ```setState()```나 ```forceUpdate()```가 실행되는 경우
    - 함수 컴포넌트의 ```useState()```의 두번째 배열 요소인 ```setter```가 실행되는 경우
    - 함수 컴포넌트의 ```useReducer()```의 두번째 배열 요소인 ```dispatch```가 실행되는 경우
    - 컴포넌트의 ```key props```가 변경되는 경우
    - 부모 컴포넌트로부터 전달받는 값인 ```props```가 변경되거나 부모 컴포넌트가 리렌더링될 경우

- 렌더링 프로세스 : 각 컴포넌트의 렌더링 결과물을 수집하면서, 가상 ```DOM```과 실제 ```DOM```을 비교하면서 실제 ```DOM```에 반영하기 위한 모든 변경 사항을 차례대로 수집 → 리액트의 재조정
  1. 리액트가 컴포넌트의 루트에서부터 업데이트가 필요한 모든 컴포넌트를 탐색
  2. 클래스 컴포넌트는 클래스 내 ```render()``` 함수를, 함수 컴포넌트는 ```FunctionComponent()``` 자체를 호출
  3. ```JSX```로 구성된 렌더링 결과물을 자바스크립트로 컴파일하면 ```React.createElement()```를 반환
  4. ```React.createElement()```가 브라우저 ```UI``` 구조를 설명하는 자바스크립트 객체를 반환

### 컴포넌트 개발 원칙 : 코드의 가독성, 유지보수성, 재사용성을 향상하여 구성 요소를 생성

- <b>가급적 순수 함수 컴포넌트 (<code>Pure Functional Component</code>)를 활용할 것!</b>
  - 상태나 생명주기 메서드 없이 단순히 ```props```를 받아 렌더링하는 컴포넌트 → 간결하고 재사용성이 높힐 수 있음
- ```Container Component```와 ```Presentational Component```를 분리할 것
  - 데이터를 가져오는 로직과 ```UI```를 그리는 로직을 분리하여 관리
- 상태를 공유하는 단위로 분리할 것
  - 관련된 상태를 함께 관리하고, 필요한 경우 ```useContext```를 사용하여 상태 공유를 구현
- 아주 깊은 구조로 중첩되는 ```Container``` 컴포넌트는 피할 것
  - ```Context```를 남발하는 대신, 상태 관리 등의 용도로 필요한 경우에만 적절히 사용할 것
- 각 컴포넌트는 독립적으로 작성할 것
  - 컴포넌트 간의 결합도를 최소화해 재사용성을 높이고 유지보수를 용이하게 만들어야 함

## 클래스 컴포넌트 (```Class Component```) : 생성자와 생명주기 메소드를 통해 상태와 생명주기 관리

```
import React, { Component } from 'react';

class MyClassComponent extends Component {
  constructor(props) {
    super(props);
    // 초기 상태 설정
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    // 컴포넌트가 마운트된 후 실행되는 코드
    console.log('Component mounted');
  }

  componentDidUpdate(prevProps, prevState) {
    // 상태 또는 속성이 업데이트된 후 실행되는 코드
    console.log('Component updated', prevState.count, '->', this.state.count);
  }

  componentWillUnmount() {
    // 컴포넌트가 언마운트되기 전 실행되는 코드
    console.log('Component will unmount');
  }

  handleIncrement = () => {
    // 상태 업데이트 예시
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleIncrement}>Increment</button>
      </div>
    );
  }
}

export default MyClassComponent;
```

### 생성자 (```Constructor```) : 메소드 내에서 컴포넌트 자체를 참조 → ```this```

- ```this.state``` : 컴포넌트의 상태를 저장 (```setState``` 메소드를 사용하여 업데이트)
- ```this.props``` : 컴포넌트에서 사용되는 속성에 접근

### 생명주기 메소드 (```Lifecycle Methods```) : 클래스 컴포넌트의 생명주기에 따라 메소드를 실행

> 클래스 컴포넌트의 생명주기 메소드가 실행되는 시점?
>
> - 마운트 (```Mount```) : 컴포넌트가 생성되는 시점
> - 업데이트 (```Update```) : 이미 생성된 컴포넌트의 내용이 변경되는 시점
> - 언마운트 (```Unmount```) : 컴포넌트가 더 이상 존재하지 않는 시점
>
> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/aec795ea-ff51-4f9d-ada3-ebca3616178f" width="80%">

- ```render()``` : 컴포넌트가 ```UI```를 렌더링하기 위해 사용 (마운트, 업데이트 과정에서 실행)
  - 리액트 클래스 컴포넌트의 유일한 필수 값으로 사용
  - 항상 순수해야 하며 부수 효과가 없어야 함 → ```render()``` 내에서 ```this.setState```를 호출하면 안됨
- ```componentDidMount()``` : 클래스 컴포넌트가 마운트된 이후에 실행
- ```componentDidUpdate()``` : 컴포넌트 업데이트가 일어난 이후에 실행
- ```componentWillUnmount()``` : 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 실행
  - ```clean-up``` 함수를 호출하기 위한 최적의 위치

> 클래스 컴포넌트의 한계?
>
> - 데이터의 흐름을 추적하기 어려움 : 서로 다른 여러 메소드에서, 작성 순서에 상관없이 상태의 업데이트가 발생 가능
> - 어플리케이션 내부 로직의 재사용이 어려움 : 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트나 속성이 많아지는 래퍼 지옥 (```wrapper hell```)이 발생
> - 기능이 많아질수록 컴포넌트의 크기가 커짐 : 내부에서 처리하는 데이터 흐름이 복잡해짐

## 함수 컴포넌트 (```Functional Component```) : 리액트 훅을 통해 상태와 생명주기 관리

```
import React, { useState, useEffect } from 'react';

const MyFunctionalComponent = () => {
  // useState 훅을 사용하여 상태 정의
  const [count, setCount] = useState(0);

  // useEffect 훅을 사용하여 부수 효과(라이프사이클 작업 등) 처리
  useEffect(() => {
    console.log('Component mounted or count updated:', count);
    // componentWillUnmount 역할을 하는 함수 (클린업 함수)
    return () => {
      console.log('Component will unmount');
    };
  }, [count]); // count가 업데이트될 때만 실행

  const handleIncrement = () => {
    // setCount를 사용하여 상태 업데이트
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
};

export default MyFunctionalComponent;
```

- ```useState```, ```useEffect```, ```useContext```와 같은 리액트 훅을 사용하여 상태를 관리
- ```useEffect``` 훅을 통해 라이프사이클 메소드와 유사한 동작을 수행 가능
- ```this``` 키워드를 사용하지 않고, 클래스 컴포넌트보다 간결하고 명료하게 작성 가능

### 리액트 훅 (```React Hook```) : 함수형 컴포넌트에서 상태와 생명주기 메서드를 사용할 때 사용

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c4f6fd02-e4fd-4f86-bd52-e4eed847cc3c" width="50%">

- 상태 관리 훅 : ```useState```, ```userContext```, ```useReducer```
- 시점 훅 : ```useLayoutEffect```, ```useEffect```
- 메모화 훅 : ```useMemo```, ```useCallback```, ```memo```

> 리액트 훅의 3원칙?
> 
> 1. 컴포넌트의 영역 안에서만 작동한다!
>   - 컴포넌트 혹은 커스텀 훅 내부에서만 호출해야 함
> 2. 기능을 여러 훅으로 나누면 좋다!
>   - 여러 훅으로 나누어져 있어도 컴포넌트에서 한번에 순차 호출
>   - 함수형 컴포넌트 ⇒ 함수 ⇒ 기능 단위 분리 ⇒ 가독성 ⇒ 테스트 및 유지보수에 유리
> 3. 컴포넌트의 최상위 레이어(스코프)에서만 호출해야 한다!
>   - 블록 내부에서는 호출할 수 없음

#### ```useState``` : 함수형 컴포넌트에서 상태를 추가하고 업데이트할 때 사용

- 클래스 컴포넌트에서의 ```this.state```와 ```this.setState```와 유사한 역할
- 첫번째 값에 현재 상태의 값, 두번째 값에 상태를 업데이트하는 함수가 담긴 배열을 반환

```
import React, { useState } from 'react';

function ExampleComponent() {
  // useState를 사용하여 count라는 상태를 정의하고 초기값을 0으로 설정
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

#### ```useRef``` : 함수형 컴포넌트 내에서 참조를 생성하고 관리할 때 사용

- 컴포넌트의 렌더링과 관계없이 변수를 저장 가능 → ```useState```와 달리 매번 ```Re-Rendering```이 일어나지 않음
- 주로 ```DOM``` 요소에 접근하거나 컴포넌트의 생명주기와 독립적으로 값을 유지하는 상황에서 활용

```
import React, { useRef, useEffect } from 'react';

function MyComponent() {
  const myInputRef = useRef(null);

  useEffect(() => {
    // 컴포넌트가 마운트된 후, input 요소에 포커스를 줌
    myInputRef.current.focus();
  }, []);

  return <input ref={myInputRef} />;
}
```
```
import { useRef, useState, useEffect } from 'react';

function MyComponent() {
  const countRef = useRef(0);
  const [count, setCount] = useState(0);

  useEffect(() => {
    // countRef는 렌더링과 무관하게 유지되는 변수
    countRef.current = count;
  }, [count]);

  const handleClick = () => {
    setCount(count + 1);
    console.log(countRef.current); // 항상 가장 최근 값 출력
  };

  return <button onClick={handleClick}>증가</button>;
}
```

#### ```forwardRef``` : 부모 컴포넌트에서 자식 컴포넌트로 ```ref```를 전달할 수 있게 함

- ```useRef```로 컴포넌트 외부 (자식)의 ```DOM```에 접근
  - 부모에서 선언 → 자식에게 전달 → 자식에서 참조 걸기 → 부모에서 컨트롤

```
import React, { useRef, forwardRef } from 'react';

// 자식 컴포넌트
const ChildComponent = forwardRef((props, ref) => {
  const internalState = useRef(null);

  // 부모 컴포넌트에서 전달한 ref에 직접 접근
  // ref.current를 통해 부모 컴포넌트의 ref를 참조할 수 있음
  const handleButtonClick = () => {
    console.log('자식 컴포넌트에서 버튼 클릭');
    console.log('내부 상태:', internalState.current);
  };

  return (
    // 여기에 컴포넌트 JSX를 작성
    <div>
      <button onClick={handleButtonClick}>자식 컴포넌트에서 클릭</button>
    </div>
  );
});

// 부모 컴포넌트
const ParentComponent = () => {
  // ref를 생성하여 자식 컴포넌트에 전달
  const childRef = useRef();

  // 부모 컴포넌트에서 ref를 자식 컴포넌트에 전달
  return (
    <div>
      {/* forwardRef를 사용하여 자식 컴포넌트에 ref 전달 */}
      <ChildComponent ref={childRef} />
    </div>
  );
};

export default ParentComponent;
```

> ```But```, 외부 ```DOM```을 참조하는 ```ref```를 갖는 것은 ```Coupling```이 강해지므로 좋지 않다!

#### ```useImperativeHandle (with forwardRef)``` : 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있게 함

- ```useImperativeHandle```을 통해 부모 컴포넌트에 함수 및 기능을 노출시킴
  - 부모에게 참조값을 전달 → 자식은 객체를 반환

```
import React, { forwardRef, useRef, useImperativeHandle } from 'react';

const ChildComponent = forwardRef((props, ref) => {
  // useImperativeHandle을 사용하여 부모 컴포넌트에 특정 함수나 값들을 노출
  useImperativeHandle(ref, () => ({
    // 부모 컴포넌트에서 입력 엘리먼트에 포커스를 맞추기 위해 함수를 노출
    focusInput: () => {
      inputRef.current.focus();
    }
  }));

  const inputRef = useRef(null);

  return <input ref={inputRef} />;
});

const ParentComponent = () => {
  const childRef = useRef(null);

  const handleClick = () => {
    // 자식 컴포넌트에서 노출한 함수를 호출하여 입력 엘리먼트에 포커스를 맞춤
    childRef.current.focusInput();
  };

  return (
    <div>
      <ChildComponent ref={childRef} />
      <button onClick={handleClick}>입력에 포커스 맞추기</button>
    </div>
  );
};

export default ParentComponent;
```

#### ```useContext``` : ```React Context```를 통해 전역으로 상태를 공유하거나 전달할 때 사용

- 리액트 컨텍스트 (```React Context```) : 컴포넌트 트리 안에서 전역적으로 데이터를 공유
  - 중첩 컴포넌트 간에 데이터를 명시적으로 전달하지 않아도 되므로, ```Props```를 여러 단계에 걸쳐 전달하지 않아도 됨

```
// 1. Context 객체 생성
const MyContext = React.createContext(defaultValue);

// 2. Context를 제공하는 컴포넌트 작성
const MyContextProvider = ({ children }) => {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    <MyContext.Provider value={contextValue}>
      {children}
    </MyContext.Provider>
  );
};

// 3. useContext를 사용하여 값에 접근
import { useContext } from 'react';

const MyComponent = () => {
  const contextValue = useContext(MyContext);

  // contextValue를 사용하여 렌더링 또는 다른 로직 수행
};
```

- ```Context.Provider``` : 컨텍스트 값을 하위 컴포넌트에 제공
  - ```value``` 속성을 통해 전달할 값을 설정

```
const MyContextProvider = ({ children }) => {
  const contextValue = // ... (상태 값이나 함수 등)

  return (
    <MyContext.Provider value={contextValue}>
      {children}
    </MyContext.Provider>
  );
};
```

#### ```useEffect``` : ```rendering``` 이후, ```mount``` 이후에 실행

- ```componentDidMount``` 시점에 비동기로 실행 (```ex.``` ```alert```, ```focus```, ```sound``` 등 ```After DOM``` 처리)
  - 함수형 컴포넌트에서 ```return JSX (render)``` 다음에 실행 (```ex.``` ```focus``` 주기, 미디어 재생, 지도에 추가 등)
- ```clean-up``` 코드는 ```componentWillUnMount``` 시점에 실행 (```useEffect's return function```)
- 의존 관계 배열 (```Dependency Array```) 가 비워져 있다면 1회만 실행 (```re-render```시 ```skip except StrictMode```)
- ```useEffect(() => { 수행 코드…; return () => 정리 코드; }, [의존 관계 배열: observer에 등록]);```

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0db5c916-f0a3-46ba-b33e-3999daa244bf" width="60%">


#### ```useLayoutEffect``` : ```rendering``` 이후, ```mount``` 이전에 실행

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/db687861-6983-4eac-8615-a144ef0efb3c" width="90%">
