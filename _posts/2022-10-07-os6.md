---
title: "[Operation System] 6. Main Memory Management"

tags:
    - Operation System

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2022-12-12
---

## 메인 메모리 관리 (```Main Memory Management```)

- 메모리 공간은 기본적으로 주소 (```address```)와 데이터 (```data```)로 구성되어 있음
  - ```CPU```는 주소를 가지고 메인 메모리에 요청을 하거나 해당 주소에 계산 결과를 저장
  - 메인 메모리는 ```CPU```가 요구하는 주소에 저장되어 있는 데이터를 ```CPU```에게 전달

<img src="https://user-images.githubusercontent.com/34755287/54821877-d74f5380-4ce6-11e9-8888-e63816796f65.png"  width="80%" style="margin-left: 2%">

- 프로그램의 빌드는 소스 파일, 목적 파일, 실행 파일 순서로 생성
  - 소스 파일 (```Source file```) : 고수준 언어 또는 어셈블리어
    - 컴파일 단계 : 소스 파일은 컴파일러 또는 어셈블러에 의해 컴파일 또는 어셈블하여 목적 파일 생성
  - 목적 파일 (```Object file```) : 컴파일된 결과 또는 어셈블된 결과
    - 링크 단계 : 목적 파일은 링커 (```Linker```)에 의해 라이브러리를 찾아 정보를 추가해 실행 파일 생성
  - 실행 파일 (```Executable file```) : 링크된 결과
    - 로드 단계 : 실행 파일은 로더 (```Loader```)에 의해 메인 메모리에 할당

<img src="https://user-images.githubusercontent.com/34755287/54821878-d74f5380-4ce6-11e9-98e8-a43b086a4837.png"  width="80%" style="margin-left: 2%">

- 빌드된 프로그램은 ```code```, ```data```, ```stack``` 영역으로 구분됨
  - 단순히 생성된 프로그램은 ```code```, ```data``` 영역만 존재
  - 로드 단계에서 프로그램이 실행을 위해 메모리에 적재되었을 때, 운영체제에 의해 ```stack``` 영역이 추가됨

### 메모리 계층 (```Memory hierarchy```) : 각각의 특징이 있는 저장 장치를 혼용해 효율성 극대화
- 메모리 매니저 (```Memory Manager```) : 메모리 하이라키를 관리하는 관리 시스템의 일부분


<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9986554C5C76482528" width="80%" style="margin-left: 2%">

- 캐시 (```Cash```) : 빠르고, 비싸고, 휘발성
- 메인 메모리 (```Main Memory```) : 캐시보다 느리고, 캐시보다 싸고, 휘발성
- 디스크 스토리지 (```Disk Storage```) : 메인 메모리보다 느리고, 메인 메모리보다 싸고, 비휘발성

> 메모리 계층 구조를 통해 프로그래머가 사용하기 좋은 모델로 <b>추상화</b>하고, 운영체제를 통해 추상회된 객체를 관리한다.

### Q. ```CPU```가 한 번에 한 프로세스를 수행하면? : ```Mono-Programming```

- 메인 프레임 (```mainframe```) : ```RAM``` 위의 ```OS```에 유저 프로그램이 주소로 연결되어 존재
- 임베디드 시스템 (```Embedded System```) : ```OS```가 위치한 ```ROM``` 아래에 유저 프로그램이 주소로 연결되어 존재
- 퍼스널 컴퓨터 (```personal computer```) : 메인 프레임 + ```ROM``` 위 장치 관리자가 유저 프로그램 위에서 ```OS```의 관리를 받음

> 하단 내용은, ```CPU```가 여러 프로세스를 돌아가면서 수행하는 ```Multi-Programming``` 환경이라 가정한다.

### Q. 만약 메모리 추상화를 사용하지 않는다면? : 모든 프로그램이 물리 메모리를 직접 사용
- 프로그래머에게 제공되는 메모리 영역 : 실제 물리 메모리 (0 ~ (실제 물리 메모리의 크기))
  - 각 주소는 ```n```비트로 구성된 셀 (```Cell```)로 정의
- 하드웨어의 도움 없이 두 프로그램이 동시에 메모리에서 실행된다는 것은 불가능
  - 메모리의 프로세스를 이미지 형태로 디스크에 저장하고, 프로그램을 메모리로 스와핑 (```Swapping```)할 순 있음

> ! 메모리 추상화를 사용하지 않는다고 했으니, 메모리 계층 구조 또한 존재하지 않는거네?
> - <b>아니다.</b> 메모리를 추상화하는 방법 중 하나로, <b>메모리 추상화를 사용하지 않는 것</b>이다.
>   - { a, b, c, d, ... } 를 추상화하는 방법 (1) := alphabetic
>   - { a, b, c, d, ... } 를 추상화하는 방법 (2) := { a, b, c, d, ... }
> 
> ... 운영체제는 메모리 계층 구조를 이루는 캐시, 메인 메모리, 디스크 스토리지를 물리 주소를 통해 직접 접근한다.
> - 그런데, 물리 주소를 직접 접근하는 방법에는 ```Protection & Relocation``` 이슈가 존재한다.

#### P1. 프로텍션 (```Protection```) : 한 프로세스가 운영체제나 다른 프로세스의 파티션을 침범하지 못하게 해야 함
- ```IBM360```모델 : 프로텍션 코드 (```Protection code```)
  - 프로세스의 ```PSW```에는 ```4bit``` 키가 포함 / 메모리를 ```2KB``` 블럭 단위로 나누고, 각 블록에 ```4bit``` 프로텍션 코드 할당
  - 수행되는 프로세스는 자신의 ```PSW``` 키와 액세스하는 블럭의 프로텍션 코드를 비교해, 일치하지 않으면 트랩 발생

#### P2. 리로케이트 (```Relocation```) : 변수 주소나 프로시저 주소에 대한 접근에 차이가 발생
- 컴파일된 ```.exe``` 파일을 파티션에 로드해 실행할 때, 바이너리 파일이 아닌, 파티션을 기준으로 접근해야 함
  - 컴파일된 ```.exe``` 파일을 파티션 A와 B에 각각 로드해 실행할 때, 각 파티션을 기준으로 접근해야 함

> 컴파일된 ```.exe``` 파일의 첫번째 명령어가 100번지에 있는 프로시저 콜이라고 가정하면...
> - 해당 파일을 파티션에 로드해 실행했을 때 : <del>0 + 100번지로 접근</del> (파티션의 시작 주소) + 100번지로 접근

- ```IBM360```모델 : 정적 재배치 (```Static Relocation```)
  - 프로그램이 메모리에 로드될 때, 파티션을 기준으로 접근하도록 명령어 수정
    - 링커가 프로그램의 어떤 부분이 리로케이트되어야 하는지 알아야 함

### 주소 바인딩 (```Address Binding```) : 프로세스의 논리적 주소를 물리적 메모리 주소로 연결
- 주소 공간 (```address space```) : 프로세스가 메모리에 접근할 때 사용하는 주소들의 집합
  - 각 프로세스들은 자신들만의 주소 공간을 가짐 -> ```logical address```
- 프로그램이 어떤 주소를 사용해도, 메인 메모리에 할당된 주소를 찾아가도록 해야 함
  - 논리 주소 (```logical address```) : CPU에서 사용하는 주소. 메모리 내 프로세스의 독립적인 공간
  - 물리 주소 (```physical address```) : 메인 메모리에서 사용하는 주소. 하드웨어에 의해 정해진 주소 공간

> ... 그러므로 프로그램이 할당된 실제 메모리 주소 공간의 위치는 프로그램을 실행하는 ```CPU```에 전혀 영향을 미치지 않음
> - 그럼 어떻게 각각의 프로세스들에게 서로 다른 주소 공간을 제공할 수 있을까?

#### ```MMU```의 재배치 레지스터 (```Relocation Register```) : 프로세스의 논리 공간을 메모리의 물리 공간으로 연속해 매핑
- 동적 재배치 (```Dynamic relocation```) : 프로세스의 논리 주소를 메모리의 물리 주소으로 변경
  - 베이스 레지스터 (```Base Register```) : (파티션의 시작 주소)
  - 리미트 레지스터 (```Limit Register```) : (파티션의 크기)

<img src="https://user-images.githubusercontent.com/34755287/54821880-d7e7ea00-4ce6-11e9-944e-3be89338213f.png" width="80%" style="margin-left: 2%">

1. 현재 프로그램이 파티션에 로드되었을 때, 프로그램이 로드된 파티션의 크기를 리미트 레지스터의 값에 저장
2. ```CPU```는 메인 메모리에서 주소가 사용 가능한지 여부를 생각하지 않고, 명시된 그대로 물리 주소를 사용하려고 함
3. ```CPU```가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더해 수행 (```Relocation```)
4. ```CPU```가 명령어를 수행할 때마다, 프로세스가 참조하려는 주소가 리미트 레지스터의 값과 동일하거나 큰지 확인 (```Protection```)
  - O : 프로텍션 바이오레이션 (```Protection Violation```) 발생시켜 메모리 참조를 중단
  - X : 프로세스가 참조하려는 주소에 베이스 레지스터의 값을 더한 값을 메모리 버스에 보냄

> Q. 그럼 베이스 레지스터 & 리미트 레지스터를 사용하면 이젠 더 이상 문제가 없는걸까?
> - 모든 메모리 참조마다 덧셈과 비교 연산이 요구되기에, 비교적 시간이 오래 걸림 : 특히 덧셈 연산이!
>   - 블로트웨어 (```Bloatware```) : 메모리의 크기를 증가하는 속도를 소프트웨어의 크기가 증가하는 속도가 역전
> 
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fe9a93b26-58ff-4ab0-8b6b-2a8b3cb3cdfd%2F정적재배치2.PNG" width="80%" style="margin-left: 2%">
> 
> - 정적 메모리 파티션 (```Fixed memory partitions```) : 메모리를 파티션 여러 개로 미리 나누고 프로세스 할당
>   - ```Multiple input Queues``` : 도착한 작업을 크기에 맞는 가장 작은 파티션에 넣음
>   - ```Single input Queue``` : 도착한 작업을 수용할 큐를 하나만 배정, 먼저 도착한 작업을 먼저 실행시킴
> 
> <img src="https://examradar.com/wp-content/uploads/2019/02/fixed-memory-partition.png" width="80%" style="margin-left: 2%">
>
> > 정적 메모리 파티션은 메모리가 시스템이 구동할 모든 프로세스를 적재 가능한 용량을 가져야 성립하나,
> > - 시스템이 구동할 모든 프로세스들이 필요한 메모리의 전체 크기는 실제 ```RAM``` 용량보다 크다.
> > - 프로그램이 시작하기 전에 이미 실행 중인 프로세스들이 적재되어 있다.
>
> ... <b>모든 프로세스들을 계속 적재하기엔, 물리 메모리 크기에 한계가 있다</b>는 문제에 대해, 2가지 해결책이 제시되었다.
> - ```Swapping``` : 한 프로세스의 전체 이미지가 메모리로 적재되어 실행되다가 실행되지 않으면 디스크로 이동
> - ```Virtual Memory``` : 한 프로세스의 전체 이미지가 아닌 일부만 메모리에 있어도 프로세스의 실행이 가능

### 스와핑 (```Swapping```) : 메모리에 로드된 프로세스 중에 장기간 미사용된 것을 하드 디스크에 이미지 형태로 저장
- 프로세스 이미지 (```Process Image```) : 프로그램이 메모리에 로드되고 실행되어 데이터가 변경된 프로세스
  - 하드 디스크에 존재하는 ```.exe```, ```.app```에 데이터가 변경되었기에 이를 하드 디스크의 ```backing store```에 저장
    - ```swap-out``` : 메인 메모리 -> ```Backing store```
    - ```swap-in``` : ```Backing store``` -> 메인 메모리

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F79e932b4-c55f-4e27-aaaf-381605691e27%2F스와핑1.PNG" width="80%" style="margin-left: 2%">

> ... ```backing store```는 메인 메모리의 모든 프로세스가 ```swap-out```될 때 데어터의 소실 없이 저장할 수 있어야 한다.
> - 그러므로, 하드 디스크에서 ```backing store```이 할당받는 크기는 <b>최소 메인 메모리의 크기</b>라 예상할 수 있다.

<img src="https://miro.medium.com/max/1200/1*QnOhzkY2mIXFKM-SoXh_8w.jpeg" width="80%" style="margin-left: 2%">

- (a) 각 프로그램의 데이터 세그먼트가 늘어날 공간을 미리 확보
- (b) 각 프로그램의 세그먼트를 프로그램 텍스트 / 데이터 세그먼트 / 스택 세그먼트로 나눔
  - 프로그램 텍스 위의 데이터 세그먼트와 스택 세그먼트가 서로를 향해 자라게끔 함
    - 힙 (```Heap```) 영역 (```Room for growth```) : 사용자가 동적으로 할당할 영역
      - ```malloc```, ```calloc``` 등의 명령어로 관리

#### 동적 메모리 파티션 (```Dynamic memory partitions```) : 프로그램이 메모리에 로드될 때마다 파티션을 나누고 할당
- 운영체제가 동적으로 할당된 프로세스를 관리 : 힙 영역이 커지므로, 프로세스의 확장을 위한 공간이 할당되어야 함

<img src="https://examradar.com/wp-content/uploads/2019/03/Memory-Management-with-Bitmap.png"  width="66%" style="margin-left: 2%">

- (b) ```Bit Maps``` 사용 : 맵에 ```X```비트를 관장할 ```Y```개의 할당 단위 (```allocation unit```)
  - 단위 유닛이 메모리에 할당되어 있으면 유닛의 값을 1, 할당되어 있지 않으면 0 (```flag bit```)

> - 할당 단위가 작아지면? : 유닛의 개수 ```Y```가 커진다.
>   - ```Y```를 표현할 ```flag bit```가 많이 필요하므로, 맵의 크기가 커져 맵을 탐색할 때의 성능이 저하된다.
> - 할당 단위가 커지면? : 유닛의 개수 ```Y```가 작아진다.
>   - ```Y```를 표현할 ```flag bit```가 적게 필요하므로, 비트맵의 공간이 작아진다.
>   - 마지막 프로세스에 빈 공간 역시 커져 더 많은 메모리 공간이 낭비될 가능성이 있다.
>
> ... ```Bit Maps```의 문제점 : 프로세스가 ```k```개의 할당 단위를 요구할 때, 맵에서 ```k```개의 0비트를 연속해서 찾아야 한다.

- (c) ```Linked Lists``` 사용 : 메모리의 낮은 주소부터 링크드 리스트의 노드가 있음
  - 각 엔트리는 ```P``` (프로세스) or ```H``` (홀)을 표현하는 ```flag```, 시작 주소, 길이, 다음 엔트리를 가리키는 포인터로 구성

> - 프로세스 종료 시 ```Linked Lists```를 업데이트하는 방법
>   - 종료되는 프로세스는 일반적으로 2개의 이웃을 가짐 → 이웃은 다른 프로세스가 차지한 공간이거나 빈 공간
> 
> <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQL0MnsZnPlU2O0BnlViAvrs8Ge5bJtE5VhIQ&usqp=CAU" width="66%" style="margin-left: 2%">
>
> - (a) ```X```에 해당되는 엔트리를 ```X```에서 ```H```로 바꿔 갱신
> - (b), (c) 2개의 엔트리를 통합해 하나로 표현
> - (d) 3개의 엔트리를 통합해 하나로 표현

#### ```Contiguous Memory Allocation``` : 메모리에 새로 생성된 프로세스들을 위한 메모리 공간 할당
- 메모리 단편화 (```Memory fragmentation```) : 메인 메모리에 흩어진 홀들이 불연속적으로 할당된 상태
  - 프로세스 생성 & 종료 반복 → ```scattered holes```
  - 홀 (```Hole```) : 메인 메모리에서 프로세스가 할당되지 않은 영역
- 외부 단편화 (```External fragmentation```) : 프로세스를 할당할 크기가 충분하나, 메모리 단편화로 할당이 불가능한 상태
 
<img src="https://user-images.githubusercontent.com/34755287/54821882-d8808080-4ce6-11e9-8ff3-193fa79c04a3.png" width="80%" style="margin-left: 2%">

- ```First-fit``` : 프로세스 크기보다 크거나 같은 홀을 탐색하는 순서 중에서 가장 먼저 찾은 홀에 프로세스 할당

<img src="https://user-images.githubusercontent.com/34755287/54821883-d8808080-4ce6-11e9-8c2d-c84b878d21ea.png" width="80%" style="margin-left: 2%">

- ```Best-fit``` : 할당할 프로세스 크기와 홀의 크기 차이가 가장 작은 홀에 프로세스 할당

<img src="https://user-images.githubusercontent.com/34755287/54821885-d8808080-4ce6-11e9-9473-db032d7eeb3a.png"  width="80%" style="margin-left: 2%">

- ```Worst-fit``` : 할당할 프로세스 크기와 홀의 크기 차이가 가장 큰 홀에 프로세스 할당
  - ```Best-fit```을 사용하였다가 다른 프로세스가 쓰지 못할 정도의 홀이 생겼을 때를 위한 대안

<img src="https://user-images.githubusercontent.com/34755287/54821887-d9191700-4ce6-11e9-9b00-fa92272b8b7d.png"  width="80%" style="margin-left: 2%">

- ```Compaction``` : 메모리 여러 곳에 흩어져있는 홀들을 강제로 하나로 병합
  - 홀을 옮기는 오버헤드가 매우 크고, 어느 홀을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않음

> 일반적으로 할당 속도는 ```First-fit```가 가장 빠르며, 메모리 이용률은 ```First-fit```와 ```Best-fit```이 비슷하다.
> - 하지만 ```Best-fit```을 사용하더라도, 외부 단편화로 인해 여전히 전체 메모리의 1/3 정도를 낭비한다. 