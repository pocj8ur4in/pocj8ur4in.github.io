---
title: "[JPA] 1. JPA"

tags:
    - JPA

toc: true
toc_sticky: true

date: 2023-12-09
last_modified_at: 2023-12-09
---

## 개발자가 ```SQL```을 직접 다룰 때의 문제

1. ### ```DB```는 객체 구조와는 다른 데이터 중심의 구조를 가져 객체를 DB에서 직접 저장하거나 조회할 수 없음
- 개발자가 객체지향 어플리케이션과 ```DB``` 중간에서 ```SQL```과 ```JDBC API```를 이용해 변환해야 함
- 객체를 DB에 CRUD하기 위해서 너무 많은 ```SQL```과 ```JDBC API```를 코드로 작성해야 함

2. ### ```DAO```를 이용해 ```SQL```를 은닉해도 결국엔 ```SQL```에 의존적인 개발이 될 수 밖에 없음
- 개발자가 엔티티를 신뢰하고 사용할 수 없음... 이게 진정한 계층 분할?

> 그럼, ```JPA```는 어떻게 문제를 해결하였는가?
>
> - 객체를 ```DB```에 저장하고 관리할 때 ```JPA```가 제공하는 ```API``` 사용
>   - 저장 → ```persist()``` : 객체를 DB에 저장하면, ```INSERT SQL```를 생성해서 ```DB```에 전달
>   - 조회 → ```find()``` : 객체 하나를 DB에서 조회하면, ```SELECT SQL```를 생성해서 ```DB```에 전달
>   - 수정 → 객체를 조회해 값을 변경하면, 트랜잭션을 커밋할 때 ```UPDATE SQL```를 생성해 ```DB```에 전달
>   - 연관 객체 조회 → 연관된 객체를 사용하는 시점에 ```SELECT SQL```를 실행

## 객체와 관계형 데이터베이스의 패러다임 불일치
- 객체지향 프로그래밍 : 추상화, 캡슙화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치 제공
- 비즈니스 요구사항을 정의한 도메인 모델 또한 객체로 모델링 → 객체와 관계형 데이터베이스는 지향하는 바가 다르다!

1. ### 상속 : 객체는 상속이라는 기능을 가지지만, 테이블은 상속이라는 기능이 없음
  - 데이터베이스 모델링의 슈퍼타입-서브타입 관계를 이용한다고 해도, 매번 2가지 ```SQL```를 만들어야 함

2. ### 연관관계 : 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조에 접근해서 조회
  - 그러나 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 이용해서 연관된 테이블을 조회
  - 그럼 객체를 테이블에 맞추어 모델링하면? : 외래 키와 참조의 예 → 객체지향의 장점을 잃어버릴 수 있다!

3. ### 객체 그래프 탐색 : 객체에서 회원이 소속된 팀을 조회할 때에는 참조를 사용해 연관된 팀을 탐색
- 그런데 참조를 통해 팀을 탐색할 수 있을지 없을지 알 수 없음 → 너무나 큰 제약사항
  - 결국 ```DAO```를 통해 ```SQL```을 직접 확인하기 위해 상황에 따른 여러 메소드를 만들어야 함

4. ### 비교 : 데이터베이스는 기본 키의 값으로 각 ```row```를 구분하지만, 객체는 동일성 비교, 동등성 비교를 활용
- 동일성 비교 (```==```) : 객체 인스턴스의 주소 값을 비교, 동등성 비교 (```equals()```) : 객체 내부의 값을 비교
  - 기본 키 값이 같은 객체를 2번 조회했을 때, 이 객체들이 다른 인스턴스면 동등하되 동일하지 않다.

> 그럼, ```JPA```는 어떻게 문제를 해결하였는가?
>
> - 상속 → 자바 컬렉션에 객체를 저장하듯이 ```JPA```에 객채를 저장하면 이를 두 테이블에 나눠 저장
> - 연관관계 → 개발자가 관계를 설정해 객체를 저장하면, 참조를 외래 키로 변환해 ```INSERT SQL``` 전달
> - 객체 그래프 탐색 : 실제 객체를 사용하는 시점까지 ```DB``` 조회를 미루는 지연 로딩 이용
> - 비교 : 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장

## ```JPA``` (```Java Persistence API```) : 자바 진영의 ```ORM``` 기술 표준
- ```ORM``` (```Object-Relational Mapping```) : 객체와 관계형 ```DB```를 매핑

### 왜 ```JPA```를 사용해야 하는가?
1. 생산성 : 반복되는 ```CRUD```용 ```SQL``` 코드를 작성하는 대신, 자바 컬렉션에 객체를 저장하듯 ```JPA```에 객체를 전달하면 됨     
2. 유지보수 : 매번 ```SQL```과 ```JDBC API``` 코드를 변경할 필요 없음
3. 패러다임의 불일치 해결 : ```ORM``` 프레임워크가 상속, 연관관계, 객체 그래프 탐색, 비교 등의 문제를 대신 해결
4. 성능 : 어플리케이션과 ```DB``` 사이에서 동작하면서 다양한 성능 최적화 기회를 제공
5. 데이터 접근 추상화 및 벤더 독립성 : ```DB``` 접근 계층을 제공해서 특정 ```DB``` 기술에 종속되지 않음

> References
>
> - <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62681446">자바 ORM 표준 JPA 프로그래밍</a>