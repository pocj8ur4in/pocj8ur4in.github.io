---
title: "[Engineer Information Processing] 4. 프로그래밍 언어 활용"

tags:
    - Engineer Information Processing

toc: true
toc_sticky: true

date: 2024-01-12
last_modified_at: 2024-02-22
---

## ```C```

### ```C``` 개요

- <b><code>C</code> 기본 자료형 : <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code></b>
- <b><code>C</code> 변수명 작성 규칙 : 영문 대소문자, 숫자, <code>_</code> 혼용 (첫글자 숫자<code>X</code>, 예약어<code>X</code>)</b>

### ```C``` 라이브러리

- <b>라이브러리 : 필요할 때 찾아 쓸 수 있도록 모듈화되어 모듈, 패키지의 형태로 제공되는 프로그램</b>
- <b>헤더 파일 (<code>.h</code>)가 필요한 이유? : 라이브러리를 사용하기 위해</b>
- <b>표준 라이브러리 : <code>string.h</code>, <code>stdio.h</code>, <code>stdlib.h</code>, <code>ctype.h</code></b>
  - <b><code>stdlib.h</code> 함수 : <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, <code>free</code>, <code>rand</code>, <code>abs</code></b>

### ```C``` 연산자

- <b><code>C</code> 연산자 종류·우선순위 : 단항 연산자 → 산술 연산자 → 시프트 연산자 → 관계 연산자 → 비트 연산자 → 논리 연산자 → 조건 연산자 → 대입 연산자 → 콤마 연산자<b>
  - <b>논리 연산자의 우선순위 : <code>NOT</code>→<code>AND</code>→<code>OR</code></b>

### ```C``` 포인터

- <b><code>C</code> 포인터 : 객체에 대한 참조를 하는 다른 객체를 가리키는 자료형</b>
  - <b>주소 연산자 <code>&</code> : 모든 변수에 대한 주소값을 구하는 연산자</b>
  - <b>간접 연산자 <code>*</code> : 포인터 변수의 자료를 구하는 연산자</b>

### ```C``` 배열 / ```C``` 구조체

- <b><code>C</code> 배열 : 배열, 구조체, 공용체</b>
  - <b>구조체 : 서로 연관된 데이터를 모아놓은 것</b>

## ```Java```

### ```Java``` 개요

- <code>Java</code> : 객체지향 프로그래밍 언어
  - <b>객체지향 구성 요소 : 클래스, 객체, 속성, 메소드, 메시지</b>
  - <b>객체지향 특징 : 캡슐화, 정보은닉, 추상화, 상속성, 다형성</b>
- <b>가비지 컬렉션 : <code>JVM</code>에서 불필요한 메모리 정리</b>
- <b><code>Java</code> 기본 자료형 : <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>boolean</code></b>
- <code>Java</code> 출력 메소드 : <code>System.out.print()</code> (줄바꿈 <code>X</code>), <code>System.out.printIn()</code> (줄바꿈 <code>O</code>), <code>System.out.printf()</code> (변환 문자 사용해 출력)
- <b><code>Java</code> 변수명 작성 규칙 : 영문 대소문자, 숫자, <code>_</code>, <code>$</code> 혼용 (첫글자 숫자<code>X</code>, 예약어<code>X</code>)</b>
- <b><code>Java</code> 연산자 종류·우선순위 : 단항 연산자 → 산술 연산자 → 비트 이동 연산자 → 관계 연산자 → 비트 논리 연산자 → 논리 연산자 → 조건 연산자 → 대입 연산자<b>

### ```Java``` 자료형

- <b><code>Java</code> 기본 자료형 : 논리형, 문자형, 정수형, 실수형</b>
- <b><code>Java</code> 참조 자료형 : 문자열, 배열, 클래스, 인터페이스, 열거형</b>

### ```Java``` 클래스

- <b>클래스 : 객체를 정의하기 위한 틀</b>
  - 클래스 선언 후 <code>new</code>로 객체 생성, 래퍼런스 변수를 선언해 객체 활용
  - 클래스 이름은 하나 이상의 문자로 (반드시 대문자로 시작해야 함)
  - 소스 파일에는 하나의 <code>public</code> 클래스만 가능
  - <code>main</code>은 실행의 시작을 위해 반드시 필요
- 추상 클래스 : 실행 코드가 없는 추상 메소드를 하나 이상 포함하는 클래스
  - 추상 메소드 : 자식 클래스에서 재정의해 사용하는 메소드
  - 클래스의 형변환 : 재정의한 메소들르 부모 클래스의 객체 변수를 통해 사용하려면 부모 클래스의 객체 변수를 선언할 때 자식 클래스의 생성자를 이용해야 함 → 클래스의 다형성

### ```Java``` 상속

- <b>상속 : 자식 클래스가 부모 클래스의 속성과 메소드를 상속받는 것</b>
- <b>메소드 오버라이딩 : 클래스 상속 상황에섯 부모 클래스의 멤버를 자식 클래스에서 상속해 내용을 수정해 사용</b>

### ```Java``` 예외 처리

- <b>예외 처리 : 오동작이나 실행 시간 동안 발생해 결과에 악영향을 미치는 오류</b>
  - <b>예외 처리 특징 : 예외 클래스 계총 구조, <code>Checked & UnChecked</code>예외, <code>try-catch-finally</code>, 다중 <code>catch</code> 블록, <code>throws & throw</code>, <code>CustomException</code></b>

## ```Python```

### 스크립트 언어와 ```Python```

- 스크립트 언어 : 소스 코드를 컴파일 과정 없이 실행할 수 있는 프로그래밍 언어
  - <b>서버 측 스크립트 언어 : <code>ASP</code>, <code>JSP</code>, <code>PHP</code>, <code>Python</code></b>
  - 클라이언트 측 스크립트 언어 : <code>JS</code>
- <b><code>Python</code> : 플랫폼 독립적, 인터프리터, 객체지향적, 동적 타이핑 대화형 언어</b>
- <b><code>Python</code> 변수명 작성 규칙 : 영문 대소문자, 숫자, <code>_</code> 혼용 (첫글자 숫자<code>X</code>, 예약어<code>X</code>)</b>
- <b><code>Scrapy</code> : <code>Python</code> 웹 크롤러 프레임워크</b>

### ```Python``` 자료형

- <b><code>Python</code> 숫자 자료형 : 정수형, 실수형, 복소수형</b>
- <b><code>Python</code> 시퀀스 자료형 : 문자열, 리스트, 튜플</b>
- <b><code>Python</code> 매핑 자료형 : 딕셔너리</b>
- <b><code>Python</code> 집합 자료형 : 집합</b>
- <b><code>Python</code> 부울 자료형 : 불리언</b>
- <b><code>Python</code> <code>None</code> 자료형 : <code>None</code></b>

### ```Python``` 연산

- <b>인덱싱 : 문자열의 각 문자에 인덱스 할당 (첫번째는 0)</b>
- <b>클래스 메소드 : 클래스에 속한 메소드 (<code>@classmethod</code> 데코레이터로 정의)</b>

### ```Python``` 함수

- <b><code>Python</code> 함수 : 재사용 가능한 코드 블록</b>
  - <b><code>range()</code> : 0~주어진 인수 미만의 연속된 정수를 리스트 객체로 반환</b>
  - <b><code>map()</code> : 주어진 함수를 순회 가능한 객체의 모든 요소에 적용해 새로운 이터레이터 반환</b>
  - <b><code>split()</code> : 구분자 기준으로 분리해 분리된 각 부분을 원소로 가지는 리스틑 반환</b> 
- <b><code>Python</code> 조건문 : <code>if ~ elif ~ else</code></b>
- <b>지역 변수 : 함수 내에서 정의된 변수</b>

## 운영체제 개론

### 운영체제 개요

- 운영체제 : 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어
  - 시스템 소프트웨어 : 컴퓨터의 전반적인 운영에 필요한 가장 기본적인 프로그램
  - 운영체제 평가 기준 : 처리 능력 향상, 응답 시간 단축, 신뢰도 향상, 사용 기능도 향상

### 운영체제의 운영 방식

- 일괄 처리 시스템 : 사용자 개입 없이 일정량 혹은 일정 시간 동안 데이터를 모아 처리
- 다중 프로그래밍 시스템 : 2개 이상의 프로그램을 주기억장치에 기억시켜 <code>CPU</code>를 번갈아 사용
  - 다중 프로그래밍 시스템 특징 : 멀티태스킹, 가상 메모리, <code>CPU</code> 리소스 사용 효율화
- 실시간 처리 시스템 : 데이터 발생 즉시 처리하여 결과 산출
- <b>시분할 시스템 :<code>CPU</code> 전체 사용 시간을 작업 시간량으로 나눠 <code>CPU</code>를 시간량 동안만 사용</b>
  - 시분할 시스템 특징 : 다중 사용자 지원, 시분할 방식, 대화식 환경
- 다중 처리 시스템 : <code>CPU</code>를 두 개 이상 두어 그 업무를 분담해 처리
  - 다중 처리 시스템 특징 : 병렬 처리, 자원 분산, 확장성
- 분산 처리 시스템 : 여러 대의 컴퓨터로 작업을 나누어 처리
- 가상화 시스템 : 하나의 물리적 시스템에서 여러 개의 가상 시스템을 구동
- 클라우드 컴퓨팅 시스템 : 인터넷을 통해 자원을 공유받고 서비스를 제공

### 운영체제의 프로그램 구성

- 제어 프로그램 : 컴퓨터 시스템의 하드웨어와 소프트웨어를 제어
  - 제어 프로그램 기능 : 프로세스·메모리·입출력·장치·자원·보안 관리
  - <b>제어 프로그램 종류 : 감시 프로그램, 작업 제어 프로그램, 데이터 관리 프로그램</b>
- 처리 프로그램 : 사용자의 응용 프로그램이나 그 작업을 실행
  - 처리 프로그램 역할 : 응용 프로그램 실행, 작업 처리, 자원 관리, 결과 제공
  - 처리 프로그램 기능 : 파일·메모리·디스크·네트워크 관리, 사용자 인터페이스
  - <b>처리 프로그램 종류 : 언어 번역 프로그램, 서비스 프로그램, 문제 프로그램</b>

### 프로세스 관리

- 프로세스 : 실행 중인 프로그램
  - 프로세스 제어 블록 (<code>PCB</code>) : 운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요 정보 저장
  - <b>프로세스 상탵 전이 : 프로세스가 다양한 상태를 거치면서 실해오디는 과정 (운영체제의 스케줄러로 관리)</b>
    - 프로세스 상태 전이 절차 : 생성 → 준비 상태 → 실행 상태 (디스패치, 할당 시간 종료) → 대기 상태 (블록, 웨이크 업) → 종료
- <b>스레드 : 프로세스 내 작업 단위 (시스템의 여러 자원을 할당받아 실행하는 프로그램 단위)</b>
- 병행 프로세스 : 두 개 이상의 프로세스들이 동시에 실행 상태에 있는 것 → 병행 프롯세스 오류 방지
  - <b>임계 영역 : 어느 시점에서 하나의 프로세스가 자원을 사용하도록 지정된 공유 영역</b>
  - <b>상호 배제 : 공유 변수에 접근하고 있는 한 프로세스 외엔 모두 공유 변수를 접근하지 못하게 함</b>
  - <b>세마포어 : 프로세스 간 동기를 유지하고 상호 배제의 원리 보장</b>
  - <b>모니터 : 모니터의 경계에서 상호배제 시행, 모니터 외부에선 모니터 내부에 직접 액세스 불가능</b>

### 교착 상태

- <b>교착 상태 : 둘 이상의 프로세스들이 서로 다른 프로세스가 차지한 자원을 요구하며 무한정 대기</b>
  - 교착 상태 발생 조건 : 상호 배제, <b>점유 및 대기</b>, 비선점, 환형 대기
  - 교착 상태 해결 방법 : 예방, 회피, 발견, 회복
- 인터럽트 : 어떤 특수 상태 발생 시 현재 실행 중인 프로그램을 일시 중단하고, 그 특수 상태를 처리하는 프로그램

### 프로세스 스케줄링

- 프로세스 스케줄링 : 프로세스 생성 및 실행에 필요한 시스템 자원을 해당 프로세스에 할당
  - 비선점 : 한 프로세스가 <code>CPU</code>를 할당받으면 다른 프로세스가 <code>CPU</code> 사용 완료까지 대기
    - <b><code>FIFO</code> : 준비 상태 큐에 도착한 순서대로 <code>CPU</code> 할당</b>
    - <b><code>SJF</code> : 준비 상태 큐에 기다리는 프로세스 중 가장 짧은 프로세스에 먼저 <code>CPU</code> 할당</b>
    - <b><code>HRN</code> : 서비스 시간, 서비스 대기 시간으로 결정된 우선순위에 따라 <code>CPU</code> 할당</b>
      - <code>HRM</code> 우선순위 계산식 = (대기 시간 + 서비스 시간) / 서비스 시간
  - 선점 : 한 프로세스가 <code>CPU</code>를 할당받아도 다른 프로세스가 우선순위가 높으면 <code>CPU</code> 점유
  

### 기억 장치 관리

- 반입 전략 : 보조 기억 장치에 보관된 프로그램이나 데이터를 주기억 장치에 언제 가져올지 결정하는 전략
  - 요구 반입 : 프로세스가 실제 필요한 때만
  - 예상 반입 : 프로세스의 실행 특성 및 예측을 기반하여 미리
- 배치 전략 : 보조 기억 장치에 보관된 프로그램이나 데이터를 주기억 장치의 어디로 가져올지 결정하는 전략
  - <b>최초 적합 : 주기억 장치 내에 적재 가능한 공간에 첫번째 분할 영역에 배치</b>
  - <b>최적 적합 : 주기억 장치 내에 적재 가능한 공간에 가장 작은 공백이 남는 부분에 배치</b>
  - <b>최악 적합 : 주기억 장치 내에 적재 가능한 공간에 가장 큰 공백이 남는 부분에 배치</b>
  - <b>단편화 : 주기억 장치 내에 빈번히 기억 장소가 할당되고 반납되면서 기억 장소들이 조각들로 나뉘는 현상</b>
    - 내부 단편화 : 프로세스가 필요한 크기보다 메모리가 더 커서 메모리 공간 낭비
    - 외부 단편화 : 메모리 할당 및 해제가 반복되면서 중간에 남는 메모리를 사용하지 못해 메모리 공간 낭비

### 가상 기억 장치

- <b>가상 기억 장치 할당 방식 : 주기억 장치의 부족한 용량을 해결하기 위해 보조 기억 장치를 주 기억 장치처럼 활용</b>
  - 세그멘테이션 : 가상 장치에 보관된 프로그램을 다양한 크기로 나눠 적재
  - <b>페이징 : 가상 기억 장치에 보관된 프로그램과 주기억 장치의 영역을 동일하게 나눠 적재</b>
- <b>페이징 부재 : 참조할 페이지가 주기억 장치에 없는 현상</b>
  - <b>페이징 부재 처리 과정 : 페이지 부재 예외 처리 → 페이지 스와핑 (디스크에서 페이지 가져옴) → 페이지 테이블 가져옴 → 프로세스 재시작</b>
- <b>워킹 셋 : 가상 기억 장치 관리에서 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합</b>
- <b>스래싱 : 하나의 프로세스가 작업 수행 과정에 수행하는 기억 장치 접근에서 지나치게 페이지 부재가 발생하여 프로세스 수행 시간보다 페이지 이동에 걸리는 시간이 더 커지는 현상</b>
- <b>기억 장치 교체 전략 : <code>OPT</code>, <code>FIFO</code>, <code>LRU</code>, <code>NUR</code>, <code>SCR</code></b>


### 디스크 스케줄링

- 디스크 스케줄링 : 사용 데이터가 디스크 곳곳에 저장되어 있을 때, 데이터 액세스를 위해 디스크 헤드의 이동 경로 결정
  - <code>FCFS</code> : <code>FIFO</code>
  - <b><code>SSFT</code> : 탐색 거리가 가까운 순서대로</b>
  - <code>SCAN</code> : 진행 방향 끝까지, 그리고 반대로

### 정보 관리

- 파일 시스템 : 연관된 데이터의 집합인 파일을 관리하는 시스템
  - <b>파일 디스크립터 (<code>FCB</code>) : 파일 관리에 필요한 정보를 가진 제어 블록</b>

### 분산 운영체제

- 분산 처리 시스템 : 여러 대의 컴퓨터들에 의 해 작업한 결과를 통신망으로 상호 교환할 수 있도록 연결된 시스템
- 투명성 : 분산 처리 운영체제에서 구제적인 시스템 환경을 사용자가 알수 없도록 하는 것
  - 투명성 종류 : 위치 투명성, 이주 투명성, 복제 투명성, 병행 투명성, 접근 투명성

### ```UNIX```, ```Linux```

- <b><code>UNIX</code> : 시분할 시스템을 위해 설계된 대화식 운영체제</b>
  - <b>쉘 : 사용자가 지정한 명령들을 해석해 커널로 전달하는 명령어 해석기 (인터페이스 담당)</b>
- <code>Linux</code> : <code>UNIX</code>와 호환, 멀티태스킹 및 멀티 유저 지원
  - <b><code>umask</code> : 파일, 디렉터리 생성 시 초기 접근 권한 설정</b>
- <b>리눅스 로그 파일 : <code>utmp</code>, <code>wtmp</code>, <code>btmp</code></b>

## 네트워크 개론

### 데이터 통신 개요

- 네트워크 : 원하는 정보를 원하는 수신자에 정확히 전송하기 위한 기반 인프라
  - 네트워크 분류 : <code>LAN</code>, <code>MAN</code>, <code>WAN</code>
  - 네트워크 관련 장비 : <b>리피터</b>, 허브, 스위치 (<b><code>L1</code>, <code>L2</code>, <code>L3</code>, <code>L4</code>, <code>L5</code></b>), 브리지, <b>라우터</b>, <b>게이트웨이</b>
- <code>LAN</code> : 근거리 통신 네트워크
  - <code>LAN</code> 토폴로지 : 성형, 링형, 버스형, 계층형, 망형
  - <code>LAN</code> 분류 : 베이스밴드, 광대역
  - 전송 매체 접근 제어 (<code>MAC</code>) : 하나의 통신 회선에 여러 컴퓨터 연결
  - <code>LAN</code> 표준 : 이더넷
- 데이터 회선망 : 전용 회선, 교환 회선
  - 회선 구성 방식 : 점 대 점 방식, 다중 점 방식, 회선 다중 방식
  - 회선 교환 방식, 축적 교환 빙식 (메시지 교환 방식, 패킷 교환 방식 (가상 회선, 데이터그램))

### ```OSI``` 7계층과 오류 제어 방식

- <code>OSI</code> 참조 모델 : 컴퓨터 네트워크에서 여러 시스템이 데이터를 통신하도록 표준화·계층화된 인터페이스
  - <b><code>DPI</code> : 전 계층의 패킷 내부 컨텐츠를 파악해 트래픽을 조장하는 패킷 분석 기술</b>
- <code>OSI</code> 7계층 구조 : <code>OSI</code> 참조 모델을 구체화한 것
  1. <b>물리 계층 : 물리적, 기계적 통신 (<code>RS-232C</code>)</b>
  2. <b>데이터 링크 계층 : 두 통신 시스템 간의 링크로 전송 (<code>HDLC</code>, <code>LLC</code>)</b>
  3. <b>네트워크 계층 : 통신망을 통해 패킷을 목적지까지 전달 (<code>IP</code>)</b>
  4. <b>전송 계층 : 통신 종단 간 데이터 전송 (<code>TCP</code>, <code>UDP</code>)</b>
  5. <b>세션 계층 : 프로세스 간 연결 관리</b>
  6. <b>표현 계층 : 응용 및 세션 사이의 대화 제어 및 데이터 변환</b>
  7. <b>응용 계층 : 응용 서비스 제공 (<code>HTTP</code>, <code>FTP</code>, <code>DNS</code>, <code></code>SMTP)</b>
- <b>자동 반복 요청 (<code>ARQ</code>) : 통신 경로에 오류 발생 시 수신자는 오류 발생을 송신자에 통보하고, 송신자는 오류가 발생한 프레임을 재전송하는 오류 제어 방식</b>
  - <code>ARQ</code> 종류 : 정지-대기 <code>ARQ</code>, 연속 <code>ARQ</code>, 선택적 재전송 <code>ARQ</code>, 적응적 <code>ARQ</code>
- 패리티 검사 : 데이터 블록에 1비트의 패리티 비트를 추가해 오류 검출 (홀수 패리티, 짝수 패리티)
- 순환 중복 검사 : 다항식 코드를 통한 에러 검사 (해밍 코드 방식)

### ```TCP/IP``` 프로토콜, 패킷 교환

- <b><code>TCP/IP</code> : 인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송수신을 돕는 표준 프로토콜</b>
  - <b><code>TCP</code> : 전송 계층 (<code>L4</code>) 역할 수행 (순서·에러·흐름 제어, 전이중·스트림 데이터 서비스, 메시지 캡슐화·역캡슐화, 다중화·역다중화)</b>
  - <b><code>UDP</code> : 전송 계층 (<code>L4</code>) 역할 수행 (비연결성·비신뢰성, 복구 <code>X</code>)</b>
  - <b><code>IP</code> : 네트워크 계층 (<code>L3</code>) 역할 수행 (라우팅·데이터그램)</b>
    - <b><code>ICMP</code> : <code>IP</code> 오류 보고 및 수정 메커니즘</b>
    - <b><code>IGMP</code> : 시작지에서 여러 목적지로 전송될 때 사용</b>
    - <b><code>ARP</code> : 논리 주소를 물리 주소로 변환</b>
- <b><code>IP</code> 프로토콜 필드 : 헤더 길이 (<code>4bit</code>), 토탈 패킷 길이 (<code>16bit</code>), <code>Time-To-Live</code> (<code>8bit</code>)</b>

### ```IP``` 주소와 경로 제어

- <b><code>IPv4</code> : 32비트 <code>IP</code> 주소 (네트워크 주소 + 호스트 주소)</b>
  - <b><code>IPV4</code> 특징 : 주소 고갈, 서브넷팅·<code>CIDR</code></b>
  - <b><code>IPv4</code> 주소 체계 : 클래스 <code>A ~ E</code></b>
  - <b>서브넷 마스크 : 네트워크를 작은 내부 네트워크로 분리해 이진 형태로 관리</b>
- <b><code>IPv6</code> : 128비트 <code>IP</code> 주소 (16비트씩 8개 필드로 분리 표기)</b>
  - <b><code>IPV6</code> 장점 : 보안성 강화, 확장 용이, 패킷 크기 제한 없음, 실시간 처리·자동 네트워크 구성 가능</b>
  - <b><code>IPV6</code> 통신 방식 : 유니캐스트, 애니캐스트, 멀티캐스트</b>
- 경로 제어 : 각 메시지에서 목적지까지 갈 수 있는 여러 경로 중에 한 경로를 설정
  - <b>경로 제어 프로토콜 : <code>IGP</code>, <code>EGP</code>, <code>BGP</code></b>
