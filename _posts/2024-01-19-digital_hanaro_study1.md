---
title: "프로그래밍 언어로서의 JavaScript와 TypeScript (2024.01.19)"

tags:
    - Digital Hanaro Study

toc: true
toc_sticky: true

date: 2024-01-19
last_modified_at: 2024-01-19
---

## 공부하고자 한 이유

```JavaScript```와 ```TypeScript```는 그동안 내가 주로 사용해온 ```C```, ```C++```, ```Java```와 같은 컴파일 언어와는 많은 차이점이 있는 스크립트 언어이다. 오늘은 본격적으로 자바스크립트를 배우기 앞서 자바스크립트와 타입스크립트가 프로그래밍 언어로서 어떤 특성을 가지는지 알아보고자 한다.

## 공부한 내용

프로그래밍 언어 (```Programming Language```)는 기계가 읽을 수 있고, 사람이 읽을 수 있는 형식으로, 계산을 서술하기 위한 표기 체계이다. 여기에서 주목할 점은 '사람이 읽을 수 있는 형식으로'이다. 사실 기계의 성능을 가장 높이는 방법은 기계의 방식을 그대로 따르는 것이지만, 프로그래밍 언어는 사람의 편의성을 위해 지속적으로 여러 개념들을 도입하였다. 대표적인 예시로 추상화 (```Abstraction```)이 있다. 추상화는 속성들의 일부분만으로, 주어진 작업이나 객체를 필요한 정도로만 묘사하는 것이다. 예를 들어 ```int x;```라는 구문이 있을 때, ```int```, ```x```, ```;```는 해당 단어나 기호를 아는 사람들에게 있어 어떤 의미를 가진다는 것을 유추할 수 있게끔 한다. 그리고 컴퓨터 역시 예약어인 ```int```나 ```;```가 어떤 의미를 가질 때, 그리고 ```x```라는 단어가 쓰였을 때 어떤 일련의 작업, 즉 명령의 순차적 실행, 위치를 표현할 변수의 사용, 그리고 변수의 값을 변경하는 배정문의 사용 등을 진행하면 되는지 알고 있다.

이 '사람이 읽을 수 있는 형식으로'라는 조건은 계산을 서술하는 방식에도 영향을 미쳤다. 앞서 설명한 일련의 흐름을 그대로 진행하는 언어는 절차 언어 (```Procedural Language```)라고 부른다. 하지만, 절차 언어는 계산이 순차적인 명령에 의하여 실행되어야 하기 때문에 공유 버스 (```Shared Bus```) 내에서 폰 노이만 병목 현상이 발생한다. ```RAM```과 ```CPU```의 속도 차이가 발생하는 하드웨어적 한계를 극복하지 못한 것이다. 또한 절차 언어는 많은 자료를 동시에 적용하는 연산, 아직 계산할 값이 아직 할당되지 않은 비결정적인 연산, 혹은 순서에 의존하지 않는 비절차적인 연산을 기술하는 데에 비효율적이다. 그래서 이 한계를 극복하기 위해 나온 방식이 바로 함수형 언어와 논리형 언어이다.

```
// 절차형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램

// 단계 1: 사용자로부터 두 수를 입력받기
var num1 = parseFloat(prompt("첫 번째 숫자를 입력하세요:"));
var num2 = parseFloat(prompt("두 번째 숫자를 입력하세요:"));

// 단계 2: 입력받은 수를 더하기
var sum = addNumbers(num1, num2);

// 단계 3: 결과 출력
alert("두 수의 합은 " + sum + "입니다.");

// 함수: 두 수를 더하는 함수 정의
function addNumbers(a, b) {
  return a + b;
}
```

함수형 언어 (```Functional Language```)는 알려진 값들을 함수들에 적용하는 것을 기반에 둔다. 함수형 언어에서의 계산은 아래의 예시와 재귀적 함수를 활용해 기술된다. 함수형 언어에서의 함수는 함수에 변수를 할당하거나 인자로 전달할 수 있는 일급 객체 (```First-Class```)로 취급하면서, 주어진 입력에 대해 항상 동일한 출력을 생성하는 불변성 (```Immutability```)의 특성을 가진다. 실제로 함수형 언어는 변수나 변수에 대한 배정문이 존재하지 않는 대신 함수와 함수를 평가하고 호출하는 방법을 제공한다.

```
// 함수형 프로그래밍 방식으로 두 수를 더하는 간단한 계산 프로그램

// 단계 1: 사용자로부터 두 수를 입력받기
var num1 = parseFloat(prompt("첫 번째 숫자를 입력하세요:"));
var num2 = parseFloat(prompt("두 번째 숫자를 입력하세요:"));

// 단계 2: 두 수를 더하는 함수 정의
function addNumbers(a, b) {
  return a + b;
}

// 단계 3: 입력받은 수를 더하기
var sum = addNumbers(num1, num2);

// 단계 4: 결과 출력
alert("두 수의 합은 " + sum + "입니다.");
```

논리형 언어 (```Logical Language```)은 논리적인 규칙과 규칙 간의 관계를 정의해, 순서가 아닌 무엇을 하고자 하려는지 기술하는 방식으로, 계산의 내용만을 선언하듯이 기술한다. 그렇기 때문에 논리형 언어는 선언적 언어 (```Declarative Language```)로 불리기도 한다. 그래서 논리형 언어에서의 변수는 기억 장소의 위치보다는 계산 과정의 중간 결과 값에 대한 이름의 성격이 강하다.

```
// 규칙 정의
function isHuman(animal) {
  return animal.species === 'Human';
}

function canSpeak(animal) {
  return animal.canSpeak === true;
}

// 사람 객체 생성
const person = {
  species: 'Human',
  canSpeak: true
};

// 규칙을 통한 논리적 추론
if (isHuman(person) && canSpeak(person)) {
  console.log('This is a speaking human.');
} else {
  console.log('This is not a speaking human.');
}
```

객체 지향 (```Object-Oriented```) 언어는 여기서 한 발 더 나아가, 프로그램을 단순히 데이터와 이를 처리하는 방법으로 나누지 않고 수많은 객체들의 집합으로 보았다. 메소드와 변수를 가지는 객체라는 추상적인 개념을 프로그램에 도입하고 이를 객체의 상호 작용으로 봄으로써, 이전에 존재하던 지나치게 많은 이름의 생성으로 인한 네임스페이스 포화 문제를 해결하고 큰 문제를 작은 문제를 하기 위한 객체들로 해결하는 상향식 (```Bottom-up```) 해결 방식을 적용하는 것이 가능해졌다.

```
// 클래스 정의
class Animal {
  constructor(species, canSpeak) {
    this.species = species;
    this.canSpeak = canSpeak;
  }
}

// Human 클래스 정의, Animal 클래스를 상속받음
class Human extends Animal {
  constructor(canSpeak) {
    // Human은 species가 'Human'으로 고정된다고 가정
    super('Human', canSpeak);
  }

  isSpeakingHuman() {
    return this.species === 'Human' && this.canSpeak === true;
  }
}

// 사람 객체 생성
const person = new Human(true);

// 객체지향 방식의 논리적 추론
if (person.isSpeakingHuman()) {
  console.log('This is a speaking human.');
} else {
  console.log('This is not a speaking human.');
}
```

이제 다시 자바스크립트가 탄생하던 시점으로 돌아오자. 자바스크립트가 탄생한 시점에는 이전에 정적으로만 존재하던 페이지가 브라우저를 통해 동적으로 페이지를 변경하는 방식이 공개되면서 브라우저에서 사용할 언어나 기술이 요구되고 있었다. ```Java Applet```처럼 웹 브라우저에 ```Java``` 어플리케이션을 내장해 동적인 페이지를 제공하는 방식으로 동작하는 기술이 있었지만, 성능 및 보안 이슈가 존재하였다. 이때 자바스크립트는 강력한 추상화와 인터프리터 방식를 내세워 꾸준히 개발자들을 유입하였고, ```Ajax```와 ```JQuery```, ```Node.js```를 통해 기존에 가진 문제점 또한 개선해나갔다.

자바스크립트의 강력한 추상화는 앞서 언급한 여러 언어들의 장점들을 채택하는 데에서 비롯되었다. 자바스크립트는 함수형 언어라고 부르지만, 객체나 함수를 통한 추상화를 지원하면서 변수를 선언할 때 타입을 명시적으로 지정할 필요가 없는 동적 타이핑 (```Dynamic Typing```) 또한 지원한다. 또한 ```async```, ```Ajax```와 같은 비동기 이벤트의 처리를 위해 콜백 (```Callback```)과 프로미스 (```Promises```) 또한 지원한다.

인터프리터 방식은 소스 코드를 한 줄씩 기계어로 번역하는 방식이므로 컴파일 방식에 비해 속도는 느리지만, 어떤 코드를 작성한 다음 바로 실행하여 문제가 있으면 바로 수정할 수 있는 디버깅이 가능하다. 그리고 반복적으로 쓰이는 함수, 클래스의 기계어를 캐싱하는 ```JIT``` 컴파일러를 인터프리터에 내장하여 속도 또한 이전에 비해 개선되었다. ```JIT``` 컴파일러를 통해 오류가 있어도 그전까지 계속 실행되거나 오류를 오류로 처리하지 않는 경우 또한 줄어들었다.

> 1. 파싱 (```Parsing```) : 소스 코드가 먼저 브라우저 엔진에 의해 파싱되어 코드의 문법적 구조를 이해하기 위한 토큰들이 생성
> 2. ```AST``` (```Abstract Syntax Tree```) 생성 : 파싱된 토큰들은 코드의 추상 구문을 나타내는 트리 구조인 ```AST```로 변환
> 3. 바이트코드 생성 : 코드를 실행 가능한 형태로 변환하기 위한 중간 단계의 표현 생성
> 4. (```JIT``` 컴파일) 후 실행 : 변환된 코드는 런타임 환경에서 실행되거나, ```JIT``` 컴파일러에 의해 기계 코드로 컴파일되어 실행

그리고 인터프리터 방식의 장점 중 하나는 프로그래밍 언어의 설계가 쉽다는 점이다. 컴파일 언어가 설계되려면 기계어에 대한 이해가 필요하지만, 스크립트 언어는 컴파일 언어나 심지어 스크립트 언어를 통해 구현될 수 있다. 타입스크립트가 바로 대표적인 예시로, 최근에는 앞서 정의한 타입스크립트 문법을 활용해 다시 문법을 만드는 것 또한 이루어지고 있다.

그렇다면 자바스크립트가 브라우저에서 어떻게 동작하는 걸까? 클라이언트 측에서 동작하는 자바스크립트는 브라우저가 웹 페이지를 로딩할 때 ```<script>``` 태그를 통해 위의 컴파일 과정이 이루어진 다음에 단일 스레드로 동작하며, 이벤트 기반 비동기 모델을 활용한다. 이런 비동기 작업을 위해 브라우저는 추가로 이벤트 큐와 이벤트 루프를 활용하고 자바스크르립트 또한 콜백 함수와 ```Ajax``` 처리를 지원한다.