---
title: "[Operation System] 7. Paging"

tags:
    - Operation System

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2022-12-12
---

## 페이징 (```Paging```) : 프로그램과 메모리를 일정한 크기로 나눔

- 가상 주소 (```Virtual address```) : 프로그램이 가상 메모리에서 참조하는 주소
  - 가상 메모리 (```Virtual Memory```)가 있다면, 각 프로그램은 자신의 고유한 가상 주소 공간을 가짐
    - 가상 메모리 사용 ```O``` : 가상 주소가 그대로 메모리 버스에 실려 물리 주소가 됨
    - 가상 메모리 사용 ```X``` : 가상 주소가 ```MMU```에 의해 물리 주소로 매핑

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F77cc13d2-02da-4be4-9ff6-369f0dbc4b26%2F페이징2.PNG"  width="66%" style="margin-left: 2%">

- 가상 주소 공간과 물리 주소 공간은 고정된 크기 단위의 유닛들로 동일하게 나뉜다.
  - 가상 페이지 (```Virtual Page```) : 가상 주소 공간을 나눈 조각. 각 페이지는 연속된 주소를 가짐
  - 페이지 프레임 (```Page Frame```) : 물리 메모리를 나눈 조각.

> - 다음 그림에서는 가상 주소 공간을 ```64KB```, 물리 메모리 공간을 ```32KB```, 유닛 크기는 ```4KB```로 가정하고 있다.
> 
> <img src="https://d2vlcm61l7u1fs.cloudfront.net/media%2F814%2F8145fa33-a835-4aec-b761-957da632ac81%2FphpBxgNnp.png" width="80%" style="margin-left: 2%">
> - 논리 주소 (```logical address```) : 세그먼트 (```segment```) + 오프셋 (```offset```)
>   - 세그먼트 (```segment```) : ```64KB```의 고정된 길이와 시작 위치으로만 구성
>   - 오프셋 (```offset```) : 세그먼트의 시작 지점에서 실제 주소까지 떨어진 거리
> - 가상 주소 (```virtual address```) : ```single 32-bit unsigned integer```
>   - 가상 페이지는 ```16```진수로 표현 (```16bit```) : ```0x00000000``` ~ ```0xffffffff```의 범위 (```4096bit```=```4KB```)
> - 물리 주소 (```physical address```) : 물리 메모리에서 각각의 셀 (```cell```)의 주소
>   - 페이지 프레임은 가상 페이지가 매핑되는 물리 메모리의 일부분(```4096bit```=```4KB```)
>
> > 명령어 ```MOV REG, 0```을 수행한다고 가정해보자.
> > - 이 명령어에서 접근하는 가상 주소 0는 MMU로 전달된다.
> > - ```MMU```는 해당 가상 주소가 가상 페이지 0에 속한 것임을 확인한다.
> > - ```MMU```는 가상 페이지 0에 매핑된 물리 주소의 페이지 프레임이 2임을 계산한다.
> > - 가상 주소 0은 물리 주소 8192로 변환되고, 이 물리 주소가 메모리 버스에 실린다.
>
> ... 가상 페이지를 페이지 프레임에 매핑하는 것만으론, 가상 주소 공간이 물리 주소 공간보다 큰 문제를 해결하지 못한다.

### 페이지 폴트 (```Page Fault```) : 페이지가 메모리에 매핑되어 있지 않음을 파악하면 ```CPU```에서 트랩 발생
- ```present``` 비트 : 어떤 페이지가 실제 메모리에 존재하는지 표현하는 비트 (가상 페이지에 ```X```로 표현)
  - 페이지가 메모리에 매핑되어 있지 않으면, ```CPU```에서 트랩을 발생시켜 운영체제에 이를 알림
- ```Page Fault```가 발생하면, 운영체제는 적게 사용되고 있는 페이지 프레임을 하나 선택
  1. 선택한 페이지가 수정되었다면 (```dirty``` 상태) 이를 디스크에 기록
  2. 선택한 페이지가 수정되지 않았다면 (```clean``` 상태) 디스크에 존재하는 것과 동일하니 기록하지 않음
  3. 선택한 기존 페이지의 내용을 지우고, 참조하려는 페이지의 내용을 페이지 프레임에 적재
  4. 선택한 기존 페이지 프레임을 ```X```로, 참조한 페이지 프레임을 숫자로 매핑시켜 가상 페이지 맵 수정
  5. 트랩이 발생한 명령어를 다시 실행

> 명령어 ```MOV REG, 24576```을 수행할 때 ```Page Fault```가 발생해 OS에서 페이지 프레임 1을 교체한다고 가정해보자.
> - 가상 페이지 1이 더 이상 매핑되지 않음 (```X```)을 표시한다.
> - 가상 페이지 7이 페이지 프레임 1에 매핑되었음을 표시한다.

### 페이징 테이블 (```Page Table```) : 가상 페이지 번호 (```VPN```)를 페이지 프레임 번호 (```PFN```)로 매핑

> 위의 매핑 정보를 바탕으로 가상 주소 ```8196```를 물리 주소 ```24580```로 변환하는 과정을 가정해 살펴보자.
> 
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F1e02251d-f340-4f21-a40a-ece83ef34966%2F페이지테이블1.PNG" width="80%" style="margin-left: 2%">
>
> - 16비트 크기를 갖는 가상 주소는 ```VPN```와 오프셋으로 구분된다.
>   - 페이지 번호는 페이지 테이블의 인덱스로 사용된다.
> - 페이지 테이블에는 ```VPN```에 대응되는 ```PFN```이 기록되어 있다.
>   - ```present```가 1이면, 페이지 테이블의 ```PFN``` 3과 가상 주소의 오프셋 12가 결합해 물리 주소가 된다.
> - 물리 주소를 주소 출력 레지스터를 통해 메모리 버스로 전달해 참조한다.
>
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F3e57db8f-32a6-4eb8-9aae-401f58178f5a%2F페이징주소변환.PNG" width="80%" style="margin-left: 2%">

- 페이지 테이블엔 디스크에 존재하는 페이지의 디스크 주소에 대한 정보가 없음 (```Page Fault``` : 운영체제 내부에서 처리)
  - 메모리에 존재하는 페이지 주소에 대한 정보만 존재 : 하드웨어가 가상 주소를 물리 주소로 변경할 때 사용

<img src="https://examradar.com/wp-content/uploads/2019/03/page-table-entry.png" width="80%" style="margin-left: 2%">

- 페이지 테이블의 각 페이지에 존재하는 정보
  - 페이지 프레임 번호 (```PFN```) : 가상 주소를 물리 주소로 매핑
    - 해당 페이지가 매핑된 물리 주소 결정
  - ```Present``` 비트 : ```PFN```이 유효한지 아닌지 결정 (가상 주소가 사용될 때마다 확인)
    - 0 (```X```)이면 해당 엔트리에 대응되는 페이지가 물리 메모리에 존재하지 않는 상태 (트랩 발생)
  - ```Protection``` 비트 : 어떤 접근이 허용되는지 표시
    - ```write```, ```read```, ```execute```
  - ```Modify``` 비트 : 페이지가 수정되었는지 아닌지 확인
    - 페이지의 내용이 ```write```되면, 하드웨어가 자동으로 비트를 1로 세팅
      - ```Modify``` 비트가 1 (```dirty```)이면, 페이지 프레임이 교체될 때 디스크에 기록되어야 함
      - ```Modify``` 비트가 0 (```clean```)이면, 페이지 프레임이 교체될 때 새로운 내용으로 덮어씌워도 됨
  - ```Reference``` 비트 : 해당 페이지가 ```write``` 또는 ```read```로 접근되었을 때 설정
    - 운영체제가 ```Page Fault```의 처리를 위해 교체할 페이지 프레임을 선택할 때 사용
  - ```Cashing Disabled``` 비트 : 해당 페이지가 캐싱될 수 있는지 여부
    - 페이지가 메모리가 아닌 장치 레지스터에 매핑되어 있을 때 실행

> > - ```64bit``` 주소를 사용하는 컴퓨터는 가상 주소 공간이 ```2^64byte```
> > - 가상 주소 공간의 한 페이지가 ```4KB = 2^12byte```이면,
> >   - 페이지 테이블의 엔트리 개수는 전체 공간을 한 페이지로 나눈 ```2^52```개
> >   - 엔트리 하나당 ```4byte```의 크기를 가진다면, 페이지 테이블의 크기는 ```2^52 * 4byte```
> 
> ... 페이징은 다음 두 가지 문제를 해결해야 한다.
> - 가상 주소 공간이 커지면, 페이지 테이블의 크기 (= 페이지 테이블 엔트리의 개수) 또한 증가한다.
>   - 페이지 테이블을 유지하기 위해 필요한 메모리의 크기가 클 수 있음
> - 가상 주소에서 물리 주소로의 변환이 빠르게 이루어져야 한다.
>   - 메모리를 참조하는 오버헤드가 작아야 함

### ```TLBs``` (```Translation Lookaside Buffers```) : 페이징의 속도를 높이고, 큰 가상 주소 공간을 지원하는 기법

> 대부분의 프로그램들은 적은 개수의 페이지를 집중적으로 참조하는 경향이 있다.
> - 페이지 테이블의 일부 엔트리만이 높은 빈도로 참조되고, 나머지 엔트리는 낮은 빈도로 참조된다.

- ```TLB``` : 페이지 테이블의 참조 없이 가상 주소를 물리 주소로 매핑할 수 있는 작은 크기의 메모리
  - ```MMU``` 내부에 존재하며, 적은 개수의 엔트리를 가짐
    - 각각의 ```TLB``` 엔트리는 한 페이지에 대한 정보를 포함

> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2F8b9807f3-f9d5-437a-8110-25ff5a9aad4a%2FTLB2.PNG" width="80%" style="margin-left: 2%">
>
> 1. ```MMU```는 주소 변환을 할 때 요청된 가상 페이지가 ```TLB```에 있는지 검색
> 2. 가상 페이지가 존재하고 보호코드를 위반하지 않으면, 대응되는 페이지 프레임을 사용하여 주소 변환을 실행
> 3. ```TLB```가 존재하지 않으면, ```TLB miss``` 발생. ```MMU```는 페이지 테이블에서 해당 페이지 테이블 엔트리를 검색
> 4. 그리고 ```TLB``` 엔트리 중 하나를 선택해 그 내용을 교체. 페이지 테이블에 없는 수정 비트는 페이지 테이블에 기록
> 5. 찾은 페이지 테이블 엔트리를 ```TLB``` 엔트리에 기록 (이때 다시 참조한다면 ```TLB hit```로 처리)
> 6. 새로운 정보가 적재될 때는 페이지 테이블 엔트리에 있는 내용이 적재

- 메모리 계층 구조에서 발생할 수 있는 ```miss```의 경우의 수 : ```2^3```가지 ```->``` 실제 발생 가능한 경우의 수 : ```5```가지
<div style="text-align: center;">
  <table>
	  <thead>
		  <tr>
			  <td>Cache</td>
        <td>TLB</td>
        <td>Virtual Memory</td>
        <td>발생 가능 여부</td>
			  <td>설명</td>
		  </tr>
	  </thead>
	  <tbody>
		  <tr>
			  <td>hit</td>
        <td>hit</td>
        <td>hit</td>
        <td>가능 (최선)</td>
			  <td>(1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X)<br>(2) Cache가 hit이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 있음</td>
		  </tr>
		  <tr>
			  <td>miss</td>
        <td>hit</td>
        <td>hit</td>
        <td>가능</td>
			  <td>(1) TLB가 hit이므로, 페이지 테이블을 확인할 필요 없이 가상 주소를 물리 주소로 변환 (메인 메모리 접근 X)<br>(2) Cache가 miss이므로, 변환한 물리적 주소로 캐시에 접근하면 데이터를 가져올 수 없음<br>(3) Virtual Memory가 hit이므로, 캐시에 데이터를 불러오기 위해 메모리에 접근하면 데이터를 가져올 수 있음<br>(4) 메모리에서 캐시로 가져온 데이터를 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>hit</td>
        <td>miss</td>
        <td>hit</td>
        <td>가능</td>
			  <td>(1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O)<br>(2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환<br>(3) Cache가 hit이므로, 변환한 물리 주소로 캐시에 접근해 캐시에 있는 데이터를 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>miss</td>
        <td>miss</td>
        <td>hit</td>
        <td>가능</td>
			  <td>(1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O)<br>(2) Virtual Memory가 hit이므로, 가상 주소를 물리 주소로 변환<br>(3) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음<br>(4) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>miss</td>
        <td>miss</td>
        <td>miss</td>
        <td>가능 (최악)</td>
			  <td>(1) TLB가 miss이므로, 페이지 테이블에 접근 (메인 메모리 접근 O)<br>(2) Virtual Memory가 miss이므로 (Page fault), 하드 디스크에서 데이터를 직접 가져와 페이지 테이블을 업데이트<br>(3) 이제 TLB가 miss > hit이므로, 가상 주소를 물리 주소로 변환 가능.<br>(4) Cache가 miss이므로, 변환한 물리 주소로 캐시에 접근하면 캐시 내에 데이터가 없음<br>(5) 메인 메모리에서 해당 데이터를 캐시로 가져와 CPU에 전달</td>
		  </tr>
      <tr>
			  <td>miss</td>
        <td>hit</td>
        <td>miss</td>
        <td>불가능</td>
			  <td>메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음</td>
		  </tr>
      <tr>
			  <td>hit</td>
        <td>hit</td>
        <td>miss</td>
        <td>불가능</td>
			  <td>메모리 계층 구조 위반 : Page fault인데 TLB가 hit일 수 없음</td>
		  </tr>
      <tr>
			  <td>hit</td>
        <td>miss</td>
        <td>miss</td>
        <td>불가능</td>
			  <td>메모리 계층 구조 위반 : Page fault인데 Cache가 hit일 수 없음 (캐시에 데이터가 있을 수 없음)</td>
		  </tr>
	  </tbody>
  </table>
</div>

> - ```TLB miss```인 경우 : 페이지 테이블에는 정보가 있지만, ```TLB```에 그 정보가 들어있지 않을 때
>   - 해결책 : 페이지 테이블의 페이지 엔트리 내 데이터를 가져와 ```TLB```에 넣음
> - ```Page fault```인 경우 : ```TLB```에도 정보가 없고, 페이지 테이블에도 그 정보가 없을 때
>   - 운영체제는 권한을 받아 하드 디스크의 데이터를 페이지 테이블에 가져오고, ```TLB```에 가져온 데이터를 넣음

### 다단계 페이지 테이블 (```Multi-level Page Table```)
- 페이지 테이블을 페이지 프레임 크기로 나눔
  - 해당 페이지 테이블의 페이지가 ```invalid```하면 메모리에 할당하지 않음
  - 기존의 단일한 페이지 테이블을 트리 구조로 연결
- 페이지 디렉토리 (```Page Dictionary```) : 페이지 프레임의 유무를 확인하는 자료구조
  - 적어도 하나의 ```PFN```이 ```valid```하다면, 페이지 디렉토리의 해당 엔트리는 존재함

> <img src="https://mblogthumb-phinf.pstatic.net/MjAxOTAyMTlfOCAg/MDAxNTUwNTA2MjIzODAw.Wv_UIJMhp3-_COSDHBtsqEz0OCp91j4zEc3Vr4lmWHQg.qFb-bL0s7WgeO7btb1857Ifsk_KZqW063BUihRmZd-wg.PNG.babobigi/Page_Table_비교.png?type=w2" width="80%" style="margin-left: 2%">
>
> - 기존의 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있음
> - 다단계 페이지 테이블에서, 가운데에 위치한 페이지는 메모리에 할당되어 있지 않음
>
> 다단계 페이지 테이블에서의 모든 페이지 테이블은 항상 메모리에 유지될 필요가 없다.

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fcf85f3b3-985d-4872-9030-eb337ae7dbbe%2F2단계페테2.PNG" width="80%" style="margin-left: 2%">

- 필요한 페이지 테이블만 메모리에 할당해 절약할 수 있음
- 페이지 디렉토리로 물리 메모리의 빈 공간에 페이지 테이블 엔트리를 생성 가능
- 기존의 ```TLB Miss```가 2번 늘어나 주소 변환이 2번 필요하고, ```TLB Miss```를 처리해 메모리를 최적화하는 로직이 복잡해짐

### 역 페이지 테이블 (```Inverted Page Table```)
- 빠른 하드웨어 레지스터로 구성된 단일한 페이지 테이블 사용
  - 페이지 테이블의 각 엔트리는 하나의 메모리 프레임에 대응
- 크기가 고정된 페이지 테이블에 프로세스를 맵핑
  - 프로세스 실행 시 운영체제는 메모리에 존재하는 프로세스의 페이지 테이블 전체를 하드웨어 레지스터 배열에 적재
- 논리 주소는 ```PID```, ```PFN```, ```offset```으로 구성
- 물리 주소는 ```MFN```와 ```offset```으로 구성

<img src="https://i0.wp.com/blog.skby.net/wp-content/uploads/2020/03/역페이지테이블-구성도.png" width="80%" style="margin-left: 2%">

1. 논리 주소의 ```PID```와 ```PFN``` 정보를 바탕으로 페이지 테이블에서 동일한 엔트리 탐색
2. 페이지 테이블에서 ```PID```와 ```PFN```가 일치하는 (```MFN```)번째 항목을 발견
3. ```MFN```과 ```Offset``` 정보를 바탕으로 확인된 메모리 주소에 접근


> - ```64bit```를 사용하는 컴퓨터에서 ```256MB```의 물리 메모리가 ```4KB``` 페이지 프레임 ```2^18```개로 구성되었다면,
>   - 페이지 테이블을 사용할 때의 페이지 테이블의 엔트리는,
>     - 가상 주소 공간 ```2^64byte```을 한 페이지 프레임의 크기 ```4KB = 2^12byte```로 나눈 ```2^52```개
>   - 역 페이지 테이블을 사용하는 페이지 테이블의 엔트리는 물리 메모리의 페이지 프레임의 개수와 같으므로,
>     - 물리 메모리 ```256MB = 2^28byte```를 한 페이지 프레임의 크기 ```4KB = 2^12byte```로 나눈 ```2^16```개

- 프로세스 실행 중엔 페이지 테이블을 위한 추가적인 메모리 참조가 필요 없음 (프로세스 확장이 페이지 테이블과 무관)
- 페이지 테이블이 커질수록 구현을 위한 비용이 증가하고, 최악의 경우 페이지 테이블 전체를 적재해야 함 ex) 문맥 교환