---
title: "[Operation System] 8. Page Replacement Algorithm"

tags:
    - Operation System

toc: true
toc_sticky: true

date: 2022-10-07
last_modified_at: 2022-12-12
---

## 페이지 교체 알고리즘 (```Page Replacement Algorithm```) : 페이지 폴트 시 교체할 페이지 선택

- 교체한 페이지가 다시 필요해져 페이지 폴트가 발생하는 비율을 줄여야 함 : 자주 사용되지 않을 페이지를 선택해야 함
  - 제거할 페이지 중 최고의 페이지는 가장 긴 시간동안 접근하지 않을 페이지

### 최적 페이지 교체 알고리즘 (```Optimal Page Replacement Algorithm```) : 가장 사용하지 않을 페이지 교체
- 운영체제가 모든 페이지 참조를 수집했다고 가정하면, 각 페이지들이 몇개의 명령어 뒤에 처음으로 참조되는지 알 수 있음
- 그 중 가장 많은 명령어 뒤에 참조되는 페이지를 교체

> 페이지 폴트가 발생했을 때, 운영체제가 각 페이지들이 어느 시점에 참조되는지 알 수 없음
> - 프로세스를 처음 돌린 뒤에 수집된 정보를 바탕으로 사용 가능

### ```NRU``` (```Not Recently Used```) 페이지 교체 알고리즘 : 최근에 사용되지 않은 페이지 교체
- 가상 메모리를 지원할 때, 각 페이지마다 운영체제가 페이지 사용 정보를 수집하기 위한 2개의 상태 비트를 유지
  - ```R``` (```Reference``` 비트) : 페이지가 참조될 때마다 설정 (```read```/```write```)
  - ```M``` (```Modify``` 비트) : 페이지가 수정될 때 마다 설정 (```clean```/```dirty```)
- 최근에 참조되지 않은 페이지를 참조된 페이지와 구별하기 위해 주기적으로 (```clock tick```마다) ```R```비트를 0으로 초기화
- 페이지를 4개의 클래스로 분류
  - 클래스 0 : ```R = 0, M = 0```
  - 클래스 1 : ```R = 0, M = 1```
  - 클래스 2 : ```R = 1, M = 0```
  - 클래스 3 : ```R = 1, M = 1```
- 페이지 폴트가 발생했을 때, 낮은 클래스에 있는 페이지 중 하나를 랜덤으로 교체
  - 참조도, 수정도 안된 클래스 3에 속한 페이지가 있으면 내쫓고,
  - 없으면 최소 한 사이클에서 참조되지 않은 클래스 2에 속한 페이지가 있으면 내쫓고,
  - 없으면 자주 참조되지만 수정되지 않은 클래스 1에 속한 페이지가 있으면 내쫓고,
  - 없으면 참조도, 수정도 이루어진 클래스 0에 속한 페이지가 있으면 내쫓는다.

> 가장 최근에 참조되지 않은, 변경된 페이지의 교체가 집중적으로 참조된, 변경되지 않은 페이지의 교체보다 좋음

### ```FIFO``` 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지 교체
- 메모리에 페이지들이 들어온 순서대로 링크드 리스트를 ```sorting```
- 페이지 폴트가 발생하면, 맨 앞에 들어온 것을 교체  

> - 메모리에 오래 있던 페이지가 자주 사용되는 페이지일 수 있음
>
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fc2b04476-5991-4656-a6d9-88aa883fa467%2Ffifo.PNG" width="80%" style="margin-left: 2%">
>
> - 벨레이디의 모순 (```Belady's anomaly```) : 페이지 프레임이 늘어나면, 페이지 폴트의 개수가 오히려 느는 경우
>
> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fe11c56af-54cc-45e8-93de-579d7b35e4e4%2F파이포.PNG" width="80%" style="margin-left: 2%">

### ```Second-Chance``` 페이지 교체 알고리즘 : 메모리에 가장 먼저 로드된 페이지의 ```R```을 검사한 후 교체
- 메모리에 페이지들이 들어온 순서대로 링크드 리스트를 ```sorting```
- 페이지 폴트가 발생하면, 가장 오래된 페이지의 ```R```을 검사
  - ```R = 0```이면, 이 페이지는 최근에 사용되지 않은 페이지이므로 교체해도 됨
  - ```R = 1```이면, 이 페이지를 맨 뒤로 옮기고, ```R```를 0으로 초기화 (적재 시간도 현재시간으로 갱신)하고 다시 검사

> 자주 참조되는 페이지를 교체할 가능성이 있는 ```FIFO```를 개선
> - 하지만, 페이지를 리스트 맨 뒤로 이동시켜아 하기 때문에 동작의 효율성이 떨어질 수 있음

### ```Clock``` 페이지 교체 알고리즘 : 시계 모양 원형 리스트를 구성하고, 화살표가 가리킨 페이지의 ```R```을 검사
- 메모리에 페이지들이 들어온 순서대로 원형 리스트를 ```sorting```
- 페이지 폴트가 발생하면, 화살표가 가리키는 페이지의 ```R```을 검사
  - ```R = 0```이면, 최근에 사용되지 않은 페이지이므로, 새로운 페이지 삽입 후 화살표를 다음 페이지로 이동
  - ```R = 1```이면, 이 페이지의 ```R```를 0으로 초기화하고 그 다음 페이지를 검사

<img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Fdcdc8fb8-202a-4637-a819-b7429c6b47ff%2F클록페이지교체.PNG" width="80%" style="margin-left: 2%">

### ```LRU``` 페이지 교체 알고리즘 : 가장 오랫동안 사용되지 않은 페이지를 교체
- 메모리에 페이지들이 들어온 순서대로 링크드 리스트를 ```sorting```
  - 가장 최근에 사용된 것을 리스트의 맨 앞에, 가장 오래된 것을 리스트의 맨 뒤에 오게끔 배치
- 페이지 폴트가 발생하면, 가장 맨뒤에 있는 페이지를 추출
  
> 모든 메모리의 참조마다 리스트를 갱신해야 함 : 리스트에서 페이지를 탐색, 삭제, 이동하는 작업은 오래 걸림

#### ```LRU```의 하드웨어 구현 1 : ```64bit``` 카운터
- 카운터가 명령을 실행할 때마다 ```C```값을 1씩 증가
- 각 페이지 테이블 엔트리는 카운터 값을 저장할 수 있는 공간을 가짐
- 메모리가 참조될 때마다 참조된 메모리를 담고 있는 페이지를 가리키는 페이지 테이블 엔트리에 ```C```값 저장
- 페이지 폴트가 발생하면, 모든 페이지 테이블 엔트리의 ```C```값을 조사해 가장 적은 값을 갖는 페이지를 교체
<br><br>

#### ```LRU```의 하드웨어 구현 2 : ```N*N bit```로 구성된 행렬을 갖는 ```LRU``` 하드웨어
- ```N```개의 페이지 프레임 -> ```N*N bit```로 구성된 행렬 : 행렬의 모든 값의 초기값은 ```0```
- 페이지 프레임 ```k```가 참조되면, ```LRU``` 하드웨어는
  - 행렬에서 ```k```번째 행의 모든 비트를 ```1```로 설정
  - ```k```번째 열의 모든 비트를 ```0```으로 설정
- 행의 이진 값이 가장 작은 행에 대응되는 페이지 프레임이 가장 과거에 참조된 것

> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Ffae59bc5-f57f-4328-9afc-aea0bbccdfcc%2Flrumatrix.PNG" width="80%" style="margin-left: 2%">
>
> 페이지가 ```0,1,2,3,2,1,0,3,2,3``` 순으로 참조되었다고 가정하자. 
> 1. 일단 ```1```행을 모두 ```1```로 ```0```열을 ```0```으로 초기화
> 2. ```1```행을 모두 ```1```로, ```1```열을 모두 ```0```으로 초기화
> 3. 페이지 폴트가 발생하면, 행 값이 제일 낮은 프레임을 교체 
> - 만약 그림 ```j```에서 페이지 폴트가 발생하였으면, ```2```행이 가장 낮으므로 프레임 ```2```를 교체

#### ```LRU```의 소프트웨어 구현 1 : ```NFU``` (```Not Frequently Used```)
- 각 페이지마다 각 페이지들이 얼마나 자주 참조되었는지 알려줄 소프트웨어 카운터를 유지 (카운터의 초기값은 0)
- 클록 인터럽트가 발생할 때마다 운영체제는 메모리의 모든 페이지를 검사하여 ```R```의 값을 소프트웨어 카운터에 더함
- 페이지 폴트가 발생하면, 가장 적은 카운터 값을 갖는 페이지가 교체

> ```NFU```에는 잊어버리는 기능이 부재되어 있다.
> - 다중 패스 컴파일러의 경우 : 패스 1에서 자주 참조된 페이지들은 높은 카운터 값을 가짐, 이는 패스 2에서도 유지
> - 만일 패스 1이 그 이후 다른 패스들보다 더 긴 실행 시간을 가진다면 혹은 패스 1에서 더 많은 참조가 일어난다면, 패스 1에서 실행된 페이지들은 그 이후 패스에서 사용되는 페이지들에 비해 더 큰 카운터 값을 가짐
>   - 그러므로 패스 1에 사용되던 페이지 대신 현재 패스에 사용하는 유용한 페이지들을 교체

#### ```LRU```의 소프트웨어 구현 2 : 에이징 (```Aging```)
- ```NFU```를 기반으로, 다음의 사항을 변경한다.
1. ```R```를 더하기 전에 오른쪽으로 1비트 시프트한다.
2. ```R```는 오른쪽 비트가 아닌 왼쪽 최상위 비트에 추가된다.

> <img src="https://velog.velcdn.com/images%2Fholicme7%2Fpost%2Feec8658e-0cbd-4fe7-b748-0792f10fa9dc%2FAGING.PNG" width="80%" style="margin-left: 2%">
> - 시간 순서를 구별할 정보를 기록
>   - ```LRU``` : 오직 하나의 비트로 참조 여부만 기록해, 페이지 3, 5 중 어떤 페이지가 더 먼저 참조되었는지 모름
>   - 에이징 : 시간 순서를 구별할 정보를 기록해, 2번의 클록 틱 전에 1번 더 참조된 페이지 5 대신 3 교체
> - 과거에 대한 정보를 제한
>   - ```NFU``` : 과거에 대한 정보를 모두 기억해 10번째 전에 참조되었는지, 100번 전에 참조되었는지 알 수 없다.
>   - 에이징 : 최대 ```N```번 전에 정보를 기록할 ```N```비트만이 존재해, 과거에 대한 정보를 제한된다.

#### 워킹 세트 알고리즘 (```The Working Set Page Replacement Algorithm```) : 페이지 집합 관리

> - 스레싱 (```Thrashing```) : 멀티 프로그래밍의 정도가 높아 페이지 폴트가 계속 발생해 페이지 교체 시간이 길어짐
>   - 멀티 프로그래밍의 정도가 높은 경우 : 여러 프로세스로 인해 프로세스가 충분한 페이지를 가지지 못함
>     - 어느 순간부터 ```CPU``` 점유율이 하락 (프로세스는 스와핑하느라 바쁜데, ```CPU```는 아무것도 안한다.)
>
> <img src="https://mblogthumb-phinf.pstatic.net/MjAxODExMDRfMjQ0/MDAxNTQxMzE5Mjc3ODM1.bCiSuD2-2aXc04gk2DAj-JDCsK_x9DU4qbT8oxnDboMg.b6_rzAgTlHnGXp01pLYY2MXkldo5oXJ3lihOgoDxk7Ug.PNG.qbxlvnf11/7eDqXQF.png?type=w800" width="80%" style="margin-left: 2%">
> 
> - ```Demand Paging``` : 실제로 필요할 때 (요청이 있으면) 그 page를 메모리에 올린다.
>   - 프로세스가 시작될 때 메모리에는 어떤 페이지도 존재하지 않음
>   - ```CPU```가 첫 명령어를 ```fetch```하면 페이지 폴트를 통해 운영체제가 로드
> - 참조의 지역성 (```Locality of reference```) : 프로세스는 작은 페이지만을 집중적으로 참조하는 경향이 있음
>   - ```locality set``` : 집중적으로 참조되는 해당 페이지의 집합

- 워킹 세트 (```Working Set```) ```W(K, T)``` : 프로세스가 현재 사용하고 있는 페이지의 집합
  - 워킹 세트의 ```locality set``` : 프로세스가 일정 시간 원활히 수행되기 위해 한번에 올라와야 하는 페이지들의 집합

> 워킹 세트를 (시간 ```T```)에 대해, 가장 최근에 (횟수 ```K```번) 발생한 메모리 참조에 의해 사용된 페이지의 집합이면,
> - 뒤의 페이지가 앞의 페이지를 포함하니 ```K```를 늘리수록 커지다가, (가상 페이지의 개수가 한정되어) 한 곳에 수렴
>
> <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSg1a1RbKAR6Xz4RjQ0lNoOr_jPwb1u1lXW1w&usqp=CAU" width="50%" style="margin-left: 2%">

- 워킹 세트 모델 (```Working Set```)
  - ```PrePaging``` : 각 프로세스의 워킹 세트를 추적하다, 프로세스가 실행되기 전 그 프로세스의 워킹 세트 미리 로드
  - 주기적인 인터럽트가 ```R```을 일정 시간마다 초기화
  - 페이지 폴트가 발생하면, 페이지 테이블을 스캔해서 쫓아낼 페이지를 탐색
  - 해당 프로세스의 워킹 세트 전체를 한꺼번에 메모리에 올라갈 수 있는 경우에만 메모리에 할당
    - 그렇지 않을 경우, 모든 페이지 프레임들을 모두 반납시키고 디스크로 ```swap-out``` (스레싱 방지)
<br><br>

- 워킹 세트 윈도우 (```Working Set Window```) : 올라올 워킹 세트를 결정 (워킹 세트 윈도우의 크기 : ```T```)
  - 페이지가 참조된 시점부터 ```T``` 시간 동안 메모리에 유지하고, 그 시점이 지나면 메모리에서 지움
- 메모리에 있는 프로세스들의 워킹 세트 크기의 합이 페이지 프레임의 수보다 클 경우 : 일부 프로세스를 ```swap-out```
  - 남은 프로세스의 워킹 세트가 메모리에 모두 올라가게 해 이를 우선적으로 충족 (멀티프로그래밍의 정도를 줄임)
- 워킹 세트를 모두 할당한 후에도 페이지 프레임이 남으면, ```swap-out```된 프로세스를 메모리에 올려 워킹 세트 재할당

> - 현재 가상 시간 (```Current virtual time```) : 프로세스가 시작된 후에 CPU를 실제 사용한 시간
> - 마지막으로 사용한 시간 (```Time of last use```)
> 
> <img src="https://camo.githubusercontent.com/d45e4dee2f521e74871e7a94b7af0510f03e27256546b5aaef4892cb6cee44ef/68747470733a2f2f736c696465706c617965722e636f6d2f736c6964652f313635393339362f372f696d616765732f32342f576f726b696e672b7365742b616c676f726974686d2b6167652b2533442b63757272656e742b7669727475616c2b74696d652b2545322538302539332b74696d652b6f662b6c6173742b7573652e6a7067" width="80%" style="margin-left: 2%">
>
> - 페이지의 현재 가상 시간이 ```2204```일 때 페이지 폴트가 발생하면,
>   -  페이지 테이블을 모두 스캔하면서 ```R```을 체크한다.
>     - ```R = 1``` : 마지막으로 페이지를 사용한 시간을 현재 가상 시간으로 바꾼다.
>     - ```R = 0``` : ```age``` = (현재 가상 시간 - 마지막으로 페이지를 사용한 시간)와 ```T``` 비교
>       - ```age > T``` : 워킹 세트에 그 페이지가 포함되어 있지 않으므로, 그 페이지를 지우고 게속 스캔한다.
>       - ```age <= T``` : 가장 큰 ```age```를 만드는 페이지를 기억하고 계속 스캔한다.
>   - 마지막까지 스캔했을 때 (모든 엔트리가 ```age <= T```이면), 가장 큰 ```age```를 만드는 페이지를 지운다.
>   - 모든 엔트리가 ```R = 1```이면 (가장 큰 ```age```를 만드는 페이지를 모른다면), 한 페이지를 랜덤으로 지운다.

### 세그멘테이션 (```Segmentation```) : 하나의 가상 주소를 제공하는 페이징과 달리, 여러 개의 가상 주소 제공
- 프로세스를 논리적 내용을 기반으로 나누어서 메모리에 배치
  - 세그멘테이션 기법에서의 프로세스는 세그멘트 (```segment```)의 집합
    - 각 세그먼트는 자기만의 선형적인 주소 공간을 가짐
  - 페이징 기법에서는 주소 공간이 서로 충돌될 수 있지만, 세그멘테이션에서는 동적으로 테이블이 커지거나 줄어듬
<br><br>

- 세그먼트 테이블 : 각 엔트리의 논리 주소는 ```<segment-number, offset>```
  - 페이징과 달리 세그먼트의 크기는 일정하지 않기에 테이블에 ```limit``` 정보가 추가로 담겨 있음
  - 만약 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 프로세스가 강제 종료

> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fol2eM%2FbtrnC38FGmG%2FKv5nbXQG2rCUeck0pRS8I0%2Fimg.png" width="80%" style="margin-left: 2%">
>
> - 논리 주소 (2, 100) : 물리 주소 4400번지
> - 논리 주소 (1, 500) : 인터럽트로 인해 프로세스가 강제로 종료 (범위 벗어남)

- 세그멘테이션의 장점
  - 보호 : 세그먼테이션도 페이징처럼 ```r, w, x```를 테이블에 추가하는데, 프로세스를 논리적으로 나눠 비트 설정 간단
  - 공유 : 세그먼테이션은 정확히 code 영역만 나누기에 다른 영역을 포함할 확률이 높은 페이징보다 더 효율적

> ...하지만 세그멘테이션은 외부 단편화 문제를 해결하지 못해, 현재는 페이징 기법을 대부분 사용한다.
>
> - 외부 단편화 : 메모리 할당을 처음 시작할 때 크기가 서로 다른 프로세스로 인해 다양한 크기의 홀이 발생 (```checkerboarding```)
>   - 세그먼트를 논리적인 단위로 나눈 세그멘테이션 역시 외부 단편화로 인해 메모리 낭비가 큼
> - 세그멘테이션을 페이징 (```Paged segmentation```) : 펜티엄 (```Pentium```)
>   - ```cs```, ```ds```, ```ss```를 각각의 세그먼트가 아닌 하나의 주소 공간으로 통일해서 사용
>     - 그러므로 ```cs```, ```ds```, ```ss```는 다 같은 셀렉터 값을 가짐
>   - 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 2번
>     - ```CPU```의 세그먼트 테이블에서 주소 변환, 그리고 다음 페이지 테이블에서 주소 변환