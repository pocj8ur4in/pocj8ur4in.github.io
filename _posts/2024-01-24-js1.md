---
title: "[JS] 자바스크립트 (JavaScript)"

tags:
    - JS

toc: true
toc_sticky: true

date: 2024-01-24
last_modified_at: 2024-01-29
---

## 자바스크립트 (```JavaScript```) : 동적 클라이언트 사이드 스크립트 언어

> - 인터프리터 언어 (```Interpreter Language```) : 코드를 한 줄씩 읽어 해당 줄을 즉시 실행하는 프로그래밍 언어
>   - 런타임에 코드를 한 줄씩 해석해 실행 → 실행 단계에서 번역 (```Interpretation at Runtime```)
>   - 변수의 타입을 런타임에 동적으로 결정 → 동적 타이핑 (```Dynamic Typing```)
> 
> → 컴파일 언어에 비해 런타임은 비교적 느린 실행 속도를 갖고 있으나, 메모리를 비교적 작게 사용

- 웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 개발
  - 초창기에는 웹 서버로부터 전달받은 ```HTML/CSS```를 단순히 렌더링하는 수준에 머무름
  - 1999년, 비동기로 데이터를 교환하는 ```Ajax``` 기능이 도입돼, 필요한 데이터만 받아 렌더링하는 것이 가능해짐
  - 2006년, ```DOM```을 쉽게 제어할 수 있는 ```JQuery```가 등장
  - 2008년, 구글의 크롬 ```V8``` 자바스크립트 엔진으로 웹 서버에서 수행되던 로직이 브라우저로 이동
  - 2009년, ```Node.js```로 브라우저 이외의 환경에서도 자바스크립트 엔진을 동작시킬 수 있게 됨
    - 프런트엔드와 백엔드 모두에서 활용될 수 있는 동형성 (```isomorphic```)이 보장
    - 비동기 ```I/O```를 지원하고 단일 스레드 이벤트 루프를 기반하여, 실시간 데이터 처리가 빈번한 ```SPA```에 적합
      - ```SPA``` (```Single Page Application```) : ```React```, ```Vue.js``` 등
- 모든 브라우저에 내장된 브라우저 표준 프로그래밍 언어로 자리잡음
  - 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어 (```Interpreter Language```)
  - 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해, 비교적 속도가 느린 인터프리터의 단점 해결
  - 명령형 (```imperative```), 함수형 (```functional```), 프로토타입 기반 (```prototype-based```), 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

### ```Node.js``` : 브라우저 밖에서 자바스크립트 코드를 실행하게 해주는 런타임 환경

> ```HTML/CSS/JS```를 실행하여 웹 페이지를 브라우저 화면에 렌더링하는 브라우저와 달리, ```Node.js``` 는 브라우저 외부에서 자바스크립트를 실행할 수 있는 환경을 제공
>
> - 브라우저와 동일하게 자바스크립트의 코어인 ```ECMScript```를 제공
> - 파싱된 ```HTML``` 요소를 선택 및 조작하는 ```DOM API```이나 클라이언트 사이드 ```Web API```를 제공되지 않음
> - 파일을 생성 및 수정할 수 있는 파일 시스템 및 ```Node.js``` 고유 ```API``` 제공

- ```npm``` : ```Node.js```의 패키지를 관리할 수 있는 도구
  - ```Node.js```에서 사용할 모듈을 패키지화해 모아둔 저장소 및 패키지 설치 및 관리를 위한 ```CLI``` 제공
  - ```npx``` (```node package execute```)을 통해 패키지를 설치 및 실행
  - 국내에서는 패키지 중복 문제를 링크 방식으로 해결한 ```yarn```을 많이 사용하는 추세

## 변수 (```variable```) : 하나의 값을 저장할 수 있는 메모리 공간

> 변수 = 선언 + 식별자 + 타입 + 값 + 소코프

- 메모리 주소를 통해 값에 직접 접근하는 것은 위험 → 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음
- 변수 이름을 어떤 값을 구별해 식별 가능한 고유한 이름이란 의미에서, 식별자 (```Identifier```)라고도 함
  - 식별자는 값이 아닌 메모리 주소를 기억하고 있어, 식별자로 메모리 공간에 저장된 값에 접근

```
var userId = 1;
var userName = 'John';

var user = { id: 1, name: 'John' };

var users = {
    { id: 1, name: 'John' }
}
```

- 변수 선언 (```variable declaration```)을 통해 변수를 생성
  - ```var```, ```let```, ```const``` 키워드로 변수를 선언
  - 변수에 값을 할당하지 않았으면, 자바스크립트 엔진에 의해 ```undefined``` 값이 할당되어 초기화
  - 선언하지 않은 식별자에 접근하면 참조 에러 (```ReferenceError```)가 발생

### 호이스팅 (```Hoisting```) : 선언문을 코드 맨 위에 올려진 것처럼 동작시키는 것

> 평가 (```evaluation```) : 표현식을 해석해서 값을 생성하거나 참조하는 것
> 
> - 평가 ```=``` 인터프리터로서의 컴파일 (선언문 실행 + 호이스팅)
> - 인터프리터로서의 실행 순서 : 전역 코드 평가 → 전역 코드 실행 → 함수 코드 평가 → 함수 코드 실행 → 복귀

- 변수, 함수, 클래스와 같이 키워드를 사용해서 선언하는 모든 식별자는 호이스팅됨
- 스코프 별로 평가가 이루어지면서 호이스팅이 일어남 → 해당 스코프의 상단으로 올려 메모리 선점 (```Linking```)
  - ```let```, ```const```도 호이스팅되지만, 초기화되기 전에 접근하면 안됨 (```notInitializedYey``` 상태로 호이스팅)
  - 선언문이 없는 변수는 호이스팅되지 않으며, 평가한 다음에 코드를 실행할 때 정의

```
console.log(a);
var a = 10;
> undefined

let v;
console.log(v); // 에러

z = 9; // 암묵적으로 var로 정의
console.log(z);
> 9

console.log(globalThis['z']);

let z = 11; // 에러 (암묵적 정의 → 호이스팅)
```

> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/75425564-29bc-4aaa-8014-63a7d3b3a435">
>
> 코드를 평가하는 시점에 호이스팅이 일어나 선언부와 구현부로 구분
> 
> → 선언부는 스택 영역에, 구현부는 힙 영역에 저장
>
> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8e05cc2f-b9d6-45be-b681-73d0f6b98229" width="80%">

- 선언문의 실행 시점 : 선언문은 런타임 (```Runtime```)이 아닌 그 이전인 평가 과정에 실행
  - 소스 코드를 한 줄씩 순차적으로 실행하기 앞서, 먼저 소스 코드의 평가 과정에서 선언문을 먼저 실행
  - 즉, 식별자를 선언하는 선언문과 값을 할당하는 할당문의 실행 시점은 서로 다름

### 값 (```value```) : 표현식이 평가되어 생성된 결과

```
10 + 20; // 30
```

- 리터럴 (```literal```) : 사람이 이해할 수 있는 문자 혹인 기호를 통해 값을 생성하는 표기법

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/21a03922-1820-4bdd-82e9-844443ccedf3" width="80%">

- 표현식 (```expression```) : 값으로 평가될 수 있는 구문
  - 구문 (```statement```) : 프로그램을 이루는 기본 단위이자 최소 실행 단위 (선언문, 할당문, 조건문, 반복문 등)
    - 토큰 (```token```) : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

#### 데이터 타입 (```Date Type```) : 값의 종류

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/f0c2d012-dc6b-418d-919f-b9dfa828448a" width="80%">

- 숫자 타입 : 정수 및 실수를 모두 포함하는 타입으로 존재 (<b>모든 수를 실수로 처리</b>)<br>→ 큰 수를 위한 ```BigInt``` 타입과는 다름! (```BigInt```는 객체 타입으로, 모든 수를 정수로 처리)
- 문자열 타입 : '', "", ``로 문자열을 감싼 텍스트 데이터
  - 템플릿 (```template```) 리터럴 : ``로 감싼 문자열 (```ES6```부터 도입)
    - 멀티라인 문자열 : 백슬레시 (```\n```) 없이 개행 가능
    - 표현식 삽입 : ```+```으로 ```${}```로 감싼 표현식을 문자열로 변환해 삽입할 수 있음
- 불리언 타입 : 참 (```true```)과 거짓 (```false```) → 제일 작은 값 (```1bit```)
- 심볼 (```symbol```) 타입 : 변경 불가능한 원시 타입 (다른 값과 중복되지 않는 유일무이한 값)
  - ```Symbol``` 함수를 호출해 생성되며, 값은 외부에 노출되지 않음 (```var key = Symbol('key');```)
  - 프로퍼티 값에 고유한 값을 저장하고 싶을 때 사용될 수 있음
- ```undefined``` 타입 : 변수 선언에 의해 확보된 메모리 공간은 쓰레기 값이 아닌 ```undefined```로 초기화
- ```null``` 타입 : 변수에 값이 없다는 것을 의도적으로 명시 (```intentional absence```)하기 위해 사용

### 동적 타이핑 (```Dynamic Typing```) : 변수를 선언할 때 데이터 타입을 사전에 선언하지 않음

- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론 (```Type Inference```)이 이루어짐
- 재할당에 의해 변수의 타입은 언제든지 동적으로 변화할 수 있음 (```loosely data```)

> 정적 타입 (```Static Typing```) : 변수를 선언할 때 데이터 타입을 사전에 선언
> 
> - 변수에 선언한 타입에 해당하는 값만 할당할 수 있음
> - 컴파일 시점에 타입 체크 (```Type Check```)를 수행하고, 통과하지 못하면 에러를 발생시킴
> - 타입의 일관성을 강제해 안정ㅇ적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임

- 자바스크립트는 ```var```, ```let```, ```const``` 키워드를 통해 변수만 선언
  - ```typeof()``` 연산자를 통해 피연산자의 데이터 타입을 문자열로 반환할 수 있음

> 동적 타이핑 및 동적 타입 언어의 단점?
>
> - 동적 타입 언어의 변수 값은 언제든지 변할 수 있음
>   - 복잡한 프로그램에서는 변수 값을 추적하기 어려울 수 있음
> - 동적 타입 언어의 변수는 값의 변경에 의해 타입 또한 언제든지 변경될 수 있음
>   - 값을 확인하기 전에는 타입을 확신할 수 없음
>   - 자바스크립트 엔진에 의해 타입이 자동으로 변환될 수도 있음
>
> → 동적 타입 언어는 유연성 (```Flexibility```)은 높지만 신뢰성 (```Reliability```)는 떨어진다.
>
>> 변수를 사용할 때 지켜면 좋은 규칙
>>
>> - 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
>> - 변수의 유효 범위인 스코프는 최대한 좁게 만들어 변수의 부작용을 억제한다.
>> - 전역 변수는 최대한 자제한다.
>> - 변수보다는 상수를 사용해 값의 변경을 억제한다.
>> - 변수 이름은 목적 및 의미를 파악할 수 있도록 네이밍하고, 특히 스코프가 넓을수록 명확하게 명명한다.

### 암묵적 타입 변환 : 자바스크립트 엔진에서 에러를 발생시키지 않도록 타입을 바꿔 표현식을 평가하는 것

- 문자열 타입 변환 : ```+```의 피연산자 중 하나가 문자열이면, 문자열 연결 연산자로 동작하므로 다른 것을 문자열로 변환
- 숫자 타입 변환 : 산술 및 비교 연산자의 피연산자 중에 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환
- 불리언 타입 변환 : 논리적 참/거짓을 평가하는 경우에 불리언 타입이 아닌 피연산자를 불리언 타입으로 변환

### 명시적 타입 변환 : 의도적으로 값의 타입을 변환하는 것 → 타입 캐스팅 (```type casting```)

- 문자열 타입으로 변환 : ```String()```, ```toString()```, 문자열 연결 연산자 ```+```
- 숫자 타입으로 변환 : ```Number()```, ```parseInt()/parseFloat()```, ```+```, ```*```
- 불리언 타입으로 변환 : ```Boolean()```, 부정 논리 연산자 ```!```를 2번

> 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것!
>
> - 원시 값은 변경 불가능한 값 (```immutable value```) → 기존 원시 값을 직접 변경 ✘
> - 자바스크립트 엔진에서 표현식을 평가하기 위해 피연산자의 값을 암묵적 타입 변환으로 새로운 타입의 값을 만듬

### 단축 평가 (```short-circuit evaluation```) : 표현식을 평가하는 중에 결과가 확정되면, 평가 과정을 생략

- 논리 평가 : 논리 연산자를 이용한 단축 평가 (좌항에서 우항으로 평가)
  - 논리곱 연산자 ```&&```는 두 피연산자가 모두 ```true```일 때, ```true``` 반환
    - 논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 반환
  - 논리합 연산자 ```||```는 두 피연산자 중 하나만  ```true```이여도, ```true``` 반환
    - 논리 연산의 결과를 결정하는 첫번째 피연사자를 그대로 반환

```
'Cat' && 'Dog' // true && 'Dog' → 'Dog'
'Cat' || 'Dog' // 'Cat'... → 'Cat'
```

> 논리 평가를 사용하는 경우?
>
> - 객체를 가리키기 기대하는 변수가 ```null``` 혹은 ```undefined```가 아닌지 확인하고 프로퍼티를 참조할 때
>
> ```
> var elem = null;
> // var value = elem.value; // TypeError
> var value = elem && elem.value; // null
> ```
>
> - 함수 매개변수에 ```undefined```가 할당되지 않도록 기본값을 설정할 때
>
> ```
> function getStringLength() {
> str = str || '';
> return str.length;
> }
> getStringLength(); // 0
> getStringLength('hello'); // 5
> ```

- 옵셔널 체이닝 (```Optional Chaining```) 연산자 ```?``` : 좌항의 피연산자가 ```null``` 혹은 ```undefined```이면 ```undefined```를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 그대로 진행함

```
var elem = null;
var str = '';

var value1 = elem?.value; console.log(value1); // undefined
var value2 = elem && elem.value; console.log(value2); // null
var value3 = str && str.length; console.log(value3); // ''
var value4 = str?.length; console.log(value4); // 0
```

- ```null``` 병합 연산자 ```??``` : 좌항의 피연산자가 ```null``` 혹은 ```undefined```이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환 → 변수에 기본값을 설정할 때 사용
  - 논리 연산자 ```||```를 사용한 단축 평가와 달리, 피연산자가  ```false```로 평가받는 ```Falsy``` 값이라도 ```null``` 혹은 ```undefined```이 아니면, 좌항의 피연산자를 반환함

```
var foo = null ?? 'default'; // 'default'
```

> - ```Falsy``` 값 : 피연산자가 ```false```로 평가받는 값
>   - ```false```, ```undefined```, ```null```, ```0```, ```-0```, ```NaN```, ```''```
> - ```Truthy``` 값 : 피연산자가 ```True```로 평가받는 값
>   - ```true```, ...

## 객체 (```Object```) : 소프트웨어에서 속성과 기능을 가지는 프로그램의 단위

- 원시 값을 제외한 나머지 값들, 즉 객체, 함수, 배열, 정규 표현식 등은 모두 객체 값

```
var person = {
  name: 'John', // "name: 'John'"은 프로퍼티, 
  age: 21       // "name"은 프로퍼티 키, "'John'"은 프로퍼티 값
};
```

→ 객체는 프로퍼티 및 메소드를 모두 포함하고 있어, 상태와 동작을 하나의 단위로 구조화할 수 있다.

- 객체는 변경 가능한 값 (```mutable```)
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값 (```Reference value```)에 접근
- 원시 값과 다르게 여러 개의 식별자들이 하나의 객체를 공유할 수 있음

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/66b574d8-6033-47c4-ac56-47dfd0440077" width="80%">

> - 원시 타입 (```Primitive```) : 값이 스택 영역에 들어감 (```Call-By-Value```) (```cf.``` 변수의 주소는 별도로 관리됨)<br>
>   → (자바스크립트 엔진에 따라) 힙 영역 내의 ```Symbol Table```이나 ```Constant Pool```에 들어갈 수 있음
> - 객체 타입 (```Object/Reference```) : 값이 힙 영역에 들어감 (```Call-By-Reference```)
>
> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/8dd9f8c1-57e3-4dda-8ea5-1358ef9db7dc" width="90%">
>
> 원시 타입과 객체 타입의 차이점? → 메모리 공간에 저장되는 위치에서 비롯된 차이!
>
> - 원시 값은 변경 불가능한 값 (```immutable```)이지만, 객체 값은 변경 가능한 값 (```mutable```)
> - 원시 값을 변수에 할당하면 변수에는 실제 값이 저장되나, 객체를 변수에 할당하면 변수에는 참조 값이 저장
> - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 (```Pass-By-Value```)되나, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 (```Pass-By-Reference```)
>
>> 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술!
>>
>> - 상수 (재할당이 금지된 변수) != 변경 불가능한 값 (읽기 전용 값)
>> - 처음 원시 값을 변수에 할당하면 실제 값이 저장되고, 값을 재할당하면 메모리 공간의 주소가 변경됨
>>
>> → 원시 값은 상태 변경을 금지해 불변성 (```Immutability```)을 보장하여, 데이터의 신뢰성을 보장한다!
>>
>> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/260dcc73-59bf-4cc7-93af-d24dea9d2518">
>>
>>
>> ```Call-By-Value```, ```Pass-By-Value``` 또한 엄격히 표현하면, 변수에 메모리 주소가 전달되는 것을 말한다!
>>
>> → 식별자는 메모리에 저장된 값을 식별해야 하므로, 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억한다.


> ```Constant Poll``` : 스택 영역과 힙 영역 외에 리터럴을 저장하기 위해 자바스크립트 ```V8``` 엔진에서 도입
>  
> <a href="https://hwan-shell.tistory.com/367"><img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/3d5b25eb-e794-444a-a999-6b9f3be49aee"></a>
>
> - ```Integer```가 저장되는 방식
>   - ```Integer```는 기본적으로 스택 영역의 ```SMI``` (```Small Integer```)에 저장
>   - ```32/64Bit OS```에서 ```32/64Bit```를 넘어서면 힙 영역의 ```Constant Poll```에 할당
>
> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/67d4d968-9ee8-42b7-9de5-4e87a0c31823">
>
> - ```String```이 저장되는 방식
>   - ```String```은 문자열으로 취급 → 모든 리터럴은 힙 영역의 ```Constant Poll```에 할당
>
> <img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/bf744728-8700-4846-b643-d076ca24712c">

### 객체 리터럴에 의한 객체 생성 : 중괄호 (```{}```) 내에 0개 이상의 프로퍼티를 정의

- 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성
- 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음 → 중괄호 뒤에 세미콜론을 붙이지 않음

```
var person = {
  name: 'John',
  sayHello: function() {
    console.log('Hello');
  }
}
```

> - ```C++```이나 ```Java``` → 클래스 (```Class```) 기반 객체지향 언어 : 클래스를 사전에 정의하고, 필요한 시점에 ```new``` 연산자와 함께 생성자 (```constructor```)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성
> - 자바스크립트 → 프로토타입 (```Prototype```) 기반 객체지향 언어 : 다양한 객체 생성 방법을 지원
>   - 객체 리터럴, ```Object``` 생성자, ```Object.create``` 메소드, 클래스 

### 프로퍼티 (```property```) : 객체의 상태를 나타내는 값 (```data```)

- 객체는 0개 이상의 프로퍼티의 집합 → 프로퍼티는 키 (```key```)와 값 (```value```)으로 구성
  - 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.
  - 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심볼 값 (```''```, ```""```, 식별자)
  - 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

```
var person = {
  name: 'John'
}
```

- 마침표 프로퍼티 접근 연산자 ```.```나 대괄호 프로퍼티 접근 연산자 ```[]```을 통해 프로퍼티 접근, 생성, 갱신, 삭제

```
// 프로퍼티 접근
console.log(person.name);
console.log(person[name]);
console.log(person[0]);

// 프로퍼티 갱신
person.name = 'Joo';

// 프로퍼티 동적 생성
person.age = 20;

// 프로퍼티 삭제
delete person.name;
```

- ```ES6``` 이후부터 객체 리터럴의 확장된 기능을 제공

```
// 프로퍼티 축약 표현
let name = 'Kim', age = 10;
const person = { name, age };

// 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const prefix = 'person';
let i = 0 ;
const obj = {
  [ ${prefix}-${++i} ] : i,
  [ ${prefix}-${++i} ] : i,
  [ ${prefix}-${++i} ] : i
};

// 메소드 축약 표현
const obj = {
  name: 'Lee',
  func() { console.log(this.name); }
};
```

> 자바스크립트 ```V8``` 엔진은 자바스크립트 객체의 프로퍼티에 접근하기 위해 동적 탐색 (```Dynamic Lookup```) 방식 대신, <a href="https://engineering.linecorp.com/ko/blog/v8-hidden-class">히든 클래스 (```Hidden Class```)</a> 방식으로 사용자 편의성과 일정한 성능을 모두 보장하고자 함

#### 메소드 (```method```) : 프로퍼티를 참조하고 조작할 수 있는 동작 (```behavior```)

- 자바스크립트의 함수는 일급 객체이므로, 값으로 취급할 수 있어 프로퍼티 값으로 사용할 수 있음
  - 일반 함수와 달리, 메소드는 객체에 묶어 있는 함수를 의미

```
var person = {
  name: 'John',
  getName: function() {
    return this.name;
  }
}
```

### 프로퍼티 키 (```Key```) 표현 규칙

```
const user = {
  '': 1,        
  ' ': 1,       // 'id': 1, '0y': 2 모두 OK!
  123: 1,       // user[123], user['123'] OK, but user.123 is SyntaxError!!
  12345n: 2,    // user[12345], user[12345n], user['12345'] OK, but user['12345n'] is undefined!
  true: 1,      // OK  user[true]  user.true
  id: 2,          
  [`name`]: 'Hong',  // But, `name`: 'Hong'은 SyntaxError: Unexpected template string!
  [Symbol()]: 'Hong',   // OK But, Symbol(): 'Hong'은 SyntaxError: Unexpected token ':'
  [`${new Date()}`]: 365,    // OK! 'Sun Jul …': 365
  'my-friends': ['Han', 'Kim'],
  getInfo: () => `${this.id}-${this.name}`,       // OK! But, this is not user!
  getInfo() { return `${this.id}-${this.name}`; }, // OK! getInfo의 최종 <f.o>
}
```

### 객체 - 프로퍼티 제어

```
console.log(Object.keys(user), Object.keys(user).length); // keys & 15, Symbol은 제외
console.log(Reflect.ownKeys(user), Reflect.ownKeys(user).length); // keys & 16 (+ Symbol)

user.addr = 'Seoul';   // ⇐⇒ user = {...user, addr: 'Seoul'}
console.log('addr' in user, user.hasOwnProperty('addr')); // true true
console.log('Ref.has>', Reflect.has(user, 'addr'));  // true
console.log('obj.getOwnPropSym>', Object.getOwnPropertySymbols(user)); // [ Symbol() ]

delete user.addr;    // ⇔ Reflect.deleteProperty(user, 'addr');
console.log('addr' in user); // false

user[`${user.id}'s name`] = `Mr. ${user.name}`;     // prop생성시 snapshot!!(id 변해도 고정)
console.log('user entries=', Object.entries(user)); // Symbol은 제외!!
```

### 객체 클래스 메소드 (```Object Class Methods```)



## 함수 (```function```) : 일련의 과정을 코드 블록으로 감싸 하나의 단위로 정의한 것

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/c6d16c9b-7b9c-4340-bbab-88b15bfd53db" width="80%">

- 자바스크립트의 함수는 객체 타입의 값 → 함수 또한 함수 리터럴 (```functional literal```)로 생성할 수 있음
  - 일반 객체와 달리, 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 가짐

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/05176279-d1d8-4756-8bb3-5186474aa123" width="80%">

### 함수 정의 : 함수를 호출하기 이전에 인수를 전달받을 매개변수, 문, 반환값을 지정하는 것

> 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되므로, 함수는 정의 (```definition```)된다.

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/0b6c992d-5608-47a8-b2bc-0af11c3c9b24" width="80%">

- 함수 리터럴는 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음
  - 함수 선언문은 표현식이 아닌 문 (```statement```) → 함수의 이름을 생략할 수 없음

> 함수 선언문은 표현식이 아닌 문이므로 변수에 할당될 수 없지만, 아래의 함수 선언문은 변수에 할당되는 것처럼 보인다.
>
> ```
> var add = function add (x, y) {
>   return x + y;
> };
> 
> console.log(add(2, 5));
> ```

## 스코프 (```Scope```) : 객체에서 접근할 수 있는 범위



## 실행 컨텍스트 (```Execution Context```) : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

```
var gg = 1;  let bb = 2;

function f1(x, y) {
  var gg = 11;   let bb = 22;
  console.log('f1>', gg, bb, zz, f2, f2.length);
  f2('first');
  { 
    const xx = 99;
    let lll = 0;
    f2('nest-first');
    var zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  function f2(t, u) { console.log(t, 'inner', xx, zz); }
  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); }
  var zz = 800;
  f2('second');
}

function f2(g) {
  console.log(g, 'global f2>', gg, bb, xx, kk);
}

let xx = 9;
if (gg > 0) { var kk = 33; var yy = 9; }

f1(1,2);   console.log(kk, yy);

f2('third');
```

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/40dca0b0-9e4b-44d6-a36c-83aee24fc2e3">

```(1)``` 전역 코드 평가 단계

```
var gg;  let bb;
function f1(x, y) { ... } // Function Object
function f2(g) { ... }    // Function Object
let xx;
var kk;
```

```(2)``` 전역 코드 실행 단계

```
var gg = 1;  let bb = 2;
let xx = 9;
if (gg > 0) { ... }
f1(1,2);   console.log(kk, yy);
f2('third');
```

```(3)``` 전역 코드 실행 단계 (```if```문 코드 블록 실행 및 종료)

```
if (gg > 0) { // var gg = 1;
  var kk = 33; var yy = 9;
}
```

```(4)``` 함수 코드 평가 단계 : ```f1(1,2)``` 호출

```
f1(1,2);

function f1(x, y) {
  var gg;   let bb;
  { ... }
  // function f2(t, u) { ... } // Function Object
  function f2(t, u, v) { ... } // Function Object
  var zz;
}
```

```(5)``` 함수 코드 평가 단계 내부의 블록 코드 평가 단계 : ```{ ... }```

```
  { 
    const xx;
    let lll;
    var zz;
    function f2(t) { ... } // Function Object
  }
```

```(6)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행

```
f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  console.log('f1>', gg, bb, zz, f2, f2.length); // f1> 11, 22, undefined, f2, 3
  f2('first');
  { ... }
  zz = 800;
  f2('second');
}
```

```(7)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행 → 함수 코드 평가 단계 : ```f2('first')``` 호출 

```
f1(1,2);

function f1(x, y) {
  f2('first');

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
```

```(8)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행 → 함수 코드 실행 단계 : ```f2('first')``` 실행 

```
f1(1,2);

function f1(x, y) {
  gg = 11;   bb = 22;
  f2('first'); // first inner2 9 undefined

  function f2(t, u, v) { console.log(t, 'inner2', xx, zz); };
}
```

```(9)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행 → 함수 코드 평가 단계 : ```f2('nest-first')``` 호출

```
function f1(x, y) {
  gg = 11; bb = 22;
  { 
    xx = 99;
    lll = 0;
    f2('nest-first');
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
```

```(10)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행 → 함수 코드 실행 단계 : ```f2('nest-first')``` 실행

```
function f1(x, y) {
  gg = 11; bb = 22;

  { 
    xx = 99;
    lll = 0;
    f2('nest-first'); // nest-first nested 99 undefined 0
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
...
}
```

```(11)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행 → 함수 코드 평가 단계 : ```f2('second')``` 호출

```
function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }

  f2('second');
}
```

```(12)``` 함수 코드 실행 단계 : ```f1(1,2)``` 실행 → 함수 코드 실행 단계 : ```f2('second')``` 실행

```
function f1(x, y) {
  gg = 11; bb = 22;
  
  {
    const xx = 99;
    lll = 0;
    zz = 88;
    function f2(t) { console.log(t, 'nested', xx, zz, lll); }
  }
  f2('second'); // second nested 99 800 0
}
```

```(13)``` 전역 코드 실행 단계 (```console.log``` 문 실행 및 종료)

```
gg = 1;  bb = 2;

console.log(kk, yy); // 33 9
```

```(14)``` 전역 코드 실행 단계 → 함수 코드 평가 단계 : ```f2('third')``` 평가

```
gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2>', gg, bb, xx, kk);
}

let xx = 9;
if (gg > 0) { var kk = 33; var yy = 9; }

f2('third');
```

```(15)``` 전역 코드 실행 단계 → 함수 코드 평가 단계 : ```f2('third')``` 실행

```
gg = 1; bb = 2;

function f2(g) {
  console.log(g, 'global f2>', gg, bb, xx, kk);
}

let xx = 9;
if (gg > 0) { var kk = 33; var yy = 9; }

f2('third'); // third global f2> 1 2 9 33
```

> <b>블록 코드 평가 및 실행</b>
> 
> 1. ```Global```/```Function``` 평가할 때 ```Block scope```를 만나면, ```Block Lexical Environment```를 생성한다.<br>(별도의 ```ExecutionContext```를 생성하지 않고 독립적인 ```Lexical Environment```만을 생성한다.)
> 2. ```Block code```를 평가하여 이 ```Block```에 대한 ```DeclarativeEnvironmentRecord```를 생성한다.
> 3. ```const```/```let```은 ```notInitializedYet``` 상태로 ```DeclarativeEnvironmentRecord```에 등록되고, ```var```/```function``` 선언식 등은 부모 ```Function scope```의 ```EnvironmentRecord```에 ```hoisting```한다.<br>(이때 ```function```은 ```<function object>```가 아니라 ```var```와 같이 ```undefined```로 초기화한다.)
> 4. ```Block```이 끝나면, 평가 종료 후 상위 ```scope code```를 계속 평가한다.
> 5. ```Block```이 실행되면, ```Block Lexical Environment```를 만들고, 부모 ```ExecutionContext```의 제어를 가져온다.
> 6. ```Block``` 내의 ```Function``` 선언식은 무조건 ```Block``` 최상단에 ```hoisting```되어 있으므로 먼저 실행한다.<br>(이 시점에 상위 ```function-scope```에 함수를 정의해, ```<function object>```으로 인정된다!)
> 7. 그 외의 코드 (할당문 및 다른 함수 호출)를 한 줄씩 실행된다.
> 8. ```Block```의 실행이 끝나면, ```ExecutionContext```의 제어를 다시 부모로 돌려준다.
> 9. ```Block```은 조건에 따라 실행 여부가 결정된다. 평가 시 블럭 내의 ```var```/```function```은 ```undefined```로 ```hoisting```되고, 조건이 만족하여 호출 및 실행될 때에만 ```Block Lexical Environment```와 ```EnvironmentRecord```를 만들고 ```<function object>```로 정의된다.

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a69498fb-6f39-413d-8a75-ef547e4ba4b5">

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/a1271743-b805-4040-9743-39e7b2cd5bda">

<img src="https://github.com/pocj8ur4in/pocj8ur4in.github.io/assets/105341168/5272ac93-d18b-4112-a45f-46d657839a3d">

## 엄격 모드 (```Strict Mode```) : 자바스크립트가 묵인한 에러를 발생시켜 엄격한 오류 검사를 적용

- 선언하지 않은 식별자는 접근할 수 없음
- 암묵적 전역 (```Implicit Global```)은 허용하지 않음
- ```Delete```로 선언된 변수, 함수, 매개변수를 삭제할 수 없음
- 블록 내에서의 함수는 블록 스코프 (블록 내 함수는 볼록의 ```DeclarativeEnvironmentRecord```에 존재)
- 함수 내에서 매개변수의 이름이 동일해선 안됨
- ```NaN```, ```Infinite``` 등의 전역 프로퍼티에 값을 할당해선 안됨

```
'use strict';


var gg = 1;
let bb = 2;

function f1(x, y) {
  var gg = 11;
  let bb = 22;
  console.log('f1>', gg, bb, zz, f2, f2.length);
  f2('* first');
  {
    const xx = 99;
    f2('* nest-first');
    var zz = 88;
    function f2(t) {
      console.log(t, '`nested`', xx, zz);
    }
  }
  function f2(t, u) {
    console.log(t, '`inner`', xx, zz);
  }
  function f2(t, u, v) {
    console.log(t, '`inner2`', xx, zz);
  }
  var zz = 800;
  console.log('gg:', gg);
  f2('* second');
}

function f2(g) {
  console.log(g, 'global f2>', gg, bb, xx, kk);
}
let xx = 9;
if (gg > 0) {
  var kk = 33;
  const yy = 9;
}
f1(1, 2); 
console.log('kkkkk>>', kk);
f2('* third');
```

## 클로저 (```Closure```) : 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의한 것

- 상위 스코프의 식별자를 참조하는 하위 스코프 (함수, 메소드)가 외부에서 참조되어 상위 스코프보다 오래 살아있는 것

```
let user;
{
  const private = {
    id: 1,
    name: 'John'
  }
  user = private;
}

user.age = 30;

console.log(user); // { id: 1, name: 'John', age: 30 }
```
```
function func(x) {
  let clo = function (y) {
    console.log(y);
  }

  return clo(x);
}

func('a'); // a
```

> 클로저를 활용하여 외부변수로 인해 오염될 수 있는 비순수함수 (```Impure Function```)를, 함수 내부로 전달된 인수에게만 의존하여 반환값을 만드는 순수함수 (```Pure Function```)로 바꿀 수 있다.
>
> ```
> // 비순수함수
> let cnt1 = 0;
>
> function func1(x) {
>   cnt1 += 1;
>   return cnt1;
> }
> 
> console.log(func1()); // 1
> console.log(func1()); // 2
> console.log(func1()); // 3
> 
> // → 순수함수
> function func2() {
>   let cnt2 = 0;
>   return function temp() {
>     cnt2 += 1;
>     return cnt2;
>   };
> }
> 
> const counter1 = func2();
> const counter2 = func2();
> 
> console.log(counter1()); // 1
> console.log(counter1()); // 2
> console.log(counter2()); // 1
> ```

